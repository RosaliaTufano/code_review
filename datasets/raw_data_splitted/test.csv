,comment,before,before_marked,after
0,I think LIBRARY are no more used,"  private static Set<String> getRootQualifiers(ResourceTypes resourceTypes) {
    return resourceTypes.getRoots().stream()
      .map(ResourceType::getQualifier)
      .filter(q -> !DEPRECATED_QUALIFIERS.contains(q))
      .collect(Collectors.toCollection(TreeSet::new));
  }
","  private static Set<String> getRootQualifiers(ResourceTypes resourceTypes) {
    return resourceTypes.getRoots().stream()
      .map(ResourceType::getQualifier)
START       .filter(q -> !DEPRECATED_QUALIFIERS.contains(q)) END 
      .collect(Collectors.toCollection(TreeSet::new));
  }
","  private static Set<String> getRootQualifiers(ResourceTypes resourceTypes) {
    return resourceTypes.getRoots().stream()
      .map(ResourceType::getQualifier)
      .collect(Collectors.toCollection(TreeSet::new));
  }
"
1,Consider using `System.lineSeparator()` instead.,"  public RuntimeFilterManager(QueryWorkUnit workUnit, DrillbitContext drillbitContext) {
    this.rootWrapper = workUnit.getRootWrapper();
    this.drillbitContext = drillbitContext;
    lineSeparator = java.security.AccessController.doPrivileged(new sun.security.action.GetPropertyAction(""line.separator""));
  }
","  public RuntimeFilterManager(QueryWorkUnit workUnit, DrillbitContext drillbitContext) {
    this.rootWrapper = workUnit.getRootWrapper();
    this.drillbitContext = drillbitContext;
START     lineSeparator = java.security.AccessController.doPrivileged(new sun.security.action.GetPropertyAction(""line.separator"")); END 
  }
","  public RuntimeFilterManager(QueryWorkUnit workUnit, DrillbitContext drillbitContext) {
    this.rootWrapper = workUnit.getRootWrapper();
    this.drillbitContext = drillbitContext;
  }
"
2,"ChangeDetailEditor_EGerriTipValue has no more arguments, 
should we just use it directly , no need to set the 
arguments ?","	private void activateMarkers() {
		if (!fGerritClient.getRepository().getServerInfo().isAnonymous()) {
			String value = NLS.bind(Messages.ChangeDetailEditor_EGerriTipValue,
					fChangeInfo.getUserSelectedRevision().get_number());
			UIUtils.showDialogTip(MARKERS_KEY, headerSection.getShell(), Messages.EGerriTip, value);
		}
	}
","	private void activateMarkers() {
		if (!fGerritClient.getRepository().getServerInfo().isAnonymous()) {
			String value = NLS.bind(Messages.ChangeDetailEditor_EGerriTipValue,
START 					fChangeInfo.getUserSelectedRevision().get_number()); END 
			UIUtils.showDialogTip(MARKERS_KEY, headerSection.getShell(), Messages.EGerriTip, value);
		}
	}
","	private void activateMarkers() {
		if (!fGerritClient.getRepository().getServerInfo().isAnonymous()) {
			UIUtils.showDialogTip(MARKERS_KEY, headerSection.getShell(), Messages.EGerriTip, Messages.ChangeDetailEditor_EGerriTipValue);
		}
	}
"
3,should be called `resource`,"  public void testCreate() throws StripeException {
    Map<String, Object> params = new HashMap<String, Object>();
    params.put(""currency"", ""usd"");

    final Order order = Order.create(params);

    assertNotNull(order);
    verifyRequest(
        APIResource.RequestMethod.POST,
        ""/v1/orders"",
        params
    );
  }
","  public void testCreate() throws StripeException {
    Map<String, Object> params = new HashMap<String, Object>();
    params.put(""currency"", ""usd"");

    final Order order = Order.create(params);

    assertNotNull(order);
    verifyRequest(
        APIResource.RequestMethod.POST,
START         ""/v1/orders"", END 
        params
    );
  }
","  public void testCreate() throws StripeException {
    final Map<String, Object> params = new HashMap<String, Object>();
    params.put(""currency"", ""usd"");

    final Order order = Order.create(params);

    assertNotNull(order);
    verifyRequest(
        APIResource.RequestMethod.POST,
        ""/v1/orders"",
        params
    );
  }
"
4,Just `return rule`.,"   private FirewallRule findById(List<FirewallRule> collection, String id) {
      FirewallRule result = null;
      for (FirewallRule rule : collection) {
         if (rule.id().equals(id)) {
            result = rule;
         }
      }
      return result;
   }
","   private FirewallRule findById(List<FirewallRule> collection, String id) {
      FirewallRule result = null;
      for (FirewallRule rule : collection) {
         if (rule.id().equals(id)) {
START             result = rule; END 
         }
      }
      return result;
   }
","   private FirewallRule findById(List<FirewallRule> collection, String id) {
      for (FirewallRule rule : collection) {
         if (rule.id().equals(id)) {
            return rule;
         }
      }
      return null;
   }
"
5,Should probably use a Set<String> instead of a List<String> so that the intention of the code is clear by first glance.,"    public void addDownload(String download){
        if(!downloads.contains(download)) {
            downloads.add(download);
        }
    }
","    public void addDownload(String download){
START         if(!downloads.contains(download)) { END 
            downloads.add(download);
        }
    }
","	public void addDownload(String download) {
		downloads.add(download);
	}
"
6,Should this be 1 or null instead of 0?,"    public void copyDetailsFromOtherCuObjectCodeActivationGlobal(CuObjectCodeActivationGlobal oldGlobal) {
        for (CuObjectCodeGlobalDetail oldDetail : oldGlobal.getObjectCodeGlobalDetails()) {
            CuObjectCodeGlobalDetail newDetail = (CuObjectCodeGlobalDetail) ObjectUtils.deepCopy(oldDetail);
            newDetail.setObjectId(null);
            newDetail.setDocumentNumber(getDocumentNumber());
            newDetail.setVersionNumber(new Long(0));
            getObjectCodeGlobalDetails().add(newDetail);
        }
    }
","    public void copyDetailsFromOtherCuObjectCodeActivationGlobal(CuObjectCodeActivationGlobal oldGlobal) {
        for (CuObjectCodeGlobalDetail oldDetail : oldGlobal.getObjectCodeGlobalDetails()) {
            CuObjectCodeGlobalDetail newDetail = (CuObjectCodeGlobalDetail) ObjectUtils.deepCopy(oldDetail);
            newDetail.setObjectId(null);
            newDetail.setDocumentNumber(getDocumentNumber());
START             newDetail.setVersionNumber(new Long(0)); END 
            getObjectCodeGlobalDetails().add(newDetail);
        }
    }
","    public void copyDetailsFromOtherCuObjectCodeActivationGlobal(CuObjectCodeActivationGlobal oldGlobal) {
        for (CuObjectCodeGlobalDetail oldDetail : oldGlobal.getObjectCodeGlobalDetails()) {
            CuObjectCodeGlobalDetail newDetail = (CuObjectCodeGlobalDetail) ObjectUtils.deepCopy(oldDetail);
            newDetail.setObjectId(null);
            newDetail.setDocumentNumber(getDocumentNumber());
            newDetail.setVersionNumber(new Long(1));
            getObjectCodeGlobalDetails().add(newDetail);
        }
    }
"
7,You can not be sure that the value is present in the local storage (see the storeVncData). Please wrap the ...valueOf(...) by try-catch,"    private void loadVncData(HasConsoleModel model, KeyMaker keyMaker) {
        if (!(model.getDefaultConsoleModel() instanceof VncConsoleModel)) {
            return;
        }

        model.setSelectedProtocol(ConsoleProtocol.VNC);
        asVncConsoleModel(model).setVncImplementation(VncConsoleModel.ClientConsoleMode
                .valueOf(clientStorage.getLocalItem(keyMaker.make(VNC_CLIENT_MODE))));
    }
","    private void loadVncData(HasConsoleModel model, KeyMaker keyMaker) {
        if (!(model.getDefaultConsoleModel() instanceof VncConsoleModel)) {
            return;
        }

        model.setSelectedProtocol(ConsoleProtocol.VNC);
        asVncConsoleModel(model).setVncImplementation(VncConsoleModel.ClientConsoleMode
START                 .valueOf(clientStorage.getLocalItem(keyMaker.make(VNC_CLIENT_MODE)))); END 
    }
","    private void loadVncData(HasConsoleModel model, KeyMaker keyMaker) {
        if (!(model.getDefaultConsoleModel() instanceof VncConsoleModel)) {
            return;
        }

        model.setSelectedProtocol(ConsoleProtocol.VNC);

        try {
            asVncConsoleModel(model).setVncImplementation(VncConsoleModel.ClientConsoleMode
                    .valueOf(clientStorage.getLocalItem(keyMaker.make(VNC_CLIENT_MODE))));
        } catch (Exception e) {
        }
    }
"
8,These arguments can all go on the same line,"    private RuleApplication applyRule()
    {
        SymbolAllocator symbolAllocator = new SymbolAllocator(symbols);
        Memo memo = new Memo(idAllocator, plan);
        Lookup lookup = Lookup.from(memo::resolve);
        Optional<PlanNode> result = inTransaction(session -> rule.apply(memo.getNode(memo.getRootGroup()), lookup, idAllocator, symbolAllocator, session));

        return new RuleApplication(
                memo,
                lookup,
                symbolAllocator.getTypes(),
                result);
    }
","    private RuleApplication applyRule()
    {
        SymbolAllocator symbolAllocator = new SymbolAllocator(symbols);
        Memo memo = new Memo(idAllocator, plan);
        Lookup lookup = Lookup.from(memo::resolve);
        Optional<PlanNode> result = inTransaction(session -> rule.apply(memo.getNode(memo.getRootGroup()), lookup, idAllocator, symbolAllocator, session));

START         return new RuleApplication( END 
                memo,
                lookup,
                symbolAllocator.getTypes(),
                result);
    }
","    private RuleApplication applyRule()
    {
        SymbolAllocator symbolAllocator = new SymbolAllocator(symbols);
        Memo memo = new Memo(idAllocator, plan);
        Lookup lookup = Lookup.from(memo::resolve);
        Optional<PlanNode> result = inTransaction(session -> rule.apply(memo.getNode(memo.getRootGroup()), lookup, idAllocator, symbolAllocator, session));

        return new RuleApplication(lookup, symbolAllocator.getTypes(), result);
    }
"
9,Why the expected output was changed?,"  public void testPushDownArray() throws Exception {
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] = 1"", 3, 2);
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] = 100"", 0, 1);
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] <> 1"", 8, 7);
    testParquetFilterPushDown(""t.`user`.hobby_ids[2] > 20"", 5, 4);
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] between 10 and 20"", 5, 5);
    testParquetFilterPushDown(""t.`user`.hobby_ids[4] = 15"", 1, 3);
    testParquetFilterPushDown(""t.`user`.hobby_ids[2] is not null"", 11, 6);
    testParquetFilterPushDown(""t.`user`.hobby_ids[3] is null"", 11, 7);
  }
","  public void testPushDownArray() throws Exception {
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] = 1"", 3, 2);
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] = 100"", 0, 1);
START     testParquetFilterPushDown(""t.`user`.hobby_ids[0] <> 1"", 8, 7); END 
    testParquetFilterPushDown(""t.`user`.hobby_ids[2] > 20"", 5, 4);
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] between 10 and 20"", 5, 5);
    testParquetFilterPushDown(""t.`user`.hobby_ids[4] = 15"", 1, 3);
    testParquetFilterPushDown(""t.`user`.hobby_ids[2] is not null"", 11, 6);
    testParquetFilterPushDown(""t.`user`.hobby_ids[3] is null"", 11, 7);
  }
","  public void testPushDownArray() throws Exception {
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] = 1"", 3, 2);
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] = 100"", 0, 1);
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] <> 1"", 8, 6);
    testParquetFilterPushDown(""t.`user`.hobby_ids[2] > 20"", 5, 3);
    testParquetFilterPushDown(""t.`user`.hobby_ids[0] between 10 and 20"", 5, 4);
    testParquetFilterPushDown(""t.`user`.hobby_ids[4] = 15"", 1, 3);
    testParquetFilterPushDown(""t.`user`.hobby_ids[2] is not null"", 11, 6);
    testParquetFilterPushDown(""t.`user`.hobby_ids[3] is null"", 11, 7);
  }
"
10,This logic should be in the default implementation.,"    default Direction getBubbleElevatorDirection() {
        Block block = this.getBlockState().getBlock();
        if (block == Blocks.BUBBLE_COLUMN) {
            return this.getBlockState().get(BubbleColumnBlock.DRAG) ? Direction.DOWN : Direction.UP;
        } else {
            return block.getBubbleElevatorDirection(this.getBlockState());
        }
    }
","    default Direction getBubbleElevatorDirection() {
        Block block = this.getBlockState().getBlock();
        if (block == Blocks.BUBBLE_COLUMN) {
START             return this.getBlockState().get(BubbleColumnBlock.DRAG) ? Direction.DOWN : Direction.UP; END 
        } else {
            return block.getBubbleElevatorDirection(this.getBlockState());
        }
    }
","    default Direction getBubbleElevatorDirection() {
        return this.getBlockState().getBlock().getBubbleElevatorDirection(this.getBlockState());
    }
"
11,Why access this method staticly?,"    public void testSystemPropertiesOverrideConfigurationValues() {

        final String keyName = CoreConfig.MAX_CASSANDRA_CONNECTIONS.toString();

        Configuration config = Configuration.getInstance();

        try {
            Assert.assertEquals(""75"",
                    config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS));

            System.setProperty(keyName, ""something else"");

            Assert.assertEquals(""something else"",
                    config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS));
        } finally {
            System.clearProperty(keyName);
            Configuration.clearProperty(keyName);
        }
    }
","    public void testSystemPropertiesOverrideConfigurationValues() {

        final String keyName = CoreConfig.MAX_CASSANDRA_CONNECTIONS.toString();

        Configuration config = Configuration.getInstance();

        try {
            Assert.assertEquals(""75"",
                    config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS));

            System.setProperty(keyName, ""something else"");

            Assert.assertEquals(""something else"",
                    config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS));
        } finally {
            System.clearProperty(keyName);
START             Configuration.clearProperty(keyName); END 
        }
    }
","    public void testSystemPropertiesOverrideConfigurationValues() {

        final String keyName = CoreConfig.MAX_CASSANDRA_CONNECTIONS.toString();

        Configuration config = Configuration.getInstance();

        try {
            Assert.assertEquals(""75"",
                    config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS));

            System.setProperty(keyName, ""something else"");

            Assert.assertEquals(""something else"",
                    config.getStringProperty(CoreConfig.MAX_CASSANDRA_CONNECTIONS));
        } finally {
            System.clearProperty(keyName);
            config.clearProperty(keyName);
        }
    }
"
12,"You can set it on a plain field, no need for atomics:

``` java
     this.inner = inner;
     o.onSubscribe(this);
     inner.request(Long.MAX_VALUE);
```","        public void onSubscribe(Subscription inner) {
            SubscriptionHelper.setOnce(this, inner);
            o.onSubscribe(this);
            inner.request(Long.MAX_VALUE);
        }
","        public void onSubscribe(Subscription inner) {
START             SubscriptionHelper.setOnce(this, inner); END 
            o.onSubscribe(this);
            inner.request(Long.MAX_VALUE);
        }
","        public void onSubscribe(Subscription inner) {
            this.inner = inner;
            o.onSubscribe(this);
            inner.request(Long.MAX_VALUE);
        }
"
13,`true` -> `false` ?,"  public WebElement forElementPresent(By by) {
    changeImplicitWait(250, TimeUnit.MILLISECONDS);
    try {
      return wait.until(ExpectedConditions.presenceOfElementLocated(by));
    } catch(TimeoutException e) {
      PageObjectLogging.log(
          ELEMENT_PRESENT_MESSAGE,
          String.format(ELEMENT_PRESENT_ERROR_FORMAT, by.toString()),
          true
      );
      throw e;
    } finally {
      restoreDeaultImplicitWait();
    }
  }
","  public WebElement forElementPresent(By by) {
    changeImplicitWait(250, TimeUnit.MILLISECONDS);
    try {
      return wait.until(ExpectedConditions.presenceOfElementLocated(by));
    } catch(TimeoutException e) {
      PageObjectLogging.log(
          ELEMENT_PRESENT_MESSAGE,
          String.format(ELEMENT_PRESENT_ERROR_FORMAT, by.toString()),
START           true END 
      );
      throw e;
    } finally {
      restoreDeaultImplicitWait();
    }
  }
","  public WebElement forElementPresent(By by) {
    changeImplicitWait(250, TimeUnit.MILLISECONDS);
    try {
      return wait.until(ExpectedConditions.presenceOfElementLocated(by));
    } catch(TimeoutException e) {
      PageObjectLogging.log(
          ELEMENT_PRESENT_MESSAGE,
          String.format(ELEMENT_PRESENT_ERROR_FORMAT, by.toString()),
          false
      );
      throw e;
    } finally {
      restoreDeaultImplicitWait();
    }
  }
"
14,could be simplified.,"  public boolean accept(Issue issue) {
    if (issueShouldNotBeReported(issue, excludedLinesByRule())) {
      return false;
    }
    return true;
  }
","  public boolean accept(Issue issue) {
START     if (issueShouldNotBeReported(issue, excludedLinesByRule())) { END 
      return false;
    }
    return true;
  }
","  public boolean accept(Issue issue) {
    return !issueShouldNotBeReported(issue, excludedLinesByRule());
  }
"
15,this method should be changed to private,"	public HashMap<String, ArrayList<Order>> getBuyOrders() {
		return buyOrders;
	}
","START 	public HashMap<String, END  ArrayList<Order>> getBuyOrders() {
		return buyOrders;
	}
","	private HashMap<String, ArrayList<Order>> getBuyOrders() {
		return buyOrders;
	}
"
16,"There's no need to make these public, even if the package is internal.","	public static Color getSystemForegroundColor(Display display) {
		ColorRegistry colorRegistry = JFaceResources.getColorRegistry();
		Color foreground = colorRegistry.get(JFacePreferences.INFORMATION_FOREGROUND_COLOR);

		if (foreground == null) {
			return JFaceColors.getInformationViewerForegroundColor(display);
		}

		return foreground;
	}
","START 	public static END  Color getSystemForegroundColor(Display display) {
		ColorRegistry colorRegistry = JFaceResources.getColorRegistry();
		Color foreground = colorRegistry.get(JFacePreferences.INFORMATION_FOREGROUND_COLOR);

		if (foreground == null) {
			return JFaceColors.getInformationViewerForegroundColor(display);
		}

		return foreground;
	}
","	private static Color getSystemForegroundColor(Display display) {
		ColorRegistry colorRegistry = JFaceResources.getColorRegistry();
		Color foreground = colorRegistry.get(JFacePreferences.INFORMATION_FOREGROUND_COLOR);

		if (foreground == null) {
			return JFaceColors.getInformationViewerForegroundColor(display);
		}

		return foreground;
	}
"
17,"You should go one step more in simplifying the rule: Change this method to return a boolean: `hasNoDefault(switchStatementTree)`

```
return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
```","  public void visitNode(Tree tree) {
    if (!hasSemantic()) {
      return;
    }
    SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree;
    Optional<CaseLabelTree> defaultLabel = getDefaultLabel(switchStatementTree);
    if (!defaultLabel.isPresent()) {
      if (!isSwitchOnEnum(switchStatementTree)) {
        reportIssue(switchStatementTree.switchKeyword(), ""Add a default case to this switch."");
      } else if (missingCasesOfEnum(switchStatementTree)) {
        reportIssue(switchStatementTree.switchKeyword(), ""Complete cases by adding the missing enum constants or add a default case to this switch."");
      }
    }
  }
","  public void visitNode(Tree tree) {
    if (!hasSemantic()) {
      return;
    }
    SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree;
START     Optional<CaseLabelTree> defaultLabel = getDefaultLabel(switchStatementTree); END 
    if (!defaultLabel.isPresent()) {
      if (!isSwitchOnEnum(switchStatementTree)) {
        reportIssue(switchStatementTree.switchKeyword(), ""Add a default case to this switch."");
      } else if (missingCasesOfEnum(switchStatementTree)) {
        reportIssue(switchStatementTree.switchKeyword(), ""Complete cases by adding the missing enum constants or add a default case to this switch."");
      }
    }
  }
","  public void visitNode(Tree tree) {
    if (!hasSemantic()) {
      return;
    }
    SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree;
    if (getDefaultLabel(switchStatementTree)) {
      if (!isSwitchOnEnum(switchStatementTree)) {
        reportIssue(switchStatementTree.switchKeyword(), ""Add a default case to this switch."");
      } else if (missingCasesOfEnum(switchStatementTree)) {
        reportIssue(switchStatementTree.switchKeyword(), ""Complete cases by adding the missing enum constants or add a default case to this switch."");
      }
    }
  }
"
18,"This method should be synchronized, otherwise, chances are eventually there might be a race condition for setting fAttribute.","    public String getAttribute() {
        if (fAttribute.equals(NOT_SET)) {
            setAttribute();
        }
        return fAttribute;
    }
","START     public String getAttribute() { END 
        if (fAttribute.equals(NOT_SET)) {
            setAttribute();
        }
        return fAttribute;
    }
","    public synchronized String getAttribute() {
        if (fAttribute.equals(NOT_SET)) {
            setAttribute();
        }
        return fAttribute;
    }
"
19,"![BLOCKER](https://sonarsource.github.io/sonar-github/severity-blocker.png 'Severity: BLOCKER') Move this ""start"" call to another method. [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3AS2693)","  public DotRunnableThread(final List<DotRunnable> allListeners) {
    this.listeners = getListeners(allListeners);
    this.flushers = getFlushers(allListeners);
    this.networkCacheFlushThread.start();
  }
","  public DotRunnableThread(final List<DotRunnable> allListeners) {
    this.listeners = getListeners(allListeners);
    this.flushers = getFlushers(allListeners);
START     this.networkCacheFlushThread.start(); END 
  }
","  public DotRunnableThread(final List<DotRunnable> allListeners) {
    this.listeners = getListeners(allListeners);
    this.flushers = getFlushers(allListeners);
  }
"
20,style nit: no braces around single line blocks,"	private void createIndex() {
		lastFoundElementPosition = 0;

		filteredPlan.clear();
		for (PlanElement element : plan.getList()) {
			if (!element.isComment()) {
				filteredPlan.add(element);
			}
		}
	}
","	private void createIndex() {
		lastFoundElementPosition = 0;

		filteredPlan.clear();
		for (PlanElement element : plan.getList()) {
START 			if (!element.isComment()) { END 
				filteredPlan.add(element);
			}
		}
	}
","	private void createIndex() {
		lastFoundElementPosition = 0;

		filteredPlan.clear();
		for (PlanElement element : plan.getList()) {
			if (!element.isComment())
				filteredPlan.add(element);
		}
	}
"
21,is there a difference between parallelStream() and entryStream().parallel() ?,"    public Collection<Map.Entry<K, V>> scanAndFilterByEntry(
            Predicate<? super Map.Entry<K, V>> entryPredicate) {
        return mainMap.entryStream().parallel()
                .filter(entryPredicate)
                .collect(Collectors.toCollection(ArrayList::new));
    }
","    public Collection<Map.Entry<K, V>> scanAndFilterByEntry(
            Predicate<? super Map.Entry<K, V>> entryPredicate) {
START         return mainMap.entryStream().parallel() END 
                .filter(entryPredicate)
                .collect(Collectors.toCollection(ArrayList::new));
    }
","    public Collection<Map.Entry<K, V>> scanAndFilterByEntry(
            Predicate<? super Map.Entry<K, V>> entryPredicate) {
        return mainMap.entryStream()
                .filter(entryPredicate)
                .collect(Collectors.toCollection(ArrayList::new));
    }
"
22,can be `private`? or at least package protected access?,"    protected boolean isValidChar(final char c) {
        return isValidChar(regExp, c);
    }
","START     protected boolean isValidChar(final char c) { END 
        return isValidChar(regExp, c);
    }
","    private boolean isValidChar(final char c) {
        return isValidChar(regExp, c);
    }
"
23,"Toni, could we please choose better variable names here? `equals` and `equals1` do not say much for newcomer to the codebase.

Or we could avoid storing partial results by:
```java
if(!Objects.equals(editorPlaceRequest, event.getPlace())) {
   return false;
}

if (!Objects.equals(getEditorIdentifier(), event.getPlace().getIdentifier())) {
    return false;
}
return true;
```

Please 
let me know what do you think.","    public boolean verifyEventIdentifier(AbstractPlaceEvent event) {
        boolean equals = Objects.equals(getEditorIdentifier(),
                                        event.getPlace().getIdentifier());
        boolean equals1 = Objects.equals(editorPlaceRequest,
                                         event.getPlace());
        return (equals &&
                equals1);
    }
","    public boolean verifyEventIdentifier(AbstractPlaceEvent event) {
        boolean equals = Objects.equals(getEditorIdentifier(),
                                        event.getPlace().getIdentifier());
        boolean equals1 = Objects.equals(editorPlaceRequest,
                                         event.getPlace());
        return (equals &&
START                 equals1); END 
    }
","    public boolean verifyEventIdentifier(AbstractPlaceEvent event) {
        return (Objects.equals(getEditorIdentifier(),
                               event.getPlace().getIdentifier()) &&
                Objects.equals(editorPlaceRequest,
                               event.getPlace()));
    }
"
24,"It's an obvious code duplication. We can save this new request with a modified URI into `this.request`, and use it in all methods. This is how it works in other classes, take a look","    public void star() throws IOException {
        this.entry.uri()
            .path(RtGist.PATH_ELEMENT_STAR).back().method(""PUT"")
            .fetch().as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);
    }
","    public void star() throws IOException {
        this.entry.uri()
START             .path(RtGist.PATH_ELEMENT_STAR).back().method(""PUT"") END 
            .fetch().as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);
    }
","    public void star() throws IOException {
        this.request.method(""PUT"")
            .fetch().as(RestResponse.class)
            .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);
    }
"
25,"What is the need to make `issueArticles` nullable? It would be easier to understand this view class if we required it.

If that's totally impractical, we should consider having a separate view class to capture the difference.","  public IssueOutputView(Issue issue) {
    this(issue, null, null);
  }
","  public IssueOutputView(Issue issue) {
START     this(issue, null, null); END 
  }
","  public IssueOutputView(Issue issue) {
    this(issue, null);
  }
"
26,"not 100% sure, but this breaks binary compatibility, right?","  public ProcessEngineConfiguration setDefaultNumberOfRetries(int defaultNumberOfRetries) {
    this.defaultNumberOfRetries = defaultNumberOfRetries;
    return this;
  }
","START   public ProcessEngineConfiguration setDefaultNumberOfRetries(int defaultNumberOfRetries) { END 
    this.defaultNumberOfRetries = defaultNumberOfRetries;
    return this;
  }
","  public void setDefaultNumberOfRetries(int defaultNumberOfRetries) {
    this.defaultNumberOfRetries = defaultNumberOfRetries;
  }
"
27,The Exception is never thrown.,"    public void testSequenceFlowSupplier() throws Exception {
        final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,
                                                                                                          candidate,
                                                                                                          index,
                                                                                                          originalParent,
                                                                                                          originalIndex);

        final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier();
        final ViewConnector<SequenceFlow> viewConnector = supplier.get();

        assertNotNull(viewConnector);
        assertNotNull(viewConnector.getSourceConnection());
        assertNotNull(viewConnector.getTargetConnection());
        assertNotNull(viewConnector.getBounds());
        assertNotNull(viewConnector.getDefinition());
    }
","START     public void testSequenceFlowSupplier() throws Exception { END 
        final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,
                                                                                                          candidate,
                                                                                                          index,
                                                                                                          originalParent,
                                                                                                          originalIndex);

        final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier();
        final ViewConnector<SequenceFlow> viewConnector = supplier.get();

        assertNotNull(viewConnector);
        assertNotNull(viewConnector.getSourceConnection());
        assertNotNull(viewConnector.getTargetConnection());
        assertNotNull(viewConnector.getBounds());
        assertNotNull(viewConnector.getDefinition());
    }
","    public void testSequenceFlowSupplier() {
        final CaseManagementSetChildNodeGraphCommand command = new CaseManagementSetChildNodeGraphCommand(parent,
                                                                                                          candidate,
                                                                                                          index,
                                                                                                          originalParent,
                                                                                                          originalIndex);

        final Supplier<ViewConnector<SequenceFlow>> supplier = command.sequenceFlowSupplier();
        final ViewConnector<SequenceFlow> viewConnector = supplier.get();

        assertNotNull(viewConnector);
        assertNotNull(viewConnector.getSourceConnection());
        assertNotNull(viewConnector.getTargetConnection());
        assertNotNull(viewConnector.getBounds());
        assertNotNull(viewConnector.getDefinition());
    }
"
28,"instead of an early assignment which might be overridden in line 2355, it can be set as the 'else' part of the if statement below (line 2356).","    public long getSessionSeqId() {
        if (sessionSeqId == null) {
            sessionSeqId = -1L;
            String sessionId = getContext().getEngineContext().getSessionId();
            // The session may not exists for quartz jobs
            if (getSessionDataContainer().isSessionExists(sessionId)) {
                sessionSeqId = getSessionDataContainer().getEngineSessionSeqId(sessionId);
            }
        }
        return sessionSeqId;
    }
","    public long getSessionSeqId() {
        if (sessionSeqId == null) {
START             sessionSeqId = -1L; END 
            String sessionId = getContext().getEngineContext().getSessionId();
            // The session may not exists for quartz jobs
            if (getSessionDataContainer().isSessionExists(sessionId)) {
                sessionSeqId = getSessionDataContainer().getEngineSessionSeqId(sessionId);
            }
        }
        return sessionSeqId;
    }
","    public long getSessionSeqId() {
        if (sessionSeqId == null) {
            String sessionId = getContext().getEngineContext().getSessionId();
            // The session may not exists for quartz jobs
            sessionSeqId = getSessionDataContainer().isSessionExists(sessionId)
                    ? getSessionDataContainer().getEngineSessionSeqId(sessionId)
                    : -1L;
        }
        return sessionSeqId;
    }
"
29,Allocate write ID is a DB/table related event and should be ignored if not lookup on this DB/table.,"  private boolean isTxnRelatedEvent(final NotificationEvent event) {
    return ((event.getEventType().equals(MessageFactory.OPEN_TXN_EVENT)) ||
            (event.getEventType().equals(MessageFactory.COMMIT_TXN_EVENT)) ||
            (event.getEventType().equals(MessageFactory.ABORT_TXN_EVENT)) ||
            (event.getEventType().equals(MessageFactory.ALLOC_WRITE_ID_EVENT))
          );
  }
","  private boolean isTxnRelatedEvent(final NotificationEvent event) {
    return ((event.getEventType().equals(MessageFactory.OPEN_TXN_EVENT)) ||
            (event.getEventType().equals(MessageFactory.COMMIT_TXN_EVENT)) ||
            (event.getEventType().equals(MessageFactory.ABORT_TXN_EVENT)) ||
START             (event.getEventType().equals(MessageFactory.ALLOC_WRITE_ID_EVENT)) END 
          );
  }
","  private boolean isTxnRelatedEvent(final NotificationEvent event) {
    return ((event.getEventType().equals(MessageFactory.OPEN_TXN_EVENT)) ||
            (event.getEventType().equals(MessageFactory.COMMIT_TXN_EVENT)) ||
            (event.getEventType().equals(MessageFactory.ABORT_TXN_EVENT)));
  }
"
30,Can't we have this static flag on FS instead? Then we wouldn't need to make FileStoreAttributeCache public.,"		public static void setBackground(boolean async) {
			background = async;
		}
","		public static void setBackground(boolean async) {
			background = async;
START 		} END 
","		private static void setBackground(boolean async) {
			background.set(async);
		}
"
31,"For a small maximuSize, like 1, it may be more reasonable to check for:

  map.size() > maximumSize","	public V put(@NonNull K key, @NonNull V value) {
		map.put(key, new Entry<>(key, value, ++time));
		if (map.size() >= maximumSize) {
			purge();
		}
		return value;
	}
","	public V put(@NonNull K key, @NonNull V value) {
		map.put(key, new Entry<>(key, value, ++time));
START 		if (map.size() >= maximumSize) { END 
			purge();
		}
		return value;
	}
","	public V put(@NonNull K key, @NonNull V value) {
		map.put(key, new Entry<>(key, value, ++time));
		if (map.size() > maximumSize) {
			purge();
		}
		return value;
	}
"
32,Shouldn't do this line - it's handled by the ...Optionally... bit in the Encr class. https://github.com/pentaho/pentaho-kettle/blob/master/core/src/org/pentaho/di/core/encryption/KettleTwoWayPasswordEncoder.java#L86-L91,"  private static void setIfNotNullOrEmpty( MongoProperties.Builder builder, MongoProp prop, String value ) {
    if ( value != null && value.trim().length() > 0 ) {
      boolean isPassword = MongoProp.PASSWORD.equals( prop );
      boolean isEncrypted = value.startsWith( Encr.PASSWORD_ENCRYPTED_PREFIX );
      if ( isPassword && isEncrypted ) {
        value = Encr.decryptPasswordOptionallyEncrypted( value );
      }
      builder.set( prop, value );
    }
  }
","  private static void setIfNotNullOrEmpty( MongoProperties.Builder builder, MongoProp prop, String value ) {
    if ( value != null && value.trim().length() > 0 ) {
      boolean isPassword = MongoProp.PASSWORD.equals( prop );
START       boolean isEncrypted = value.startsWith( Encr.PASSWORD_ENCRYPTED_PREFIX ); END 
      if ( isPassword && isEncrypted ) {
        value = Encr.decryptPasswordOptionallyEncrypted( value );
      }
      builder.set( prop, value );
    }
  }
","  private static void setIfNotNullOrEmpty( MongoProperties.Builder builder, MongoProp prop, String value ) {
    if ( value != null && value.trim().length() > 0 ) {
      boolean isPassword = MongoProp.PASSWORD.equals( prop );
      if ( isPassword ) {
        value = Encr.decryptPasswordOptionallyEncrypted( value );
      }
      builder.set( prop, value );
    }
  }
"
33,"One use/test case is, a non-serializable pojo (user type) that is encoded as a UTF-8 byte[ ] with some string representation of it.","   public Mutation toMutation(K key) {
      V valueFromStorage = (V) valueDataConversion.fromStorage(value);
      return new Mutations.ReadWriteWithValue<>(valueFromStorage, f);
   }
","   public Mutation toMutation(K key) {
START       V valueFromStorage = (V) valueDataConversion.fromStorage(value); END 
      return new Mutations.ReadWriteWithValue<>(valueFromStorage, f);
   }
","   public Mutation toMutation(K key) {
      return new Mutations.ReadWriteWithValue<>(value, f);
   }
"
34,IMHO it does not need to be public,"		public Entry(Map.Entry<String,String> e) {
		    this(e.getKey(), e.getValue());
        }
","START 		public Entry(Map.Entry<String,String> e) { END 
		    this(e.getKey(), e.getValue());
        }
","		private Entry(Map.Entry<String,String> e) {
		    this(e.getKey(), e.getValue());
        }
"
35,parts[1].isEmpty,"  private String parsePath() throws URISyntaxException {
    String[] parts = uri.split(""\\?"")[0].split("":"", 2);

    if (parts.length < 2 || parts[1].length() < 1) throw new URISyntaxException(uri, ""invalid path"");
    else                                           return parts[1];
  }
","  private String parsePath() throws URISyntaxException {
    String[] parts = uri.split(""\\?"")[0].split("":"", 2);

START     if (parts.length < 2 || parts[1].length() < 1) throw new URISyntaxException(uri, ""invalid path""); END 
    else                                           return parts[1];
  }
","  private String parsePath() throws URISyntaxException {
    String[] parts = uri.split(""\\?"")[0].split("":"", 2);

    if (parts.length < 2 || parts[1].isEmpty()) throw new URISyntaxException(uri, ""invalid path"");
    else                                        return parts[1];
  }
"
36,"this will affect the sorting also on the webadmin - but on webadmin we support sortable columns.

Please move this logic to UserPortalTemplateListModel.","    public void setItems(Collection value) {
        genVersionToBaseTemplate(value);
        final List<VmTemplate> sortedValues = sortTemplates(value);
        super.setItems(sortedValues);
    }
","    public void setItems(Collection value) {
        genVersionToBaseTemplate(value);
START         final List<VmTemplate> sortedValues = sortTemplates(value); END 
        super.setItems(sortedValues);
    }
","    public void setItems(Collection value) {
        genVersionToBaseTemplate(value);
        super.setItems(value);
    }
"
37,"why you need this line?
 table.setRowData(new ArrayList<ListModel>());","    public void edit(VolumeBrickModel object) {
        table.setRowData(new ArrayList<ListModel>());
        table.edit(object.getBricks());
        Driver.driver.edit(object);
    }
","    public void edit(VolumeBrickModel object) {
START         table.setRowData(new ArrayList<ListModel>()); END 
        table.edit(object.getBricks());
        Driver.driver.edit(object);
    }
","    public void edit(VolumeBrickModel object) {
        table.edit(object.getBricks());
        Driver.driver.edit(object);
    }
"
38,`return quickFilters`,"    public List<QuickFilter> getQuickFilters() {
        return this.quickFilters;
    }
","    public List<QuickFilter> getQuickFilters() {
START         return this.quickFilters; END 
    }
","    public List<QuickFilter> getQuickFilters() {
        return quickFilters;
    }
"
39,"why not directly assertEquals(LOW, fCondition.min()); ?","    public void testBounds() {
        int low = fCondition.min();
        assertEquals(LOW, low);
        int high = fCondition.max();
        assertEquals(HIGH, high);
    }
","    public void testBounds() {
        int low = fCondition.min();
        START  assertEquals(LOW, low); END 
        int high = fCondition.max();
        assertEquals(HIGH, high);
    }
","    public void testBounds() {
        assertEquals(LOW, (int) fCondition.min());
        assertEquals(HIGH, (int) fCondition.max());
    }
"
40,`this` is redundant here.,"    public String weather() {
        String result = this.restTemplate.getForObject(""http://"" + WEATHER_SERVICE + ""/weather"", String.class);
        return ""Weather Service Response: "" + result;
    }
","    public String weather() {
START         String result = this.restTemplate.getForObject(""http://"" + WEATHER_SERVICE + ""/weather"", String.class); END 
        return ""Weather Service Response: "" + result;
    }
","    public String weather() {
        String result = restTemplate.getForObject(""http://"" + WEATHER_SERVICE + ""/weather"", String.class);
        return ""Weather Service Response: "" + result;
    }
"
41,Let's move this into an EnablementTester.evaluate(...) method.,"	public boolean isExtensionEnabled() {
		if (enablement != null) {
			try {
				return enablement.getExpression().evaluate(new EvaluationContext(null, new Object()))
						.equals(EvaluationResult.TRUE);
			} catch (CoreException e) {
				// TODO: handle exception
			}
		}
		return true;

	}
","	public boolean isExtensionEnabled() {
		if (enablement != null) {
			try {
START 				return enablement.getExpression().evaluate(new EvaluationContext(null, new Object())) END 
						.equals(EvaluationResult.TRUE);
			} catch (CoreException e) {
				// TODO: handle exception
			}
		}
		return true;

	}
","	public boolean isExtensionEnabled() {
		return enablement != null ? enablement.evaluate() : true;

	}
"
42,'null' must be first operande,"	public ProviderNotificationManager createProviderNotificationManager(final DiagramEventBroker diagramEventBroker, final EObject view, final NotificationListener notificationListener) {
		if (manager != null) {
			return manager;
		}
		manager = new ProviderNotificationManager(diagramEventBroker, view, notificationListener) {
			@Override
			protected void registerListeners() {
				// TODO install listener on allocation(Abstraction) of the model.
			}
		};
		return manager;
	}
","	public ProviderNotificationManager createProviderNotificationManager(final DiagramEventBroker diagramEventBroker, final EObject view, final NotificationListener notificationListener) {
START 		if (manager != null) { END 
			return manager;
		}
		manager = new ProviderNotificationManager(diagramEventBroker, view, notificationListener) {
			@Override
			protected void registerListeners() {
				// TODO install listener on allocation(Abstraction) of the model.
			}
		};
		return manager;
	}
","	public ProviderNotificationManager createProviderNotificationManager(final DiagramEventBroker diagramEventBroker, final EObject view, final NotificationListener notificationListener) {
		if (null != manager) {
			return manager;
		}
		manager = new ProviderNotificationManager(diagramEventBroker, view, notificationListener) {
			@Override
			protected void registerListeners() {
				// TODO install listener on allocation(Abstraction) of the model.
			}
		};
		return manager;
	}
"
43,This method can be`private`.,"    public void startSyncFolderOperation(OCFile folder) {
        long currentSyncTime = System.currentTimeMillis(); 
        
        mSyncInProgress = true;
        
        // perform folder synchronization
        RemoteOperation synchFolderOp = new RefreshFolderOperation( folder,
                                                                        currentSyncTime, 
                                                                        false,
                                                                        false,
                                                                        false,
                                                                        getStorageManager(),
                                                                        getAccount(),
                                                                        getApplicationContext()
                                                                      );
        synchFolderOp.execute(getAccount(), this, null, null);
    }
","START     public void startSyncFolderOperation(OCFile folder) { END 
        long currentSyncTime = System.currentTimeMillis(); 
        
        mSyncInProgress = true;
        
        // perform folder synchronization
        RemoteOperation synchFolderOp = new RefreshFolderOperation( folder,
                                                                        currentSyncTime, 
                                                                        false,
                                                                        false,
                                                                        false,
                                                                        getStorageManager(),
                                                                        getAccount(),
                                                                        getApplicationContext()
                                                                      );
        synchFolderOp.execute(getAccount(), this, null, null);
    }
","    private void startSyncFolderOperation(OCFile folder) {
        long currentSyncTime = System.currentTimeMillis(); 
        
        mSyncInProgress = true;
        
        // perform folder synchronization
        RemoteOperation synchFolderOp = new RefreshFolderOperation( folder,
                                                                        currentSyncTime, 
                                                                        false,
                                                                        false,
                                                                        false,
                                                                        getStorageManager(),
                                                                        getAccount(),
                                                                        getApplicationContext()
                                                                      );
        synchFolderOp.execute(getAccount(), this, null, null);
    }
"
44,This can be private again.,"   public static ProtobufMetadataManagerImpl getProtobufMetadataManager(EmbeddedCacheManager cacheManager) {
      if (cacheManager == null) {
         throw new IllegalArgumentException(""cacheManager cannot be null"");
      }
      ProtobufMetadataManagerImpl metadataManager = (ProtobufMetadataManagerImpl) cacheManager.getGlobalComponentRegistry().getComponent(ProtobufMetadataManager.class);
      if (metadataManager == null) {
         throw new IllegalStateException(""ProtobufMetadataManager not initialised yet!"");
      }
      return metadataManager;
   }
","START    public static ProtobufMetadataManagerImpl getProtobufMetadataManager(EmbeddedCacheManager cacheManager) { END 
      if (cacheManager == null) {
         throw new IllegalArgumentException(""cacheManager cannot be null"");
      }
      ProtobufMetadataManagerImpl metadataManager = (ProtobufMetadataManagerImpl) cacheManager.getGlobalComponentRegistry().getComponent(ProtobufMetadataManager.class);
      if (metadataManager == null) {
         throw new IllegalStateException(""ProtobufMetadataManager not initialised yet!"");
      }
      return metadataManager;
   }
","   private static ProtobufMetadataManagerImpl getProtobufMetadataManager(EmbeddedCacheManager cacheManager) {
      if (cacheManager == null) {
         throw new IllegalArgumentException(""cacheManager cannot be null"");
      }
      ProtobufMetadataManagerImpl metadataManager = (ProtobufMetadataManagerImpl) cacheManager.getGlobalComponentRegistry().getComponent(ProtobufMetadataManager.class);
      if (metadataManager == null) {
         throw new IllegalStateException(""ProtobufMetadataManager not initialised yet!"");
      }
      return metadataManager;
   }
"
45,Should this log message be before or after we actually do update the session key?,"        public void onSessionKeyUpdate(SessionKey sessionKey) {
            log.info(""Session key updated"");

            synchronized (DistributedHerder.this) {
                DistributedHerder.this.sessionKey = sessionKey.key();
                if (isLeader() && keyRotationIntervalMs > 0) {
                    DistributedHerder.this.keyExpiration = sessionKey.creationTimestamp() + keyRotationIntervalMs;
                }
            }
        }
","        public void onSessionKeyUpdate(SessionKey sessionKey) {
START             log.info(""Session key updated""); END 

            synchronized (DistributedHerder.this) {
                DistributedHerder.this.sessionKey = sessionKey.key();
                if (isLeader() && keyRotationIntervalMs > 0) {
                    DistributedHerder.this.keyExpiration = sessionKey.creationTimestamp() + keyRotationIntervalMs;
                }
            }
        }
","        public void onSessionKeyUpdate(SessionKey sessionKey) {
            log.info(""Session key updated"");

            synchronized (DistributedHerder.this) {
                DistributedHerder.this.sessionKey = sessionKey.key();
                // Track the expiration of the key if and only if this worker is the leader
                // Followers will receive rotated keys from the follower and won't be responsible for
                // tracking expiration and distributing new keys themselves
                if (isLeader() && keyRotationIntervalMs > 0) {
                    DistributedHerder.this.keyExpiration = sessionKey.creationTimestamp() + keyRotationIntervalMs;
                }
            }
        }
"
46,forgotten line of code?,"	public String getAuthorizationUrl(OAuthConfig config) {
		System.out.print(""Authorisation URL: "");
		
		// User must provide these 5 elements to the service builder		
		String url = String.format(AUTHORIZE_URL, 
				OAuthEncoder.encode(config.getApiKey()),
				OAuthEncoder.encode(config.getCallback()),
				OAuthEncoder.encode(config.getScope()),
				OAuthEncoder.encode(config.getState()));
		
		return url;
	}
","	public String getAuthorizationUrl(OAuthConfig config) {
START 		System.out.print(""Authorisation URL: ""); END 
		
		// User must provide these 5 elements to the service builder		
		String url = String.format(AUTHORIZE_URL, 
				OAuthEncoder.encode(config.getApiKey()),
				OAuthEncoder.encode(config.getCallback()),
				OAuthEncoder.encode(config.getScope()),
				OAuthEncoder.encode(config.getState()));
		
		return url;
	}
","	public String getAuthorizationUrl(OAuthConfig config) {
		
		// User must provide these 4 elements to the service builder		
		String url = String.format(AUTHORIZE_URL, 
				OAuthEncoder.encode(config.getApiKey()),
				OAuthEncoder.encode(config.getCallback()),
				OAuthEncoder.encode(config.getScope()),
				OAuthEncoder.encode(config.getState()));
		
		return url;
	}
"
47,"This code here should be inside the if, because we don't need to do anything if the parameter request is not PARAM_WORKER","    public Object getParameter(String name) {
        final HostThread currentHostThread = fCurrentHostThread;
        if (currentHostThread == null) {
            return null;
        }
        if (name.equals(CriticalPathModule.PARAM_WORKER)) {
            /* Try to find the worker for the critical path */
            IAnalysisModule mod = getModule();
            if ((mod != null) && (mod instanceof CriticalPathModule)) {
                LttngWorker worker = new LttngWorker(currentHostThread, """", 0); //$NON-NLS-1$
                return worker;
            }
            return currentHostThread;
        }
        return null;
    }
","    public Object getParameter(String name) {
START         final HostThread currentHostThread = fCurrentHostThread; END 
        if (currentHostThread == null) {
            return null;
        }
        if (name.equals(CriticalPathModule.PARAM_WORKER)) {
            /* Try to find the worker for the critical path */
            IAnalysisModule mod = getModule();
            if ((mod != null) && (mod instanceof CriticalPathModule)) {
                LttngWorker worker = new LttngWorker(currentHostThread, """", 0); //$NON-NLS-1$
                return worker;
            }
            return currentHostThread;
        }
        return null;
    }
","    public Object getParameter(String name) {
        if (name.equals(CriticalPathModule.PARAM_WORKER)) {
            final HostThread currentHostThread = fCurrentHostThread;
            if (currentHostThread == null) {
                return null;
            }
            /* Try to find the worker for the critical path */
            IAnalysisModule mod = getModule();
            if ((mod != null) && (mod instanceof CriticalPathModule)) {
                LttngWorker worker = new LttngWorker(currentHostThread, """", 0); //$NON-NLS-1$
                return worker;
            }
            return currentHostThread;
        }
        return null;
    }
"
48,Maybe `expectThrowable` for consistency?,"	public static ExceptionThrowingSubTest expectThrowable(Runnable runnable) {
		return expectException( runnable.toString(), runnable );
	}
","	public static ExceptionThrowingSubTest expectThrowable(Runnable runnable) {
START 		return expectException( runnable.toString(), runnable ); END 
	}
","	public static ExceptionThrowingSubTest expectThrowable(Runnable runnable) {
		return expectThrowable( runnable.toString(), runnable );
	}
"
49,remove this,"    protected CONNECTCXFClient(ServicePortDescriptor<T> portDescriptor, String url, AssertionType assertion,
        ServicePortBuilder<T> portBuilder) {
        serviceEndpoint = super.configureBasePort(portBuilder.createPort(), url,
            assertion != null ? assertion.getTransactionTimeout() : null);
        configCNCheck();
    }
","    protected CONNECTCXFClient(ServicePortDescriptor<T> portDescriptor, String url, AssertionType assertion,
        ServicePortBuilder<T> portBuilder) {
        serviceEndpoint = super.configureBasePort(portBuilder.createPort(), url,
            assertion != null ? assertion.getTransactionTimeout() : null);
START         configCNCheck(); END 
    }
","    protected CONNECTCXFClient(ServicePortDescriptor<T> portDescriptor, String url, AssertionType assertion,
        ServicePortBuilder<T> portBuilder) {
        serviceEndpoint = super.configureBasePort(portBuilder.createPort(), url,
            assertion != null ? assertion.getTransactionTimeout() : null);
    }
"
50,Can we add the name of the setting in there somewhere as well?,"    public <V> Setting<V> get(SimpleUri id, Class<V> valueType) {
        Setting setting = settings.get(id);
        Class settingValueClass = setting.getValueClass();

        if (!settingValueClass.equals(valueType)) {
            throw new ClassCastException(
                    ""Expected a Setting of type "" + valueType.getName() +
                    "", found a Setting of type "" + settingValueClass.getName()
            );
        }

        return (Setting<V>) setting;
    }
","    public <V> Setting<V> get(SimpleUri id, Class<V> valueType) {
        Setting setting = settings.get(id);
        Class settingValueClass = setting.getValueClass();

        if (!settingValueClass.equals(valueType)) {
            throw new ClassCastException(
                    ""Expected a Setting of type "" + valueType.getName() +
                    "", found a Setting of type "" + settingValueClass.getName()
START             ); END 
        }

        return (Setting<V>) setting;
    }
","    public <V> Setting<V> get(SimpleUri id, Class<V> valueType) {
        Setting setting = settings.get(id);

        if (setting == null) {
            return null;
        }

        Class settingValueClass = setting.getValueClass();

        if (!settingValueClass.equals(valueType)) {
            throw new ClassCastException(
                    ""Expected a Setting of type "" + valueType.getName() +
                    "", found a Setting of type "" + settingValueClass.getName()
            );
        }

        return (Setting<V>) setting;
    }
"
51,"it's better to init customFields with an empty collection to avoid ""==null""","    public String getCustomField(String fieldName) {
        if(customFields == null) return null;
        for (CustomField f : customFields) {
            if (f.getName().equals(fieldName)) {
                return f.getValue();
            }
        }
        return null;
    }
","    public String getCustomField(String fieldName) {
START         if(customFields == null) return null; END 
        for (CustomField f : customFields) {
            if (f.getName().equals(fieldName)) {
                return f.getValue();
            }
        }
        return null;
    }
","    public String getCustomField(String fieldName) {
        for (CustomField f : customFields) {
            if (f.getName().equals(fieldName)) {
                return f.getValue();
            }
        }
        return null;
    }
"
52,"Any way we can clean this up? It seems to only be needed for example commands, but hard to check what the command is here since it's wrapped in decorators.","    private CommandCall duplicateCommandForDifferentElement(CommandCall commandCall, Element element) {

        String expression = commandCall.getExpression();
        if (expression.equals("""")) {
            expression = element.getText();
        }

        return new CommandCall(null, commandCall.getCommand(), element, expression, commandCall.getResource());
    }
","    private CommandCall duplicateCommandForDifferentElement(CommandCall commandCall, Element element) {

        String expression = commandCall.getExpression();
START         if (expression.equals("""")) { END 
            expression = element.getText();
        }

        return new CommandCall(null, commandCall.getCommand(), element, expression, commandCall.getResource());
    }
","    private CommandCall duplicateCommandForDifferentElement(CommandCall commandCall, Element element) {
        return new CommandCall(
                null,
                commandCall.getCommand(),
                element,
                commandCall.getExpression(),
                commandCall.getResource());
    }
"
53,"TException is throwable, too, and treated the same -- combine the catch clauses?","  public M fromBytes(byte[] messageBuffer) {
    if (deserializer == null)
      deserializer = new ThriftBinaryDeserializer();
    try {
      M message = typeRef.safeNewInstance();
      deserializer.deserialize(message, messageBuffer);
      return message;
    } catch (TException e) {
      logWarning(""failed to deserialize"", e);
      return null;
    } catch (Throwable e) {
      // Arbitrary bytes can cause a runtime exception in Thrift
      logWarning(""failed to deserialize"", e);
      return null;
    }
  }
","  public M fromBytes(byte[] messageBuffer) {
    if (deserializer == null)
      deserializer = new ThriftBinaryDeserializer();
    try {
      M message = typeRef.safeNewInstance();
      deserializer.deserialize(message, messageBuffer);
      return message;
    } catch (TException e) {
      logWarning(""failed to deserialize"", e);
      return null;
START     } catch (Throwable e) { END 
      // Arbitrary bytes can cause a runtime exception in Thrift
      logWarning(""failed to deserialize"", e);
      return null;
    }
  }
","  public M fromBytes(byte[] messageBuffer) {
    if (deserializer == null)
      deserializer = new ThriftBinaryDeserializer();
    try {
      M message = typeRef.safeNewInstance();
      deserializer.deserialize(message, messageBuffer);
      return message;
    } catch (Throwable e) {
      // normally a TException. but some corrupt records can cause
      // other runtime exceptions (e.g. IndexOutOfBoundsException).
      logWarning(""failed to deserialize"", e);
      return null;
    }
  }
"
54,remove,"    public void showPage(Control page) {
		if (page.isDisposed() || page.getParent() != this) {
			return;
		}

		currentPage = page;

        // show new page
		page.setVisible(true);
		layout(true);

		// hide old (and all others) *after* new page has been made visible in
		// order to avoid flashing
		Control[] children = getChildren();
		for (Control element : children) {
			Control child = element;
			if (child != page && !child.isDisposed()) {
				child.setVisible(false);
			}
		}
    }
","    public void showPage(Control page) {
		if (page.isDisposed() || page.getParent() != this) {
			return;
		}

		currentPage = page;

        // show new page
		page.setVisible(true);
		layout(true);

		// hide old (and all others) *after* new page has been made visible in
		// order to avoid flashing
		Control[] children = getChildren();
		for (Control element : children) {
START 			Control child = element; END 
			if (child != page && !child.isDisposed()) {
				child.setVisible(false);
			}
		}
    }
","    public void showPage(Control page) {
		if (page.isDisposed() || page.getParent() != this) {
			return;
		}

		currentPage = page;

        // show new page
		page.setVisible(true);
		layout(true);

		// hide old (and all others) *after* new page has been made visible in
		// order to avoid flashing
		for (Control child : getChildren()) {
			if (child != page && !child.isDisposed()) {
				child.setVisible(false);
			}
		}
    }
"
55,info vs warn,"    public void info(String message, Object... objects) {
        LOG.warn(message, objects);
    }
","    public void info(String message, Object... objects) {
START         LOG.warn(message, objects); END 
    }
","    public void info(String message, Object... objects) {
        LOG.info(message, objects);
    }
"
56,Let's avoid `null` and rework to empty string,"	public String getLinkAt(int offset) {
		// Check if there is a link at the offset
		for (int i = 0; i < linkRanges.size(); i++) {
			if (linkRanges.get(i).isOffsetInRange(offset)) {
				return hrefs.get(i);
			}
		}
		return null;
	}
","	public String getLinkAt(int offset) {
		// Check if there is a link at the offset
		for (int i = 0; i < linkRanges.size(); i++) {
			if (linkRanges.get(i).isOffsetInRange(offset)) {
				return hrefs.get(i);
			}
		}
START 		return null; END 
	}
","	public Optional<String> getLinkAt(int offset) {
		// Check if there is a link at the offset
		for (int i = 0; i < linkRanges.size(); i++) {
			if (linkRanges.get(i).contains(offset)) {
				return Optional.of(hrefs.get(i));
			}
		}
		return Optional.empty();
	}
"
57,This change I requested was supposed to remove the need for a read lock,"   public String toString() {
      readLock.lock();
      try {
         return ""FileListCacheValue{fileNames="" + getFileNames() + ""}"";
      } finally {
         readLock.unlock();
      }
   }
","   public String toString() {
      readLock.lock();
      try {
START          return ""FileListCacheValue{fileNames="" + getFileNames() + ""}""; END 
      } finally {
         readLock.unlock();
      }
   }
","   public String toString() {
      return ""FileListCacheValue{fileNames="" + getFileNames() + ""}"";
   }
"
58,Please not here. This is not a standard SWT table.,"    protected Control createControl(Composite parent) {
        
        // Configure table
        CTConfiguration config = new CTConfiguration(parent, CTConfiguration.STYLE_GRID);
        config.setHorizontalAlignment(SWT.CENTER);
        config.setCellSelectionEnabled(false);
        config.setColumnSelectionEnabled(false);
        config.setRowSelectionEnabled(false);
        config.setColumnHeaderLayout(CTConfiguration.COLUMN_HEADER_LAYOUT_FILL_EQUAL);
        config.setRowHeaderLayout(CTConfiguration.ROW_HEADER_LAYOUT_DEFAULT);

        this.table = new ComponentTable(parent, SWT.FULL_SELECTION, config);
        return this.table.getControl();
    }
","    protected Control createControl(Composite parent) {
        
        // Configure table
        CTConfiguration config = new CTConfiguration(parent, CTConfiguration.STYLE_GRID);
        config.setHorizontalAlignment(SWT.CENTER);
        config.setCellSelectionEnabled(false);
        config.setColumnSelectionEnabled(false);
        config.setRowSelectionEnabled(false);
        config.setColumnHeaderLayout(CTConfiguration.COLUMN_HEADER_LAYOUT_FILL_EQUAL);
        config.setRowHeaderLayout(CTConfiguration.ROW_HEADER_LAYOUT_DEFAULT);

START         this.table = new ComponentTable(parent, SWT.FULL_SELECTION, config); END 
        return this.table.getControl();
    }
","    protected Control createControl(Composite parent) {
        
        // Configure table
        CTConfiguration config = new CTConfiguration(parent, CTConfiguration.STYLE_GRID);
        config.setHorizontalAlignment(SWT.CENTER);
        config.setCellSelectionEnabled(false);
        config.setColumnSelectionEnabled(false);
        config.setRowSelectionEnabled(false);
        config.setColumnHeaderLayout(CTConfiguration.COLUMN_HEADER_LAYOUT_FILL_EQUAL);
        config.setRowHeaderLayout(CTConfiguration.ROW_HEADER_LAYOUT_DEFAULT);

        this.table = new ComponentTable(parent, SWT.NONE, config);
        return this.table.getControl();
    }
"
59,return 'true',"	public boolean isEnabled() {
		return getActiveTextEditor() != null;
	}
","	public boolean isEnabled() {
		return START  getActiveTextEditor() != null; END 
	}
","	public boolean isEnabled() {
		return true;
	}
"
60,maybe you need a specific Exception Type,"    void verifyMetadata(MessageMetadata metadata) throws Exception {
        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) {
            log.error(""Wrong message metadata {}, expecting  type {} snapshot {}"", metadata,
                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);
            throw new Exception(""wrong type of message"");
        }
    }
","    void verifyMetadata(MessageMetadata metadata) throws Exception {
        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE || metadata.getSnapshotTimestamp() != srcGlobalSnapshot) {
            log.error(""Wrong message metadata {}, expecting  type {} snapshot {}"", metadata,
                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);
START             throw new Exception(""wrong type of message""); END 
        }
    }
","    void verifyMetadata(MessageMetadata metadata) throws Exception {
        if (metadata.getMessageMetadataType() != MessageType.LOG_ENTRY_MESSAGE) {
            log.error(""Wrong message metadata {}, expecting  type {} snapshot {}"", metadata,
                    MessageType.LOG_ENTRY_MESSAGE, srcGlobalSnapshot);
            throw new Exception(""wrong type of message"");
        }
    }
"
61,"This is a bug, the setter does nothing, use 'this'","    public void setVmBackup(VmBackup value) {
        vmBackup = value;
    }
","    public void setVmBackup(VmBackup value) {
        START  vmBackup = value; END 
    }
","    public void setVmBackup(VmBackup value) {
        this.vmBackup = value;
    }
"
62,what is this part for? you are not checking throw statements.,"  public void setPrice1(int price3) {
    if (price3 < 0 || price3 > 10000) {
      throw new IllegalArgumentException(""Invalid price: "" + price3); // Compliant
    }
    if (true) {
      assert price3 > 1000; // Noncompliant
    }
  }
","  public void setPrice1(int price3) {
    if (price3 < 0 || price3 > 10000) {
START       throw new IllegalArgumentException(""Invalid price: "" + price3); // Compliant END 
    }
    if (true) {
      assert price3 > 1000; // Noncompliant
    }
  }
","  public void setPrice1(int price3) {
    if (true) {
      assert price3 > 1000; // Noncompliant
    }
  }
"
63,This will fail on `null`,"    public String evaluate(TransactionContext txnCtx, Input<Object>[] args) {
        assert args.length == 2 : ""repeat takes exactly two arguments"";
        var text = (String) args[0].value();
        if (text == null) {
            return null;
        }
        var repetitions = (int) args[1].value();
        if (repetitions <= 0) {
            return """";
        } else {
            return text.repeat(repetitions);
        }
    }
","    public String evaluate(TransactionContext txnCtx, Input<Object>[] args) {
        assert args.length == 2 : ""repeat takes exactly two arguments"";
        var text = (String) args[0].value();
        if (text == null) {
            return null;
        }
START         var repetitions = (int) args[1].value(); END 
        if (repetitions <= 0) {
            return """";
        } else {
            return text.repeat(repetitions);
        }
    }
","    public String evaluate(TransactionContext txnCtx, Input<Object>[] args) {
        assert args.length == 2 : ""repeat takes exactly two arguments"";
        var text = (String) args[0].value();
        var repetitions = (Integer) args[1].value();
        if (text == null || repetitions == null) {
            return null;
        }

        if (repetitions <= 0) {
            return """";
        } else {
            return text.repeat(repetitions);
        }
    }
"
64,why is this public?,"  public void setActionBarNotificationBarColor(MaterialColor color) {
    getSupportActionBar().setBackgroundDrawable(new ColorDrawable(color.toActionBarColor(this)));

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      getWindow().setStatusBarColor(color.toStatusBarColor(this));
    }
  }
","START   public void setActionBarNotificationBarColor(MaterialColor color) { END 
    getSupportActionBar().setBackgroundDrawable(new ColorDrawable(color.toActionBarColor(this)));

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      getWindow().setStatusBarColor(color.toStatusBarColor(this));
    }
  }
","  private void setActionBarNotificationBarColor(MaterialColor color) {
    getSupportActionBar().setBackgroundDrawable(new ColorDrawable(color.toActionBarColor(this)));

    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      getWindow().setStatusBarColor(color.toStatusBarColor(this));
    }
  }
"
65,Please use {} for every if/else/for/etc. block.,"    public static ProjectBuildType getProjectType(IProject project) {
        // ------------ AUTOTOOLS
        // Autotools has an 'Autotools' nature by which we can identify it.
        if (isAutoTools(project))
            return ProjectBuildType.AUTO_TOOLS;

        IConfiguration defaultConfiguration = helper_getActiveConfiguration(project);
        IBuilder builder = defaultConfiguration.getBuilder();
        Boolean projIsManaged = builder.isManagedBuildOn();

        if (projIsManaged)
            return ProjectBuildType.MANAGED_MAKEFILE;
        else
            return ProjectBuildType.OTHER; //E.g a manual makefile.
    }
","    public static ProjectBuildType getProjectType(IProject project) {
        // ------------ AUTOTOOLS
        // Autotools has an 'Autotools' nature by which we can identify it.
START         if (isAutoTools(project)) END 
            return ProjectBuildType.AUTO_TOOLS;

        IConfiguration defaultConfiguration = helper_getActiveConfiguration(project);
        IBuilder builder = defaultConfiguration.getBuilder();
        Boolean projIsManaged = builder.isManagedBuildOn();

        if (projIsManaged)
            return ProjectBuildType.MANAGED_MAKEFILE;
        else
            return ProjectBuildType.OTHER; //E.g a manual makefile.
    }
","    public static ProjectBuildType getProjectType(IProject project) {
        // ---------- AUTOTOOLS
        // Autotools has an 'Autotools' nature by which we can identify it.
        if (isAutoTools(project)) {
            return ProjectBuildType.AUTO_TOOLS;
        }

        IConfiguration defaultConfiguration = helper_getActiveConfiguration(project);
        IBuilder builder = defaultConfiguration.getBuilder();
        Boolean projIsManaged = builder.isManagedBuildOn();

        // ----------  MANAGED PROJECT
        if (projIsManaged) {
            return ProjectBuildType.MANAGED_MAKEFILE;
        }
        else {
            return ProjectBuildType.OTHER; //E.g a manual makefile.
        }
    }
"
66,This isn't necessary.,"  protected long download(T object, File outFile) throws IOException
  {
    try {
      openObjectFunction.open(object, outFile);
    }
    catch (IOException e) {
      throw new RuntimeException(e);
    }
    return outFile.length();
  }
","  protected long download(T object, File outFile) throws IOException
  {
    try {
      openObjectFunction.open(object, outFile);
    }
START     catch (IOException e) { END 
      throw new RuntimeException(e);
    }
    return outFile.length();
  }
","  protected long download(T object, File outFile) throws IOException
  {
    openObjectFunction.open(object, outFile);
    return outFile.length();
  }
"
67,what's the point of catching and then throwing the same exception type?,"   private Collection<VCastResult> getResultFiles(VCastDataStore dataStore) {
      Collection<VCastResult> results = null;
      try {
         results = dataStore.getAllResults();
      } catch (OseeCoreException ex) {
         throw new OseeCoreException(ex, ""SQL error while reading results"");
      }
      return results;
   }
","   private Collection<VCastResult> getResultFiles(VCastDataStore dataStore) {
      Collection<VCastResult> results = null;
      try {
         results = dataStore.getAllResults();
      } catch (OseeCoreException ex) {
START          throw new OseeCoreException(ex, ""SQL error while reading results""); END 
      }
      return results;
   }
","   private Collection<VCastResult> getResultFiles(VCastDataStore dataStore) {
      Collection<VCastResult> results = null;
      results = dataStore.getAllResults();
      return results;
   }
"
68,public,"        public PinotQueryGeneratorContext visitFilter(FilterNode node, PinotQueryGeneratorContext context)
        {
            context = node.getSource().accept(this, context);
            requireNonNull(context, ""context is null"");
            LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections();
            String filter = node.getPredicate().accept(pinotFilterExpressionConverter, (var) -> selections.get(var)).getDefinition();
            return context.withFilter(filter).withOutputColumns(node.getOutputVariables());
        }
","        public PinotQueryGeneratorContext visitFilter(FilterNode node, PinotQueryGeneratorContext context)
START         { END 
            context = node.getSource().accept(this, context);
            requireNonNull(context, ""context is null"");
            LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections();
            String filter = node.getPredicate().accept(pinotFilterExpressionConverter, (var) -> selections.get(var)).getDefinition();
            return context.withFilter(filter).withOutputColumns(node.getOutputVariables());
        }
","        public PinotQueryGeneratorContext visitFilter(FilterNode node, PinotQueryGeneratorContext context)
        {
            context = node.getSource().accept(this, context);
            requireNonNull(context, ""context is null"");
            LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections();
            String filter = node.getPredicate().accept(pinotFilterExpressionConverter, selections::get).getDefinition();
            return context.withFilter(filter).withOutputColumns(node.getOutputVariables());
        }
"
69,JavaDoc and method signature did not match. Please update the JavaDoc!,"    private Space(String enumeratedValue) {
        this.enumeratedValue = enumeratedValue;
    }
","START     private Space(String enumeratedValue) { END 
        this.enumeratedValue = enumeratedValue;
    }
","    Space(String enumeratedValue) {
        this.enumeratedValue = enumeratedValue;
    }
"
70,still requires fix: domain.getstorage_domain_type() == type,"    public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) {
        Guid returnValue = Guid.Empty;
        List<storage_domains> domains = getAllForStoragePool(pool);
        for (storage_domains domain : domains) {
            if (domain.getstorage_domain_type() == StorageDomainType.Master) {
                returnValue = domain.getId();
                break;
            }
        }
        return returnValue;
    }
","    public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) {
        Guid returnValue = Guid.Empty;
        List<storage_domains> domains = getAllForStoragePool(pool);
        for (storage_domains domain : domains) {
START             if (domain.getstorage_domain_type() == StorageDomainType.Master) { END 
                returnValue = domain.getId();
                break;
            }
        }
        return returnValue;
    }
","    public Guid getStorageDomainIdForPoolByType(Guid pool, StorageDomainType type) {
        Guid returnValue = Guid.Empty;
        List<storage_domains> domains = getAllForStoragePool(pool);
        for (storage_domains domain : domains) {
            if (domain.getstorage_domain_type() == type) {
                returnValue = domain.getId();
                break;
            }
        }
        return returnValue;
    }
"
71,"For this it's better to do:

```
threadsLocked.inc();
try {
    // other stuff
} finally {
    threadsLocked.dec();
}
```

This way if an exception is thrown we still decrement the threadsLocked counter.","    public void lock(T id) throws InterruptedException {
        threadsLocked.inc();
        idsLocked.update(1);
        lockInternal(id);
        threadsLocked.dec();
    }
","    public void lock(T id) throws InterruptedException {
START         threadsLocked.inc(); END 
        idsLocked.update(1);
        lockInternal(id);
        threadsLocked.dec();
    }
","    public void lock(T id) throws InterruptedException {
        threadsLocked.inc();
        try {
            idsLocked.update(1);
            lockInternal(id);
        } finally {
            threadsLocked.dec();
        }
    }
"
72,"looks like syntax typo

(`Add position checks in RunLenghtEncodedBlock` commit)","    public RunLengthEncodedBlock(Block value, int positionCount)
    {
        requireNonNull(value, ""value is null"");
        if (value.getPositionCount() != 1) {
            throw new IllegalArgumentException(format(""Expected value to contain a single position but has %s positions"", value.getPositionCount()));
        }

        // value can not be a RunLengthEncodedBlock because this could cause stack overflow in some of the methods
        if (value instanceof RunLengthEncodedBlock) {
            throw new IllegalArgumentException(format(""Value can not be an instance of a %s"", getClass().getName()));
        }

        if (positionCount < 0) {
            throw new IllegalArgumentException(""positionCount is negative"");
        }

        this.value = value
        this.positionCount = positionCount;
    }
","    public RunLengthEncodedBlock(Block value, int positionCount)
    {
        requireNonNull(value, ""value is null"");
        if (value.getPositionCount() != 1) {
            throw new IllegalArgumentException(format(""Expected value to contain a single position but has %s positions"", value.getPositionCount()));
        }

        // value can not be a RunLengthEncodedBlock because this could cause stack overflow in some of the methods
        if (value instanceof RunLengthEncodedBlock) {
            throw new IllegalArgumentException(format(""Value can not be an instance of a %s"", getClass().getName()));
        }

        if (positionCount < 0) {
            throw new IllegalArgumentException(""positionCount is negative"");
        }

START         this.value = value END 
        this.positionCount = positionCount;
    }
","    public RunLengthEncodedBlock(Block value, int positionCount)
    {
        requireNonNull(value, ""value is null"");
        if (value.getPositionCount() != 1) {
            throw new IllegalArgumentException(format(""Expected value to contain a single position but has %s positions"", value.getPositionCount()));
        }

        if (value instanceof RunLengthEncodedBlock) {
            this.value = ((RunLengthEncodedBlock) value).getValue();
        }
        else {
            this.value = value;
        }

        if (positionCount < 0) {
            throw new IllegalArgumentException(""positionCount is negative"");
        }

        this.positionCount = positionCount;
    }
"
73,Is the idea to always copy because the request could be used again in a Retry (independent of a speculative execution being executed?),"        public Message.Request request() {
            Message.Request request = callback.request();
            if (retryConsistencyLevel != null && retryConsistencyLevel != request.consistency())
                return request.copy(retryConsistencyLevel);
            else
                return request;
        }
","        public Message.Request request() {
START             Message.Request request = callback.request(); END 
            if (retryConsistencyLevel != null && retryConsistencyLevel != request.consistency())
                return request.copy(retryConsistencyLevel);
            else
                return request;
        }
","        public Message.Request request() {
            if (retryConsistencyLevel != null && retryConsistencyLevel != request.consistency())
                return request.copy(retryConsistencyLevel);
            else
                return request;
        }
"
74,I would prefer to use full words. For example `directoryAllow`.,"    public void init(FilterConfig filterConfig) throws ServletException {
        dirAllowed = Context.getConfig().getBoolean(""media.dirAllowed"");
    }
","    public void init(FilterConfig filterConfig) throws ServletException {
START         dirAllowed = Context.getConfig().getBoolean(""media.dirAllowed""); END 
    }
","    public void init(FilterConfig filterConfig) throws ServletException {
    }
"
75,"This is backwards, you want the expected condition to be here.","    public ExtentBufferedCompositePattern(Extent extent, Pattern... patterns) {
        super(extent);
        checkArgument(patterns.length == 0, ""patterns cannot be empty"");
        this.patterns = patterns;
    }
","    public ExtentBufferedCompositePattern(Extent extent, Pattern... patterns) {
        super(extent);
START         checkArgument(patterns.length == 0, ""patterns cannot be empty""); END 
        this.patterns = patterns;
    }
","    public ExtentBufferedCompositePattern(Extent extent, Pattern... patterns) {
        super(extent);
        checkArgument(patterns.length != 0, ""patterns cannot be empty"");
        this.patterns = patterns;
    }
"
76,"It's tangential, but `IllegalArgumentException` seems more reasonable.","	public boolean isValid(Object[] value, ConstraintValidatorContext context) {
		if ( value.length != 3 ) {
			throw new IllegalStateException( ""Unexpected method signature"" );
		}
		// one or both limits are unbounded => always consistent
		if ( value[1] == null || value[2] == null ) {
			return true;
		}
		return ( (Date) value[1] ).before( (Date) value[2] );
	}
","	public boolean isValid(Object[] value, ConstraintValidatorContext context) {
		if ( value.length != 3 ) {
START 			throw new IllegalStateException( ""Unexpected method signature"" ); END 
		}
		// one or both limits are unbounded => always consistent
		if ( value[1] == null || value[2] == null ) {
			return true;
		}
		return ( (Date) value[1] ).before( (Date) value[2] );
	}
","	public boolean isValid(Object[] value, ConstraintValidatorContext context) {
		if ( value.length != 3 ) {
			throw new IllegalArgumentException( ""Unexpected method signature"" );
		}
		// one or both limits are unbounded => always consistent
		if ( value[1] == null || value[2] == null ) {
			return true;
		}
		return ( (Date) value[1] ).before( (Date) value[2] );
	}
"
77,maybe check for start of file or newline also?,"	private static boolean monoNativeFailure(Either<Utils.CommandResult> result) {
		if (result == null || !result.isSuccess()) {
			return true;
		} else {
			Utils.CommandResult commandResult = result.get();
			return monoNativeFailure(commandResult.output) || monoNativeFailure(commandResult.error);
		}
	}
","START 	private static boolean monoNativeFailure(Either<Utils.CommandResult> result) { END 
		if (result == null || !result.isSuccess()) {
			return true;
		} else {
			Utils.CommandResult commandResult = result.get();
			return monoNativeFailure(commandResult.output) || monoNativeFailure(commandResult.error);
		}
	}
","	static boolean monoNativeFailure(Either<Utils.CommandResult> result) {
		if (result == null || !result.isSuccess()) {
			return true;
		} else {
			Utils.CommandResult commandResult = result.get();
			return monoNativeFailure(commandResult.output) || monoNativeFailure(commandResult.error);
		}
	}
"
78,"Another extra space, can you plese cleanup all these similar things? There're a few others, some functions have spaces in parameters, some don't like `queryPos( APPBARDATA ABData )` vs. `dwABM.setValue(ShellAPI.ABM_QUERYPOS);`. Sorry to be a pest, just looks messy and inconsistent.","    private void removeAppBar()  {
    	
		DWORD dwABM = new DWORD();
    	APPBARDATA ABData = new APPBARDATA.ByReference();
    	ABData.cbSize.setValue( ABData.size() );
    	dwABM.setValue(ShellAPI.ABM_REMOVE);
    	UINT_PTR result = Shell32.INSTANCE.SHAppBarMessage( dwABM, ABData);
        assertNotNull(result );

    }
","    private void removeAppBar()  {
    	
		DWORD dwABM = new DWORD();
    	APPBARDATA ABData = new APPBARDATA.ByReference();
    	ABData.cbSize.setValue( ABData.size() );
    	dwABM.setValue(ShellAPI.ABM_REMOVE);
    	UINT_PTR result = Shell32.INSTANCE.SHAppBarMessage( dwABM, ABData);
START         assertNotNull(result ); END 

    }
","    private void removeAppBar() {
        APPBARDATA data = new APPBARDATA.ByReference();
        data.cbSize.setValue(data.size());
        UINT_PTR result = Shell32.INSTANCE.SHAppBarMessage(new DWORD(ShellAPI.ABM_REMOVE), data);
        assertNotNull(result);

    }
"
79,"stray parens

Also, use the standard couldMatch format used through Denizen, not this weird inline thing.","    public boolean couldMatch(ScriptPath path) {
        return (path.eventLower.startsWith(""mythicmob"") && (path.eventArgLowerAt(2).equals(""spawns"")));
    }
","    public boolean couldMatch(ScriptPath path) {
START         return (path.eventLower.startsWith(""mythicmob"") && (path.eventArgLowerAt(2).equals(""spawns""))); END 
    }
","    public boolean couldMatch(ScriptPath path) {
        if (!path.eventLower.startsWith(""mythicmob"")) {
            return false;
        }
        if (!path.eventArgLowerAt(2).equals(""spawns"")) {
            return false;
        }
        return true;
    }
"
80,Why does it resolve controller home? is it better to name it with HomeDir?  It's because this class not only called from controller but agent.,"	void init() {
		controllerHomeDir = resolveControllerHomeDir();
		this.initAccessOfDirectories();
		this.initAccessOfHosts();
	}
","	void init() {
START 		controllerHomeDir = resolveControllerHomeDir(); END 
		this.initAccessOfDirectories();
		this.initAccessOfHosts();
	}
","	void init() {
		this.initAccessOfDirectories();
		this.initAccessOfHosts();
	}
"
81,"It is always expected that launch would be an instance of GdbLaunch, I don't think the check is required.","    protected Sequence getServicesSequence(DsfSession session, ILaunch launch, IProgressMonitor rm) {
    	if (launch instanceof GdbLaunch) {
    		return new ServicesLaunchSequence(session, (GdbLaunch)launch, rm);
    	}
    	return null;
    }
","    protected Sequence getServicesSequence(DsfSession session, ILaunch launch, IProgressMonitor rm) {
    	if (launch instanceof GdbLaunch) {
    		return new ServicesLaunchSequence(session, (GdbLaunch)launch, rm);
    	}
    	return null;
START     } END 
","    protected Sequence getServicesSequence(DsfSession session, ILaunch launch, IProgressMonitor rm) {
   		return new ServicesLaunchSequence(session, (GdbLaunch)launch, rm);
    }
"
82,"`MiddlewareQueryException` is now a run time exception so it is not required to be part of the method signature. Not invalid to have it in signature, but Sonar will report it as a _Major_ category violation.","	public AdvanceResult advanceNursery(final AdvancingNursery advanceInfo, final Workbook workbook) throws RuleException, MiddlewareQueryException, FieldbookException {
		return this.namingConventionService.advanceNursery(advanceInfo, workbook);
	}
","START 	public AdvanceResult advanceNursery(final AdvancingNursery advanceInfo, final Workbook workbook) throws RuleException, MiddlewareQueryException, FieldbookException { END 
		return this.namingConventionService.advanceNursery(advanceInfo, workbook);
	}
","	public AdvanceResult advanceNursery(final AdvancingNursery advanceInfo, final Workbook workbook) throws RuleException, FieldbookException {
		return this.namingConventionService.advanceNursery(advanceInfo, workbook);
	}
"
83,"Please make it non-static, similar to what is done with ManagementNetworkFinder","    public org.ovirt.engine.api.model.Cluster update(org.ovirt.engine.api.model.Cluster incoming) {

        //TODO MM: Dear code reviewer! I'm not sure if this is really cool. I'd assume mapping should happen in mappers, but their powers are limited. Please advise.
        MacPool macPool = incoming.getMacPool();
        macPool.setId(MacPoolIdByIdOrName.get(macPool.getId(), macPool.getName(), this));

        return performUpdate(incoming,
                             new QueryIdResolver<>(VdcQueryType.GetClusterById, IdQueryParameters.class),
                             VdcActionType.UpdateCluster,
                             new UpdateParametersProvider());
    }
","    public org.ovirt.engine.api.model.Cluster update(org.ovirt.engine.api.model.Cluster incoming) {

        //TODO MM: Dear code reviewer! I'm not sure if this is really cool. I'd assume mapping should happen in mappers, but their powers are limited. Please advise.
        MacPool macPool = incoming.getMacPool();
        START macPool.setId(MacPoolIdByIdOrName.get(macPool.getId(), END  macPool.getName(), this));

        return performUpdate(incoming,
                             new QueryIdResolver<>(VdcQueryType.GetClusterById, IdQueryParameters.class),
                             VdcActionType.UpdateCluster,
                             new UpdateParametersProvider());
    }
","    public org.ovirt.engine.api.model.Cluster update(org.ovirt.engine.api.model.Cluster incoming) {

        return performUpdate(incoming,
                             new QueryIdResolver<>(VdcQueryType.GetClusterById, IdQueryParameters.class),
                             VdcActionType.UpdateCluster,
                             new UpdateParametersProvider(this));
    }
"
84,handle this with an error log and returning null instead of a viewer? as the view won't work with an incorrect id?,"    protected @NonNull TmfViewer createLeftChildViewer(@Nullable Composite parent) {
        String analysisId = NonNullUtils.nullToEmptyString(getViewSite().getSecondaryId());
        return new AbstractSegmentStoreScatterChartTreeViewer(Objects.requireNonNull(parent)) {

            @Override
            protected @Nullable ISegmentStoreProvider getSegmentStoreProvider(ITmfTrace trace) {
                IAnalysisModule module = TmfTraceUtils.getAnalysisModuleOfClass(trace, IAnalysisModule.class, analysisId);
                if (module instanceof ISegmentStoreProvider) {
                    return (ISegmentStoreProvider) module;
                }
                return null;
            }

        };
    }
","    protected @NonNull TmfViewer createLeftChildViewer(@Nullable Composite parent) START {
        String analysisId = NonNullUtils.nullToEmptyString(getViewSite().getSecondaryId()); END 
        return new AbstractSegmentStoreScatterChartTreeViewer(Objects.requireNonNull(parent)) {

            @Override
            protected @Nullable ISegmentStoreProvider getSegmentStoreProvider(ITmfTrace trace) {
                IAnalysisModule module = TmfTraceUtils.getAnalysisModuleOfClass(trace, IAnalysisModule.class, analysisId);
                if (module instanceof ISegmentStoreProvider) {
                    return (ISegmentStoreProvider) module;
                }
                return null;
            }

        };
    }
","    protected @NonNull TmfViewer createLeftChildViewer(@Nullable Composite parent) {
        String analysisId = String.valueOf(getViewSite().getSecondaryId());
        return new AbstractSegmentStoreScatterChartTreeViewer(Objects.requireNonNull(parent)) {

            @Override
            protected @Nullable ISegmentStoreProvider getSegmentStoreProvider(ITmfTrace trace) {
                IAnalysisModule module = TmfTraceUtils.getAnalysisModuleOfClass(trace, IAnalysisModule.class, analysisId);
                if (module instanceof ISegmentStoreProvider) {
                    return (ISegmentStoreProvider) module;
                }
                return null;
            }

        };
    }
"
85,I think it makes more sense to omit this assert in the expected exception cases?,"    public void testReservedSkippableBeforeStreamIdentifier() throws Exception {
        ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
            -0x7f, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y'
        });

        assertFalse(channel.writeInbound(in));
    }
","    public void testReservedSkippableBeforeStreamIdentifier() throws Exception {
        ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
            -0x7f, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y'
        });

START         assertFalse(channel.writeInbound(in)); END 
    }
","    public void testReservedSkippableBeforeStreamIdentifier() throws Exception {
        ByteBuf in = Unpooled.wrappedBuffer(new byte[] {
            -0x7f, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y'
        });

        channel.writeInbound(in);
    }
"
86,In the `get` method which calls `getChild` we use `property.getName()` instead of `field.getName().getPrefixedName()` as the key in the `children` map. Can you make this consistent so that we're sure there's no discrepancy between prefixed/unprefixed?,"    public void set(String name, Property property) throws PropertyNotFoundException {
        Field field = getType().getField(name);
        if (field == null) {
            Property removedProperty = computeRemovedProperty(name);
            if (removedProperty != null) {
                removedProperty.set(name, property);
            }
            return;
        }
        children.put(field.getName().getPrefixedName(), property);
        setIsModified();
    }
","    public void set(String name, Property property) throws PropertyNotFoundException {
        Field field = getType().getField(name);
        if (field == null) {
            Property removedProperty = computeRemovedProperty(name);
            if (removedProperty != null) {
                removedProperty.set(name, property);
            }
            return;
        }
START         children.put(field.getName().getPrefixedName(), property); END 
        setIsModified();
    }
","    public void set(String name, Property property) throws PropertyNotFoundException {
        Field field = getType().getField(name);
        if (field == null) {
            Property removedProperty = computeRemovedProperty(name);
            if (removedProperty != null) {
                removedProperty.set(name, property);
            }
            return;
        }
        children.put(property.getName(), property);
        setIsModified();
    }
"
87,`andCardinality(Container)` should be called here instead of `and(Container).getCardinality()`,"    public int andCardinality(Container x) {
    	if (this.getCardinality() == 0)
    		return 0;
    	else if (x.getCardinality() ==0)
    		return 0;
		else
		{
    		if (x instanceof ArrayContainer)
            	return and((ArrayContainer) x).getCardinality();
        	else if (x instanceof BitmapContainer)
            	return and((BitmapContainer) x).getCardinality();
        	return and((RunContainer) x).getCardinality();
    	}
    }
","    public int andCardinality(Container x) {
    	if (this.getCardinality() == 0)
    		return 0;
    	else if (x.getCardinality() ==0)
    		return 0;
		else
		{
    		if (x instanceof ArrayContainer)
START             	return and((ArrayContainer) x).getCardinality(); END 
        	else if (x instanceof BitmapContainer)
            	return and((BitmapContainer) x).getCardinality();
        	return and((RunContainer) x).getCardinality();
    	}
    }
","    public int andCardinality(Container x) {
        if (this.getCardinality() == 0)
            return 0;
        else if (x.getCardinality() == 0)
            return 0;
        else {
            if (x instanceof ArrayContainer)
                return andCardinality((ArrayContainer) x);
            else if (x instanceof BitmapContainer)
                return andCardinality((BitmapContainer) x);
            return andCardinality((RunContainer) x);
        }
    }
"
88,(nit) Initialize with initial capacity to be the number of workers.,"  public Set<WorkerNetAddress> getWorkerAddresses() throws UnavailableException {
    if (mSafeModeManager.isInSafeMode()) {
      throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage());
    }
    Set<WorkerNetAddress> workerAddresses = new HashSet<>();
    for (MasterWorkerInfo worker : mWorkers) {
      // worker net address is unmodifiable after initialization, no locking is needed
      workerAddresses.add(worker.getWorkerAddress());
    }
    return workerAddresses;
  }
","  public Set<WorkerNetAddress> getWorkerAddresses() throws UnavailableException {
    if (mSafeModeManager.isInSafeMode()) {
      throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage());
    }
START     Set<WorkerNetAddress> workerAddresses = new HashSet<>(); END 
    for (MasterWorkerInfo worker : mWorkers) {
      // worker net address is unmodifiable after initialization, no locking is needed
      workerAddresses.add(worker.getWorkerAddress());
    }
    return workerAddresses;
  }
","  public Set<WorkerNetAddress> getWorkerAddresses() throws UnavailableException {
    if (mSafeModeManager.isInSafeMode()) {
      throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage());
    }
    Set<WorkerNetAddress> workerAddresses = new HashSet<>(mWorkers.size());
    for (MasterWorkerInfo worker : mWorkers) {
      // worker net address is unmodifiable after initialization, no locking is needed
      workerAddresses.add(worker.getWorkerAddress());
    }
    return workerAddresses;
  }
"
89,"move this to where `signature` is declared, since it never changes?","    public void setUp() {
        params.put(""CallSid"", ""CA1234567890ABCDE"");
        params.put(""Caller"", ""+14158675309"");
        params.put(""Digits"", ""1234"");
        params.put(""From"", ""+14158675309"");
        params.put(""To"", ""+18005551212"");

        signature = ""RSOYDt4T1cUTdK1PDd93/VVr8B8="";
    }
","    public void setUp() {
        params.put(""CallSid"", ""CA1234567890ABCDE"");
        params.put(""Caller"", ""+14158675309"");
        params.put(""Digits"", ""1234"");
        params.put(""From"", ""+14158675309"");
        params.put(""To"", ""+18005551212"");

START         signature = ""RSOYDt4T1cUTdK1PDd93/VVr8B8=""; END 
    }
","    public void setUp() {
        params.put(""Digits"", ""1234"");
        params.put(""CallSid"", ""CA1234567890ABCDE"");
        params.put(""To"", ""+18005551212"");
        params.put(""Caller"", ""+14158675309"");
        params.put(""From"", ""+14158675309"");
    }
"
90,public @Nullable String...,"        public String getAttributeValue(@Nullable String name) {
            return name;
        }
","START         public String getAttributeValue(@Nullable String name) { END 
            return name;
        }
","        public @Nullable String getAttributeValue(@Nullable String name) {
            return name;
        }
"
91,This logic will obviously need updated once we change `this.cookiesToClear`.,"	public void logout(HttpServletRequest request, HttpServletResponse response,
			Authentication authentication) {
		for (Object cookie : cookiesToClear) {
			Cookie realCookie = null;
			if (cookie instanceof String) {
				realCookie = new Cookie((String) cookie, null);
				String cookiePath = request.getContextPath() + ""/"";
				realCookie.setPath(cookiePath);
				realCookie.setMaxAge(0);
			}else if (cookie instanceof Cookie){
				realCookie = (Cookie) cookie;
			}
			response.addCookie(realCookie);
		}
	}
","	public void logout(HttpServletRequest request, HttpServletResponse response,
			Authentication authentication) {
		for (Object cookie : cookiesToClear) {
			Cookie realCookie = null;
START 			if (cookie instanceof String) { END 
				realCookie = new Cookie((String) cookie, null);
				String cookiePath = request.getContextPath() + ""/"";
				realCookie.setPath(cookiePath);
				realCookie.setMaxAge(0);
			}else if (cookie instanceof Cookie){
				realCookie = (Cookie) cookie;
			}
			response.addCookie(realCookie);
		}
	}
","	public void logout(HttpServletRequest request, HttpServletResponse response,
			Authentication authentication) {
		cookiesToClear.forEach(
			f -> response.addCookie(f.apply(request))
		);
	}
"
92,Can remove the throws `InvalidWebSocketException` now.,"    private MethodHandles.Lookup getMethodHandleLookup(Class<?> endpointClass) throws InvalidWebSocketException
    {
        return MethodHandles.publicLookup().in(endpointClass);
    }
","START     private MethodHandles.Lookup getMethodHandleLookup(Class<?> endpointClass) throws InvalidWebSocketException END 
    {
        return MethodHandles.publicLookup().in(endpointClass);
    }
","    private MethodHandles.Lookup getMethodHandleLookup(Class<?> endpointClass)
    {
        return MethodHandles.publicLookup().in(endpointClass);
    }
"
93,won't this be a double-decrement?,"        public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception
        {
            if (maxConnections > 0) {
                if (numConnections.incrementAndGet() > maxConnections) {
                    ctx.getChannel().close();
                    numConnections.decrementAndGet();
                    log.info(""Accepted connection above limit ({}). Dropping."", maxConnections);
                }
            }
            super.channelOpen(ctx, e);
        }
","        public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception
        {
            if (maxConnections > 0) {
                if (numConnections.incrementAndGet() > maxConnections) {
                    ctx.getChannel().close();
START                     numConnections.decrementAndGet(); END 
                    log.info(""Accepted connection above limit ({}). Dropping."", maxConnections);
                }
            }
            super.channelOpen(ctx, e);
        }
","        public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception
        {
            if (maxConnections > 0) {
                if (numConnections.incrementAndGet() > maxConnections) {
                    ctx.getChannel().close();
                    // numConnections will be decremented in channelClosed
                    log.info(""Accepted connection above limit ({}). Dropping."", maxConnections);
                }
            }
            super.channelOpen(ctx, e);
        }
"
94,"this assumes the input is sorted, but the test case is what calls this; its very possible that the test defined them in non-sorted order","        public Builder from(int ... nums)
        {
            this.matchers.add((from, to, msg) -> Arrays.binarySearch(nums, from) >= 0);
            return this;
        }
","        public Builder from(int ... nums)
        {
START             this.matchers.add((from, to, msg) -> Arrays.binarySearch(nums, from) >= 0); END 
            return this;
        }
","        public Builder from(int... nums)
        {
            from = nums;
            return this;
        }
"
95,@qeesung: nit you can merge the above 2 lines as `checkNotNull` returns `channelClass`.,"    public B channel(Class<? extends C> channelClass) {
        ObjectUtil.checkNotNull(channelClass, ""channelClass"");
        return channelFactory(new ReflectiveChannelFactory<C>(channelClass));
    }
","    public B channel(Class<? extends C> channelClass) {
        ObjectUtil.checkNotNull(channelClass, ""channelClass"");
START         return channelFactory(new ReflectiveChannelFactory<C>(channelClass)); END 
    }
","    public B channel(Class<? extends C> channelClass) {
        return channelFactory(new ReflectiveChannelFactory<C>(
                ObjectUtil.checkNotNull(channelClass, ""channelClass"")
        ));
    }
"
96,"For variables which you are using in one place, remove them and just use the actual value in that one place.","	public void getActiveConditions_shouldGetActiveConditions() {
		List<Condition> activeConditions = conditionService.getActiveConditions(patientService.getPatient(2));
		Condition firstActiveCondition = activeConditions.get(0);
		Condition secondActiveCondition = activeConditions.get(1);
		String firstUUID = ""2cc6880e-2c46-11e4-9138-a6c5e4d20fb7"";
		String secondUUID = ""2cc6880e-2c46-15e4-9038-a6c5e4d22fb7"";
		Assert.assertTrue(activeConditions.size() == 2);
		Assert.assertEquals(firstUUID,firstActiveCondition.getUuid());
		Assert.assertEquals(secondUUID, secondActiveCondition.getUuid());
	}
","	public void getActiveConditions_shouldGetActiveConditions() {
		List<Condition> activeConditions = conditionService.getActiveConditions(patientService.getPatient(2));
		Condition firstActiveCondition = activeConditions.get(0);
		Condition secondActiveCondition = activeConditions.get(1);
START 		String firstUUID = ""2cc6880e-2c46-11e4-9138-a6c5e4d20fb7""; END 
		String secondUUID = ""2cc6880e-2c46-15e4-9038-a6c5e4d22fb7"";
		Assert.assertTrue(activeConditions.size() == 2);
		Assert.assertEquals(firstUUID,firstActiveCondition.getUuid());
		Assert.assertEquals(secondUUID, secondActiveCondition.getUuid());
	}
","	public void getActiveConditions_shouldGetActiveConditions() {
		List<Condition> activeConditions = conditionService.getActiveConditions(patientService.getPatient(2));
		Assert.assertTrue(activeConditions.size() == 2);
		Assert.assertEquals(""2cc6880e-2c46-11e4-9138-a6c5e4d20fb7"",activeConditions.get(0).getUuid());
		Assert.assertEquals(""2cc6880e-2c46-15e4-9038-a6c5e4d22fb7"", activeConditions.get(1).getUuid());
	}
"
97,why is there a `newArrayList`?,"  public synchronized Inode<?> getInodeOrNull() {
    if (!fullPathExists()) {
      return null;
    }
    List<Inode<?>> inodeList = Lists.newArrayList(mLockList.getInodes());
    return inodeList.get(inodeList.size() - 1);
  }
","  public synchronized Inode<?> getInodeOrNull() {
    if (!fullPathExists()) {
      return null;
    }
START     List<Inode<?>> inodeList = Lists.newArrayList(mLockList.getInodes()); END 
    return inodeList.get(inodeList.size() - 1);
  }
","  public synchronized Inode<?> getInodeOrNull() {
    if (!fullPathExists()) {
      return null;
    }
    List<Inode<?>> inodeList = mLockList.getInodes();
    return inodeList.get(inodeList.size() - 1);
  }
"
98,why not `list.stream().forEach`?,"  private static <T> Set<T> findDuplicates(Collection<T> list) {
    Set<T> duplicates = new HashSet<>();
    Set<T> uniques = new HashSet<>();

    for(T t : list) {
      if(!uniques.add(t)) {
        duplicates.add(t);
      }
    }

    return duplicates;
  }
","  private static <T> Set<T> findDuplicates(Collection<T> list) {
    Set<T> duplicates = new HashSet<>();
    Set<T> uniques = new HashSet<>();

START     for(T t : list) { END 
      if(!uniques.add(t)) {
        duplicates.add(t);
      }
    }

    return duplicates;
  }
","  private static <T> Set<T> findDuplicates(Collection<T> list) {
    Set<T> duplicates = new HashSet<>();
    Set<T> uniques = new HashSet<>();

    list.stream().forEach(t -> {
      if (!uniques.add(t)) {
        duplicates.add(t);
      }
    });

    return duplicates;
  }
"
99,This isn't right.,"		public boolean next() throws IOException {
			for (;;) {
				LogQueueEntry t = queue.poll();
				if (t == null) {
					return false;
				}

				refName = t.lc.getRefName();
				updateIndex = t.lc.getUpdateIndex();
				entry = t.lc.getReflogEntry();
				boolean include = includeDeletes || entry != null;
				skipShadowed(refName, updateIndex);
				add(t);
				if (include) {
					return true;
				}
				return true;
			}
		}
","		public boolean next() throws IOException {
			for (;;) {
				LogQueueEntry t = queue.poll();
				if (t == null) {
					return false;
				}

				refName = t.lc.getRefName();
				updateIndex = t.lc.getUpdateIndex();
				entry = t.lc.getReflogEntry();
				boolean include = includeDeletes || entry != null;
				skipShadowed(refName, updateIndex);
				add(t);
START 				if (include) {
					return true;
				}
				return true; END 
			}
		}
","		public boolean next() throws IOException {
			for (;;) {
				LogQueueEntry t = queue.poll();
				if (t == null) {
					return false;
				}

				refName = t.lc.getRefName();
				updateIndex = t.lc.getUpdateIndex();
				entry = t.lc.getReflogEntry();
				boolean include = includeDeletes || entry != null;
				skipShadowed(refName, updateIndex);
				add(t);
				if (include) {
					return true;
				}
			}
		}
"
100,"That's not logic for this method.
If we are here, we have to be already sure that it is our own group.
The real problem is definitely in the `ForceReleaseMessageGroupProcessor` implementation.
We have to check for its presence there.
All other logic should not be affected.

Please, make this `remove()` method `protected`.","	void remove(MessageGroup group) {
		Object correlationKey = group.getGroupId();
		if (this.groupIds.contains(correlationKey)) {
			this.messageStore.removeMessageGroup(correlationKey);
			this.groupIds.remove(correlationKey);
		}
	}
","	void remove(MessageGroup group) {
		Object correlationKey = group.getGroupId();
START 		if (this.groupIds.contains(correlationKey)) { END 
			this.messageStore.removeMessageGroup(correlationKey);
			this.groupIds.remove(correlationKey);
		}
	}
","	protected void remove(MessageGroup group) {
		Object correlationKey = group.getGroupId();
		this.messageStore.removeMessageGroup(correlationKey);
		this.groupIds.remove(group.getGroupId());
	}
"
101,"Hmm, this feels like premature optimization. The offsets map is more likely to be a problem. Also, I'm not sure we should restrict the usage. It is possible today to send offsets for multiple groups. Is there a good reason to restrict this even if it doesn't make sense in streams?","    public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets,
                                         String consumerGroupId) throws ProducerFencedException {
        if (!cachedGroupMetadata.groupId().equals(consumerGroupId)) {
            // Generally this logic should only be triggered once during first call.
            log.warn(""Cached consumer groupId changed from {} to {}. If the old group id is not empty, this indicates an abuse of this API"",
                cachedGroupMetadata.groupId(), consumerGroupId);
            cachedGroupMetadata = new ConsumerGroupMetadata(consumerGroupId,
                JoinGroupRequest.UNKNOWN_GENERATION_ID, JoinGroupRequest.UNKNOWN_MEMBER_ID, Optional.empty());
        }
        sendOffsetsToTransactionInternal(offsets, cachedGroupMetadata, false);
    }
","    public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets,
                                         String consumerGroupId) throws ProducerFencedException {
START         if (!cachedGroupMetadata.groupId().equals(consumerGroupId)) { END 
            // Generally this logic should only be triggered once during first call.
            log.warn(""Cached consumer groupId changed from {} to {}. If the old group id is not empty, this indicates an abuse of this API"",
                cachedGroupMetadata.groupId(), consumerGroupId);
            cachedGroupMetadata = new ConsumerGroupMetadata(consumerGroupId,
                JoinGroupRequest.UNKNOWN_GENERATION_ID, JoinGroupRequest.UNKNOWN_MEMBER_ID, Optional.empty());
        }
        sendOffsetsToTransactionInternal(offsets, cachedGroupMetadata, false);
    }
","    public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets,
                                         String consumerGroupId) throws ProducerFencedException {
        sendOffsetsToTransaction(offsets, new ConsumerGroupMetadata(consumerGroupId));
    }
"
102,"The issue we found was when the original `reason` could not be logged due to an error in its `toString`. Do we have any concern that logging the _new_ error might have the same issue? Would it be better to have two stages to this?

1. Catch the logging error, then try to log that error.
2. Catch _that_ error if it happens, and log a generic, static message.","  public boolean cancel(final Exception rootReason) {
    if (transitionCancel(rootReason)) {
      final Exception reason = new CancellationException(rootReason);
      try {
        traceFailure(reason);
      } catch (Throwable ex) {
        LOGGER.warn(""Exception thrown in logging trace for failure!"", ex);
      }
      getSettableDelegate().fail(reason);
      return true;
    }
    return false;
  }
","  public boolean cancel(final Exception rootReason) {
    if (transitionCancel(rootReason)) {
      final Exception reason = new CancellationException(rootReason);
      try {
        traceFailure(reason);
      } catch (Throwable ex) {
START         LOGGER.warn(""Exception thrown in logging trace for failure!"", ex); END 
      }
      getSettableDelegate().fail(reason);
      return true;
    }
    return false;
  }
","  public boolean cancel(final Exception rootReason) {
    if (transitionCancel(rootReason)) {
      final Exception reason = new CancellationException(rootReason);
      try {
        traceFailure(reason);
      } catch (Throwable ex) {
        LOGGER.warn(""Exception thrown in logging trace for failure!"", ex);
      } finally {
        // guard any exception that may throw from catch block
        getSettableDelegate().fail(reason);
      }
      return true;
    }
    return false;
  }
"
103,Can be private,"    int allVersionsCombined()
    {
        return formatIdentifier >>> SHIFT_FORMAT_IDENTIFIER | formatVersion >>> SHIFT_FORMAT_VERSION;
    }
","START     int allVersionsCombined() END 
    {
        return formatIdentifier >>> SHIFT_FORMAT_IDENTIFIER | formatVersion >>> SHIFT_FORMAT_VERSION;
    }
","    private int allVersionsCombined()
    {
        return formatIdentifier >>> SHIFT_FORMAT_IDENTIFIER | formatVersion >>> SHIFT_FORMAT_VERSION;
    }
"
104,the connection configuration is never serialized.,"   protected void writeJDBCStoreConnection(XMLExtendedStreamWriter writer, SimpleConnectionFactoryConfiguration configuration) throws XMLStreamException {
      writer.writeStartElement(Element.SIMPLE_CONNECTION);
      writeOptional(writer, Attribute.CONNECTION_URL, configuration.connectionUrl());
      writeOptional(writer, Attribute.DRIVER_CLASS, configuration.driverClass());
      writeOptional(writer, Attribute.USERNAME, configuration.username());
      writeOptional(writer, Attribute.PASSWORD, configuration.password());
      writer.writeEndElement();
   }
","START    protected void writeJDBCStoreConnection(XMLExtendedStreamWriter writer, SimpleConnectionFactoryConfiguration configuration) throws XMLStreamException { END 
      writer.writeStartElement(Element.SIMPLE_CONNECTION);
      writeOptional(writer, Attribute.CONNECTION_URL, configuration.connectionUrl());
      writeOptional(writer, Attribute.DRIVER_CLASS, configuration.driverClass());
      writeOptional(writer, Attribute.USERNAME, configuration.username());
      writeOptional(writer, Attribute.PASSWORD, configuration.password());
      writer.writeEndElement();
   }
","   private void writeJDBCStoreConnection(XMLExtendedStreamWriter writer, SimpleConnectionFactoryConfiguration configuration) throws XMLStreamException {
      writer.writeStartElement(Element.SIMPLE_CONNECTION);
      writeOptional(writer, Attribute.CONNECTION_URL, configuration.connectionUrl());
      writeOptional(writer, Attribute.DRIVER_CLASS, configuration.driverClass());
      writeOptional(writer, Attribute.USERNAME, configuration.username());
      writeOptional(writer, Attribute.PASSWORD, configuration.password());
      writer.writeEndElement();
   }
"
105,"""public"" or ""private"" ?","    static ByteBuf copyData(ByteBufList list) {
        ByteBuf buf = Unpooled.buffer(list.readableBytes());
        for (int i = 0; i < list.size(); i++) {
            buf.writeBytes(list.getBuffer(i).slice());
        }
        return buf;
    }
","START     static ByteBuf copyData(ByteBufList list) { END 
        ByteBuf buf = Unpooled.buffer(list.readableBytes());
        for (int i = 0; i < list.size(); i++) {
            buf.writeBytes(list.getBuffer(i).slice());
        }
        return buf;
    }
","    private static ByteBuf copyData(ByteBufList list) {
        ByteBuf buf = Unpooled.buffer(list.readableBytes());
        for (int i = 0; i < list.size(); i++) {
            buf.writeBytes(list.getBuffer(i).slice());
        }
        return buf;
    }
"
106,Useless,"	private String getXMI_ID(final EObject eobject) {
		if (eobject.eResource() instanceof XMIResource) {
			return ((XMIResource) eobject.eResource()).getID(eobject);
		}
		;
		return null;
	}
","	private String getXMI_ID(final EObject eobject) {
		if (eobject.eResource() instanceof XMIResource) {
			return ((XMIResource) eobject.eResource()).getID(eobject);
		}
START 		; END 
		return null;
	}
","	private String getXMI_ID(final EObject eobject) {
		if (eobject.eResource() instanceof XMIResource) {
			return ((XMIResource) eobject.eResource()).getID(eobject);
		}
		return null;
	}
"
107,Can you format these overrides?,"	@Override public float getPressure () {
		return 0;
	}
","START 	@Override public float getPressure () { END 
		return 0;
	}
","	public float getPressure () {
		return 0;
	}
"
108,"I'm probably missing something, but it seems like this is part of the next case (isn't `queue.size() >= 0` an invariant?). Is this called out just to emphasize that setting `0` => ""no queuing""?","    private boolean checkForJournalFlush() {
//        System.err.printf(""checkForJournalFlush: queue size=%d; journal size = %d\n"", queue.size(), journal.size()) ;
//        System.err.printf(""checkForJournalFlush: QueueBatchSize=%d; MaxQueueThreshold=%d; JournalThresholdSize=%d\n"",
//                          QueueBatchSize, MaxQueueThreshold, JournalThresholdSize) ;
        if ( QueueBatchSize == 0 )
            return true ;
        if ( queue.size() >= QueueBatchSize )
            // Based on number of queued commits
            //   The MaxQueueThreshold is handled in processDelayedReplayQueue. 
            return true ;
        boolean journalSizeFlush = (JournalThresholdSize > 0 && journal.size() > JournalThresholdSize ) ;
        if ( journalSizeFlush )
            // JENA-1222
            // Based on Journal file growing large in terms of bytes
            return true ;
        // No test for excessive queue length (MaxQueueThreshold).
        // That happens in notifyCommit (writer exit).
        return false ;
    }
","    private boolean checkForJournalFlush() {
//        System.err.printf(""checkForJournalFlush: queue size=%d; journal size = %d\n"", queue.size(), journal.size()) ;
//        System.err.printf(""checkForJournalFlush: QueueBatchSize=%d; MaxQueueThreshold=%d; JournalThresholdSize=%d\n"",
//                          QueueBatchSize, MaxQueueThreshold, JournalThresholdSize) ;
START         if ( QueueBatchSize == 0 ) END 
            return true ;
        if ( queue.size() >= QueueBatchSize )
            // Based on number of queued commits
            //   The MaxQueueThreshold is handled in processDelayedReplayQueue. 
            return true ;
        boolean journalSizeFlush = (JournalThresholdSize > 0 && journal.size() > JournalThresholdSize ) ;
        if ( journalSizeFlush )
            // JENA-1222
            // Based on Journal file growing large in terms of bytes
            return true ;
        // No test for excessive queue length (MaxQueueThreshold).
        // That happens in notifyCommit (writer exit).
        return false ;
    }
","    private boolean checkForJournalFlush() {
        if ( queue.size() >= QueueBatchSize )
            return true ;
        boolean journalSizeFlush = (JournalThresholdSize > 0 && journal.size() > JournalThresholdSize ) ;
        if ( journalSizeFlush )
            // JENA-1222
            // Based on Journal file growing large in terms of bytes
            return true ;
        // No test here for excessive queue length (MaxQueueThreshold).
        return false ;
    }
"
109,Use add(ProjectConfig) method here instead of repeating the same code?,"  private ProjectState newProjectState(ProjectConfig local) {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager gitMgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;

    all.put(local.getProject().getNameKey(), new ProjectState(sitePaths,
        projectCache, allProjectsName, projectControlFactory, envFactory,
        gitMgr, rulesCache, commentLinks, local));

    return all.get(local.getProject().getNameKey());
  }
","  private ProjectState newProjectState(ProjectConfig local) {
    START  PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager gitMgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;

    all.put(local.getProject().getNameKey(), new ProjectState(sitePaths,
        projectCache, allProjectsName, projectControlFactory, envFactory,
        gitMgr, rulesCache, commentLinks, local)); END 

    return all.get(local.getProject().getNameKey());
  }
","  private ProjectState newProjectState(ProjectConfig local) {
    add(local);
    return all.get(local.getProject().getNameKey());
  }
"
110,"There's a re-declaration error here, that got fixed on the parent branch. That needs to get merged in here.","    public static Collection<PersonaAccount> getPersonaAccountsForAccount(long accountId) throws CentralRepoException {
        String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE
                + "" WHERE persona_accounts.account_id = "" + accountId
                + ""AND p.status_id != "" + Persona.PersonaStatus.DELETED.getStatusId();

        CentralRepository cr = CentralRepository.getInstance();

        if (cr != null) {
            String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE
                    + "" WHERE persona_accounts.account_id = "" + accountId;

            PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback();
            cr.executeSelectSQL(queryClause, queryCallback);

            return queryCallback.getPersonaAccountsList();
        }

        return new ArrayList<>();
    }
","    public static Collection<PersonaAccount> getPersonaAccountsForAccount(long accountId) throws CentralRepoException {
        String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE
                + "" WHERE persona_accounts.account_id = "" + accountId
START                 + ""AND p.status_id != "" + Persona.PersonaStatus.DELETED.getStatusId(); END 

        CentralRepository cr = CentralRepository.getInstance();

        if (cr != null) {
            String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE
                    + "" WHERE persona_accounts.account_id = "" + accountId;

            PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback();
            cr.executeSelectSQL(queryClause, queryCallback);

            return queryCallback.getPersonaAccountsList();
        }

        return new ArrayList<>();
    }
","    public static Collection<PersonaAccount> getPersonaAccountsForAccount(long accountId) throws CentralRepoException {
        String queryClause = PERSONA_ACCOUNTS_QUERY_CALUSE
                + "" WHERE persona_accounts.account_id = "" + accountId
                + ""AND p.status_id != "" + Persona.PersonaStatus.DELETED.getStatusId();

        CentralRepository cr = CentralRepository.getInstance();

        if (cr != null) {
            PersonaAccountsQueryCallback queryCallback = new PersonaAccountsQueryCallback();
            cr.executeSelectSQL(queryClause, queryCallback);

            return queryCallback.getPersonaAccountsList();
        }

        return new ArrayList<>();
    }
"
111,"The same question, how ""column supports filtering"" relates to ""has multiple values""?","  public boolean hasMultipleValues(final String dimension)
  {
    if (isVirtualColumn(dimension)) {
      return virtualColumns.getVirtualColumn(dimension).capabilities(dimension).hasMultipleValues();
    }

    final Column column = index.getColumn(dimension);
    if (column == null || !columnSupportsFiltering(column)) {
      return false;
    } else {
      return column.getCapabilities().hasMultipleValues();
    }
  }
","  public boolean hasMultipleValues(final String dimension)
  {
    if (isVirtualColumn(dimension)) {
      return virtualColumns.getVirtualColumn(dimension).capabilities(dimension).hasMultipleValues();
    }

    final Column column = index.getColumn(dimension);
START     if (column == null || !columnSupportsFiltering(column)) { END 
      return false;
    } else {
      return column.getCapabilities().hasMultipleValues();
    }
  }
","  public boolean hasMultipleValues(final String dimension)
  {
    if (isVirtualColumn(dimension)) {
      return virtualColumns.getVirtualColumn(dimension).capabilities(dimension).hasMultipleValues();
    }

    final Column column = index.getColumn(dimension);
    return column != null && column.getCapabilities().hasMultipleValues();
  }
"
112,This won't work? You wait until the node is powered on when you want to resume it. This will take forever.,"   public void resumeNode(String id) {
      waitServerUntilAvailable.apply(getNode(id));
      api.serverApi().updateStatus(id, Server.UpdateStatus.create(Types.ServerAction.POWER_ON, Types.ServerActionMethod.HARDWARE));
   }
","   public void resumeNode(String id) {
START       waitServerUntilAvailable.apply(getNode(id)); END 
      api.serverApi().updateStatus(id, Server.UpdateStatus.create(Types.ServerAction.POWER_ON, Types.ServerActionMethod.HARDWARE));
   }
","   public void resumeNode(String id) {
      api.serverApi().updateStatus(id, Server.UpdateStatus.create(Types.ServerAction.POWER_ON, Types.ServerActionMethod.HARDWARE));
   }
"
113,"either make this a get method that returns the result, or have it be a ""load"" method. Having it do both is unexpected (same for above method)","	public IStyledLabelProvider[] getLabelProviders() {
		if (fLabelProviders == null) {
			fLabelProviders = CHEProviderSettings.getCCallHierarchyLabelProviders();
		}
		return fLabelProviders;
	}
","	public IStyledLabelProvider[] getLabelProviders() {
START 		if (fLabelProviders == null) { END 
			fLabelProviders = CHEProviderSettings.getCCallHierarchyLabelProviders();
		}
		return fLabelProviders;
	}
","	public IStyledLabelProvider[] getLabelProviders() {
		return fLabelProviders;
	}
"
114,Why are these registered at all? What invokes them?,"    public void registerOperations(ManagementResourceRegistration resourceRegistration) {
        if (showResources) {
            resourceRegistration.registerOperationHandler(ShowJaxrsResourcesHandler.DEFINITION, new ShowJaxrsResourcesHandler());
        } else {
            resourceRegistration.registerOperationHandler(ADD_DEFINITION, JaxrsSubsystemAdd.INSTANCE);
            resourceRegistration.registerOperationHandler(REMOVE_DEFINITION, ReloadRequiredRemoveStepHandler.INSTANCE);
        }
    }
","    public void registerOperations(ManagementResourceRegistration resourceRegistration) {
        if (showResources) {
            resourceRegistration.registerOperationHandler(ShowJaxrsResourcesHandler.DEFINITION, new ShowJaxrsResourcesHandler());
        } else {
            resourceRegistration.registerOperationHandler(ADD_DEFINITION, JaxrsSubsystemAdd.INSTANCE);
START             resourceRegistration.registerOperationHandler(REMOVE_DEFINITION, ReloadRequiredRemoveStepHandler.INSTANCE); END 
        }
    }
","    public void registerOperations(ManagementResourceRegistration resourceRegistration) {
        super.registerOperations(resourceRegistration);
        resourceRegistration.registerOperationHandler(ShowJaxrsResourcesHandler.DEFINITION, new ShowJaxrsResourcesHandler());
    }
"
115,And one for luck ;-),"    public int hashCode() {
        int result = processId.hashCode();
        result = 31 * result + taskId.hashCode();
        result = 31 * result + taskName.hashCode();
        result = 31 * result + formName.hashCode();
        return result;
    }
","    public int hashCode() {
START         int result = processId.hashCode(); END 
        result = 31 * result + taskId.hashCode();
        result = 31 * result + taskName.hashCode();
        result = 31 * result + formName.hashCode();
        return result;
    }
","    public int hashCode() {
        int result = processId.hashCode();
        result = ~~result;
        result = 31 * result + taskId.hashCode();
        result = ~~result;
        result = 31 * result + taskName.hashCode();
        result = ~~result;
        result = 31 * result + formName.hashCode();
        result = ~~result;
        return result;
    }
"
116,Can probably remove synchronized now?,"    public synchronized void stop(final String reason)
    {
        new Thread( ""Shutdown Thread"" )
        {
            @Override
            public void run()
            {
                independentThreadStop( reason, true );
            }
        }.start();
    }
","START     public synchronized void stop(final String reason) END 
    {
        new Thread( ""Shutdown Thread"" )
        {
            @Override
            public void run()
            {
                independentThreadStop( reason, true );
            }
        }.start();
    }
","    public void stop(final String reason)
    {
        new Thread( ""Shutdown Thread"" )
        {
            @Override
            public void run()
            {
                independentThreadStop( reason, true );
            }
        }.start();
    }
"
117,braces,"        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            return ((key == null ? e.getKey() == null : key.equals(e.getKey())) &&
                    (value == null ? e.getValue() == null : value.equals(e.getValue())));
        }
","        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                START return END  false;
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            return ((key == null ? e.getKey() == null : key.equals(e.getKey())) &&
                    (value == null ? e.getValue() == null : value.equals(e.getValue())));
        }
","        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry)) {
                return false;
            }
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            return ((key == null ? e.getKey() == null : key.equals(e.getKey())) &&
                    (value == null ? e.getValue() == null : value.equals(e.getValue())));
        }
"
118,protected ?,"    public PostgreSqlEngine(final PdbProperties properties, final String driver) throws DatabaseEngineException {
        super(driver, properties, Dialect.POSTGRESQL);
    }
","START     public PostgreSqlEngine(final PdbProperties properties, final String driver) throws DatabaseEngineException { END 
        super(driver, properties, Dialect.POSTGRESQL);
    }
","    protected PostgreSqlEngine(final PdbProperties properties, final String driver) throws DatabaseEngineException {
        super(driver, properties, Dialect.POSTGRESQL);
    }
"
119,"make dispose synchronized, then we could remove the volatile keyword in the class member.","  public void dispose() {
    clearCachedSwingEditor();
  }
","START   public void dispose() { END 
    clearCachedSwingEditor();
  }
","  public synchronized void dispose() {
    clearCachedSwingEditor();
  }
"
120,I'm thinking that new thread is not needed for the reconnect task. This thread should be dead already by the time a new reconnect is needed and I see `Timer` instance serving the purpose of this thread. What do you think?,"        public void run()
        {
            if(thread == null || !Thread.currentThread().equals(thread))
            {
                thread = new Thread(this);
                thread.start();
            }
            else
            {
                try
                {
                    if (logger.isInfoEnabled())
                        logger.info(""Start reconnecting "" + provider);

                    provider.register(
                        getUIService().getDefaultSecurityAuthority(provider));
                } catch (OperationFailedException ex)
                {
                    logger.error(""cannot re-register provider will keep going"",
                        ex);
                }
            }
        }
","        public void run()
        {
            if(thread == null || !Thread.currentThread().equals(thread))
            {
START                 thread = new Thread(this); END 
                thread.start();
            }
            else
            {
                try
                {
                    if (logger.isInfoEnabled())
                        logger.info(""Start reconnecting "" + provider);

                    provider.register(
                        getUIService().getDefaultSecurityAuthority(provider));
                } catch (OperationFailedException ex)
                {
                    logger.error(""cannot re-register provider will keep going"",
                        ex);
                }
            }
        }
","        public void run()
        {
            try
            {
                if (logger.isInfoEnabled())
                    logger.info(""Start reconnecting "" + provider);

                provider.register(
                    getUIService().getDefaultSecurityAuthority(provider));
            } catch (OperationFailedException ex)
            {
                logger.error(""cannot re-register provider will keep going"",
                    ex);
            }
        }
"
121,Couldn't this actually depend on the class and generate the name from that?,"  public void checkProperties(Properties properties)
  {
    properties.setProperty(""log4j.shutdownCallbackRegistry"", ""io.druid.common.config.Log4jShutdown"");
    properties.setProperty(""log4j.shutdownHookEnabled"", ""true"");
  }
","  public void checkProperties(Properties properties)
  {
START     properties.setProperty(""log4j.shutdownCallbackRegistry"", ""io.druid.common.config.Log4jShutdown""); END 
    properties.setProperty(""log4j.shutdownHookEnabled"", ""true"");
  }
","  public void checkProperties(Properties properties)
  {
    if (!properties.contains(""log4j.shutdownCallbackRegistry"")) {
      properties.setProperty(""log4j.shutdownCallbackRegistry"", ""io.druid.common.config.Log4jShutdown"");
    }
    if (!properties.contains(""log4j.shutdownHookEnabled"")) {
      properties.setProperty(""log4j.shutdownHookEnabled"", ""true"");
    }
  }
"
122,"```suggestion
        assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, EMPTY_VALUE);
```","    public void testUnmarshallTopLevelEmptyEventProperties() throws Exception {
        Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH);
        assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM);

        StartTimerEvent emptyTop = getStartNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, StartTimerEvent.class);
        assertGeneralSet(emptyTop.getGeneral(), EMPTY_VALUE, EMPTY_VALUE);
        assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, """");
        // Know issue. Should be uncommented after https://issues.jboss.org/browse/JBPM-7038 will be fixed
        //assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE);
    }
","    public void testUnmarshallTopLevelEmptyEventProperties() throws Exception {
        Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH);
        assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM);

        StartTimerEvent emptyTop = getStartNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, StartTimerEvent.class);
        assertGeneralSet(emptyTop.getGeneral(), EMPTY_VALUE, EMPTY_VALUE);
START         assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, """"); END 
        // Know issue. Should be uncommented after https://issues.jboss.org/browse/JBPM-7038 will be fixed
        //assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE);
    }
","    public void testUnmarshallTopLevelEmptyEventProperties() throws Exception {
        Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH);
        assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM);

        StartTimerEvent emptyTop = getStartNodeById(diagram, EMPTY_TOP_LEVEL_EVENT_ID, StartTimerEvent.class);
        assertGeneralSet(emptyTop.getGeneral(), EMPTY_VALUE, EMPTY_VALUE);
        assertTimerEventEmpty(emptyTop.getExecutionSet(), NON_INTERRUPTING, EMPTY_VALUE);
        // Know issue. Should be uncommented after https://issues.jboss.org/browse/JBPM-7038 will be fixed
        //assertDataIOSet(emptySubprocess.getDataIOSet(), EMPTY_VALUE);
    }
"
123,We should handle maxIdle as well,"      private EmbeddedExpirableMetadata(
            long lifespan, TimeUnit lifespanUnit,
            long maxIdle, TimeUnit maxIdleUnit, EntryVersion version) {
         super(version);
         this.lifespan = lifespan < 0 ? lifespan : lifespanUnit.toMillis(lifespan);
         this.maxIdle = maxIdleUnit.toMillis(maxIdle);
      }
","      private EmbeddedExpirableMetadata(
            long lifespan, TimeUnit lifespanUnit,
            long maxIdle, TimeUnit maxIdleUnit, EntryVersion version) {
         super(version);
         this.lifespan = lifespan < 0 ? lifespan : lifespanUnit.toMillis(lifespan);
START          this.maxIdle = maxIdleUnit.toMillis(maxIdle); END 
      }
","      private EmbeddedExpirableMetadata(
            long lifespan, TimeUnit lifespanUnit,
            long maxIdle, TimeUnit maxIdleUnit, EntryVersion version) {
         super(version);
         this.lifespan = lifespan < 0 ? -1 : lifespanUnit.toMillis(lifespan);
         this.maxIdle = maxIdle < 0 ? -1 : maxIdleUnit.toMillis(maxIdle);
      }
"
124,@Lars Do you think that for consistency (and maybe another slight performance enhancement) this line should be changed as well?,"	protected void setMatcherString(String pattern) {
		if (pattern.length() == 0) {
			searchPattern = null;
		} else {
			SearchPattern patternMatcher = new SearchPattern();
			if (pattern.indexOf('*') != 0 && pattern.indexOf('?') != 0 && pattern.indexOf('.') != 0) {
				pattern = ""*"" + pattern; //$NON-NLS-1$
			}
			patternMatcher.setPattern(pattern);
			searchPattern = patternMatcher;
		}
	}
","	protected void setMatcherString(String pattern) {
		if (pattern.length() == 0) {
			searchPattern = null;
		} else {
			SearchPattern patternMatcher = new SearchPattern();
			if (pattern.indexOf('*') != 0 && pattern.indexOf('?') != 0 && pattern.indexOf('.') != 0) {
START 				pattern = ""*"" + pattern; //$NON-NLS-1$ END 
			}
			patternMatcher.setPattern(pattern);
			searchPattern = patternMatcher;
		}
	}
","	protected void setMatcherString(String pattern) {
		if (pattern.length() == 0) {
			searchPattern = null;
		} else {
			SearchPattern patternMatcher = new SearchPattern();
			if (pattern.indexOf('*') != 0 && pattern.indexOf('?') != 0 && pattern.indexOf('.') != 0) {
				pattern = '*' + pattern;
			}
			patternMatcher.setPattern(pattern);
			searchPattern = patternMatcher;
		}
	}
"
125,yeah let's remove this :),"    public DefaultEditorSession(final ManagedSession session,
                                final CanvasCommandManager<AbstractCanvasHandler> canvasCommandManager,
                                final @Session SessionCommandManager<AbstractCanvasHandler> sessionCommandManager,
                                final @Request SessionCommandManager<AbstractCanvasHandler> requestCommandManager,
                                final ClientCommandRegistry<org.kie.workbench.common.stunner.core.command.Command<AbstractCanvasHandler, CanvasViolation>> clientCommandRegistry) {
        this.session = session;
        this.commandRegistry = clientCommandRegistry.setSession(session);
        this.sessionCommandManager = sessionCommandManager;
        this.requestCommandManager = requestCommandManager;
        this.canvasCommandManager = canvasCommandManager;
    }
","    public DefaultEditorSession(final ManagedSession session,
                                final CanvasCommandManager<AbstractCanvasHandler> canvasCommandManager,
                                final @Session SessionCommandManager<AbstractCanvasHandler> sessionCommandManager,
                                final @Request SessionCommandManager<AbstractCanvasHandler> requestCommandManager,
                                final ClientCommandRegistry<org.kie.workbench.common.stunner.core.command.Command<AbstractCanvasHandler, CanvasViolation>> clientCommandRegistry) {
        this.session = session;
START         this.commandRegistry = clientCommandRegistry.setSession(session); END 
        this.sessionCommandManager = sessionCommandManager;
        this.requestCommandManager = requestCommandManager;
        this.canvasCommandManager = canvasCommandManager;
    }
","    public DefaultEditorSession(final ManagedSession session,
                                final CanvasCommandManager<AbstractCanvasHandler> canvasCommandManager,
                                final @Session SessionCommandManager<AbstractCanvasHandler> sessionCommandManager,
                                final @Request SessionCommandManager<AbstractCanvasHandler> requestCommandManager,
                                final ClientCommandRegistry<org.kie.workbench.common.stunner.core.command.Command<AbstractCanvasHandler, CanvasViolation>> clientCommandRegistry) {
        this.session = session;
        this.commandRegistry = clientCommandRegistry;
        this.sessionCommandManager = sessionCommandManager;
        this.requestCommandManager = requestCommandManager;
        this.canvasCommandManager = canvasCommandManager;
    }
"
126,"For consistency across the project, please remove the `final` keyword here.","	private String transformToHeaderValue(Directive... directives) {
		final StringBuilder sb = new StringBuilder();
		for (int i = 0; i < directives.length - 1; i++) {
			sb.append(directives[i].headerValue).append("", "");
		}
		sb.append(directives[directives.length - 1].headerValue);
		return sb.toString();
	}
","	private String transformToHeaderValue(Directive... directives) {
START 		final StringBuilder sb = new StringBuilder(); END 
		for (int i = 0; i < directives.length - 1; i++) {
			sb.append(directives[i].headerValue).append("", "");
		}
		sb.append(directives[directives.length - 1].headerValue);
		return sb.toString();
	}
","	private String transformToHeaderValue(Directive... directives) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < directives.length - 1; i++) {
			sb.append(directives[i].headerValue).append("", "");
		}
		sb.append(directives[directives.length - 1].headerValue);
		return sb.toString();
	}
"
127,"🐜 De-facto we process errors in the logging handler. E.g. logging constructs the string, and it may cause OutOfMemoryError, which suppresses the original one. I'd rather vote that Errors are being rethrown without any processing","    private static void fireOnFailure(final NodeProvisioner.PlannedNode plannedNode, final Throwable cause) {
        for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {
            try {
                cl.onFailure(plannedNode, cause);
            } catch (Throwable e) {
                LOGGER.log(Level.SEVERE, ""Unexpected uncaught exception encountered while ""
                        + ""processing onFailure() listener call in "" + cl + "" for agent ""
                        + plannedNode.displayName, e);
                if (e instanceof Error) {
                    throw e;
                }
            }
        }
    }
","    private static void fireOnFailure(final NodeProvisioner.PlannedNode plannedNode, final Throwable cause) {
        for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {
            try {
                cl.onFailure(plannedNode, cause);
            } catch (Throwable e) {
                LOGGER.log(Level.SEVERE, ""Unexpected uncaught exception encountered while ""
                        + ""processing onFailure() listener call in "" + cl + "" for agent ""
                        + plannedNode.displayName, e);
START                 if (e instanceof Error) { END 
                    throw e;
                }
            }
        }
    }
","    private static void fireOnFailure(final NodeProvisioner.PlannedNode plannedNode, final Throwable cause) {
        for (CloudProvisioningListener cl : CloudProvisioningListener.all()) {
            try {
                cl.onFailure(plannedNode, cause);
            } catch (Error e) {
                throw e;
            } catch (Throwable e) {
                LOGGER.log(Level.SEVERE, ""Unexpected uncaught exception encountered while ""
                        + ""processing onFailure() listener call in "" + cl + "" for agent ""
                        + plannedNode.displayName, e);
            }
        }
    }
"
128,"These two logs could be `Logger.v()`. That's all, good to go!","    public synchronized boolean isLastMQNotifLongAgo() {
        long delay = 18 * 3600;  // 24h - 3h = 18h
        long threshold = sharedPreferences.getLong(getCurrentModeName() + LAST_MORNING_Q_TIMESTAMP, - delay) + delay;
        if (threshold < Calendar.getInstance().getTimeInMillis()) {
            Logger.d(TAG, ""{} - Last MQ notif was yesterday"", getCurrentModeName());
            return true;
        } else {
            Logger.d(TAG, ""{} - Last MQ notif was recent, do not notify"", getCurrentModeName());
            return false;
        }
    }
","    public synchronized boolean isLastMQNotifLongAgo() {
        long delay = 18 * 3600;  // 24h - 3h = 18h
        long threshold = sharedPreferences.getLong(getCurrentModeName() + LAST_MORNING_Q_TIMESTAMP, - delay) + delay;
        if (threshold < Calendar.getInstance().getTimeInMillis()) {
            Logger.d(TAG, ""{} - Last MQ notif was yesterday"", getCurrentModeName());
            return true;
        } else {
START             Logger.d(TAG, ""{} - Last MQ notif was recent, do not notify"", getCurrentModeName()); END 
            return false;
        }
    }
","    public synchronized boolean isLastMQNotifLongAgo() {
        long delay = 18 * 3600;  // 24h - 3h = 18h
        long threshold = sharedPreferences.getLong(getCurrentModeName() + LAST_MORNING_Q_TIMESTAMP, - delay) + delay;
        if (threshold < Calendar.getInstance().getTimeInMillis()) {
            Logger.v(TAG, ""{} - Last MQ notif was yesterday"", getCurrentModeName());
            return true;
        } else {
            Logger.v(TAG, ""{} - Last MQ notif was recent, do not notify"", getCurrentModeName());
            return false;
        }
    }
"
129,Ditto `input != null`,"    public CrewMember apply(org.atlasapi.media.entity.CrewMember input) {
        if (input instanceof org.atlasapi.media.entity.Actor) {
            return translateLegacyActor((org.atlasapi.media.entity.Actor) input);
        } else if(Objects.nonNull(input)) {
            return translateLegacyCrewMember(input);
        } else {
            return null;
        }
    }
","    public CrewMember apply(org.atlasapi.media.entity.CrewMember input) {
        if (input instanceof org.atlasapi.media.entity.Actor) {
            return translateLegacyActor((org.atlasapi.media.entity.Actor) input);
START         } else if(Objects.nonNull(input)) { END 
            return translateLegacyCrewMember(input);
        } else {
            return null;
        }
    }
","    public CrewMember apply(org.atlasapi.media.entity.CrewMember input) {
        // we carry IDs through from Owl to Deer, reject anything without one
        if (null == input.getId()) {
            return null;
        }

        if (input instanceof org.atlasapi.media.entity.Actor) {
            return translateLegacyActor((org.atlasapi.media.entity.Actor) input);
        } else if(null != input) {
            return translateLegacyCrewMember(input);
        } else {
            return null;
        }
    }
"
130,Did you want to assert something before close in all these cases? i.e. it's not empty.,"    public void testSocket() throws Exception {
        Socket s = new Socket();
        s.connect(server.getLocalAddress());
        s.close();

        assertEquals(Collections.EMPTY_MAP, tagger.getLiveDescriptors());
    }
","    public void testSocket() throws Exception {
        Socket s = new Socket();
        s.connect(server.getLocalAddress());
        s.close();

        assertEquals(Collections.EMPTY_MAP, START tagger.getLiveDescriptors()); END 
    }
","    public void testSocket() throws Exception {
        Socket s = new Socket();
        s.connect(server.getLocalAddress());
        assertEquals(1, tagger.getLiveDescriptors().size());

        s.close();

        assertEquals(Collections.EMPTY_MAP, tagger.getLiveDescriptors());
    }
"
131,`requireNonNull` is not needed given `copyOf` checks for nullability.,"    public ValuesMatcher(
            Map<String, Integer> outputSymbolAliases,
            Optional<Integer> expectedOutputSymbolCount,
            Optional<List<List<Expression>>> expectedRows)
    {
        this.outputSymbolAliases = ImmutableMap.copyOf(requireNonNull(outputSymbolAliases, ""outputSymbolAliases is null""));
        this.expectedOutputSymbolCount = requireNonNull(expectedOutputSymbolCount, ""expectedOutputSymbolCount is null"");
        this.expectedRows = requireNonNull(expectedRows, ""expectedRows is null"");
    }
","    public ValuesMatcher(
            Map<String, Integer> outputSymbolAliases,
            Optional<Integer> expectedOutputSymbolCount,
            Optional<List<List<Expression>>> expectedRows)
    {
START         this.outputSymbolAliases = ImmutableMap.copyOf(requireNonNull(outputSymbolAliases, ""outputSymbolAliases is null"")); END 
        this.expectedOutputSymbolCount = requireNonNull(expectedOutputSymbolCount, ""expectedOutputSymbolCount is null"");
        this.expectedRows = requireNonNull(expectedRows, ""expectedRows is null"");
    }
","    public ValuesMatcher(
            Map<String, Integer> outputSymbolAliases,
            Optional<Integer> expectedOutputSymbolCount,
            Optional<List<List<Expression>>> expectedRows)
    {
        this.outputSymbolAliases = ImmutableMap.copyOf(outputSymbolAliases);
        this.expectedOutputSymbolCount = requireNonNull(expectedOutputSymbolCount, ""expectedOutputSymbolCount is null"");
        this.expectedRows = requireNonNull(expectedRows, ""expectedRows is null"");
    }
"
132,Can just pass id and let Java autoboxing take care of it.,"	protected Button getButton(int id) {
		return buttons.get(new Integer(id));
	}
","	protected Button getButton(int id) {
START 		return buttons.get(new Integer(id)); END 
	}
","	protected Button getButton(int id) {
		return buttons.get(id);
	}
"
133,Better: Map,"	public void setInitializationData(IConfigurationElement config, String propertyName, Object data) {
		if (data instanceof Hashtable) {
			Hashtable<?, ?> table = (Hashtable<?, ?>) data;
			color = (String) table.get(""color""); //$NON-NLS-1$
		}
	}
","	public void setInitializationData(IConfigurationElement config, String propertyName, Object data) {
		if (data instanceof START  Hashtable) { END 
			Hashtable<?, ?> table = (Hashtable<?, ?>) data;
			color = (String) table.get(""color""); //$NON-NLS-1$
		}
	}
","	public void setInitializationData(IConfigurationElement config, String propertyName, Object data) {
		if (data instanceof Hashtable<?, ?>) {
			Hashtable<?, ?> map = (Hashtable<?, ?>) data;
			color = (String) map.get(""color""); //$NON-NLS-1$
		}
	}
"
134,`cause` —> `e` please,"    public void addRequestCleanupHandler(HttpServletRequest request) {
        RequestContext.getActiveContext(request).addRequestCleanupHandler(new RequestCleanupHandler() {
            @Override
            public void cleanup(HttpServletRequest req) {
                try {
                    close();
                } catch (OperationException cause) {
                    throw new NuxeoException(cause);
                }
            }
        });
    }
","    public void addRequestCleanupHandler(HttpServletRequest request) {
        RequestContext.getActiveContext(request).addRequestCleanupHandler(new RequestCleanupHandler() {
            @Override
            public void cleanup(HttpServletRequest req) {
                try {
                    close();
                } catch (OperationException cause) {
START                     throw new NuxeoException(cause); END 
                }
            }
        });
    }
","    public void addRequestCleanupHandler(HttpServletRequest request) {
        RequestContext.getActiveContext(request).addRequestCleanupHandler(new RequestCleanupHandler() {
            @Override
            public void cleanup(HttpServletRequest req) {
                try {
                    close();
                } catch (OperationException e) {
                    throw new NuxeoException(e);
                }
            }
        });
    }
"
135,Why not move the logic about `Kind.FILE_INPUT` inside `isStmtListIncrementsNestingLevel`?,"  public void visitStatementList(PyStatementListTree pyStatementListTree) {
    if (isStmtListIncrementsNestingLevel(pyStatementListTree) && !pyStatementListTree.parent().is(Kind.FILE_INPUT)) {
      nestingLevelStack.peek().increment();
      super.visitStatementList(pyStatementListTree);
      nestingLevelStack.peek().decrement();
    } else {
      super.visitStatementList(pyStatementListTree);
    }
  }
","  public void visitStatementList(PyStatementListTree pyStatementListTree) {
START     if (isStmtListIncrementsNestingLevel(pyStatementListTree) && !pyStatementListTree.parent().is(Kind.FILE_INPUT)) { END 
      nestingLevelStack.peek().increment();
      super.visitStatementList(pyStatementListTree);
      nestingLevelStack.peek().decrement();
    } else {
      super.visitStatementList(pyStatementListTree);
    }
  }
","  public void visitStatementList(PyStatementListTree pyStatementListTree) {
    if (isStmtListIncrementsNestingLevel(pyStatementListTree)) {
      nestingLevelStack.peek().increment();
      super.visitStatementList(pyStatementListTree);
      nestingLevelStack.peek().decrement();
    } else {
      super.visitStatementList(pyStatementListTree);
    }
  }
"
136,no need to add the same message to the secondary location,"  private static void checkLxmlParseCall(SubscriptionContext ctx) {
    CallExpression callExpression = (CallExpression) ctx.syntaxNode();
    if (checkCallExpressionFqn(callExpression, LXML_PARSE)) {
      CallExpression parserCall = getParserCall(
        getArgValueAsCallExpression(
          TreeUtils.nthArgumentOrKeyword(1, ""parser"", callExpression.arguments())));
      if (parserCall != null && isUnsafeParserUsage(parserCall)) {
        ctx.addIssue(parserCall, MESSAGE).secondary(callExpression, MESSAGE);
      }
    }
  }
","  private static void checkLxmlParseCall(SubscriptionContext ctx) {
    CallExpression callExpression = (CallExpression) ctx.syntaxNode();
    if (checkCallExpressionFqn(callExpression, LXML_PARSE)) {
      CallExpression parserCall = getParserCall(
        getArgValueAsCallExpression(
          TreeUtils.nthArgumentOrKeyword(1, ""parser"", callExpression.arguments())));
      if (parserCall != null && isUnsafeParserUsage(parserCall)) {
START         ctx.addIssue(parserCall, MESSAGE).secondary(callExpression, MESSAGE); END 
      }
    }
  }
","  private static void checkLxmlParseCall(SubscriptionContext ctx) {
    CallExpression callExpression = (CallExpression) ctx.syntaxNode();
    if (checkCallExpressionFqn(callExpression, LXML_PARSE)) {
      CallExpression parserCall = getParserCall(
        getArgValueAsCallExpression(
          TreeUtils.nthArgumentOrKeyword(1, ""parser"", callExpression.arguments())));
      if (parserCall != null && isUnsafeParserUsage(parserCall)) {
        ctx.addIssue(parserCall, MESSAGE).secondary(callExpression, null);
      }
    }
  }
"
137,The same error is reported twice.,"	public int getVisibility(IBinding member) {
		try {
			PDOMCPPMemberBlock members = new PDOMCPPMemberBlock(getLinkage(), record + MEMBERLIST);
			return members.getAccessibility(member);
		} catch (CoreException e) {
			CCorePlugin.log(e);
			throw new IllegalArgumentException(member.getName() + "" is not a member of "" + getName()); //$NON-NLS-1$
		}
	}
","	public int getVisibility(IBinding member) {
		try {
			PDOMCPPMemberBlock members = new PDOMCPPMemberBlock(getLinkage(), record + MEMBERLIST);
			return members.getAccessibility(member);
		} catch (CoreException e) {
			CCorePlugin.log(e);
START 			throw new IllegalArgumentException(member.getName() + "" is not a member of "" + getName()); //$NON-NLS-1$ END 
		}
	}
","	public int getVisibility(IBinding member) {
		try {
			PDOMCPPMemberBlock members = new PDOMCPPMemberBlock(getLinkage(), record + MEMBERLIST);
			return members.getVisibility(member);
		} catch (CoreException e) {
			CCorePlugin.log(e);
			throw new IllegalArgumentException(member.getName() + "" is not a member of "" + getName()); //$NON-NLS-1$
		}
	}
"
138,"Nitpick: It's generally safer to include curly brackets for _all_ if statements. It can help protect against a future developer accidentally introducing a bug if another line is added to the if statement.

Alternatively, a more succinct way of writing this method would be:
```
    return (dynamicTemplateData == null) ? Collections.<String, Object>emptyMap() : dynamicTemplateData;
```","  public Map<String,Object> getDynamicTemplateData() {
    if(dynamicTemplateData == null)
       return Collections.<String,Object>emptyMap();
    return dynamicTemplateData;
  }
","  public Map<String,Object> getDynamicTemplateData() {
    if(dynamicTemplateData == null)
START        return Collections.<String,Object>emptyMap(); END 
    return dynamicTemplateData;
  }
","  public Map<String,Object> getDynamicTemplateData() {
    return dynamicTemplateData == null
            ? Collections.<String,Object>emptyMap() : dynamicTemplateData;
  }
"
139,"I'm not sure about public modifier here as version field represents reference's implementation details. I doubt consumers would be really interested in it.

I would leave it private (or even remove it) unless there is a real usecase that requires access to its value. Making it private later would be hard (due to API breakage), we can make it public later without any problems.","	public String getVersion() {
		return version;
	}
","START 	public String getVersion() { END 
		return version;
	}
","	String getVersion() {
		return version;
	}
"
140,You can drop PERUNADMIN check here. And also in all other such methods in this file please.,"	public List<User> getUsers(PerunSession sess) throws InternalErrorException, PrivilegeException {
		Utils.checkPerunSession(sess);

		// Authorization
		if(!AuthzResolver.isAuthorized(sess, Role.PERUNADMIN) &&
				!AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) {
			throw new PrivilegeException(sess, ""getUsers"");
		}

		return getUsersManagerBl().getUsers(sess);
	}
","	public List<User> getUsers(PerunSession sess) throws InternalErrorException, PrivilegeException {
		Utils.checkPerunSession(sess);

		// Authorization
		if(!AuthzResolver.isAuthorized(sess, Role.PERUNADMIN) &&
START 				!AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) { END 
			throw new PrivilegeException(sess, ""getUsers"");
		}

		return getUsersManagerBl().getUsers(sess);
	}
","	public List<User> getUsers(PerunSession sess) throws InternalErrorException, PrivilegeException {
		Utils.checkPerunSession(sess);

		// Authorization
		if(!AuthzResolver.isAuthorized(sess, Role.PERUNOBSERVER)) {
			throw new PrivilegeException(sess, ""getUsers"");
		}

		return getUsersManagerBl().getUsers(sess);
	}
"
141,"Negation missing?

 if (!cluster.isSetRequiredSwitchType()) {","    protected void setDefaultSwitchTypeIfNeeded() {
        Cluster cluster = getCluster();
        if (cluster.isSetRequiredSwitchType()) {
            SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion());
            cluster.setRequiredSwitchTypeForCluster(defaultSwitchType);
        }
    }
","    protected void setDefaultSwitchTypeIfNeeded() {
        Cluster cluster = getCluster();
        START  if (cluster.isSetRequiredSwitchType()) { END 
            SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion());
            cluster.setRequiredSwitchTypeForCluster(defaultSwitchType);
        }
    }
","    protected void setDefaultSwitchTypeIfNeeded() {
        Cluster cluster = getCluster();
        if (!cluster.isSetRequiredSwitchType()) {
            SwitchType defaultSwitchType = DefaultSwitchType.getDefaultSwitchType(cluster.getCompatibilityVersion());
            cluster.setRequiredSwitchTypeForCluster(defaultSwitchType);
        }
    }
"
142,Removed.,"    public List<BlockLocationInfo> getBlockLocations(AlluxioURI alluxioURI)
            throws IOException
    {
        throw new UnsupportedOperationException(""GetBlockLocations is not supported."");
    }
","    public List<BlockLocationInfo> getBlockLocations(AlluxioURI alluxioURI)
START             throws IOException END 
    {
        throw new UnsupportedOperationException(""GetBlockLocations is not supported."");
    }
","    public List<BlockLocationInfo> getBlockLocations(AlluxioURI alluxioURI)
    {
        throw new UnsupportedOperationException(""GetBlockLocations is not supported."");
    }
"
143,can this be in the second ctor and call this(null) here?,"    public CustomTxtParserWizard() {
        super();
        setWindowTitle(Messages.CustomTxtParserInputWizardPage_windowTitle);
    }
","    public CustomTxtParserWizard() {
        super();
START         setWindowTitle(Messages.CustomTxtParserInputWizardPage_windowTitle); END 
    }
","    public CustomTxtParserWizard() {
        this(null);
    }
"
144,Don't see how this change is necessary,"    protected Provider<AdditionalProperties> createProvider(String name) {
        Provider<AdditionalProperties> p = mock(Provider.class);
        when(p.getName()).thenReturn(name);
        return p;
    }
","START     protected Provider<AdditionalProperties> createProvider(String name) { END 
        Provider<AdditionalProperties> p = mock(Provider.class);
        when(p.getName()).thenReturn(name);
        return p;
    }
","    private Provider<AdditionalProperties> createProvider(String name) {
        Provider<AdditionalProperties> p = mock(Provider.class);
        when(p.getName()).thenReturn(name);
        return p;
    }
"
145,"You can change the 28 case to a default case, and remove this.","    public static int mapApiToArtVersion(int api) {
        if (api < 19) {
            return NO_VERSION;
        }

        switch (api) {
            case 19:
            case 20:
                return 7;
            case 21:
                return 39;
            case 22:
                return 45;
            case 23:
                return 64;
            case 24:
            case 25:
                return 79;
            case 26:
                return 124;
            case 27:
                return 131;
            case 28:
                // 144 is the current version in the master branch of AOSP as of 2018-05-22
                return 144;
        }

        return 143;
    }
","    public static int mapApiToArtVersion(int api) {
        if (api < 19) {
            return NO_VERSION;
        }

        switch (api) {
            case 19:
            case 20:
                return 7;
            case 21:
                return 39;
            case 22:
                return 45;
            case 23:
                return 64;
            case 24:
            case 25:
                return 79;
            case 26:
                return 124;
            case 27:
                return 131;
            case 28:
                // 144 is the current version in the master branch of AOSP as of 2018-05-22
                return 144;
        }

START         return 143; END 
    }
","    public static int mapApiToArtVersion(int api) {
        if (api < 19) {
            return NO_VERSION;
        }

        switch (api) {
            case 19:
            case 20:
                return 7;
            case 21:
                return 39;
            case 22:
                return 45;
            case 23:
                return 64;
            case 24:
            case 25:
                return 79;
            case 26:
                return 124;
            case 27:
                return 131;
            default:
                // 144 is the current version in the master branch of AOSP as of 2018-05-22
                return 144;
        }
    }
"
146,"@jomarko 
If it is possible to move all those ""context.getScenarioGridPanel().setFocus(true);"" inside commonExecution, then move this ""verify(scenarioGridPanelMock).setFocus(true);"" inside ""commonExecution"" Test","    public void onAppendColumnEvent() {
        AppendColumnEvent event = new AppendColumnEvent(COLUMN_GROUP);
        scenarioSimulationEventHandler.onEvent(event);
        verify(scenarioSimulationEventHandler, times(1)).commonExecution(eq(scenarioSimulationContextLocal), isA(AppendColumnCommand.class));
        verify(scenarioGridPanelMock).setFocus(true);
    }
","    public void onAppendColumnEvent() {
        AppendColumnEvent event = new AppendColumnEvent(COLUMN_GROUP);
        scenarioSimulationEventHandler.onEvent(event);
        verify(scenarioSimulationEventHandler, times(1)).commonExecution(eq(scenarioSimulationContextLocal), isA(AppendColumnCommand.class));
START         verify(scenarioGridPanelMock).setFocus(true); END 
    }
","    public void onAppendColumnEvent() {
        AppendColumnEvent event = new AppendColumnEvent(COLUMN_GROUP);
        scenarioSimulationEventHandler.onEvent(event);
        verify(scenarioSimulationEventHandler).commonExecution(eq(scenarioSimulationContextLocal),
                                                               isA(AppendColumnCommand.class),
                                                               eq(true));
    }
"
147,"Since getAdapter() has a generic interface, there is no need to type cast anymore.","  public static <T extends Widget> T serializeAndDeserialize( T instance ) throws Exception {
    byte[] bytes = serialize( instance );
    T result = ( T )deserialize( bytes );
    Object adapter = result.getDisplay().getAdapter( IDisplayAdapter.class );
    IDisplayAdapter displayAdapter = ( IDisplayAdapter )adapter;
    displayAdapter.attachThread();
    return result;
  }
","  public static <T extends Widget> T serializeAndDeserialize( T instance ) throws Exception {
    byte[] bytes = serialize( instance );
    T result = ( T )deserialize( bytes );
START     Object adapter = result.getDisplay().getAdapter( IDisplayAdapter.class ); END 
    IDisplayAdapter displayAdapter = ( IDisplayAdapter )adapter;
    displayAdapter.attachThread();
    return result;
  }
","  public static <T> T serializeAndDeserialize( T instance ) throws Exception {
    byte[] bytes = serialize( instance );
    return ( T )deserialize( bytes );
  }
"
148,maybe line wrap?,"	public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) {
		for (PreReceiveHook hook : hooks) {
			hook.onPreReceive(rp, commands);
		}
	}
","START 	public void onPreReceive(ReceivePack rp, Collection<ReceiveCommand> commands) { END 
		for (PreReceiveHook hook : hooks) {
			hook.onPreReceive(rp, commands);
		}
	}
","	public void onPreReceive(ReceivePack rp,
			Collection<ReceiveCommand> commands) {
		for (int i = 0; i < count; i++)
			hooks[i].onPreReceive(rp, commands);
	}
"
149,This only checks the first parameter for `null`. Could you update the version that takes in a `List` to check the entries for `null`s and update this line to call that version?,"    public DescriptionBuilder withAdditionalAnnotations(Annotation annotation, Annotation... additionalAnnotations) {
        if (annotation == null) {
            throw new NullPointerException(""Cannot add a null annotation"");
        }
        annotations.add(annotation);
        annotations.addAll(Arrays.asList(additionalAnnotations));
        return this;
    }
","    public DescriptionBuilder withAdditionalAnnotations(Annotation annotation, Annotation... additionalAnnotations) {
        if (annotation == null) {
            throw new NullPointerException(""Cannot add a null annotation"");
        }
        annotations.add(annotation);
START         annotations.addAll(Arrays.asList(additionalAnnotations)); END 
        return this;
    }
","    public DescriptionBuilder withAdditionalAnnotations(Annotation annotation, Annotation... additionalAnnotations) {
        List<Annotation> annotations = new ArrayList<Annotation>();
        annotations.add(annotation);
        annotations.addAll(Arrays.asList(additionalAnnotations));
        return withAdditionalAnnotations(annotations);
    }
"
150,instanceof?,"	public void onAttach(final Activity activity)
	{
		super.onAttach(activity);

		try {
			mListener = (Listener) activity;
		} catch (final ClassCastException e) {
			Lg.e(activity.getClass().getName(), "" should implement "", Listener.class.getName());
		}
	}
","	public void onAttach(final Activity activity)
	{
		super.onAttach(activity);

		try {
			mListener = (Listener) activity;
START 		} catch (final ClassCastException e) { END 
			Lg.e(activity.getClass().getName(), "" should implement "", Listener.class.getName());
		}
	}
","	public void onAttach(final Activity activity)
	{
		super.onAttach(activity);

		if (activity instanceof Listener) {
			mListener = (Listener) activity;
		} else {
			Lg.e(activity.getClass().getName(), "" should implement "", Listener.class.getName());
		}
	}
"
151,Need to be careful here. We can't always assume classification problems. Maybe use -1 (last dimension) instead?,"    private void preloadDataSet(){
        preloadedDataSet = load(iter.next());
        totalOutcomes = preloadedDataSet.getLabels().size(1);
        inputColumns = preloadedDataSet.getFeatureMatrix().size(1);
        batch = preloadedDataSet.numExamples();
    }
","    private void preloadDataSet(){
        preloadedDataSet = load(iter.next());
        totalOutcomes = preloadedDataSet.getLabels().size(1);
        inputColumns = preloadedDataSet.getFeatureMatrix().size(1);
START         batch = preloadedDataSet.numExamples(); END 
    }
","    private void preloadDataSet(){
        preloadedDataSet = load(iter.next());
        totalOutcomes = preloadedDataSet.getLabels().size(1);
        inputColumns = preloadedDataSet.getFeatureMatrix().size(1);
    }
"
152,`log.info()` to `ss.info()`.,"    public void startup(Application application, ComponentStartupStatus ss) {
        FileOps.ensureDir(deltaClientZone);
        FileOps.clearAll(deltaClientZone);
        zone = Zone.connect(deltaClientZone);
        deltaLink = DeltaLinkHTTP.connect(deltaServerURL);
        deltaClient = DeltaClient.create(zone, deltaLink);
        jmsMessagingClient = application.getJMSMessagingClient();
        log.info(String.format(""DeltaClient connected to DeltaServer at %s with zone %s"", deltaServerURL, deltaClientZone));
    }
","    public void startup(Application application, ComponentStartupStatus ss) {
        FileOps.ensureDir(deltaClientZone);
        FileOps.clearAll(deltaClientZone);
        zone = Zone.connect(deltaClientZone);
        deltaLink = DeltaLinkHTTP.connect(deltaServerURL);
        deltaClient = DeltaClient.create(zone, deltaLink);
        jmsMessagingClient = application.getJMSMessagingClient();
START         log.info(String.format(""DeltaClient connected to DeltaServer at %s with zone %s"", deltaServerURL, deltaClientZone)); END 
    }
","    public void startup(Application application, ComponentStartupStatus ss) {
        FileOps.ensureDir(deltaClientZone);
        FileOps.clearAll(deltaClientZone);
        Zone zone = Zone.connect(deltaClientZone);
        deltaLink = DeltaLinkHTTP.connect(deltaServerURL);
        deltaClient = DeltaClient.create(zone, deltaLink);
        jmsMessagingClient = application.getJMSMessagingClient();
        ss.info(String.format(""DeltaClient connected to DeltaServer at %s with zone %s"", deltaServerURL, deltaClientZone));
    }
"
153,"I think we don't need this change. 
We have similar structure in the `UdpSyslogReceivingChannelAdapter` below but you don't override the `onInit()` logic there.","	protected void onInit() {
		super.onInit();
		if (this.connectionFactory == null) {
			this.connectionFactory = new TcpNioServerConnectionFactory(super.getPort());
			this.connectionFactory.setDeserializer(new ByteArrayLfSerializer());
			this.connectionFactory.setBeanFactory(getBeanFactory());
			if (this.applicationEventPublisher != null) {
				this.connectionFactory.setApplicationEventPublisher(this.applicationEventPublisher);
			}
			this.connectionFactory.afterPropertiesSet();
		}
		this.connectionFactory.registerListener(this);
	}
","	protected void onInit() {
		super.onInit();
		if (this.connectionFactory == null) {
START 			this.connectionFactory = new TcpNioServerConnectionFactory(super.getPort()); END 
			this.connectionFactory.setDeserializer(new ByteArrayLfSerializer());
			this.connectionFactory.setBeanFactory(getBeanFactory());
			if (this.applicationEventPublisher != null) {
				this.connectionFactory.setApplicationEventPublisher(this.applicationEventPublisher);
			}
			this.connectionFactory.afterPropertiesSet();
		}
		this.connectionFactory.registerListener(this);
	}
","	protected void onInit() {
		super.onInit();
		if (this.connectionFactory == null) {
			this.connectionFactory = new TcpNioServerConnectionFactory(getPort());
			this.connectionFactory.setDeserializer(new ByteArrayLfSerializer());
			this.connectionFactory.setBeanFactory(getBeanFactory());
			if (this.applicationEventPublisher != null) {
				this.connectionFactory.setApplicationEventPublisher(this.applicationEventPublisher);
			}
			this.connectionFactory.afterPropertiesSet();
		}
		this.connectionFactory.registerListener(this);
	}
"
154,are there some unit tests for this? Will this handle extraneous whitespaces well?,"  public static Pair<Integer, Integer> getPrecisionAndScale(String type) {
    String param = type.substring(8, type.length() - 1);
    String[] params = param.split("","");
    return new Pair<>(Integer.parseInt(params[0].trim()), Integer.parseInt(params[1].trim()));
  }
","START   public static Pair<Integer, Integer> getPrecisionAndScale(String type) { END 
    String param = type.substring(8, type.length() - 1);
    String[] params = param.split("","");
    return new Pair<>(Integer.parseInt(params[0].trim()), Integer.parseInt(params[1].trim()));
  }
","  public static Pair<Integer, Integer> getPrecisionAndScale(String type) {
    type = type.trim();
    String param = type.substring(8, type.length() - 1);
    String[] params = param.split("","");
    return new Pair<>(Integer.parseInt(params[0].trim()), Integer.parseInt(params[1].trim()));
  }
"
155,"we don't know if these were used in extensions, can the things that were public remain so?","  static String constructSegmentPath(String baseKey, String storageDir)
  {
    return JOINER.join(
        baseKey.isEmpty() ? null : baseKey,
        storageDir
    ) + ""/index.zip"";
  }
","START   static String constructSegmentPath(String baseKey, String storageDir) END 
  {
    return JOINER.join(
        baseKey.isEmpty() ? null : baseKey,
        storageDir
    ) + ""/index.zip"";
  }
","  public static String constructSegmentPath(String baseKey, String storageDir)
  {
    return JOINER.join(
        baseKey.isEmpty() ? null : baseKey,
        storageDir
    ) + ""/index.zip"";
  }
"
156,"I find it strange that the constructor already does some work. Might catch someone by surprise, especially if he wants to concatenate several iterators. I'd like this better if only hasNext() or next() actually advanced. It's more predictable.

Maybe similar to the logic in CachingKeyPairProvider$CancellingKeyPairIterator . That one is similar to MappingIterator<Path, KeyPair>.","	public MappingIterator(Collection<S> source, Function<S, D> transformation) {
		this.sourceIt = source.iterator();
		this.transformation = transformation;
		readNext();
	}
","	public MappingIterator(Collection<S> source, Function<S, D> transformation) {
		this.sourceIt = source.iterator();
		this.transformation = transformation;
START 		readNext(); END 
	}
","	public MappingIterator(Collection<S> source, Function<S, D> transformation) {
		this.sourceIt = source.iterator();
		this.transformation = transformation;
	}
"
157,"remove(a,b) is going to use equals which is not right for XWikiAttachment. You should use remove(a) != b instead.","    public boolean removeAll(Collection<?> c)
    {
        boolean changed = false;
        for (XWikiAttachment x : (Collection<? extends XWikiAttachment>) c) {
            if (map.remove(x.getFilename(), x)) {
                changed = true;
            }
        }
        if (changed) {
            updatedMap();
        }
        return changed;
    }
","    public boolean removeAll(Collection<?> c)
    {
        boolean changed = false;
        for (XWikiAttachment x : (Collection<? extends XWikiAttachment>) c) {
START             if (map.remove(x.getFilename(), x)) { END 
                changed = true;
            }
        }
        if (changed) {
            updatedMap();
        }
        return changed;
    }
","    public boolean removeAll(Collection<?> c)
    {
        boolean changed = false;
        for (XWikiAttachment x : (Collection<? extends XWikiAttachment>) c) {
            if (map.get(x.getFilename()) == x) {
                map.remove(x.getFilename());
                changed = true;
            }
        }
        if (changed) {
            updatedMap();
        }
        return changed;
    }
"
158,@erdemedeiros let's remove all the system outs,"    public void run(String... strings) throws Exception {
        System.out.println("">>> Starting Audit App... "");
    }
","    public void run(String... strings) throws Exception {
START         System.out.println("">>> Starting Audit App... ""); END 
    }
","    public void run(String... strings) throws Exception {
    }
"
159,This is already initialized by super class.,"  public CollectEnvCommand(FileSystemContext fsContext) {
    super(fsContext);
    mCommands = new HashMap<>();
    mCommandsAlt = new HashMap<>();
    registerCommands();
  }
","  public CollectEnvCommand(FileSystemContext fsContext) {
    super(fsContext);
START     mCommands = new HashMap<>();
    mCommandsAlt = new HashMap<>(); END 
    registerCommands();
  }
","  public CollectEnvCommand(FileSystemContext fsContext) {
    super(fsContext);
    registerCommands();
  }
"
160,"The ""else"" seems unnecessary","  protected void setBlobStorageService(BlobStorageService blobStorageService) {
    if (blobStorageService == null) {
      throw new IllegalArgumentException(""BlobStorageService cannot be null"");
    } else {
      this.blobStorageService = blobStorageService;
      logger.trace(""BlobStorage service set to {}"", blobStorageService.getClass());
    }
  }
","  protected void setBlobStorageService(BlobStorageService blobStorageService) {
    if (blobStorageService == null) {
      throw new IllegalArgumentException(""BlobStorageService cannot be null"");
START     } else { END 
      this.blobStorageService = blobStorageService;
      logger.trace(""BlobStorage service set to {}"", blobStorageService.getClass());
    }
  }
","  protected void setBlobStorageService(BlobStorageService blobStorageService) {
    if (blobStorageService == null) {
      throw new IllegalArgumentException(""BlobStorageService cannot be null"");
    }
    this.blobStorageService = blobStorageService;
    logger.trace(""BlobStorage service set to {}"", blobStorageService.getClass());
  }
"
161,I don't think this hurts but line 96 already sets this window.tbr to false and I have not seen that this property has changed.,"	public void dispose() {
		app.getChildren().remove(windowModel);
		coolBarManager.dispose();
		menuManager.dispose();
		statusLineManager.dispose();
		windowModel.setToBeRendered(false);
		windowModel.getContext().deactivate();
		windowModel.getContext().dispose();
		((Shell) windowModel.getWidget()).dispose();
	}
","	public void dispose() {
		app.getChildren().remove(windowModel);
		coolBarManager.dispose();
		menuManager.dispose();
		statusLineManager.dispose();
START 		windowModel.setToBeRendered(false); END 
		windowModel.getContext().deactivate();
		windowModel.getContext().dispose();
		((Shell) windowModel.getWidget()).dispose();
	}
","	public void dispose() {
		app.getChildren().remove(windowModel);
		coolBarManager.dispose();
		menuManager.dispose();
		statusLineManager.dispose();
		windowModel.getContext().deactivate();
		windowModel.getContext().dispose();
		((Shell) windowModel.getWidget()).dispose();
	}
"
162,The executor shouldn't be needed here either,"   public void setUp() {
      n = new CacheManagerNotifierImpl();
      cl = new CacheManagerListener();

      TestingUtil.inject(n, TestingUtil.named(KnownComponentNames.ASYNC_NOTIFICATION_EXECUTOR, new WithinThreadExecutor()));

      n.start();
      n.addListener(cl);
   }
","   public void setUp() {
      n = new CacheManagerNotifierImpl();
      cl = new CacheManagerListener();

START       TestingUtil.inject(n, TestingUtil.named(KnownComponentNames.ASYNC_NOTIFICATION_EXECUTOR, new WithinThreadExecutor())); END 

      n.start();
      n.addListener(cl);
   }
","   public void setUp() {
      n = new CacheManagerNotifierImpl();
      cl = new CacheManagerListener();

      n.start();
      n.addListener(cl);
   }
"
163,Should be `final char rv;`.,"    public char getLabel() {
        char rv;
        switch (getType()) {
            case INPUT_VAL: rv = buttonData.inputVal;   break;
            case AUTO_CHAR: rv = buttonData.autoChar;   break;
            case CUSTOM:    rv = buttonData.customChar; break;
            default:        rv='*'; // Should never happen.
        }

        return rv;
    }
","    public char getLabel() {
START         char rv; END 
        switch (getType()) {
            case INPUT_VAL: rv = buttonData.inputVal;   break;
            case AUTO_CHAR: rv = buttonData.autoChar;   break;
            case CUSTOM:    rv = buttonData.customChar; break;
            default:        rv='*'; // Should never happen.
        }

        return rv;
    }
","    public char getLabel() {
        final char rv;
        switch (getType()) {
            case INPUT_VAL: rv = buttonData.inputVal;   break;
            case AUTO_CHAR: rv = buttonData.autoChar;   break;
            case CUSTOM:    rv = buttonData.customChar; break;
            default:        rv = '*'; // Should never happen.
        }

        return rv;
    }
"
164,I would prefer to move this call to the private `ReleasableBytesReference` constructor.,"    public ReleasableBytesReference retainedSlice(int from, int length) {
        BytesReference slice = delegate.slice(from, length);
        refCounted.incRef();
        return new ReleasableBytesReference(slice, refCounted);
    }
","    public ReleasableBytesReference retainedSlice(int from, int length) {
        BytesReference slice = delegate.slice(from, length);
START         refCounted.incRef(); END 
        return new ReleasableBytesReference(slice, refCounted);
    }
","    public ReleasableBytesReference retainedSlice(int from, int length) {
        return new ReleasableBytesReference(delegate.slice(from, length), refCounted);
    }
"
165,"This set races with the dereference of L101 and may cause NPE. Besides, since it would be set to the value `lio` essentially (plus a transparent SafeSubscriber layer), you don't really need this field. Just call `this.unsubscribe()` on L101.","    public static <T> Iterable<T> latest(final Observable<? extends T> source) {
        return new Iterable<T>() {
            @Override
            public Iterator<T> iterator() {
                LatestObserverIterator<T> lio = new LatestObserverIterator<T>();
                lio.subscription = source.materialize().subscribe(lio);
                return lio;
            }
        };
    }
","    public static <T> Iterable<T> latest(final Observable<? extends T> source) {
        return new Iterable<T>() {
            @Override
            public Iterator<T> iterator() {
                LatestObserverIterator<T> lio = new LatestObserverIterator<T>();
START                 lio.subscription = source.materialize().subscribe(lio); END 
                return lio;
            }
        };
    }
","    public static <T> Iterable<T> latest(final Observable<? extends T> source) {
        return new Iterable<T>() {
            @Override
            public Iterator<T> iterator() {
                LatestObserverIterator<T> lio = new LatestObserverIterator<T>();
                source.materialize().subscribe(lio);
                return lio;
            }
        };
    }
"
166,"Discussion: does it make sense to return an enum entry here that I guess only exists for this method? Other alternatives could be to return `null` here, or an Optional","    public static MessageType fromId(String id) {
        for(MessageType current : values()) {
            if(current.getId().equals(id)) {
                return current;
            }
        }
        return UNKNOWN;
    }
","    public static MessageType fromId(String id) {
        for(MessageType current : values()) {
            if(current.getId().equals(id)) {
                return current;
            }
        }
START         return UNKNOWN; END 
    }
","    public static Optional<MessageType> fromId(String id) {
        for (MessageType current : values()) {
            if (current.getId().equals(id)) {
                return Optional.of(current);
            }
        }
        return Optional.empty();
    }
"
167,"Please remove unnecessary brackets:

 return vdsDynamic.getStatus() == VDSStatus.Down
         || vdsDynamic.getStatus() == VDSStatus.Reboot
         || (vdsDynamic.getStatus() == VDSStatus.NonOperational
                 && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE);

Even remaining brackets are not necessary, but they makes code more readable","    private boolean isHostNetworkUnreacable(VDS vds) {
        VdsDynamic vdsDynamic = vds.getDynamicData();
        return ((vdsDynamic.getStatus() == VDSStatus.Down)
                 || (vdsDynamic.getStatus() == VDSStatus.Reboot)
                 || (vdsDynamic.getStatus() == VDSStatus.NonOperational
                     && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE));
    }
","    private boolean isHostNetworkUnreacable(VDS vds) {
        VdsDynamic vdsDynamic = vds.getDynamicData();
        return ((vdsDynamic.getStatus() == VDSStatus.Down)
                 || (vdsDynamic.getStatus() == VDSStatus.Reboot)
                 || (vdsDynamic.getStatus() == VDSStatus.NonOperational
START                      && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE)); END 
    }
","    private boolean isHostNetworkUnreacable(VDS vds) {
        VdsDynamic vdsDynamic = vds.getDynamicData();
        return (vdsDynamic.getStatus() == VDSStatus.Down
                 || vdsDynamic.getStatus() == VDSStatus.Reboot
                 || (vdsDynamic.getStatus() == VDSStatus.NonOperational
                     && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE));
    }
"
168,"Having the Java Config style, it'd better to make this class `public`.","	ScriptExecutingMessageSource(AbstractScriptExecutingMessageProcessor<?> scriptMessageProcessor) {
		this.scriptMessageProcessor = scriptMessageProcessor;
	}
","START 	ScriptExecutingMessageSource(AbstractScriptExecutingMessageProcessor<?> scriptMessageProcessor) { END 
		this.scriptMessageProcessor = scriptMessageProcessor;
	}
","	public ScriptExecutingMessageSource(AbstractScriptExecutingMessageProcessor<?> scriptMessageProcessor) {
		this.scriptMessageProcessor = scriptMessageProcessor;
	}
"
169,How come there needs to be a substring for this?,"	public void typeInSearchField(String content, int length) {
		waitForElementVisibleByElement(searchInput);
		searchInput.sendKeys(content.substring(0, length));
		PageObjectLogging.log(
				""typeInSearchField"",
				""String >>"" + content.substring(0, length) + ""<< was typed in string field"",
				true
		);
	}
","	public void typeInSearchField(String content, int length) {
		waitForElementVisibleByElement(searchInput);
START 		searchInput.sendKeys(content.substring(0, length)); END 
		PageObjectLogging.log(
				""typeInSearchField"",
				""String >>"" + content.substring(0, length) + ""<< was typed in string field"",
				true
		);
	}
","	public void typeInSearchField(String content, int length) {
		waitForElementVisibleByElement(searchInput);
		searchInput.sendKeys(content.substring(0, 3));
		PageObjectLogging.log(
				""typeInSearchField"",
				""String >>"" + content.substring(0, length) + ""<< was typed in string field"",
				true
		);
	}
"
170,Inline.,"  public Iterable<E> read(Configuration configuration) throws IOException {
    // TODO: what to do with Configuration? create new view?
    DatasetReader<E> reader = view.newReader();
    return reader; // TODO: who calls close?
  }
","  public Iterable<E> read(Configuration configuration) throws IOException {
    // TODO: what to do with Configuration? create new view?
    DatasetReader<E> reader = view.newReader();
START     return reader; // TODO: who calls close? END 
  }
","  public Iterable<E> read(Configuration configuration) throws IOException {
    // TODO: what to do with Configuration? create new view?
    return view.newReader(); // TODO: who calls close?
  }
"
171,"if it is not constant, please convert to lower case?","    public void setRefreshInterval(final long refreshInterval) {
        REFRESH_INTERVAL_IN_SECONDS = refreshInterval;
    }
","    public void setRefreshInterval(final long refreshInterval) {
START         REFRESH_INTERVAL_IN_SECONDS = refreshInterval; END 
    }
","    public void setRefreshInterval(final long refreshInterval) {
        this.refreshInterval = refreshInterval;
    }
"
172,"These copy-paste sections are starting to clutter up the presenter.
Please try to extract a common denominator (e.g. a function) to reduce repeating code snippets.","	public void onNewImageFromCamera() {
		if (navigator.isSdkAboveOrEqualM() && !navigator.doIHavePermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
			navigator.askForPermission(new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE},
					PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA);
		} else {
			interactor.createFile(this, CREATE_FILE_TAKE_PHOTO, null);
		}
	}
","	public void onNewImageFromCamera() {
START 		if (navigator.isSdkAboveOrEqualM() && !navigator.doIHavePermission(Manifest.permission.WRITE_EXTERNAL_STORAGE)) { END 
			navigator.askForPermission(new String[] {Manifest.permission.WRITE_EXTERNAL_STORAGE},
					PERMISSION_EXTERNAL_STORAGE_NEW_IMAGE_CAMERA);
		} else {
			interactor.createFile(this, CREATE_FILE_TAKE_PHOTO, null);
		}
	}
","	public void onNewImageFromCamera() {
		interactor.createFile(this, CREATE_FILE_TAKE_PHOTO, null);
	}
"
173,Please make sure there are overloaded constructors available for the old constructor signature. Then you also wont have to change this existing test.,"	public void testEquals() throws Exception {
		FixedWidthConfiguration conf1 = new FixedWidthConfiguration(1, ""UTF8"",
				10, true, false, true);
		FixedWidthConfiguration conf2 = new FixedWidthConfiguration(1, ""UTF8"",
				10, true, false, true);
		assertEquals(conf1, conf2);

		FixedWidthConfiguration conf3 = new FixedWidthConfiguration(1, ""UTF8"",
				10, false, false, true);
		assertFalse(conf1.equals(conf3));
	}
","	public void testEquals() throws Exception {
		FixedWidthConfiguration conf1 = new FixedWidthConfiguration(1, ""UTF8"",
START 				10, true, false, true); END 
		FixedWidthConfiguration conf2 = new FixedWidthConfiguration(1, ""UTF8"",
				10, true, false, true);
		assertEquals(conf1, conf2);

		FixedWidthConfiguration conf3 = new FixedWidthConfiguration(1, ""UTF8"",
				10, false, false, true);
		assertFalse(conf1.equals(conf3));
	}
","	public void testEquals() throws Exception {
		FixedWidthConfiguration conf1 = new FixedWidthConfiguration(1, ""UTF8"", 10, true);
		FixedWidthConfiguration conf2 = new FixedWidthConfiguration(1, ""UTF8"", 10, true);
		assertEquals(conf1, conf2);

		FixedWidthConfiguration conf3 = new FixedWidthConfiguration(1, ""UTF8"", 10, false);
		assertFalse(conf1.equals(conf3));
	}
"
174,"You actually don't need a private variable for storing the link preview. If you look at the line directly above, the findFragmentByTag() function finds the dialog by its tag name (also specified above). You can cast the return value of this function into a LinkPreviewDialog, and call dismiss() on it.","    public void showLinkPreview(PageTitle title, int entrySource) {
        final String linkPreviewFragmentTag = ""link_preview_dialog"";
        if (getSupportFragmentManager().findFragmentByTag(linkPreviewFragmentTag) == null) {
            linkPreview = LinkPreviewDialog.newInstance(title, entrySource);
            linkPreview.show(getSupportFragmentManager(), linkPreviewFragmentTag);
        }
    }
","    public void showLinkPreview(PageTitle title, int entrySource) {
        final String linkPreviewFragmentTag = ""link_preview_dialog"";
        if (getSupportFragmentManager().findFragmentByTag(linkPreviewFragmentTag) == null) {
START             linkPreview = LinkPreviewDialog.newInstance(title, entrySource); END 
            linkPreview.show(getSupportFragmentManager(), linkPreviewFragmentTag);
        }
    }
","    public void showLinkPreview(PageTitle title, int entrySource) {
        final String linkPreviewFragmentTag = ""link_preview_dialog"";
        if (getSupportFragmentManager().findFragmentByTag(linkPreviewFragmentTag) == null) {
            LinkPreviewDialog linkPreview = LinkPreviewDialog.newInstance(title, entrySource);
            linkPreview.show(getSupportFragmentManager(), linkPreviewFragmentTag);
        }
    }
"
175,"IMO, if you use `if (...) { ... }`, it makes the code easy to read. I meant the `{` and  `}` are missing :)

edit: the same for the following `if`s","   public void clear() {
      if (loader instanceof CacheStore)
         try {
            ((CacheStore) loader).clear();
         } catch (CacheLoaderException e) {
            throw newCacheLoaderException(e);
         }
   }
","   public void clear() {
START       if (loader instanceof CacheStore) END 
         try {
            ((CacheStore) loader).clear();
         } catch (CacheLoaderException e) {
            throw newCacheLoaderException(e);
         }
   }
","   public void clear() {
      if (loader instanceof CacheStore) {
         try {
            ((CacheStore) loader).clear();
         } catch (CacheLoaderException e) {
            throw newCacheLoaderException(e);
         }
      }
   }
"
176,This file needs some work to ensure it works with client.,"   public ApplicabilityIds getApplicabilityIds() {
      // TBD - Replace with call to IApplicabilityService calls once implemented
      ApplicabilityIds ids = new ApplicabilityIds();
      //      ids.getApplicabilityIds().add(new ApplicabilityId(345L, ""ARC-210""));
      //      ids.getApplicabilityIds().add(new ApplicabilityId(366L, ""COMM""));
      //      ids.getApplicabilityIds().add(new ApplicabilityId(376L, ""ASM""));
      //      ids.getApplicabilityIds().add(new ApplicabilityId(368L, ""UTF""));
      //      ids.getApplicabilityIds().add(new ApplicabilityId(466L, ""MDR""));
      return ids;
   }
","   public ApplicabilityIds getApplicabilityIds() {
      // TBD - Replace with call to IApplicabilityService calls once implemented
START       ApplicabilityIds ids = new ApplicabilityIds(); END 
      //      ids.getApplicabilityIds().add(new ApplicabilityId(345L, ""ARC-210""));
      //      ids.getApplicabilityIds().add(new ApplicabilityId(366L, ""COMM""));
      //      ids.getApplicabilityIds().add(new ApplicabilityId(376L, ""ASM""));
      //      ids.getApplicabilityIds().add(new ApplicabilityId(368L, ""UTF""));
      //      ids.getApplicabilityIds().add(new ApplicabilityId(466L, ""MDR""));
      return ids;
   }
","   public ApplicabilityIds getApplicabilityIds() {
      return null;
   }
"
177,private?,"   MediaType tryNarrowMediaType(MediaType negotiated, AdvancedCache<?, ?> cache) {
      if (!negotiated.matchesAll()) return negotiated;
      MediaType storageMediaType = cache.getValueDataConversion().getStorageMediaType();

      if (storageMediaType == null) return negotiated;
      if (storageMediaType.equals(MediaType.APPLICATION_OBJECT)) return TEXT_PLAIN;
      if (storageMediaType.match(MediaType.APPLICATION_PROTOSTREAM)) return APPLICATION_JSON;

      return negotiated;
   }
","START    MediaType tryNarrowMediaType(MediaType negotiated, AdvancedCache<?, ?> cache) { END 
      if (!negotiated.matchesAll()) return negotiated;
      MediaType storageMediaType = cache.getValueDataConversion().getStorageMediaType();

      if (storageMediaType == null) return negotiated;
      if (storageMediaType.equals(MediaType.APPLICATION_OBJECT)) return TEXT_PLAIN;
      if (storageMediaType.match(MediaType.APPLICATION_PROTOSTREAM)) return APPLICATION_JSON;

      return negotiated;
   }
","   private MediaType tryNarrowMediaType(MediaType negotiated, AdvancedCache<?, ?> cache) {
      if (!negotiated.matchesAll()) return negotiated;
      MediaType storageMediaType = cache.getValueDataConversion().getStorageMediaType();

      if (storageMediaType == null) return negotiated;
      if (storageMediaType.equals(MediaType.APPLICATION_OBJECT)) return TEXT_PLAIN;
      if (storageMediaType.match(MediaType.APPLICATION_PROTOSTREAM)) return APPLICATION_JSON;

      return negotiated;
   }
"
178,This does not do anything. Can be removed,"	protected void addJAROption(Composite comp) {
		fJarButton = new Button(comp, SWT.CHECK);
		fJarButton.setText(getJarButtonText());
		fJarButton.addSelectionListener(widgetSelectedAdapter(e -> {
		}));
	}
","	protected void addJAROption(Composite comp) {
		fJarButton = new Button(comp, SWT.CHECK);
		fJarButton.setText(getJarButtonText());
START 		fJarButton.addSelectionListener(widgetSelectedAdapter(e -> { END 
		}));
	}
","	protected void addJAROption(Composite comp) {
		fJarButton = new Button(comp, SWT.CHECK);
		fJarButton.setText(getJarButtonText());
	}
"
179,"The additional check is not used in other instructions, is it needed?","    public String getTurnDescription( Translation tr )
    {
        if (rawName || !name.isEmpty())
            return getName();

        return tr.tr(""finish"");
    }
","    public String getTurnDescription( Translation tr )
    {
START         if (rawName || !name.isEmpty()) END 
            return getName();

        return tr.tr(""finish"");
    }
","    public String getTurnDescription( Translation tr )
    {
        if (rawName)
            return getName();

        return tr.tr(""finish"");
    }
"
180,Catch?,"    private void fetchPresenterWidgetTemplate(PresenterOptions presenterOptions) throws Exception {
        PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions();
        presenterWidgetOptions.setSingleton(presenterConfigModel.isUseSingleton());

        try {
            createdPresenterWidgetTemplates = CreatePresenterWidget.run(presenterOptions, presenterWidgetOptions, true);
        } catch (Exception e) {
            throw e;
        }
    }
","    private void fetchPresenterWidgetTemplate(PresenterOptions presenterOptions) throws Exception {
        PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions();
        presenterWidgetOptions.setSingleton(presenterConfigModel.isUseSingleton());

        try {
            createdPresenterWidgetTemplates = CreatePresenterWidget.run(presenterOptions, presenterWidgetOptions, true);
        } catch (Exception e) {
START             throw e; END 
        }
    }
","    private void fetchPresenterWidgetTemplate(PresenterOptions presenterOptions) throws Exception {
        PresenterWidgetOptions presenterWidgetOptions = new PresenterWidgetOptions();
        presenterWidgetOptions.setSingleton(presenterConfigModel.isUseSingleton());

        createdPresenterWidgetTemplates = CreatePresenterWidget.run(presenterOptions, presenterWidgetOptions, true);
    }
"
181,"Make this as a log.error statement. And needs to have space after the "",""","	public String toString() {
		
		StringWriter writer = new StringWriter();
		try {
			new ObjectMapper().writeValue(writer, graph);
		}
		catch (Exception e) {
			log.debug (""Error while constructing new ObjectMapper"",e);
		}
		return writer.toString();
	}
","	public String toString() {
		
		StringWriter writer = new StringWriter();
		try {
			new ObjectMapper().writeValue(writer, graph);
		}
		catch (Exception e) {
			log.debug (""Error while constructing new ObjectMapper"",e);
START 		} END 
		return writer.toString();
	}
","	public String toString() {
		
		StringWriter writer = new StringWriter();
		try {
			new ObjectMapper().writeValue(writer, graph);
		}
		catch (Exception e) {
			log.error (""Error while constructing new ObjectMapper"", e);
		}
		return writer.toString();
	}
"
182,"How about replacing these four lines with:
```
this(topic, Objects.requireNotNull(task).connector(), task.task(), discoverTimestamp);
```
and then removing the TODO line?","    public TopicStatus(String topic, ConnectorTaskId task, long discoverTimestamp) {
        //TODO: check non-null
        this.topic = topic;
        this.connector = task.connector();
        this.task = task.task();
        this.discoverTimestamp = discoverTimestamp;
    }
","    public TopicStatus(String topic, ConnectorTaskId task, long discoverTimestamp) {
        //TODO: check non-null
        this.topic = topic;
        this.connector = task.connector();
        this.task = task.task();
START         this.discoverTimestamp = discoverTimestamp; END 
    }
","    public TopicStatus(String topic, ConnectorTaskId task, long discoverTimestamp) {
        this(topic, task.connector(), task.task(), discoverTimestamp);
    }
"
183,Just add an envelope section to `createFromEsriGeometry` method in this file,"    private static OGCGeometry readGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length)
    {
        switch (type) {
            case POINT:
                return readPoint(input);
            case MULTI_POINT:
            case LINE_STRING:
            case MULTI_LINE_STRING:
            case POLYGON:
            case MULTI_POLYGON:
                return readSimpleGeometry(input, inputSlice, type, length);
            case GEOMETRY_COLLECTION:
                return readGeometryCollection(input, inputSlice);
            case ENVELOPE:
                return OGCGeometry.createFromEsriGeometry(readEnvelope(input), null);
            default:
                throw new IllegalArgumentException(""Unexpected type: "" + type);
        }
    }
","    private static OGCGeometry readGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length)
    {
        switch (type) {
            case POINT:
                return readPoint(input);
            case MULTI_POINT:
            case LINE_STRING:
            case MULTI_LINE_STRING:
            case POLYGON:
            case MULTI_POLYGON:
                return readSimpleGeometry(input, inputSlice, type, length);
            case GEOMETRY_COLLECTION:
                return readGeometryCollection(input, inputSlice);
            case ENVELOPE:
START                 return OGCGeometry.createFromEsriGeometry(readEnvelope(input), null); END 
            default:
                throw new IllegalArgumentException(""Unexpected type: "" + type);
        }
    }
","    private static OGCGeometry readGeometry(BasicSliceInput input, Slice inputSlice, GeometryType type, int length)
    {
        switch (type) {
            case POINT:
                return readPoint(input);
            case MULTI_POINT:
            case LINE_STRING:
            case MULTI_LINE_STRING:
            case POLYGON:
            case MULTI_POLYGON:
                return readSimpleGeometry(input, inputSlice, type, length);
            case GEOMETRY_COLLECTION:
                return readGeometryCollection(input, inputSlice);
            case ENVELOPE:
                return createFromEsriGeometry(readEnvelope(input), false);
            default:
                throw new IllegalArgumentException(""Unexpected type: "" + type);
        }
    }
"
184,Could set `null` to the `values` field too,"  public void close()
  {
    sketch = null;
  }
","  public void close()
  {
START     sketch = null; END 
  }
","  public void close()
  {
    sketch = null;
    values = null;
  }
"
185,"We still need to account for the probe batch size here when we are processing a spilled partition. If we try to account for it in he PostBuildCalculator it will already be too late, because we will have already prefetched the probe side batch.","  public boolean shouldSpill() {
    // Expected new batch size like the current, plus the Hash Values vector (4 bytes per HV)
    long batchSize = ( batchMemoryManager.getRecordBatchSizer(RIGHT_INDEX).getRowAllocWidth() + 4 ) * recordsPerBatch;
    long reserveForOutgoing = batchMemoryManager.getOutputBatchSize();
    long memoryAvailableNow = allocator.getLimit() - allocator.getAllocatedMemory() - reserveForOutgoing;
    boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow;
    if ( needsSpill ) {
      logger.debug(""should spill now - batch size {}, mem avail {}, reserved for outgoing {}"", batchSize, memoryAvailableNow, reserveForOutgoing);
    }
    return needsSpill;   // go spill if too little memory is available
  }
","  public boolean shouldSpill() {
    // Expected new batch size like the current, plus the Hash Values vector (4 bytes per HV)
    long batchSize = ( batchMemoryManager.getRecordBatchSizer(RIGHT_INDEX).getRowAllocWidth() + 4 ) * recordsPerBatch;
    long reserveForOutgoing = batchMemoryManager.getOutputBatchSize();
START     long memoryAvailableNow = allocator.getLimit() - allocator.getAllocatedMemory() - reserveForOutgoing; END 
    boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow;
    if ( needsSpill ) {
      logger.debug(""should spill now - batch size {}, mem avail {}, reserved for outgoing {}"", batchSize, memoryAvailableNow, reserveForOutgoing);
    }
    return needsSpill;   // go spill if too little memory is available
  }
","  public boolean shouldSpill() {
    // Expected new batch size like the current, plus the Hash Values vector (4 bytes per HV)
    long batchSize = ( batchMemoryManager.getRecordBatchSizer(RIGHT_INDEX).getRowAllocWidth() + 4 ) * recordsPerBatch;
    long reserveForOutgoing = batchMemoryManager.getOutputBatchSize();
    long memoryAvailableNow = allocator.getLimit() - allocator.getAllocatedMemory();
    boolean needsSpill = minBatchesInAvailableMemory * batchSize > memoryAvailableNow - reserveForOutgoing;
    if ( needsSpill ) {
      logger.debug(""should spill now - batch size {}, mem avail {}, reserved for outgoing {}"", batchSize, memoryAvailableNow, reserveForOutgoing);
    }
    return needsSpill;   // go spill if too little memory is available
  }
"
186,same as above. we shouldn't be throwing run-time exceptions when close is called.,"    public void close() {
        try {
            Await.result(beam.close());
        } catch (Exception e) {
            final String errorMsg = ""Error while closing Druid beam client"";
            LOG.error(errorMsg, e);
            throw new RuntimeException(errorMsg);
        }
    }
","    public void close() {
        try {
            Await.result(beam.close());
        } catch (Exception e) {
            final String errorMsg = ""Error while closing Druid beam client"";
            LOG.error(errorMsg, e);
START             throw new RuntimeException(errorMsg); END 
        }
    }
","    public void close() {
        try {
            Await.result(beam.close());
        } catch (Exception e) {
            LOG.error(""Error while closing Druid beam client"", e);
        }
    }
"
187,"Bug 517068 is actually targeting 0.12.1. Only 0.12.100 has it right now, but it should be backported to 0.12.1.","	private boolean isPlatformKeybindingBug517068Fixed() {
		Bundle bundle = Platform.getBundle(""org.eclipse.e4.ui.bindings""); //$NON-NLS-1$
		Version currentVersion = bundle.getVersion();
		Version fixVersion = new Version(0, 12, 100);
		return currentVersion.compareTo(fixVersion) >= 0;
	}
","	private boolean isPlatformKeybindingBug517068Fixed() {
		Bundle bundle = Platform.getBundle(""org.eclipse.e4.ui.bindings""); //$NON-NLS-1$
		Version currentVersion = bundle.getVersion();
START 		Version fixVersion = new Version(0, 12, 100); END 
		return currentVersion.compareTo(fixVersion) >= 0;
	}
","	private boolean isPlatformKeybindingBug517068Fixed() {
		Bundle bundle = Platform.getBundle(""org.eclipse.e4.ui.bindings""); //$NON-NLS-1$
		Version currentVersion = bundle.getVersion();
		Version fixVersion = new Version(0, 12, 1);
		return currentVersion.compareTo(fixVersion) >= 0;
	}
"
188,"Why not just:

return StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) && StringUtils.equals( p1.getPrefix(), p2.getPrefix() );","    public static boolean isPluginPrefixAndArtifactIdEquals( Plugin p1, Plugin p2 )
    {
        if ( StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() )
            && StringUtils.equals( p1.getPrefix(), p2.getPrefix() ) )
        {
            return true;
        }

        return false;
    }
","    public static boolean isPluginPrefixAndArtifactIdEquals( Plugin p1, Plugin p2 )
    {
START         if ( StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() ) END 
            && StringUtils.equals( p1.getPrefix(), p2.getPrefix() ) )
        {
            return true;
        }

        return false;
    }
","    public static boolean isPluginPrefixAndArtifactIdEquals( Plugin p1, Plugin p2 )
    {
        return StringUtils.equals( p1.getArtifactId(), p2.getArtifactId() )
            && StringUtils.equals( p1.getPrefix(), p2.getPrefix() );
    }
"
189,I think tuple size used to be 3. I'll fix it.,"    public <VT> MessageOut<T> withParameter(ParameterType type, VT value)
    {
        List<Object> newParameters = new ArrayList<>(parameters.size() + 3);
        newParameters.addAll(parameters);
        newParameters.add(type);
        newParameters.add(value);
        return new MessageOut<T>(verb, payload, serializer, newParameters);
    }
","    public <VT> MessageOut<T> withParameter(ParameterType type, VT value)
    {
START         List<Object> newParameters = new ArrayList<>(parameters.size() + 3); END 
        newParameters.addAll(parameters);
        newParameters.add(type);
        newParameters.add(value);
        return new MessageOut<T>(verb, payload, serializer, newParameters);
    }
","    public <VT> MessageOut<T> withParameter(ParameterType type, VT value)
    {
        List<Object> newParameters = new ArrayList<>(parameters.size() + 2);
        newParameters.addAll(parameters);
        newParameters.add(type);
        newParameters.add(value);
        return new MessageOut<T>(verb, payload, serializer, newParameters);
    }
"
190,should this be < 0? do we want to import a 0 nanosecond range?,"    private boolean validateTimeRange() {
        boolean isEmpty = fStartTimeRangeText.getText().isEmpty() || fEndTimeRangeText.getText().isEmpty();
        return !isEmpty && parseTimeRange() && fStartTimestamp.compareTo(fEndTimestamp) <= 0;
    }
","    private boolean validateTimeRange() {
        boolean isEmpty = fStartTimeRangeText.getText().isEmpty() || fEndTimeRangeText.getText().isEmpty();
        return !isEmpty && parseTimeRange() && fStartTimestamp.compareTo(fEndTimestamp) <= 0;
START     } END 
","    private boolean validateTimeRange() {
        boolean isEmpty = fStartTimeRangeText.getText().isEmpty() || fEndTimeRangeText.getText().isEmpty();
        return !isEmpty && parseTimeRange() && fStartTimestamp.compareTo(fEndTimestamp) < 0;
    }
"
191,Move filenamePath declaration to this line and make it final,"	public static String getFileNamePath(final String filename, final FieldbookProperties fieldbookProperties) {

		String filenamePath = """";
		StringBuilder filenameBuilder = new StringBuilder();
		filenameBuilder.append(fieldbookProperties.getUploadDirectory());
		filenameBuilder.append(File.separator);
		filenameBuilder.append(SettingsUtil.cleanSheetAndFileName(filename));

		filenamePath = filenameBuilder.toString();
		return filenamePath;
	}
","	public static String getFileNamePath(final String filename, final FieldbookProperties fieldbookProperties) {

		String filenamePath = """";
		StringBuilder filenameBuilder = new StringBuilder();
		filenameBuilder.append(fieldbookProperties.getUploadDirectory());
		filenameBuilder.append(File.separator);
		filenameBuilder.append(SettingsUtil.cleanSheetAndFileName(filename));

START 		filenamePath = filenameBuilder.toString(); END 
		return filenamePath;
	}
","	public static String getFileNamePath(final String filename, final FieldbookProperties fieldbookProperties) {

		final StringBuilder filenameBuilder = new StringBuilder();
		filenameBuilder.append(fieldbookProperties.getUploadDirectory());
		filenameBuilder.append(File.separator);
		filenameBuilder.append(SettingsUtil.cleanSheetAndFileName(filename));

		final String filenamePath = filenameBuilder.toString();
		return filenamePath;
	}
"
192,this line can be removed,"    protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map,
            final StorageDomainStatus status) {
        executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() {
            @SuppressWarnings(""synthetic-access"")
            @Override
            public StoragePoolIsoMap runInTransaction() {
                CompensationContext context = getCompensationContext();
                context.snapshotEntityStatus(map, map.getstatus());
                map.setstatus(status);
                getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getstatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
","    protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map,
            final StorageDomainStatus status) {
        executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() {
            @SuppressWarnings(""synthetic-access"")
            @Override
            public StoragePoolIsoMap runInTransaction() {
START                 CompensationContext context = getCompensationContext(); END 
                context.snapshotEntityStatus(map, map.getstatus());
                map.setstatus(status);
                getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getstatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
","    protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map,
            final StorageDomainStatus status) {
        executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() {
            @Override
            public StoragePoolIsoMap runInTransaction() {
                CompensationContext context = getCompensationContext();
                context.snapshotEntityStatus(map, map.getstatus());
                updateStatus(map, status);
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
"
193,remove `final` modifier.,"  public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
    if (tree.expression().is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) tree.expression();
      final Symbol owner = identifier.symbol().owner();
      if (owner != null && owner.isMethodSymbol()) {
        // No need to investigate selection on local symbols
        return;
      }
    }
    if (tree.expression().symbolType().isSubtypeOf(""java.lang.Class"")) {
      // No need to investigate selection on a Class object
      return;
    }
    super.visitMemberSelectExpression(tree);
  }
","  public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
    if (tree.expression().is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) tree.expression();
START       final Symbol owner = identifier.symbol().owner(); END 
      if (owner != null && owner.isMethodSymbol()) {
        // No need to investigate selection on local symbols
        return;
      }
    }
    if (tree.expression().symbolType().isSubtypeOf(""java.lang.Class"")) {
      // No need to investigate selection on a Class object
      return;
    }
    super.visitMemberSelectExpression(tree);
  }
","  public void visitMemberSelectExpression(MemberSelectExpressionTree tree) {
    if (tree.expression().is(Tree.Kind.IDENTIFIER)) {
      IdentifierTree identifier = (IdentifierTree) tree.expression();
      Symbol owner = identifier.symbol().owner();
      if (owner != null && owner.isMethodSymbol()) {
        // No need to investigate selection on local symbols
        return;
      }
    }
    if (tree.expression().symbolType().isSubtypeOf(""java.lang.Class"")) {
      // No need to investigate selection on a Class object
      return;
    }
    super.visitMemberSelectExpression(tree);
  }
"
194,"Hi, @mmedenjak  is right we need a fallback mechanism when server is not available. Having a fallback mechanism have greater scope. Lets make the `computeIfPresentLocally` only implementation for now for the client. The optimisation for the client can be addressed later.","    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
        checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED);

        if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) {
            BiFunctionExecutingEntryProcessor<K, V> ep = new BiFunctionExecutingEntryProcessor<>(remappingFunction);
            return executeOnKeyInternal(key, ep);
        } else {
            return computeIfPresentLocally(key, remappingFunction);
        }
    }
","    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
        checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED);

START         if (SerializationUtil.isClassStaticAndSerializable(remappingFunction)) { END 
            BiFunctionExecutingEntryProcessor<K, V> ep = new BiFunctionExecutingEntryProcessor<>(remappingFunction);
            return executeOnKeyInternal(key, ep);
        } else {
            return computeIfPresentLocally(key, remappingFunction);
        }
    }
","    public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
        checkNotNull(key, NULL_KEY_IS_NOT_ALLOWED);
        checkNotNull(key, NULL_BIFUNCTION_IS_NOT_ALLOWED);

        return computeIfPresentLocally(key, remappingFunction);
    }
"
195,we don't need this check right. For loop won't enter if tasks are empty. We should avoid having multiple returns.,"    public void sendUnanchored(Task task, String stream, List<Object> values, ExecutorTransfer transfer) {
        Tuple tuple = task.getTuple(stream, values);
        List<Integer> tasks = task.getOutgoingTasks(stream, values);
        if (tasks.size() == 0) {
            return;
        }
        for (Integer t : tasks) {
            transfer.transfer(t, tuple);
        }
    }
","    public void sendUnanchored(Task task, String stream, List<Object> values, ExecutorTransfer transfer) {
        Tuple tuple = task.getTuple(stream, values);
        List<Integer> tasks = task.getOutgoingTasks(stream, values);
START         if (tasks.size() == 0) { END 
            return;
        }
        for (Integer t : tasks) {
            transfer.transfer(t, tuple);
        }
    }
","    public void sendUnanchored(Task task, String stream, List<Object> values, ExecutorTransfer transfer) {
        Tuple tuple = task.getTuple(stream, values);
        List<Integer> tasks = task.getOutgoingTasks(stream, values);
        for (Integer t : tasks) {
            transfer.transfer(t, tuple);
        }
    }
"
196,"Unless I'm mistaken, you don't need to reload the whole server, just restart the services of the parent resource.
You can leverage RestartParentResourceRegistration for this.","    AffinityResourceDefinition(PathElement path) {
        super(path, UndertowExtension.getResolver(Constants.HANDLER, Constants.AFFINITY, path.getValue()), new ReloadRequiredAddStepHandler(), new ReloadRequiredRemoveStepHandler());
    }
","    AffinityResourceDefinition(PathElement path) {
START         super(path, UndertowExtension.getResolver(Constants.HANDLER, Constants.AFFINITY, path.getValue()), new ReloadRequiredAddStepHandler(), new ReloadRequiredRemoveStepHandler()); END 
    }
","    AffinityResourceDefinition(PathElement path) {
        super(path, UndertowExtension.getResolver(Constants.HANDLER, Constants.AFFINITY, path.getValue()));
    }
"
197,throws,"  @Override public E poll() {
    lock.lock();
    try {
      if (queue.isEmpty()) {
        return null;
      }
      E peek = queue.peek();
      queue.remove();
      return peek;
    } catch (IOException e) {
      QueueFile.<Error>getSneakyThrowable(e);
      return null;
    } finally {
      lock.unlock();
    }
  }
","  @Override public E poll() {
    lock.lock();
    try {
      if (queue.isEmpty()) {
        return null;
      }
      E peek = queue.peek();
      queue.remove();
      return peek;
    } catch (IOException e) {
      QueueFile.<Error>getSneakyThrowable(e);
START       return null; END 
    } finally {
      lock.unlock();
    }
  }
","  @Override public E poll() {
    lock.lock();
    try {
      if (queue.isEmpty()) {
        return null;
      }
      E peek = queue.peek();
      queue.remove();
      return peek;
    } catch (IOException e) {
      throw QueueFile.<Error>getSneakyThrowable(e);
    } finally {
      lock.unlock();
    }
  }
"
198,log.tracef,"    public void testTimeout() throws SystemException, RemoteException {
        log.info(""Method stateful #testTimeout called"");
        Transaction txn;
        txn = tm.getTransaction();

        TxTestUtil.enlistTestXAResource(txn);
        TxTestUtil.enlistTestXAResource(txn);

        try {
            TxTestUtil.waitForTimeout(tm);
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw new RemoteException(""Interupted during waiting for transaction timeout"", ie);
        }
    }
","    public void testTimeout() throws SystemException, RemoteException {
START         log.info(""Method stateful #testTimeout called""); END 
        Transaction txn;
        txn = tm.getTransaction();

        TxTestUtil.enlistTestXAResource(txn);
        TxTestUtil.enlistTestXAResource(txn);

        try {
            TxTestUtil.waitForTimeout(tm);
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw new RemoteException(""Interupted during waiting for transaction timeout"", ie);
        }
    }
","    public void testTimeout() throws SystemException, RemoteException {
        log.trace(""Method stateful #testTimeout called"");
        Transaction txn;
        txn = tm.getTransaction();

        TxTestUtil.enlistTestXAResource(txn);
        TxTestUtil.enlistTestXAResource(txn);

        try {
            TxTestUtil.waitForTimeout(tm);
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            throw new RemoteException(""Interupted during waiting for transaction timeout"", ie);
        }
    }
"
199,doesn't need to be public,"		public UnstagedComparator(boolean sortAlphabetically) {
			this.alphabeticallySort = sortAlphabetically;
		}
","START 		public UnstagedComparator(boolean sortAlphabetically) { END 
			this.alphabeticallySort = sortAlphabetically;
		}
","		private UnstagedComparator(boolean sortAlphabetically) {
			this.alphabeticallySort = sortAlphabetically;
		}
"
200,So why not just add it to the boolean expression in line #1377?,"    public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) {
        StorageType storageType = diskImage.getStorageTypes().get(0);
        String diskType = getDiskType(vm, diskImage, device);
        boolean isNativeIO = !""file"".equals(diskType) || (storageType == StorageType.GLUSTERFS
                && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion()));
        // marked as transient disk (file type) and uses cache when snapshotId is not null
        if (device.getSnapshotId() != null) {
            isNativeIO = false;
        }
        return isNativeIO;
    }
","    public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) {
        StorageType storageType = diskImage.getStorageTypes().get(0);
        String diskType = getDiskType(vm, diskImage, device);
        boolean isNativeIO = !""file"".equals(diskType) || (storageType == StorageType.GLUSTERFS
                && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion()));
        // marked as transient disk (file type) and uses cache when snapshotId is not null
        if START (device.getSnapshotId() != null) { END 
            isNativeIO = false;
        }
        return isNativeIO;
    }
","    public boolean shouldUseNativeIO(VM vm, DiskImage diskImage, VmDevice device) {
        StorageType storageType = diskImage.getStorageTypes().get(0);
        String diskType = getDiskType(vm, diskImage, device);
        return (!""file"".equals(diskType) || (storageType == StorageType.GLUSTERFS
                && FeatureSupported.useNativeIOForGluster(vm.getCompatibilityVersion())))
                && device.getSnapshotId() == null;
        // marked as transient disk (file type) and uses cache when snapshotId is not null
        // so native io should not be used
    }
"
201,"Lines 316-319 can be rewritten as 

return execute(request, !isAnonymous(), monitor);","	public <T> T execute(Request<T> request, IProgressMonitor monitor) throws IOException, GerritException {
		if (!isAnonymous()) {
			return execute(request, true, monitor);
		}
		return execute(request, false, monitor);
	}
","	public <T> T execute(Request<T> request, IProgressMonitor monitor) throws IOException, GerritException {
		if (!isAnonymous()) {
			return execute(request, true, monitor);
		}
START 		return execute(request, false, monitor); END 
	}
","	public <T> T execute(Request<T> request, IProgressMonitor monitor) throws IOException, GerritException {
		return execute(request, !isAnonymous(), monitor);
	}
"
202,"Maybe highlight should be called from setText instead?  That way, if the text is changed after construction it will get highlighted too.","  public HighlightingInlineHyperlink(final String text, final String token,
      final String toHighlight) {
    super(text, token);
    highlight(text, toHighlight);
  }
","  public HighlightingInlineHyperlink(final String text, final String token,
      final String toHighlight) {
    super(text, token);
START     highlight(text, toHighlight); END 
  }
","  public HighlightingInlineHyperlink(final String text, final String token,
      final String toHighlight) {
    super(text, token);
    this.toHighlight = toHighlight;
    highlight(text, toHighlight);
  }
"
203,"Not sure if this is guideline, I would prefer to use `protected` visibility rather than package protected one.","    String serializeInstallCmd(Collection<String> packages) {
        if (packages.isEmpty()) {
            return """";
        } else {
            return CommandInfo.CMD_INSTALL + "" "" + String.join("" "", packages);
        }
    }
","START     String serializeInstallCmd(Collection<String> packages) { END 
        if (packages.isEmpty()) {
            return """";
        } else {
            return CommandInfo.CMD_INSTALL + "" "" + String.join("" "", packages);
        }
    }
","    protected String serializeInstallCmd(Collection<String> packages) {
        if (packages.isEmpty()) {
            return """";
        } else {
            return CommandInfo.CMD_INSTALL + "" "" + String.join("" "", packages);
        }
    }
"
204,"I would prefer to have the IOException thrown by roundtrip.  Catching it will still cause the test to fail, but it will be harder to debug.","    private List roundtrip(List vals, Map conf) {
        List ret = null;
        try {
            ret = deserialize(serialize(vals, conf), conf);
        } catch (IOException e) {
            LOG.error(""Exception when serialize/deserialize "", e);
        }
        return ret;
    }
","    private List roundtrip(List vals, Map conf) {
        List ret = null;
        try {
            ret = deserialize(serialize(vals, conf), conf);
START         } catch (IOException e) { END 
            LOG.error(""Exception when serialize/deserialize "", e);
        }
        return ret;
    }
","    private List roundtrip(List vals, Map conf) throws IOException {
        return deserialize(serialize(vals, conf), conf);
    }
"
205,"Why RESTART_JVM?

AFAICT if I add this after boot the service is installed immediately.

You'd have to redeploy any app for it to use the module, but that doesn't even require a reload much less a process restart.","    public GlobalDirectoryResourceDefinition() {
        super(new SimpleResourceDefinition.Parameters(PathElement.pathElement(EESubsystemModel.GLOBAL_DIRECTORY), EeExtension.getResourceDescriptionResolver(EESubsystemModel.GLOBAL_DIRECTORY))
                .setAddRestartLevel(OperationEntry.Flag.RESTART_JVM)
                .setRemoveRestartLevel(OperationEntry.Flag.RESTART_JVM)
                .setAddHandler(GlobalDirectoryResourceDefinition.ADD)
                .setRemoveHandler(GlobalDirectoryResourceDefinition.REMOVE)
                .setCapabilities(EE_GLOBAL_DIRECTORY_CAPABILITY)
        );
    }
","    public GlobalDirectoryResourceDefinition() {
        super(new SimpleResourceDefinition.Parameters(PathElement.pathElement(EESubsystemModel.GLOBAL_DIRECTORY), EeExtension.getResourceDescriptionResolver(EESubsystemModel.GLOBAL_DIRECTORY))
START                 .setAddRestartLevel(OperationEntry.Flag.RESTART_JVM) END 
                .setRemoveRestartLevel(OperationEntry.Flag.RESTART_JVM)
                .setAddHandler(GlobalDirectoryResourceDefinition.ADD)
                .setRemoveHandler(GlobalDirectoryResourceDefinition.REMOVE)
                .setCapabilities(EE_GLOBAL_DIRECTORY_CAPABILITY)
        );
    }
","    public GlobalDirectoryResourceDefinition() {
        super(new SimpleResourceDefinition.Parameters(PathElement.pathElement(EESubsystemModel.GLOBAL_DIRECTORY), EeExtension.getResourceDescriptionResolver(EESubsystemModel.GLOBAL_DIRECTORY))
                .setAddHandler(GlobalDirectoryResourceDefinition.ADD)
                .setRemoveHandler(GlobalDirectoryResourceDefinition.REMOVE)
                .setCapabilities(EE_GLOBAL_DIRECTORY_CAPABILITY)
        );
    }
"
206,You can remove the this,"    public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) {
        super(parentShell);
        this.fChartViewer = chartViewer;
    }
","    public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) {
        super(parentShell);
        START  this.fChartViewer END  = chartViewer;
    }
","    public LockRangeDialog(Shell parentShell, TmfXYChartViewer chartViewer) {
        super(parentShell);
        fChartViewer = chartViewer;
    }
"
207,"I am confused when this is supposed to be """" or `this`?","  public String toStringShort() {
    return MoreObjects.toStringHelper("""")
        .add(""ClientType"", getStringFromOptional(mClientType))
        .add(""ClientHostname"", mLocalHostName)
        .add(""ServerAddress"", mServerAddress)
        .add(""ChannelId"", mChannelId)
        .omitNullValues()
        .toString();
  }
","  public String toStringShort() {
START     return MoreObjects.toStringHelper("""") END 
        .add(""ClientType"", getStringFromOptional(mClientType))
        .add(""ClientHostname"", mLocalHostName)
        .add(""ServerAddress"", mServerAddress)
        .add(""ChannelId"", mChannelId)
        .omitNullValues()
        .toString();
  }
","  public String toStringShort() {
    return MoreObjects.toStringHelper(this)
        .add(""ClientType"", getStringFromOptional(mClientType))
        .add(""ClientHostname"", mLocalHostName)
        .add(""ServerAddress"", mServerAddress)
        .add(""ChannelId"", mChannelId)
        .omitNullValues()
        .toString();
  }
"
208,"for the boolean parameter could be useful to use enums, so that it is more clear what it means","    public CompilationUnit() {
        this(null, false, null, new NodeList<>(), new NodeList<>(), null);
    }
","    public CompilationUnit() {
START         this(null, false, null, new NodeList<>(), new NodeList<>(), null); END 
    }
","    public CompilationUnit() {
        this(null, null, new NodeList<>(), new NodeList<>(), null);
    }
"
209,cast is not needed.,"        public void startBucket(String bucketKey) {
            BulkCommand command = getCurrentCommand();
            description = (String) command.getParam(PARAM_DESC);
        }
","        public void startBucket(String bucketKey) {
            BulkCommand command = getCurrentCommand();
START             description = (String) command.getParam(PARAM_DESC); END 
        }
","        public void startBucket(String bucketKey) {
            BulkCommand command = getCurrentCommand();
            description = command.getParam(PARAM_DESC);
        }
"
210,shouldn't provider be validated for existence prior to accessing it?,"    protected void executeQueryCommand() {
        Provider provider = getDbFacade().getProviderDao().get(getParameters().getId());
        NetworkProviderProxy client = getProviderProxyFactory().create(provider);
        getQueryReturnValue().setReturnValue(client.getAll());
    }
","    protected void executeQueryCommand() {
START         Provider provider = getDbFacade().getProviderDao().get(getParameters().getId()); END 
        NetworkProviderProxy client = getProviderProxyFactory().create(provider);
        getQueryReturnValue().setReturnValue(client.getAll());
    }
","    protected void executeQueryCommand() {
        Provider<?> provider = getDbFacade().getProviderDao().get(getParameters().getId());
        NetworkProviderProxy client = getProviderProxyFactory().create(provider);
        getQueryReturnValue().setReturnValue(client.getAll());
    }
"
211,"In some tests you're using `editor.clear()`, in some you don't. I guess it's better to use it in all tests. Assume that the tests are executed in a random order and should also start in a clean state. So using a [@Before method (setUp)](http://junit.sourceforge.net/javadoc/org/junit/Before.html) to clear the `SharedPreferences` seems like a good idea. Maybe create a static util method so others can benefit from it as well.","	public void testCrashlyticsUninitializedOnAnonymousReportDisabled() {
		Context context = InstrumentationRegistry.getTargetContext();
		SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit();
		editor.putBoolean(SettingsActivity.SETTINGS_CRASH_REPORTS, false);
		editor.clear();
		editor.commit();
		CrashReporter crashReporter = new CrashReporter(context);
		assertFalse(crashReporter.initialize());
	}
","	public void testCrashlyticsUninitializedOnAnonymousReportDisabled() {
		Context context = InstrumentationRegistry.getTargetContext();
		SharedPreferences.Editor editor = PreferenceManager.getDefaultSharedPreferences(context).edit();
		editor.putBoolean(SettingsActivity.SETTINGS_CRASH_REPORTS, false);
START 		editor.clear(); END 
		editor.commit();
		CrashReporter crashReporter = new CrashReporter(context);
		assertFalse(crashReporter.initialize());
	}
","	public void testCrashlyticsUninitializedOnAnonymousReportDisabled() {
		editor.putBoolean(SettingsActivity.SETTINGS_CRASH_REPORTS, false);
		editor.commit();

		assertFalse(CrashReporter.initialize(context));
	}
"
212,"it can be simplified to a single return statement

 protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { 
   return VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(),
getReturnValue().getCanDoActionMessages());
  }","    protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(),
                getReturnValue().getCanDoActionMessages())) {
            return false;
        } else {
            return true;
        }
    }
","START     protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) { END 
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(),
                getReturnValue().getCanDoActionMessages())) {
            return false;
        } else {
            return true;
        }
    }
","    protected boolean uniqueInterfaceName(List<VmNetworkInterface> interfaces) {
        return VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterfaceName(),
                getReturnValue().getCanDoActionMessages());
    }
"
213,typo --> ;;,"    private CompletableFuture<CorfuInterClusterReplicationServerNode> startDiscoveryService(ServerContext serverContext) throws InterruptedException {

        log.info(""Start Discovery Service."");
        CompletableFuture<CorfuInterClusterReplicationServerNode> discoveryServiceCallback = new CompletableFuture<>();

        this.clusterManagerAdapter = buildClusterManagerAdapter(serverContext.getPluginConfigFilePath());

        // Start LogReplicationDiscovery Service, responsible for
        // acquiring lock, retrieving Site Manager Info and processing this info
        // so this node is initialized as Source (sender) or Sink (receiver)
        replicationDiscoveryService = new CorfuReplicationDiscoveryService(serverContext,
                clusterManagerAdapter, discoveryServiceCallback);;

        return discoveryServiceCallback;
    }
","    private CompletableFuture<CorfuInterClusterReplicationServerNode> startDiscoveryService(ServerContext serverContext) throws InterruptedException {

        log.info(""Start Discovery Service."");
        CompletableFuture<CorfuInterClusterReplicationServerNode> discoveryServiceCallback = new CompletableFuture<>();

        this.clusterManagerAdapter = buildClusterManagerAdapter(serverContext.getPluginConfigFilePath());

        // Start LogReplicationDiscovery Service, responsible for
        // acquiring lock, retrieving Site Manager Info and processing this info
        // so this node is initialized as Source (sender) or Sink (receiver)
        replicationDiscoveryService = new CorfuReplicationDiscoveryService(serverContext,
START                 clusterManagerAdapter, discoveryServiceCallback);; END 

        return discoveryServiceCallback;
    }
","    private CompletableFuture<CorfuInterClusterReplicationServerNode> startDiscoveryService(ServerContext serverContext) {

        log.info(""Start Discovery Service."");
        CompletableFuture<CorfuInterClusterReplicationServerNode> discoveryServiceCallback = new CompletableFuture<>();

        this.clusterManagerAdapter = buildClusterManagerAdapter(serverContext.getPluginConfigFilePath());

        // Start LogReplicationDiscovery Service, responsible for
        // acquiring lock, retrieving Site Manager Info and processing this info
        // so this node is initialized as Source (sender) or Sink (receiver)
        replicationDiscoveryService = new CorfuReplicationDiscoveryService(serverContext,
                clusterManagerAdapter, discoveryServiceCallback);

        replicationDiscoveryService.start();
        return discoveryServiceCallback;
    }
"
214,"I would change the order to:
assertTrue(prevChunk < smallChunk2);
assertTrue(smallChunk2 < smallChunk1);
assertTrue(smallChunk1 < nextChunk);","	public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock() throws Exception {
		long prevChunk = mallocChunks(4);
		long middleChunk = mallocChunks(4);
		long nextChunk = mallocChunks(2);

		free(middleChunk);
		// This should be taken from the end of ""middleChunk"", since that's closer to the smaller neighbor
		long smallChunk1 = mallocChunks(1);
		// This should also be taken from the end of the remaining portion of ""middleChunk"" 
		long smallChunk2 = mallocChunks(1);

		assertTrue(""The small chunks should have been allocated from the end of the free block"",
				smallChunk1 > smallChunk2);
		assertTrue(""The small chunks should have been allocated from space before 'nextChunk'"",
				smallChunk1 < nextChunk);
		assertTrue(""The small chunks should have been allocated from space after 'prevChunk'"",
				smallChunk2 > prevChunk);
	}
","	public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock() throws Exception {
		long prevChunk = mallocChunks(4);
		long middleChunk = mallocChunks(4);
		long nextChunk = mallocChunks(2);

		free(middleChunk);
		// This should be taken from the end of ""middleChunk"", since that's closer to the smaller neighbor
		long smallChunk1 = mallocChunks(1);
		// This should also be taken from the end of the remaining portion of ""middleChunk"" 
		long smallChunk2 = mallocChunks(1);

START 		assertTrue(""The small chunks should have been allocated from the end of the free block"",
				smallChunk1 > smallChunk2);
		assertTrue(""The small chunks should have been allocated from space before 'nextChunk'"",
				smallChunk1 < nextChunk);
		assertTrue(""The small chunks should have been allocated from space after 'prevChunk'"",
				smallChunk2 > prevChunk); END 
	}
","	public void testEndOfFreeBlockIsUsedIfThePreviousBlockIsLargerThanTheNextBlock() throws Exception {
		long prevChunk = mallocChunks(4);
		long middleChunk = mallocChunks(4);
		long nextChunk = mallocChunks(2);

		free(middleChunk);
		// This should be taken from the end of ""middleChunk"", since that's closer to the smaller neighbor
		long smallChunk1 = mallocChunks(1);
		// This should also be taken from the end of the remaining portion of ""middleChunk""
		long smallChunk2 = mallocChunks(1);

		assertTrue(""The small chunks should have been allocated from space after 'prevChunk'"",
				prevChunk < smallChunk2);
		assertTrue(""The small chunks should have been allocated from the end of the free block"",
				smallChunk2 < smallChunk1);
		assertTrue(""The small chunks should have been allocated from space before 'nextChunk'"",
				smallChunk1 < nextChunk);
	}
"
215,Why did you add this `System.out.println()` call? Maybe a logger is a better solution.,"    public void shouldSetTempImagesPathAsCompleteDirectory() {
        URI path = URI.create(""/pages/newImagesTemp/"");
        ConfigCore.setImagesPath(URI.create(""/pages/newImagesTemp/""));
        System.out.println(ConfigCore.getTempImagesPathAsCompleteDirectory());

        assertEquals(""Temp images path was set incorrectly!"", path, URI.create(""/pages/newImagesTemp/""));
    }
","    public void shouldSetTempImagesPathAsCompleteDirectory() {
        URI path = URI.create(""/pages/newImagesTemp/"");
        ConfigCore.setImagesPath(URI.create(""/pages/newImagesTemp/""));
START         System.out.println(ConfigCore.getTempImagesPathAsCompleteDirectory()); END 

        assertEquals(""Temp images path was set incorrectly!"", path, URI.create(""/pages/newImagesTemp/""));
    }
","    public void shouldSetTempImagesPathAsCompleteDirectory() {
        URI path = URI.create(""/pages/newImagesTemp/"");
        ConfigCore.setImagesPath(URI.create(""/pages/newImagesTemp/""));

        assertEquals(""Temp images path was set incorrectly!"", path, URI.create(""/pages/newImagesTemp/""));
    }
"
216,Please move this check before assigning the variables.,"  public MetadataHashAggPOP(@JsonProperty(""child"") PhysicalOperator child,
      @JsonProperty(""context"") MetadataAggregateContext context,
      @JsonProperty(""phase"") OperatorPhase phase) {
    super(child, phase, context.groupByExpressions(), Collections.emptyList(), 1.0F);
    this.context = context;
    this.phase = phase;
    Preconditions.checkArgument(context.createNewAggregations(),
        ""Hash aggregate for metadata collecting should be used only for creating new aggregations."");
  }
","  public MetadataHashAggPOP(@JsonProperty(""child"") PhysicalOperator child,
      @JsonProperty(""context"") MetadataAggregateContext context,
      @JsonProperty(""phase"") OperatorPhase phase) {
    super(child, phase, context.groupByExpressions(), Collections.emptyList(), 1.0F);
START     this.context = context; END 
    this.phase = phase;
    Preconditions.checkArgument(context.createNewAggregations(),
        ""Hash aggregate for metadata collecting should be used only for creating new aggregations."");
  }
","  public MetadataHashAggPOP(@JsonProperty(""child"") PhysicalOperator child,
      @JsonProperty(""context"") MetadataAggregateContext context,
      @JsonProperty(""phase"") OperatorPhase phase) {
    super(child, phase, context.groupByExpressions(), Collections.emptyList(), 1.0F);
    Preconditions.checkArgument(context.createNewAggregations(),
        ""Hash aggregate for metadata collecting should be used only for creating new aggregations."");
    this.context = context;
    this.phase = phase;
  }
"
217,Please first log the error and then inform the user.,"    private void saveProcess(Process process) {
        try {
            serviceManager.getProcessService().save(process);
        } catch (DataException e) {
            Helper.setFehlerMeldung(KITODO_SCRIPT_FIELD, ""Error while saving process: "" + process.getTitle(), e);
            logger.error(KITODO_SCRIPT_FIELD + ""Error while saving process: "" + process.getTitle(), e);
        }
    }
","    private void saveProcess(Process process) {
        try {
            serviceManager.getProcessService().save(process);
        } catch (DataException e) {
START             Helper.setFehlerMeldung(KITODO_SCRIPT_FIELD, ""Error while saving process: "" + process.getTitle(), e); END 
            logger.error(KITODO_SCRIPT_FIELD + ""Error while saving process: "" + process.getTitle(), e);
        }
    }
","    private void saveProcess(Process process) {
        try {
            serviceManager.getProcessService().save(process);
        } catch (DataException e) {
            logger.error(KITODO_SCRIPT_FIELD + ""Error while saving process: "" + process.getTitle(), e);
            Helper.setFehlerMeldung(KITODO_SCRIPT_FIELD, ""Error while saving process: "" + process.getTitle(), e);
        }
    }
"
218,private static,"    private String toHexString(QuantileDigest qdigest)
    {
        return new SqlVarbinary(qdigest.serialize().getBytes()).toString().replaceAll(""\\s+"", "" "");
    }
","START     private String toHexString(QuantileDigest qdigest) END 
    {
        return new SqlVarbinary(qdigest.serialize().getBytes()).toString().replaceAll(""\\s+"", "" "");
    }
","    private static String toHexString(QuantileDigest qdigest)
    {
        return new SqlVarbinary(qdigest.serialize().getBytes()).toString().replaceAll(""\\s+"", "" "");
    }
"
219,this should be private method,"	public String getHeader(){
		return selectedPageHeader.getText();
	}
","START 	public String getHeader(){ END 
		return selectedPageHeader.getText();
	}
","	private String getHeader(){
		return selectedPageHeader.getText();
	}
"
220,"Does it have any sense to check for duplicated email here? IMO I am not seeing much sense to have hardcoded username or email same for all users? So I would just delete this line and also completely delete the methods ""checkDuplicateEmail"" and ""checkDuplicateUsername"" . And you can instead implement method on the HardcodedAttributeMapperFactory ""validateConfiguration"" and throw an error in case that ""username"" or ""email"" was configured as user model attribute.","    public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) {
        String userModelAttrName = getUserModelAttribute();

        String attributeValue = getAttributeValue();
        Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase());

        if (userModelProperty != null) {
            checkDuplicateEmail(userModelAttrName, attributeValue, realm, ldapProvider.getSession(), user);
            setPropertyOnUserModel(userModelProperty, user, attributeValue);
        } else {
            user.setAttribute(userModelAttrName, Arrays.asList(attributeValue));
        }
    }
","    public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) {
        String userModelAttrName = getUserModelAttribute();

        String attributeValue = getAttributeValue();
        Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase());

        if (userModelProperty != null) {
START             checkDuplicateEmail(userModelAttrName, attributeValue, realm, ldapProvider.getSession(), user); END 
            setPropertyOnUserModel(userModelProperty, user, attributeValue);
        } else {
            user.setAttribute(userModelAttrName, Arrays.asList(attributeValue));
        }
    }
","    public void onImportUserFromLDAP(LDAPObject ldapUser, UserModel user, RealmModel realm, boolean isCreate) {
        String userModelAttrName = getUserModelAttribute();

        String attributeValue = getAttributeValue();
        Property<Object> userModelProperty = userModelProperties.get(userModelAttrName.toLowerCase());

        if (userModelProperty != null) {
            setPropertyOnUserModel(userModelProperty, user, attributeValue);
        } else {
            user.setAttribute(userModelAttrName, Arrays.asList(attributeValue));
        }
    }
"
221,boolean instead of Boolean,"    public Boolean delete( ProjectName projectName )
    {
        return callWithContext( () -> {
            final Boolean result = doDelete( projectName );
            LOG.info( ""Project deleted: "" + projectName );

            return result;
        } );
    }
","START     public Boolean delete( ProjectName projectName ) END 
    {
        return callWithContext( () -> {
            final Boolean result = doDelete( projectName );
            LOG.info( ""Project deleted: "" + projectName );

            return result;
        } );
    }
","    public boolean delete( ProjectName projectName )
    {
        return callWithContext( () -> {
            final boolean result = doDelete( projectName );
            LOG.info( ""Project deleted: "" + projectName );

            return result;
        } );
    }
"
222,this isn't needed anymore right?,"    public static void startServerInstance(File dataDir,
            ServerCnxnFactory factory, String hostPort) throws IOException,
            InterruptedException, KeeperException.NoNodeException {
        final int port = getPort(hostPort);
        LOG.info(""STARTING server instance 127.0.0.1:{}"", port);
        ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000);
        factory.startup(zks);
        Assert.assertTrue(""waiting for server up"", ClientBase.waitForServerUp(
                ""127.0.0.1:"" + port, CONNECTION_TIMEOUT, factory.isSecure()));
    }
","    public static void startServerInstance(File dataDir,
            ServerCnxnFactory factory, String hostPort) throws IOException,
START             InterruptedException, KeeperException.NoNodeException { END 
        final int port = getPort(hostPort);
        LOG.info(""STARTING server instance 127.0.0.1:{}"", port);
        ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000);
        factory.startup(zks);
        Assert.assertTrue(""waiting for server up"", ClientBase.waitForServerUp(
                ""127.0.0.1:"" + port, CONNECTION_TIMEOUT, factory.isSecure()));
    }
","    public static void startServerInstance(File dataDir,
            ServerCnxnFactory factory, String hostPort) throws IOException,
            InterruptedException {
        final int port = getPort(hostPort);
        LOG.info(""STARTING server instance 127.0.0.1:{}"", port);
        ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000);
        factory.startup(zks);
        Assert.assertTrue(""waiting for server up"", ClientBase.waitForServerUp(
                ""127.0.0.1:"" + port, CONNECTION_TIMEOUT, factory.isSecure()));
    }
"
223,"If you want, you can change to use hamcrest here too. The method `Matchers.is` compare if two objects are equals.","	public void shouldShowAllMusicsAsHTTP() {
		MockHttpResult mockHttpResult = new MockHttpResult();
		controller = new MusicController(dao, userInfo, mockHttpResult, validator, musics);
		when(dao.listAll()).thenReturn(Arrays.asList(music));
		controller.showAllMusicsAsHTTP();
		assertEquals(""<p class=\""content\"">""+ Arrays.asList(music).toString()+""</p>"", mockHttpResult.getBody());
	}
","	public void shouldShowAllMusicsAsHTTP() {
		MockHttpResult mockHttpResult = new MockHttpResult();
		controller = new MusicController(dao, userInfo, mockHttpResult, validator, musics);
		when(dao.listAll()).thenReturn(Arrays.asList(music));
		controller.showAllMusicsAsHTTP();
		assertEquals(""<p class=\""content\"">""+ Arrays.asList(music).toString()+""</p>"", mockHttpResult.getBody());
START 	} END 
","	public void shouldShowAllMusicsAsHTTP() {
		MockHttpResult mockHttpResult = new MockHttpResult();
		controller = new MusicController(dao, userInfo, mockHttpResult, validator, musics);
		when(dao.listAll()).thenReturn(Arrays.asList(music));
		controller.showAllMusicsAsHTTP();
		assertThat(mockHttpResult.getBody(), is(""<p class=\""content\"">""+ Arrays.asList(music).toString()+""</p>""));
	}
"
224,wouldn't you want the conditions check prior to assignments?,"   public AttributeValueSearch(IAttributeType attributeType, String attributeValue) {
      this.attributeType = attributeType;
      this.attributeValue = attributeValue;
      Conditions.checkNotNull(attributeType, ""attributeType"");
      Conditions.checkNotNullOrEmpty(attributeValue, ""attributeValue"");
   }
","   public AttributeValueSearch(IAttributeType attributeType, String attributeValue) {
      this.attributeType = attributeType;
      this.attributeValue = attributeValue;
    START    Conditions.checkNotNull(attributeType, ""attributeType"");
      Conditions.checkNotNullOrEmpty(attributeValue, ""attributeValue""); END 
   }
","   public AttributeValueSearch(IAttributeType attributeType, String attributeValue) {
      Conditions.checkNotNull(attributeType, ""attributeType"");
      Conditions.checkNotNullOrEmpty(attributeValue, ""attributeValue"");
      this.attributeType = attributeType;
      this.attributeValue = attributeValue;
   }
"
225,"What made you to wrap, when you still use a simple long afterwards?","	public ListenerContainerIdleEvent(Object source, long idleTime, @Nullable String id, String... queueNames) {
		super(source);
		this.idleTime = Duration.ofMillis(idleTime);
		this.listenerId = id;
		this.queueNames = Arrays.asList(queueNames);
	}
","	public ListenerContainerIdleEvent(Object source, long idleTime, @Nullable String id, String... queueNames) {
		super(source);
START 		this.idleTime = Duration.ofMillis(idleTime); END 
		this.listenerId = id;
		this.queueNames = Arrays.asList(queueNames);
	}
","	public ListenerContainerIdleEvent(Object source, long idleTime, @Nullable String id, String... queueNames) {
		super(source);
		this.idleTime = idleTime;
		this.listenerId = id;
		this.queueNames = Arrays.asList(queueNames);
	}
"
226,you should break out of the loop early after finding the target module," 	public static XARecoveryModule getRegisteredXARecoveryModule () {
 		if (registeredXARecoveryModule == null) {
			RecoveryManager recMan = RecoveryManager.manager();
			Vector recoveryModules = recMan.getModules();

			if (recoveryModules != null) {
				Enumeration modules = recoveryModules.elements();

				while (modules.hasMoreElements()) {
					RecoveryModule m = (RecoveryModule) modules.nextElement();

					if (m instanceof XARecoveryModule) {
						registeredXARecoveryModule = (XARecoveryModule) m;
					}
				}
			}
		}
		return registeredXARecoveryModule;
	}
"," 	public static XARecoveryModule getRegisteredXARecoveryModule () {
 		if (registeredXARecoveryModule == null) {
			RecoveryManager recMan = RecoveryManager.manager();
			Vector recoveryModules = recMan.getModules();

			if (recoveryModules != null) {
				Enumeration modules = recoveryModules.elements();

				while (modules.hasMoreElements()) {
					RecoveryModule m = (RecoveryModule) modules.nextElement();

					if (m instanceof XARecoveryModule) {
START 						registeredXARecoveryModule = (XARecoveryModule) m; END 
					}
				}
			}
		}
		return registeredXARecoveryModule;
	}
"," 	public static XARecoveryModule getRegisteredXARecoveryModule () {
 		if (registeredXARecoveryModule == null) {
			RecoveryManager recMan = RecoveryManager.manager();
			Vector recoveryModules = recMan.getModules();

			if (recoveryModules != null) {
				Enumeration modules = recoveryModules.elements();

				while (modules.hasMoreElements()) {
					RecoveryModule m = (RecoveryModule) modules.nextElement();

					if (m instanceof XARecoveryModule) {
						registeredXARecoveryModule = (XARecoveryModule) m;
						break;
					}
				}
			}
		}
		return registeredXARecoveryModule;
	}
"
227,possible NPE,"    public String getUrl() {
        return PluginImpl.getInstance().getServer(serverName).getConfig().getGerritFrontEndUrlFor(tEvent);
    }
","    public String getUrl() {
START         return PluginImpl.getInstance().getServer(serverName).getConfig().getGerritFrontEndUrlFor(tEvent); END 
    }
","    public String getUrl() {
        return url;
    }
"
228,"Please move abortProcessInstance into the final statement, it should be done in any case.
Also please delete e.printStackTrace();  - it doesn't bring any value.
Also please delete fail(e.getMessage()); - unexpected exceptions should be thrown out of test method, JUnit will handle it as a failing test, printing exception with stacktrace to the log.","    public void testBoundarySignalProcessInstance() throws Exception {
        Long processInstanceId = processClient.startProcess(CONTAINER_ID, PROCESS_ID_BOUNDARY_SIGNAL_PROCESS);
        assertNotNull(processInstanceId);
        assertTrue(processInstanceId.longValue() > 0);

        try {
            checkAvailableBoundarySignals(CONTAINER_ID, processInstanceId);
        } catch (Exception e){
            processClient.abortProcessInstance(CONTAINER_ID, processInstanceId);
            e.printStackTrace();
            fail(e.getMessage());
        }
    }
","    public void testBoundarySignalProcessInstance() throws Exception {
        Long processInstanceId = processClient.startProcess(CONTAINER_ID, PROCESS_ID_BOUNDARY_SIGNAL_PROCESS);
        assertNotNull(processInstanceId);
        assertTrue(processInstanceId.longValue() > 0);

        try {
START             checkAvailableBoundarySignals(CONTAINER_ID, processInstanceId); END 
        } catch (Exception e){
            processClient.abortProcessInstance(CONTAINER_ID, processInstanceId);
            e.printStackTrace();
            fail(e.getMessage());
        }
    }
","    public void testBoundarySignalProcessInstance() throws Exception {
        Long processInstanceId = processClient.startProcess(CONTAINER_ID, PROCESS_ID_BOUNDARY_SIGNAL_PROCESS);
        assertNotNull(processInstanceId);
        assertTrue(processInstanceId.longValue() > 0);

        try {
            checkAvailableBoundarySignals(CONTAINER_ID, processInstanceId);
        } finally {
            processClient.abortProcessInstance(CONTAINER_ID, processInstanceId);
        }
    }
"
229,why not calling isAppConfiguredInSourceServerXml(fileName) to make sure the app installed to the dropins location is not configured?,"    private void validateAppConfig(String fileName) throws Exception {
        String appsDir = getAppsDirectory();
        if (appsDir.equalsIgnoreCase(""apps"") && !isAppConfiguredInSourceServerXml(fileName)) {
            // add application configuration
            applicationXml.createWebApplicationElement(fileName);
        }
        else if (appsDir.equalsIgnoreCase(""dropins"") && isAnyAppConfiguredInSourceServerXml())
            throw new MojoExecutionException(messages.getString(""error.install.app.dropins.directory""));
    }
","    private void validateAppConfig(String fileName) throws Exception {
        String appsDir = getAppsDirectory();
        if (appsDir.equalsIgnoreCase(""apps"") && !isAppConfiguredInSourceServerXml(fileName)) {
            // add application configuration
            applicationXml.createWebApplicationElement(fileName);
        }
START         else if (appsDir.equalsIgnoreCase(""dropins"") && isAnyAppConfiguredInSourceServerXml()) END 
            throw new MojoExecutionException(messages.getString(""error.install.app.dropins.directory""));
    }
","    private void validateAppConfig(String fileName) throws Exception {
        String appsDir = getAppsDirectory();
        if (appsDir.equalsIgnoreCase(""apps"") && !isAppConfiguredInSourceServerXml(fileName)) {
            // add application configuration
            applicationXml.createWebApplicationElement(fileName);
        }
        else if (appsDir.equalsIgnoreCase(""dropins"") && isAppConfiguredInSourceServerXml(fileName))
            throw new MojoExecutionException(messages.getString(""error.install.app.dropins.directory""));
    }
"
230,Please add `private` modifier,"		static RequestContextDataHolder getRequestContext(Context ctx) {
			return ctx.getOrDefault(REQUEST_CONTEXT_DATA_HOLDER, null);
		}
","START 		static RequestContextDataHolder getRequestContext(Context ctx) { END 
			return ctx.getOrDefault(REQUEST_CONTEXT_DATA_HOLDER, null);
		}
","		private static RequestContextDataHolder getRequestContext(Context ctx) {
			return ctx.getOrDefault(REQUEST_CONTEXT_DATA_HOLDER, null);
		}
"
231,I'd inline this to conform with the rest of the class.,"    public long getNumberOfImagesInStorageDomain(Guid storageDomainId) {
        MapSqlParameterSource params = getCustomMapSqlParameterSource().addValue(""storage_domain_id"", storageDomainId);
        return getCallsHandler().executeRead(""GetNumberOfImagesInStorageDomain"", getLongMapper(), params);
    }
","    public long getNumberOfImagesInStorageDomain(Guid storageDomainId) {
START         MapSqlParameterSource params = getCustomMapSqlParameterSource().addValue(""storage_domain_id"", storageDomainId); END 
        return getCallsHandler().executeRead(""GetNumberOfImagesInStorageDomain"", getLongMapper(), params);
    }
","    public long getNumberOfImagesInStorageDomain(Guid storageDomainId) {
        return getCallsHandler().executeRead(""GetNumberOfImagesInStorageDomain"",
                getLongMapper(),
                getCustomMapSqlParameterSource().addValue(""storage_domain_id"", storageDomainId));
    }
"
232,Is it really necessary to wait 100 milliseconds? Why not `Thread.sleep(1)`. Why not `Thread.yield()`?,"    public TestObjectAsync() {
        try {
            Thread.sleep(100);
            Thread.sleep(100);
            counter = 1;
        }
        catch (InterruptedException ie) {
            throw new RuntimeException(ie);
        }
    }
","    public TestObjectAsync() {
        try {
START             Thread.sleep(100); END 
            Thread.sleep(100);
            counter = 1;
        }
        catch (InterruptedException ie) {
            throw new RuntimeException(ie);
        }
    }
","    public TestObjectAsync() {
        try {
            Thread.sleep(1);
            Thread.sleep(1);
            counter = 1;
        }
        catch (InterruptedException ie) {
            throw new RuntimeException(ie);
        }
    }
"
233,"Maybe 
`beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0` should be checked before calling getField ?
Method getField modifies field via reflection and optionally recursively calls itself, so it could be costly.","    private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) {
        Field field = getField(beanClass, beanProp.getName());
        return field != null
                ? field.getAnnotationsByType(Optional.class).length > 0
                        || beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0
                : beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0;
    }
","    private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) {
        Field field = getField(beanClass, beanProp.getName());
        return field != null
                ? field.getAnnotationsByType(Optional.class).length > 0
START                         || beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0 END 
                : beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0;
    }
","    private static boolean isOptionalProperty(Class beanClass, PropertyDescriptor beanProp) {
        if (beanProp.getReadMethod().getAnnotationsByType(Optional.class).length > 0) {
            return true;
        }
        Field field = getField(beanClass, beanProp.getName());
        return field != null && field.getAnnotationsByType(Optional.class).length > 0;
    }
"
234,Why is this method required? Didn't see it used anywhere in the code,"public int getImageselector () {
	return imageSelectorIndex;
}
","public int getImageselector () {
	return imageSelectorIndex;
START } END 
","int getImageselector () {
	return imageSelectorIndex;
}
"
235,I don't think we want to pass in an `Inflater` and than have `ZipInflaterInputStream` call `end()` on it.,"	public InputStream getInputStream(FileHeader entry) throws IOException {
		if (entry == null) {
			return null;
		}
		InputStream inputStream = getEntryData(entry).getInputStream();
		if (entry.getMethod() == ZipEntry.DEFLATED) {
			inputStream = new ZipInflaterInputStream(inputStream, new Inflater(true),
					(int) entry.getSize());
		}
		return inputStream;
	}
","	public InputStream getInputStream(FileHeader entry) throws IOException {
		if (entry == null) {
			return null;
		}
		InputStream inputStream = getEntryData(entry).getInputStream();
		if (entry.getMethod() == ZipEntry.DEFLATED) {
START 			inputStream = new ZipInflaterInputStream(inputStream, new Inflater(true), END 
					(int) entry.getSize());
		}
		return inputStream;
	}
","	public InputStream getInputStream(FileHeader entry) throws IOException {
		if (entry == null) {
			return null;
		}
		InputStream inputStream = getEntryData(entry).getInputStream();
		if (entry.getMethod() == ZipEntry.DEFLATED) {
			inputStream = new ZipInflaterInputStream(inputStream, (int) entry.getSize());
		}
		return inputStream;
	}
"
236,Can you explain the idea behind storing transformation here and not anywhere else (at the very beginning of repaint())? Is it worth to keep this information and to compare it within getDoubleBufferGraphics() rather using the up-to-date viewportModel  Transformation. is it because of a non-atomar opration betwenn getImage() and getDoubleBufferGraphics() calls?,"    private org.eclipse.swt.graphics.Image createImage() {
        org.eclipse.swt.graphics.Image newImage;
        RenderedImage image = renderManager.getImage();
        this.backBufferTrsf=renderManager.getMapInternal().getViewportModel().worldToScreenTransform();
        if (image != null)
            newImage = AWTSWTImageUtils.createSWTImage(image, false);
        else {
            newImage = new Image(getDisplay(), getWidth(), getHeight());
        }
        return newImage;
    }
","    private org.eclipse.swt.graphics.Image createImage() {
        org.eclipse.swt.graphics.Image newImage;
        RenderedImage image = renderManager.getImage();
START         this.backBufferTrsf=renderManager.getMapInternal().getViewportModel().worldToScreenTransform(); END 
        if (image != null)
            newImage = AWTSWTImageUtils.createSWTImage(image, false);
        else {
            newImage = new Image(getDisplay(), getWidth(), getHeight());
        }
        return newImage;
    }
","    private org.eclipse.swt.graphics.Image createImage() {
        org.eclipse.swt.graphics.Image newImage;
        RenderedImage image = renderManager.getImage();
        
        if (image != null)
            newImage = AWTSWTImageUtils.createSWTImage(image, false);
        else {
            newImage = new Image(getDisplay(), getWidth(), getHeight());
        }
        return newImage;
    }
"
237,this is nullable,"    public VirtualMachine getCurrentMachineBuild(ITmfEvent event) {
        VirtualMachine machine = innerGetCurrentMachine(event);
        if (machine == null) {
            synchronized (fStateSystem) {
                String hostId = event.getTrace().getHostId();
                machine = createMachine(fStateSystem, event.getTimestamp().toNanos(), hostId, event.getTrace().getName());
                fKnownMachines.put(hostId, machine);
            }

        }
        return machine;
    }
","    public VirtualMachine getCurrentMachineBuild(ITmfEvent event) {
        VirtualMachine machine = innerGetCurrentMachine(event);
        if (machine == null) {
            synchronized (fStateSystem) {
                String hostId = event.getTrace().getHostId();
START                 machine = createMachine(fStateSystem, event.getTimestamp().toNanos(), hostId, event.getTrace().getName()); END 
                fKnownMachines.put(hostId, machine);
            }

        }
        return machine;
    }
","    public VirtualMachine getCurrentMachineBuild(ITmfEvent event) {
        VirtualMachine machine = innerGetCurrentMachine(event);
        if (machine == null) {
            synchronized (fStateSystem) {
                String hostId = event.getTrace().getHostId();
                machine = createMachine(fStateSystem, event.getTimestamp().toNanos(), hostId, String.valueOf(event.getTrace().getName()));
                fKnownMachines.put(hostId, machine);
            }

        }
        return machine;
    }
"
238,Why do we need it here?,"    public static Predicate<Expression> isInferenceCandidate()
    {
        return expression -> {
            expression = normalizeInPredicateToEquality(expression);
            if (expression instanceof ComparisonExpression &&
                    isDeterministic(expression) &&
                    !mayReturnNullOnNonNullInput(expression) &&
                    !isDynamicFilter(expression)) {
                ComparisonExpression comparison = (ComparisonExpression) expression;
                if (comparison.getType() == ComparisonExpressionType.EQUAL) {
                    // We should only consider equalities that have distinct left and right components
                    return !comparison.getLeft().equals(comparison.getRight());
                }
            }
            return false;
        };
    }
","    public static Predicate<Expression> isInferenceCandidate()
    {
        return expression -> {
            expression = normalizeInPredicateToEquality(expression);
            if (expression instanceof ComparisonExpression &&
                    isDeterministic(expression) &&
                    !mayReturnNullOnNonNullInput(expression) &&
START                     !isDynamicFilter(expression)) { END 
                ComparisonExpression comparison = (ComparisonExpression) expression;
                if (comparison.getType() == ComparisonExpressionType.EQUAL) {
                    // We should only consider equalities that have distinct left and right components
                    return !comparison.getLeft().equals(comparison.getRight());
                }
            }
            return false;
        };
    }
","    public static Predicate<Expression> isInferenceCandidate()
    {
        return expression -> {
            expression = normalizeInPredicateToEquality(expression);
            if (expression instanceof ComparisonExpression &&
                    isDeterministic(expression) &&
                    !mayReturnNullOnNonNullInput(expression)) {
                ComparisonExpression comparison = (ComparisonExpression) expression;
                if (comparison.getType() == ComparisonExpressionType.EQUAL) {
                    // We should only consider equalities that have distinct left and right components
                    return !comparison.getLeft().equals(comparison.getRight());
                }
            }
            return false;
        };
    }
"
239,instanceof,"  private void updateGroup(final TupleBatch tb, final int row, final Object[] curAggStates)
      throws DbException {
    for (int agg = 0; agg < aggregators.length; ++agg) {
      if (!(aggregators[agg]
          .getClass()
          .getName()
          .equals(StatefulUserDefinedAggregator.class.getName()))) {
        aggregators[agg].addRow(tb, row, curAggStates[agg]);
      }
    }
  }
","  private void updateGroup(final TupleBatch tb, final int row, final Object[] curAggStates)
      throws DbException {
    for (int agg = 0; agg < aggregators.length; ++agg) {
      if (!(aggregators[agg]
          .getClass()
          .getName()
START           .equals(StatefulUserDefinedAggregator.class.getName()))) { END 
        aggregators[agg].addRow(tb, row, curAggStates[agg]);
      }
    }
  }
","  private void updateGroup(final TupleBatch tb, final int row, final Object[] curAggStates)
      throws DbException {

    for (int agg = 0; agg < aggregators.length; ++agg) {
      if (!(aggregators[agg] instanceof StatefulUserDefinedAggregator)) {
        aggregators[agg].addRow(tb, row, curAggStates[agg]);
      }
    }
  }
"
240,Please apply same changes as requested in first review here.,"	protected void update(float delta) {
		int lengthInterpretation;
		try {
			lengthInterpretation = length == null ? 0 : length.interpretInteger(sprite);
		} catch (InterpretationException interpretationException) {
			lengthInterpretation = 0;
			Log.d(getClass().getSimpleName(), ""Formula interpretation for this specific Brick failed."", interpretationException);
		}
		this.sprite.runningStitch.activateStitching(sprite, new SimpleRunningStitch(sprite, lengthInterpretation));
	}
","	protected void update(float delta) {
		int lengthInterpretation;
		try {
START 			lengthInterpretation = length == null ? 0 : length.interpretInteger(sprite); END 
		} catch (InterpretationException interpretationException) {
			lengthInterpretation = 0;
			Log.d(getClass().getSimpleName(), ""Formula interpretation for this specific Brick failed."", interpretationException);
		}
		this.sprite.runningStitch.activateStitching(sprite, new SimpleRunningStitch(sprite, lengthInterpretation));
	}
","	protected void update(float delta) {
		int lengthInterpretation = 0;
		try {
			if (length != null) {
				lengthInterpretation = length.interpretInteger(sprite);
			}
		} catch (InterpretationException interpretationException) {
			lengthInterpretation = 0;
			Log.d(getClass().getSimpleName(), ""Formula interpretation for this specific Brick failed."", interpretationException);
		}
		this.sprite.runningStitch.activateStitching(sprite, new SimpleRunningStitch(sprite, lengthInterpretation));
	}
"
241,remove line,"	protected void processSpanImpl(Span span, Map<String, String[]> servletRequestParameters) {
		long sum = 0;
		for (String weaselParameterToSum : weaselParametersToSum) {
			final Long timing = parsedLongOrNull(getParameterValueOrNull(weaselParameterToSum, servletRequestParameters));
			if (timing == null) {
				discardSpan(span);
				return;
			} else {
				sum += timing;
			}
		}
		span.setTag(TIMING_RESOURCE, sum);
	}
","	protected void processSpanImpl(Span span, Map<String, String[]> servletRequestParameters) {
		long sum = 0;
		for (String weaselParameterToSum : weaselParametersToSum) {
			final Long timing = parsedLongOrNull(getParameterValueOrNull(weaselParameterToSum, servletRequestParameters));
			if (timing == null) {
START 				discardSpan(span); END 
				return;
			} else {
				sum += timing;
			}
		}
		span.setTag(TIMING_RESOURCE, sum);
	}
","	protected void processSpanImpl(Span span, Map<String, String[]> servletRequestParameters) {
		long sum = 0;
		for (String weaselParameterToSum : weaselParametersToSum) {
			final Long timing = parsedLongOrNull(getParameterValueOrNull(weaselParameterToSum, servletRequestParameters));
			if (timing == null) {
				return;
			} else {
				sum += timing;
			}
		}
		span.setTag(TIMING_RESOURCE, sum);
	}
"
242,`.map(ThrowingFunction.unchecked(p -> p))` unnecessary,"    private void close(Path path)
            throws IOException
    {
        Path directoryWhereGeneratedArtifactsWasPlaced = path.getParent();
        try (Stream<Path> s = Files.list(directoryWhereGeneratedArtifactsWasPlaced))
        {
            s.filter(p -> !Files.isDirectory(p)).map(ThrowingFunction.unchecked(p -> p))
                                                .forEach(ThrowingConsumer.unchecked(Files::delete));
        }
    }
","    private void close(Path path)
            throws IOException
    {
        Path directoryWhereGeneratedArtifactsWasPlaced = path.getParent();
        try (Stream<Path> s = Files.list(directoryWhereGeneratedArtifactsWasPlaced))
        {
START             s.filter(p -> !Files.isDirectory(p)).map(ThrowingFunction.unchecked(p -> p)) END 
                                                .forEach(ThrowingConsumer.unchecked(Files::delete));
        }
    }
","    private void close(Path path)
            throws IOException
    {
        Path directoryWhereGeneratedArtifactsWasPlaced = path.getParent();
        try (Stream<Path> s = Files.list(directoryWhereGeneratedArtifactsWasPlaced))
        {
            s.filter(p -> !Files.isDirectory(p)).forEach(ThrowingConsumer.unchecked(Files::delete));
        }
    }
"
243,"As a general rule: If you're unsure whether or not to suppress a warning, don't!

You discovered the principal problem of mutable objects. The easy fix is to use [immutable objects](http://en.wikipedia.org/wiki/Immutable_object) whenever possible. `MessageReference` looks like it could be easily made immutable. So you should definitely do that instead of suppressing the warning.","    public void hashcodeVerifyEqualsContract() {
        EqualsVerifier.forClass(MessageReference.class).suppress(Warning.NONFINAL_FIELDS).verify();
    }
","    public void hashcodeVerifyEqualsContract() {
START         EqualsVerifier.forClass(MessageReference.class).suppress(Warning.NONFINAL_FIELDS).verify(); END 
    }
","    public void hashcodeVerifyEqualsContract() {
        EqualsVerifier.forClass(MessageReference.class).verify();
    }
"
244,nit: you can merge both lines above as `checkNotNull` will return the given argument,"    public HttpRequest setUri(String uri) {
        ObjectUtil.checkNotNull(uri, ""uri"");
        this.uri = uri;
        return this;
    }
","    public HttpRequest setUri(String uri) {
        ObjectUtil.checkNotNull(uri, ""uri"");
START         this.uri = uri; END 
        return this;
    }
","    public HttpRequest setUri(String uri) {
        this.uri = ObjectUtil.checkNotNull(uri, ""uri"");
        return this;
    }
"
245,"Make all Guice constructors package private by removing the method modifier. Just:

``` java
@Inject
ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) {
```","   protected ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) {
      this.creds = creds;
   }
","START    protected ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) { END 
      this.creds = creds;
   }
","   ServiceKeyAuthentication(@Provider Supplier<Credentials> creds) {
      this.creds = creds;
   }
"
246,rename 'child',"    protected int countChildrenOf(IResource checkResource) throws CoreException {
        if (checkResource.getType() == IResource.FILE) {
			return 1;
		}

        int count = 0;
        if (checkResource.isAccessible()) {
			for (IResource resource : ((IContainer) checkResource).members()) {
				count += countChildrenOf(resource);
			}
        }

        return count;
    }
","    protected int countChildrenOf(IResource checkResource) throws CoreException {
        if (checkResource.getType() == IResource.FILE) {
			return 1;
		}

        int count = 0;
        if (checkResource.isAccessible()) {
			for (IResource START  resource : END  ((IContainer) checkResource).members()) {
				count += countChildrenOf(resource);
			}
        }

        return count;
    }
","    protected int countChildrenOf(IResource checkResource) throws CoreException {
        if (checkResource.getType() == IResource.FILE) {
			return 1;
		}

        int count = 0;
        if (checkResource.isAccessible()) {
			for (IResource child : ((IContainer) checkResource).members()) {
				count += countChildrenOf(child);
			}
        }

        return count;
    }
"
247,"If this is null, can't we keep it null? That way you can disable the folder watching if you're not interested in it. The `startMonitor` method below also checks for the return value of this method being `null`.

I guess `null` would then also be the default.","  public String getAppFolderToMonitor() {
    if (folder == null) {
      File f = new File(""Applications"");
      folder = f.getAbsolutePath();
    }
    return folder;
  }
","  public String getAppFolderToMonitor() {
START     if (folder == null) { END 
      File f = new File(""Applications"");
      folder = f.getAbsolutePath();
    }
    return folder;
  }
","  public String getAppFolderToMonitor() {
    return folder;
  }
"
248,I don't think you need this,"    private static void count(Object inputBase, long inputAddress, int inputSize, int[] counts)
    {
        long input = inputAddress;

        Arrays.fill(counts, 0);

        if (inputSize != 0) {
            for (int i = 0; i < inputSize; i++) {
                int symbol = UNSAFE.getByte(inputBase, input) & 0xFF;
                input++;
                counts[symbol]++;
            }
        }
    }
","    private static void count(Object inputBase, long inputAddress, int inputSize, int[] counts)
    {
        long input = inputAddress;

        Arrays.fill(counts, 0);

START         if (inputSize != 0) { END 
            for (int i = 0; i < inputSize; i++) {
                int symbol = UNSAFE.getByte(inputBase, input) & 0xFF;
                input++;
                counts[symbol]++;
            }
        }
    }
","    private static void count(Object inputBase, long inputAddress, int inputSize, int[] counts)
    {
        long input = inputAddress;

        Arrays.fill(counts, 0);

        for (int i = 0; i < inputSize; i++) {
            int symbol = UNSAFE.getByte(inputBase, input) & 0xFF;
            input++;
            counts[symbol]++;
        }
    }
"
249,"If it's interrupted you might want to return too, rather than getting stuck in another park.","	public void submit(List<LuceneWork> workList, IndexingMonitor monitor) {
		Changeset changeset = new Changeset( workList, Thread.currentThread(), monitor );
		transferQueue.add( changeset );
		wakeUpConsumer();
		boolean interrupted = false;
		while ( ! changeset.isProcessed() ) {
			LockSupport.park();
			if ( Thread.interrupted() ) {
				interrupted = true;
			}
		}
		if ( interrupted ) {
			Thread.currentThread().interrupt();
		}
	}
","	public void submit(List<LuceneWork> workList, IndexingMonitor monitor) {
		Changeset changeset = new Changeset( workList, Thread.currentThread(), monitor );
		transferQueue.add( changeset );
		wakeUpConsumer();
		boolean interrupted = false;
		while ( ! changeset.isProcessed() ) {
			LockSupport.park();
			if ( Thread.interrupted() ) {
START 				interrupted = true; END 
			}
		}
		if ( interrupted ) {
			Thread.currentThread().interrupt();
		}
	}
","	public void submit(List<LuceneWork> workList, IndexingMonitor monitor) {
		Changeset changeset = new Changeset( workList, Thread.currentThread(), monitor );
		transferQueue.add( changeset );
		wakeUpConsumer();
		boolean interrupted = false;
		while ( ! changeset.isProcessed() && ! interrupted ) {
			LockSupport.park();
			if ( Thread.interrupted() ) {
				interrupted = true;
			}
		}
		if ( interrupted ) {
			Thread.currentThread().interrupt();
		}
	}
"
250,could we directly reduce this to debug level?,"    public void setHttpService(HttpService httpService) {
        logger.info(""setHttpService called"");
        this.httpService = httpService;
    }
","    public void setHttpService(HttpService httpService) {
START         logger.info(""setHttpService called""); END 
        this.httpService = httpService;
    }
","    public void setHttpService(HttpService httpService) {
        logger.debug(""setHttpService called"");
        this.httpService = httpService;
    }
"
251,"Oh, yes, `Name` can only be qualified by another `Name`. I think it's a safe assumption to make :-)","    public boolean isInternal() {
        return getParentNode()
                .filter(parent -> parent instanceof Name)
                .map(parent -> (Name) parent)
                .flatMap(Name::getQualifier)
                .map(parentNameQualifier -> parentNameQualifier == this)
                .orElse(false);
    }
","    public boolean isInternal() {
        return getParentNode()
                .filter(parent -> parent instanceof Name)
                .map(parent -> (Name) parent)
                .flatMap(Name::getQualifier)
START                 .map(parentNameQualifier -> parentNameQualifier == this) END 
                .orElse(false);
    }
","    public boolean isInternal() {
        return getParentNode()
                .filter(parent -> parent instanceof Name)
                .isPresent();
    }
"
252,`valueOf` looks more appropriate (like `String#valueOf`),"  private void logStart() {
    log(3,
        ""Running test "" + m_testName + "" on "" + m_classMap.size() + "" "" + "" classes, ""
        + "" included groups:["" + Strings.mapToString(m_xmlMethodSelector.getIncludedGroups())
        + ""] excluded groups:["" + Strings.mapToString(m_xmlMethodSelector.getExcludedGroups()) + ""]"");

    if (getVerbose() >= 3) {
      for (ITestClass tc : m_classMap.values()) {
        ((TestClass) tc).dump();
      }
    }
  }
","  private void logStart() {
    log(3,
        ""Running test "" + m_testName + "" on "" + m_classMap.size() + "" "" + "" classes, ""
START         + "" included groups:["" + Strings.mapToString(m_xmlMethodSelector.getIncludedGroups()) END 
        + ""] excluded groups:["" + Strings.mapToString(m_xmlMethodSelector.getExcludedGroups()) + ""]"");

    if (getVerbose() >= 3) {
      for (ITestClass tc : m_classMap.values()) {
        ((TestClass) tc).dump();
      }
    }
  }
","  private void logStart() {
    log(3,
        ""Running test "" + m_testName + "" on "" + m_classMap.size() + "" "" + "" classes, ""
        + "" included groups:["" + Strings.valueOf(m_xmlMethodSelector.getIncludedGroups())
        + ""] excluded groups:["" + Strings.valueOf(m_xmlMethodSelector.getExcludedGroups()) + ""]"");

    if (getVerbose() >= 3) {
      for (ITestClass tc : m_classMap.values()) {
        ((TestClass) tc).dump();
      }
    }
  }
"
253,"Does this mean that every Job will be named ```""NutchJob""```?","  public NutchJob(Configuration conf) throws IOException {
    super(conf, ""NutchJob"");
  }
","  public NutchJob(Configuration conf) throws IOException {
START     super(conf, ""NutchJob""); END 
  }
","  public NutchJob(Configuration conf) {
    super(conf, NutchJob.class);
  }
"
254,"Should use BundleContext.getProperty here, or the EnvonmentInfo service.","	private void loadMachineUUID() {
		if (System.getProperty(PROP_UUID) != null)
			return;
		String uuid = loadExistingUUID();
		if (uuid == null) {
			uuid = UUID.randomUUID().toString();
			saveUUID(uuid);
		}
		EnvironmentInfo environment = environmentTracker.getService();
		if (environment != null) {
			environment.setProperty(PROP_UUID, uuid);
		} else {
			System.setProperty(PROP_UUID, uuid);
		}
	}
","	private void loadMachineUUID() {
		if START (System.getProperty(PROP_UUID) != END  null)
			return;
		String uuid = loadExistingUUID();
		if (uuid == null) {
			uuid = UUID.randomUUID().toString();
			saveUUID(uuid);
		}
		EnvironmentInfo environment = environmentTracker.getService();
		if (environment != null) {
			environment.setProperty(PROP_UUID, uuid);
		} else {
			System.setProperty(PROP_UUID, uuid);
		}
	}
","	private void loadMachineUUID() {
		EnvironmentInfo environment = environmentTracker.getService();
		if (environment != null) {
			if (environment.getProperty(PROP_UUID) != null)
				return;
		}
		String uuid = loadExistingUUID();
		if (uuid == null) {
			uuid = UUID.randomUUID().toString();
			saveUUID(uuid);
		}
		if (environment != null) {
			environment.setProperty(PROP_UUID, uuid);
		} else {
			System.setProperty(PROP_UUID, uuid);
		}
	}
"
255,"Maybe we can use `AtomicInteger` and get rid of `synchronized` keyword ? On a side note, I noticed that you haven't enabled the `parallel` attribute on `@DataProvider` annotation. So you can completely get rid of the need for ensuring Thread safety.","    public synchronized boolean retry(ITestResult result) {
        if (currentTry < maxreruntimes)
        {
            ++currentTry;

            return true;
        }
        return false;
    }
","    public synchronized boolean retry(ITestResult result) {
        if (currentTry < maxreruntimes)
        {
START             ++currentTry; END 

            return true;
        }
        return false;
    }
","    public boolean retry(ITestResult result) {
        if (currentTry < maxreruntimes)
        {
            ++currentTry;

            return true;
        }
        return false;
    }
"
256,It was much nicer when we did not have to explicitly cast everywhere to `(Statistics<T>)`. Please consider re-working this part your changes.,"  public Statistics<T> visitIntConstant(ValueExpressions.IntExpression expr, Void value) throws RuntimeException {
    return (Statistics<T>)getStatistics(expr.getInt());
  }
","  public Statistics<T> visitIntConstant(ValueExpressions.IntExpression expr, Void value) throws RuntimeException {
START     return (Statistics<T>)getStatistics(expr.getInt()); END 
  }
","  public Statistics<T> visitIntConstant(ValueExpressions.IntExpression expr, Void value) throws RuntimeException {
    return getStatistics(expr.getInt());
  }
"
257,"It might even  be more readable to export the symbolic constants outside the class, instead of null. Either way is fine. It might be clearer for debugging and logging.","    public ServiceDate getEnd() {
        return end == UNBOUNDED_END ? null : end;
    }
","    public ServiceDate getEnd() {
START         return end == UNBOUNDED_END ? null : end; END 
    }
","    public ServiceDate getEnd() {
        return end;
    }
"
258,no public,"  public boolean isLoggedIn() {
    return token != null && hub != null;
  }
","  START  public boolean END  isLoggedIn() {
    return token != null && hub != null;
  }
","  public boolean isLoggedIn() {
    return token != null && user != null;
  }
"
259,"The complete method could be stripped down to:
```
try {
    this.buildStatus = StashBuildState.valueOf(buildStatus);
} catch (Exception e) {
    // ignore unknown or null values
}
```","    public void setBuildStatus(String buildStatus) {
        StashBuildState overwrittenBuildState = null;
        try {
            overwrittenBuildState = StashBuildState.valueOf(buildStatus);
        } catch (Exception e) {
            // ignore unknown or null values
        }
        this.buildStatus = overwrittenBuildState;
    }
","START     public void setBuildStatus(String buildStatus) { END 
        StashBuildState overwrittenBuildState = null;
        try {
            overwrittenBuildState = StashBuildState.valueOf(buildStatus);
        } catch (Exception e) {
            // ignore unknown or null values
        }
        this.buildStatus = overwrittenBuildState;
    }
","    public void setBuildStatus(String buildStatus) {
        try {
            this.buildStatus = StashBuildState.valueOf(buildStatus);
        } catch (Exception e) {
            // ignore unknown or null values
        }
    }
"
260,Put this in the config preinit please,"    public void preInit(FMLPreInitializationEvent evt) {
        RegistryHelper.useOtherModConfigFor(MODID, BCCore.MODID);

        BCSiliconConfig.preInit();
        BCSiliconItems.preInit();
        BCSiliconBlocks.preInit();

        // Reload after all of the definitions have been created.
        BCSiliconConfig.reloadConfig(EnumRestartRequirement.GAME);

        NetworkRegistry.INSTANCE.registerGuiHandler(INSTANCE, BCSiliconProxy.getProxy());

        BCSiliconProxy.getProxy().fmlPreInit();
    }
","    public void preInit(FMLPreInitializationEvent evt) {
        RegistryHelper.useOtherModConfigFor(MODID, BCCore.MODID);

        BCSiliconConfig.preInit();
        BCSiliconItems.preInit();
        BCSiliconBlocks.preInit();

        // Reload after all of the definitions have been created.
START         BCSiliconConfig.reloadConfig(EnumRestartRequirement.GAME); END 

        NetworkRegistry.INSTANCE.registerGuiHandler(INSTANCE, BCSiliconProxy.getProxy());

        BCSiliconProxy.getProxy().fmlPreInit();
    }
","    public void preInit(FMLPreInitializationEvent evt) {
        RegistryHelper.useOtherModConfigFor(MODID, BCCore.MODID);

        BCSiliconConfig.preInit();
        BCSiliconItems.preInit();
        BCSiliconBlocks.preInit();

        NetworkRegistry.INSTANCE.registerGuiHandler(INSTANCE, BCSiliconProxy.getProxy());

        BCSiliconProxy.getProxy().fmlPreInit();
    }
"
261,"Recycling a digest to which we still have references (namely in the member variable`digest`) is bound to give problems at some point: another thread may obtain it by means of `HashType.get()` while we are still using it!

If you insist on recycling digests, I guess this could be done in the finalizer of `Hash`. Note that the semantics of `finally` don't have anything to do with finalizers!","	public Hash(HashType type){
		this.type = type;
		try {
			digest = type.get();
		} finally {
			type.recycle(digest);
		}
	}
","	public Hash(HashType type){
		this.type = type;
		try {
			digest = type.get();
		} finally {
START 			type.recycle(digest); END 
		}
	}
","	public Hash(HashType type){
		this.type = type;
		digest = type.get();
	}
"
262,the mapping is still performed before the validation. it should be after it,"    private boolean validateExternalVnicProfileMapping() {
        drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings());
        final ValidationResult validationResult =
                externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(
                        getParameters().getExternalVnicProfileMappings(),
                        getParameters().getClusterId());
        return validate(validationResult);
    }
","    private boolean validateExternalVnicProfileMapping() {
START         drMappingHelper.mapVnicProfiles(vmTemplateFromConfiguration.getInterfaces(), getParameters().getExternalVnicProfileMappings()); END 
        final ValidationResult validationResult =
                externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(
                        getParameters().getExternalVnicProfileMappings(),
                        getParameters().getClusterId());
        return validate(validationResult);
    }
","    private boolean validateExternalVnicProfileMapping() {
        final ValidationResult validationResult =
                externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(
                        getParameters().getExternalVnicProfileMappings(),
                        getParameters().getClusterId());
        return validate(validationResult);
    }
"
263,do we need a `null` case?,"  public void serDeTest() {
    doSerDeTest(Collections.emptyList());
    doSerDeTest(Arrays.asList(""a"", ""b"", ""/signedId/abcdef""));
  }
","  public void serDeTest() {
START     doSerDeTest(Collections.emptyList()); END 
    doSerDeTest(Arrays.asList(""a"", ""b"", ""/signedId/abcdef""));
  }
","  public void serDeTest() {
    doSerDeTest(null);
    doSerDeTest(Collections.emptyList());
    doSerDeTest(Arrays.asList(""a"", ""b"", ""/signedId/abcdef""));
  }
"
264,use String.valueOf(vm.getnum_of_monitors()) instead.,"    protected void buildVmVideoCards() {
        createInfo.add(VdsProperties.display, vm.getdisplay_type().toString()); // vnc,qxl
        createInfo.add(VdsProperties.num_of_monitors,
                (new Integer(vm.getnum_of_monitors())).toString());
    }
","    protected void buildVmVideoCards() {
        createInfo.add(VdsProperties.display, vm.getdisplay_type().toString()); // vnc,qxl
        createInfo.add(VdsProperties.num_of_monitors,
START                 (new Integer(vm.getnum_of_monitors())).toString()); END 
    }
","    protected void buildVmVideoCards() {
        createInfo.add(VdsProperties.display, vm.getdisplay_type().toString()); // vnc,qxl
        createInfo.add(VdsProperties.num_of_monitors, String.valueOf(vm.getnum_of_monitors()));
    }
"
265,[optional] maybe this method can be static and should be moved to end of the class,"  String encode(String segment) {
    return URL.encodeQueryString(type.replacePathSeparator(segment));
  }
","START   String encode(String segment) { END 
    return URL.encodeQueryString(type.replacePathSeparator(segment));
  }
","  private String encode(String segment) {
    return URL.encodeQueryString(type.replacePathSeparator(segment));
  }
"
266,"This code is duplicate. Moreover, repeated ""add"" operations are not necessary.
You can use something like this:
```
		return Arrays.asList(
			A_U_D_preferredMail, 
			A_U_D_ISMail, 
			A_U_D_publicAliasMails, 
			A_U_D_privateAliasMails, 
			A_U_D_o365EmailAddressesMU);
```","	public List<String> getStrongDependencies() {
		List<String> strongDependencies = new ArrayList<>();
		strongDependencies.add(A_U_D_preferredMail);
		strongDependencies.add(A_U_D_ISMail);
		strongDependencies.add(A_U_D_publicAliasMails);
		strongDependencies.add(A_U_D_privateAliasMails);
		strongDependencies.add(A_U_D_o365EmailAddressesMU);
		return strongDependencies;
	}
","	public List<String> getStrongDependencies() {
		List<String> strongDependencies = new ArrayList<>();
START 		strongDependencies.add(A_U_D_preferredMail); END 
		strongDependencies.add(A_U_D_ISMail);
		strongDependencies.add(A_U_D_publicAliasMails);
		strongDependencies.add(A_U_D_privateAliasMails);
		strongDependencies.add(A_U_D_o365EmailAddressesMU);
		return strongDependencies;
	}
","	public List<String> getStrongDependencies() {
		return Arrays.asList(
			A_U_D_preferredMail,
			A_U_D_ISMail,
			A_U_D_publicAliasMails,
			A_U_D_privateAliasMails,
			A_U_D_o365EmailAddressesMU);
	}
"
267,`isCacheable` is now `true`? I guess this was supposed to be `false` for generic extractors. Or am I wrong?,"    boolean isCacheable() {
        return true;
    }
","    boolean isCacheable() {
START         return true; END 
    }
","    boolean isCacheable() {
        return false;
    }
"
268,It does not make sense to expose a protected method and mark it as @Deprecated from the beginning. Maybe you should remove the annotation and make it package-private ?,"    protected static KeyManagerFactory buildKeyManagerFactory(File certChainFile,
            String keyAlgorithm, File keyFile, String keyPassword, KeyManagerFactory kmf,
            String keyStore)
                    throws KeyStoreException, NoSuchAlgorithmException, NoSuchPaddingException,
                    InvalidKeySpecException, InvalidAlgorithmParameterException, IOException,
                    CertificateException, KeyException, UnrecoverableKeyException {
        return buildKeyManagerFactory(toX509Certificates(certChainFile), keyAlgorithm,
                                      toPrivateKey(keyFile, keyPassword), keyPassword, kmf, keyStore);
    }
","START     protected static KeyManagerFactory buildKeyManagerFactory(File certChainFile, END 
            String keyAlgorithm, File keyFile, String keyPassword, KeyManagerFactory kmf,
            String keyStore)
                    throws KeyStoreException, NoSuchAlgorithmException, NoSuchPaddingException,
                    InvalidKeySpecException, InvalidAlgorithmParameterException, IOException,
                    CertificateException, KeyException, UnrecoverableKeyException {
        return buildKeyManagerFactory(toX509Certificates(certChainFile), keyAlgorithm,
                                      toPrivateKey(keyFile, keyPassword), keyPassword, kmf, keyStore);
    }
","    static KeyManagerFactory buildKeyManagerFactory(File certChainFile,
            String keyAlgorithm, File keyFile, String keyPassword, KeyManagerFactory kmf,
            String keyStore)
                    throws KeyStoreException, NoSuchAlgorithmException, NoSuchPaddingException,
                    InvalidKeySpecException, InvalidAlgorithmParameterException, IOException,
                    CertificateException, KeyException, UnrecoverableKeyException {
        return buildKeyManagerFactory(toX509Certificates(certChainFile), keyAlgorithm,
                                      toPrivateKey(keyFile, keyPassword), keyPassword, kmf, keyStore);
    }
"
269,It's probably a bad idea to be checking for exception messages in the first place.,"  public void testWrongPortConnection()
      throws Exception {
    BlockingChannel channel =
        new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory,
            clientSSLConfig);
    try {
      // send request
      channel.connect();
      fail(""should have thrown!"");
    } catch (IOException e) {
      assertTrue(e.getMessage().contains(""Connection refused""));
    }
  }
","  public void testWrongPortConnection()
      throws Exception {
    BlockingChannel channel =
        new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory,
            clientSSLConfig);
    try {
      // send request
      channel.connect();
      fail(""should have thrown!"");
    } catch (IOException e) {
START       assertTrue(e.getMessage().contains(""Connection refused"")); END 
    }
  }
","  public void testWrongPortConnection()
      throws Exception {
    BlockingChannel channel =
        new SSLBlockingChannel(hostName, sslPort + 1, new MetricRegistry(), 10000, 10000, 10000, 2000, sslSocketFactory,
            clientSSLConfig);
    try {
      // send request
      channel.connect();
      fail(""should have thrown!"");
    } catch (IOException e) {
    }
  }
"
270,the .contains() should probably be in the synchronized block too,"    public void notifyParameterChanged(String name) {
        if (!fParameterNames.contains(name)) {
            throw new RuntimeException(String.format(Messages.TmfAbstractAnalysisModule_InvalidParameter, name, getName()));
        }
        synchronized (fParameters) {
            Object oldValue = fParameters.get(name);
            Object value = getParameter(name);
            if ((value != null) && !(value.equals(oldValue))) {
                parameterChanged(name);
            }
        }
    }
","    public void notifyParameterChanged(String name) {
        if (!fParameterNames.contains(name)) {
            throw new RuntimeException(String.format(Messages.TmfAbstractAnalysisModule_InvalidParameter, name, getName()));
        }
START         synchronized (fParameters) { END 
            Object oldValue = fParameters.get(name);
            Object value = getParameter(name);
            if ((value != null) && !(value.equals(oldValue))) {
                parameterChanged(name);
            }
        }
    }
","    public void notifyParameterChanged(String name) {
        synchronized (fParameters) {
            if (!fParameterNames.contains(name)) {
                throw new RuntimeException(String.format(Messages.TmfAbstractAnalysisModule_InvalidParameter, name, getName()));
            }
            Object oldValue = fParameters.get(name);
            Object value = getParameter(name);
            if ((value != null) && !(value.equals(oldValue))) {
                parameterChanged(name);
            }
        }
    }
"
271,"Is this idiomatic?  In fact expect that won't be true, it's just that will be interrupted before the assertTrue returns?  Would be clearer to omit the assertTrue?","    public void testUnrecognizedSpec() {
        when(authentication.getAttributes().get(any(String.class))).thenReturn(""strong_two_factor"");
        spec.setAuthenticationMethod(""weak_two_factor"");
        assertTrue(this.spec.isSatisfiedBy(this.assertion));
    }
","    public void testUnrecognizedSpec() {
        when(authentication.getAttributes().get(any(String.class))).thenReturn(""strong_two_factor"");
        spec.setAuthenticationMethod(""weak_two_factor"");
START         assertTrue(this.spec.isSatisfiedBy(this.assertion)); END 
    }
","    public void testUnrecognizedSpec() {
        when(authentication.getAttributes().get(any(String.class))).thenReturn(""strong_two_factor"");
        spec.setAuthenticationMethod(""weak_two_factor"");
        spec.isSatisfiedBy(this.assertion);
    }
"
272,Why does this claim to return Bundle? Doesn't really matter though :),"    public static Bundle updateBundleConfig(Connection connection, Bundle bundle)
            throws SQLException {
        final String sql = ""UPDATE portti_view_bundle_seq SET config=? WHERE bundle_id=? AND view_id=?"";

        try (final PreparedStatement statement =
                     connection.prepareStatement(sql)) {
            statement.setString(1, bundle.config);
            statement.setLong(2, bundle.bundle);
            statement.setLong(3, bundle.view);
            statement.execute();
        }
        return null;
    }
","START     public static Bundle updateBundleConfig(Connection connection, Bundle bundle) END 
            throws SQLException {
        final String sql = ""UPDATE portti_view_bundle_seq SET config=? WHERE bundle_id=? AND view_id=?"";

        try (final PreparedStatement statement =
                     connection.prepareStatement(sql)) {
            statement.setString(1, bundle.config);
            statement.setLong(2, bundle.bundle);
            statement.setLong(3, bundle.view);
            statement.execute();
        }
        return null;
    }
","    private void updateBundleConfig(Connection connection, Bundle bundle)
            throws SQLException {
        final String sql = ""UPDATE portti_view_bundle_seq SET config=? WHERE bundle_id=? AND view_id=?"";

        try (final PreparedStatement statement =
                     connection.prepareStatement(sql)) {
            statement.setString(1, bundle.config);
            statement.setLong(2, bundle.bundle);
            statement.setLong(3, bundle.view);
            statement.execute();
        }
    }
"
273,`Integer.parseInt`,"    protected int getOverProvisioningFactor() {
        return Integer.valueOf(Framework.getProperty(WORKMANAGER_OVERPROVISIONING_PROP, DEFAULT_WORKMANAGER_OVERPROVISIONING));
    }
","    protected int getOverProvisioningFactor() {
START         return Integer.valueOf(Framework.getProperty(WORKMANAGER_OVERPROVISIONING_PROP, DEFAULT_WORKMANAGER_OVERPROVISIONING)); END 
    }
","    protected int getOverProvisioningFactor() {
        return Integer.parseInt(
                Framework.getProperty(WORKMANAGER_OVERPROVISIONING_PROP, DEFAULT_WORKMANAGER_OVERPROVISIONING));
    }
"
274,Please move `super.onDestroy` to the end of the method.,"	protected void onDestroy() {
		super.onDestroy();
		webView.setDownloadListener(null);
	}
","	protected void onDestroy() {
START 		super.onDestroy(); END 
		webView.setDownloadListener(null);
	}
","	protected void onDestroy() {
		webView.setDownloadListener(null);
		super.onDestroy();
	}
"
275,Which part in this test calls `NettyResponseChannel.close()`?,"  public void closeTest() {
    // request is keep-alive by default.
    HttpRequest request = createRequestWithHeaders(HttpMethod.GET, TestingUri.Close.toString());
    EmbeddedChannel channel = createEmbeddedChannel();
    channel.writeInbound(request);

    // drain the channel of content.
    while (channel.readOutbound() != null) {
      ;
    }
    assertFalse(""Channel should be closed"", channel.isOpen());
  }
","START   public void closeTest() { END 
    // request is keep-alive by default.
    HttpRequest request = createRequestWithHeaders(HttpMethod.GET, TestingUri.Close.toString());
    EmbeddedChannel channel = createEmbeddedChannel();
    channel.writeInbound(request);

    // drain the channel of content.
    while (channel.readOutbound() != null) {
      ;
    }
    assertFalse(""Channel should be closed"", channel.isOpen());
  }
","  public void closeTest() {
    // request is keep-alive by default.
    HttpRequest request = createRequestWithHeaders(HttpMethod.GET, TestingUri.Close.toString());
    EmbeddedChannel channel = createEmbeddedChannel();
    channel.writeInbound(request);

    // drain the channel of content.
    while (channel.readOutbound() != null) {
    }
    assertFalse(""Channel should be closed"", channel.isOpen());
  }
"
276,"Please consider adding an overridden version of the `Script(String, int, Logger)` constructor that accepts `Duration` to encapsulate this type conversion.","    public String getRuleLogsForVms() {
        final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger);
        cmd.add(""get_rule_logs_for_vms"");
        final OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser();
        final String result = cmd.execute(parser);
        if (result == null) {
            return parser.getLine();
        }
        return null;
    }
","    public String getRuleLogsForVms() {
START         final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); END 
        cmd.add(""get_rule_logs_for_vms"");
        final OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser();
        final String result = cmd.execute(parser);
        if (result == null) {
            return parser.getLine();
        }
        return null;
    }
","    public String getRuleLogsForVms() {
        final Script cmd = new Script(_securityGroupPath, _timeout, s_logger);
        cmd.add(""get_rule_logs_for_vms"");
        final OutputInterpreter.OneLineParser parser = new OutputInterpreter.OneLineParser();
        final String result = cmd.execute(parser);
        if (result == null) {
            return parser.getLine();
        }
        return null;
    }
"
277,We can avoid the instance creation if the reporter already exist,"  private void addReporter(Class<? extends IReporter> r) {
    m_reporters.put(r, ClassHelper.newInstance(r));
  }
","  private void addReporter(Class<? extends IReporter> r) {
START     m_reporters.put(r, ClassHelper.newInstance(r)); END 
  }
","  private void addReporter(Class<? extends IReporter> r) {
    if (!m_reporters.containsKey(r)) {
      m_reporters.put(r, ClassHelper.newInstance(r));
    }
  }
"
278,Don't mark methods as `final`.,"    public final synchronized void addFunctions(List<? extends SqlFunction> functions)
    {
        addFunctions(TEMP_DEFAULT_CATALOG, functions);
    }
","START     public final synchronized void addFunctions(List<? extends SqlFunction> functions) END 
    {
        addFunctions(TEMP_DEFAULT_CATALOG, functions);
    }
","    public void addFunctions(List<? extends SqlFunction> functions)
    {
        addFunctions(TEMP_DEFAULT_CATALOG, functions);
    }
"
279,"You can join the ifs. There's a content assist for that, it's awesome.","    public synchronized void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
        if (oldInput != newInput) {
            if (newInput != null) {
                ImportTraceContentProvider input = (ImportTraceContentProvider) newInput;
                clearCandidates();
                fTraceTypes.putAll(input.fTraceTypes);
                fTraceFiles.putAll(fTraceFiles);
            }
        }
    }
","    public synchronized void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
START         if (oldInput != newInput) { END 
            if (newInput != null) {
                ImportTraceContentProvider input = (ImportTraceContentProvider) newInput;
                clearCandidates();
                fTraceTypes.putAll(input.fTraceTypes);
                fTraceFiles.putAll(fTraceFiles);
            }
        }
    }
","    public synchronized void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
        if (oldInput != newInput && newInput != null) {
            ImportTraceContentProvider input = (ImportTraceContentProvider) newInput;
            clearCandidates();
            fTraceTypes.putAll(input.fTraceTypes);
            fTraceFiles.putAll(fTraceFiles);
        }
    }
"
280,please set a modifier - protected seem suitable,"    boolean isPowerManagementLegal() {
        return IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup()
                .getcompatibility_version().toString());
    }
","START     boolean isPowerManagementLegal() { END 
        return IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup()
                .getcompatibility_version().toString());
    }
","    protected boolean isPowerManagementLegal() {
        return IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup()
                .getcompatibility_version().toString());
    }
"
281,Should avoid `System.out` in tests. Instead can you write to log4j,"        public void info(String message) {
            System.out.println(message);
            info.add(message);
        }
","        public void info(String message) {
START             System.out.println(message); END 
            info.add(message);
        }
","        public void info(String message) {
            info.add(message);
        }
"
282,Probably should crash if bad format string,"  public static File makeNumericDimFile(File dir, String dimension, ByteOrder order)
  {
    return new File(dir, StringUtils.safeFormat(""numeric_dim_%s_%s.drd"", dimension, order));
  }
","  public static File makeNumericDimFile(File dir, String dimension, ByteOrder order)
  {
START     return new File(dir, StringUtils.safeFormat(""numeric_dim_%s_%s.drd"", dimension, order)); END 
  }
","  public static File makeNumericDimFile(File dir, String dimension, ByteOrder order)
  {
    return new File(dir, StringUtils.format(""numeric_dim_%s_%s.drd"", dimension, order));
  }
"
283,Is there any longer a need for the VM ID ?,"    private AuditLogableBase createAuditLog(final VmNic iface) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(iface.getVmId());
        logable.addCustomValue(""MACAddr"", iface.getMacAddress());
        logable.addCustomValue(""IfaceName"", iface.getName());
        return logable;
    }
","    private AuditLogableBase createAuditLog(final VmNic iface) {
        AuditLogableBase logable = new AuditLogableBase();
START         logable.setVmId(iface.getVmId()); END 
        logable.addCustomValue(""MACAddr"", iface.getMacAddress());
        logable.addCustomValue(""IfaceName"", iface.getName());
        return logable;
    }
","    private AuditLogableBase createAuditLog(final VmNic iface) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue(""MACAddr"", iface.getMacAddress());
        logable.addCustomValue(""IfaceName"", iface.getName());
        return logable;
    }
"
284,"same here, redundant?","    public boolean equals( VirtualValue other )
    {
        if ( other == null || !(other instanceof MapValue) )
        {
            return false;
        }
        MapValue that = (MapValue) other;
        return size() == that.size() &&
                Arrays.equals( keys, that.keys ) &&
                Arrays.equals( values, that.values );
    }
","    public boolean equals( VirtualValue other )
    {
START         if ( other == null || !(other instanceof MapValue) ) END 
        {
            return false;
        }
        MapValue that = (MapValue) other;
        return size() == that.size() &&
                Arrays.equals( keys, that.keys ) &&
                Arrays.equals( values, that.values );
    }
","    public boolean equals( VirtualValue other )
    {
        if ( other == null || other.getClass() != MapValue.class )
        {
            return false;
        }
        MapValue that = (MapValue) other;
        return map.equals( that.map );
    }
"
285,nit: Formatting,"    private void processSingleClusterChanges(ManageNetworkClustersParameters param) {
        final List<ActionParametersBase> setupNetworksParams = new ArrayList<>(
                createNetworkClustersToSetupNetworksParametersTransformer().transform(
                        param.getAttachments(),
                        param.getDetachments(),
                        param.getUpdates())
        );

        HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams);
        setupNetworksParams.forEach(this::withRootCommandInfo);
        runInternalMultipleActions(ActionType.PersistentHostSetupNetworks, setupNetworksParams, getContext().getExecutionContext());
    }
","    private void processSingleClusterChanges(ManageNetworkClustersParameters param) {
        final List<ActionParametersBase> setupNetworksParams = new ArrayList<>(
                createNetworkClustersToSetupNetworksParametersTransformer().transform(
                        param.getAttachments(),
                        param.getDetachments(),
                        param.getUpdates())
        );

        HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams);
        setupNetworksParams.forEach(this::withRootCommandInfo);
        START  runInternalMultipleActions(ActionType.PersistentHostSetupNetworks, setupNetworksParams, getContext().getExecutionContext()); END 
    }
","    private void processSingleClusterChanges(ManageNetworkClustersParameters param) {
        final List<ActionParametersBase> setupNetworksParams = new ArrayList<>(
                createNetworkClustersToSetupNetworksParametersTransformer().transform(
                        param.getAttachments(),
                        param.getDetachments(),
                        param.getUpdates())
        );

        HostSetupNetworksParametersBuilder.updateParametersSequencing(setupNetworksParams);
        setupNetworksParams.forEach(this::withRootCommandInfo);
        runInternalMultipleActions(ActionType.PersistentHostSetupNetworks, setupNetworksParams);
    }
"
286,[minor] Can be static?,"   private void setFixedLengthStreamingMode(HttpURLConnection connection, long length) {
      try { // Not caching method as invocation is literally sending > 2GB, which means reflection isn't a limiter!
         HttpURLConnection.class.getMethod(""setFixedLengthStreamingMode"", long.class).invoke(connection, length);
      } catch (Exception e) {
         throw new IllegalArgumentException(""Cannot transfer 2 GB or larger chunks due to JDK 1.6 limitations."" +
               "" Use chunked encoding or multi-part upload, if possible, or use a different http driver."" +
               "" For more information: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6755625"");
      }
   }
","START    private void setFixedLengthStreamingMode(HttpURLConnection connection, long length) { END 
      try { // Not caching method as invocation is literally sending > 2GB, which means reflection isn't a limiter!
         HttpURLConnection.class.getMethod(""setFixedLengthStreamingMode"", long.class).invoke(connection, length);
      } catch (Exception e) {
         throw new IllegalArgumentException(""Cannot transfer 2 GB or larger chunks due to JDK 1.6 limitations."" +
               "" Use chunked encoding or multi-part upload, if possible, or use a different http driver."" +
               "" For more information: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6755625"");
      }
   }
","   private static void setFixedLengthStreamingMode(HttpURLConnection connection, long length) {
      try { // Not caching method as invocation is literally sending > 2GB, which means reflection isn't a limiter!
         HttpURLConnection.class.getMethod(""setFixedLengthStreamingMode"", long.class).invoke(connection, length);
      } catch (Exception e) {
         throw new IllegalArgumentException(""Cannot transfer 2 GB or larger chunks due to JDK 1.6 limitations."" +
               "" Use chunked encoding or multi-part upload, if possible, or use a different http driver."" +
               "" For more information: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6755625"");
      }
   }
"
287,"Method should probably be protected, given writing this for sub-classing.","    String getErrorMessage(ClientResponse clientResponse) {
        String response = clientResponse.getEntity(String.class);
        try {
            // Try to see if the server responded with an error message from the API
            ApiError error = getJsonParser().readValue(response, ApiError.class);
            return error.getMessage();
        } catch (IOException e) {
            // If not, inform the user of the underlying response (e.g. if server threw NPE or whatever)
            int statusCode = clientResponse.getStatus();
            ClientResponse.Status status = clientResponse.getClientResponseStatus();
            String responseText = clientResponse.getEntity(String.class);
            return ""Server returned ""+status+""(""+statusCode+""); ""+responseText;
        }
    }
","START     String getErrorMessage(ClientResponse clientResponse) { END 
        String response = clientResponse.getEntity(String.class);
        try {
            // Try to see if the server responded with an error message from the API
            ApiError error = getJsonParser().readValue(response, ApiError.class);
            return error.getMessage();
        } catch (IOException e) {
            // If not, inform the user of the underlying response (e.g. if server threw NPE or whatever)
            int statusCode = clientResponse.getStatus();
            ClientResponse.Status status = clientResponse.getClientResponseStatus();
            String responseText = clientResponse.getEntity(String.class);
            return ""Server returned ""+status+""(""+statusCode+""); ""+responseText;
        }
    }
","    protected String getErrorMessage(ClientResponse clientResponse) {
        String response = clientResponse.getEntity(String.class);
        try {
            // Try to see if the server responded with an error message from the API
            ApiError error = getJsonParser().readValue(response, ApiError.class);
            return error.getMessage();
        } catch (IOException e) {
            // If not, inform the user of the underlying response (e.g. if server threw NPE or whatever)
            int statusCode = clientResponse.getStatus();
            ClientResponse.Status status = clientResponse.getClientResponseStatus();
            String responseText = clientResponse.getEntity(String.class);
            return ""Server returned ""+status+""(""+statusCode+""); ""+responseText;
        }
    }
"
288,`b ^ (b >> 31)` is missed here.,"        public int hashCode() {
            int bits = 1;
            bits = 31 * bits + this.type.ordinal();
            bits = 31 * bits + getToX();
            bits = 31 * bits + getToY();
            bits = 31 * bits + getToZ();
            bits = 31 * bits + getFromX();
            bits = 31 * bits + getFromY();
            bits = 31 * bits + getFromZ();
            return bits;
        }
","        public int hashCode() {
            int bits = 1;
            bits = 31 * bits + this.type.ordinal();
            bits = 31 * bits + getToX();
            bits = 31 * bits + getToY();
            bits = 31 * bits + getToZ();
            bits = 31 * bits + getFromX();
            bits = 31 * bits + getFromY();
            bits = 31 * bits + getFromZ();
START             return bits; END 
        }
","        public int hashCode() {
            int bits = 1;
            bits = 31 * bits + this.type.ordinal();
            bits = 31 * bits + getToX();
            bits = 31 * bits + getToY();
            bits = 31 * bits + getToZ();
            bits = 31 * bits + getFromX();
            bits = 31 * bits + getFromY();
            bits = 31 * bits + getFromZ();
            return bits ^ (bits >> 31);
        }
"
289,"This should call all

``` java
return all(params, (RequestOptions) null);
```","	public static AccountCollection all(Map<String, Object> params)
			throws AuthenticationException, InvalidRequestException,
			APIConnectionException, CardException, APIException {
		return request(RequestMethod.GET, classURL(Account.class), params, AccountCollection.class, (RequestOptions) null);
	}
","	public static AccountCollection all(Map<String, Object> params)
			throws AuthenticationException, InvalidRequestException,
			APIConnectionException, CardException, APIException {
START 		return request(RequestMethod.GET, classURL(Account.class), params, AccountCollection.class, (RequestOptions) null); END 
	}
","	public static AccountCollection all(Map<String, Object> params)
			throws AuthenticationException, InvalidRequestException,
			APIConnectionException, CardException, APIException {
		return all(params, (RequestOptions) null);
	}
"
290,"Since this is a Fragment with a lifecycle, consider holding a reference to Call<?> and canceling it in onDestroy() if Call<?> is nonnull.","        public void onSaveClick() {
            editView.setSaveState(true);
            WikidataDescriptionEditDataClient client = new WikidataDescriptionEditDataClient();
            client.submitDescription(pageTitle, editView.getDescription(),
                    new WikidataDescriptionEditDataClient.Callback() {
                @Override
                public void success() {
                    editView.setSaveState(false);
                    L.i(""WD description edit successful"");
                    // TODO: go to success fragment
                }

                @Override
                public void failure(@NonNull Throwable caught) {
                    editView.setSaveState(false);
                    L.e(""WD description edit failed: "", caught);
                    // TODO: go to failure fragment
                }
            });
        }
","        public void onSaveClick() {
            editView.setSaveState(true);
            WikidataDescriptionEditDataClient client = new WikidataDescriptionEditDataClient();
START             client.submitDescription(pageTitle, editView.getDescription(), END 
                    new WikidataDescriptionEditDataClient.Callback() {
                @Override
                public void success() {
                    editView.setSaveState(false);
                    L.i(""WD description edit successful"");
                    // TODO: go to success fragment
                }

                @Override
                public void failure(@NonNull Throwable caught) {
                    editView.setSaveState(false);
                    L.e(""WD description edit failed: "", caught);
                    // TODO: go to failure fragment
                }
            });
        }
","        public void onSaveClick() {
            editView.setSaveState(true);
            if (client == null) {
                client = new WikidataDescriptionEditDataClient();
            }
            client.request(pageTitle, editView.getDescription(),
                    new WikidataDescriptionEditDataClient.Callback() {
                @Override
                public void success() {
                    editView.setSaveState(false);
                    L.i(""WD description edit successful"");
                    // TODO: go to success fragment
                }

                @Override
                public void failure(@NonNull Throwable caught) {
                    editView.setSaveState(false);
                    L.e(""WD description edit failed: "", caught);
                    // TODO: go to failure fragment
                }
            });
        }
"
291,why not use the passed in editorInput,"	protected ResourceSet loadResource(IEditorInput editorInput) {
		final URI resourceURI = EditUIUtil.getURI(getEditorInput(), null);
		return ResourceSetHelpers.loadResourceSetWithProxies(resourceURI, getCommandStack());
	}
","	protected ResourceSet loadResource(IEditorInput editorInput) {
START 		final URI resourceURI = EditUIUtil.getURI(getEditorInput(), null); END 
		return ResourceSetHelpers.loadResourceSetWithProxies(resourceURI, getCommandStack());
	}
","	protected ResourceSet loadResource(IEditorInput editorInput) {
		final URI resourceURI = EditUIUtil.getURI(editorInput, null);
		return ResourceSetHelpers.loadResourceSetWithProxies(resourceURI, getCommandStack());
	}
"
292,declared exception isn't thrown,"	FileReftableStack.CompactionStats getCompactionStats() throws IOException {
		return reftableStack.getStats();
	}
","	FileReftableStack.CompactionStats getCompactionStats() START  throws IOException { END 
		return reftableStack.getStats();
	}
","	FileReftableStack.CompactionStats getCompactionStats() {
		return reftableStack.getStats();
	}
"
293,"This changes default behaviour, right? Should it?","    public OnlineBackup incremental( String targetDirectory )
    {
        outcome = new BackupService().doIncrementalBackup( hostNameOrIp, port, new File( targetDirectory ),
                getConsistencyCheck( true ), timeoutMillis, defaultConfig() );
        return this;
    }
","    public OnlineBackup incremental( String targetDirectory )
    {
        outcome = new BackupService().doIncrementalBackup( hostNameOrIp, port, new File( targetDirectory ),
START                 getConsistencyCheck( true ), timeoutMillis, defaultConfig() ); END 
        return this;
    }
","    public OnlineBackup incremental( String targetDirectory )
    {
        outcome = new BackupService().doIncrementalBackup( hostNameOrIp, port, new File( targetDirectory ),
                getConsistencyCheck( false ), timeoutMillis, defaultConfig() );
        return this;
    }
"
294,This could just be `return !(isDiscarding() || isCalleeData()) || isAsync();`,"    private boolean isValidConfiguration() {
        if (isDiscarding() || isCalleeData()) {
            return isAsync();
        } else {
            return true;
        }
    }
","    private boolean isValidConfiguration() {
        if (isDiscarding() || isCalleeData()) {
            return isAsync();
        } else {
            return true;
START         } END 
    }
","    private boolean isValidConfiguration() {
        return !(isDiscarding() || isCalleeData()) || isAsync();
    }
"
295,should this be set if ret is false? I don't know.,"    public boolean setTrace(@NonNull ITmfTrace trace) throws TmfAnalysisException {
        boolean ret = super.setTrace(trace);
        if (!ret) {
            return ret;
        }
        ret = fCriticalPathModule.setTrace(trace);
        fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId());
        return ret;
    }
","    public boolean setTrace(@NonNull ITmfTrace trace) throws TmfAnalysisException {
        boolean ret = super.setTrace(trace);
        if (!ret) {
            return ret;
        }
        ret = fCriticalPathModule.setTrace(trace);
START         fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId()); END 
        return ret;
    }
","    public boolean setTrace(@NonNull ITmfTrace trace) throws TmfAnalysisException {
        boolean ret = super.setTrace(trace);
        if (!ret) {
            return ret;
        }
        ret = fCriticalPathModule.setTrace(trace);
        if (ret) {
            fCriticalPathModule.setParameter(CriticalPathModule.PARAM_GRAPH, getId());
        }
        return ret;
    }
"
296,"Before, with waitOtherJobs, we ""Do nothing"" in case of InterruptedException. Why do you change that? Have you test the difference?","    public void fillContextMenu(final IMenuManager menu) {
        super.fillContextMenu(menu);
        final ISelection selection = getContext().getSelection();
        if (selection.isEmpty()) {
            return;
        }

        // Wait the end of the loading of the representations file
        try {
            Job.getJobManager().join(AbstractRepresentationsFileJob.FAMILY, new NullProgressMonitor());
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        // Differents behavior between win and linux : windows will not
        // display contextual menu if busy cursor while dialog is shown.

        // Fill the context menu
        contextMenuFiller.fillContextMenu(menu, selection);
    }
","    public void fillContextMenu(final IMenuManager menu) {
        super.fillContextMenu(menu);
        final ISelection selection = getContext().getSelection();
        if (selection.isEmpty()) {
            return;
        }

        // Wait the end of the loading of the representations file
        try {
            Job.getJobManager().join(AbstractRepresentationsFileJob.FAMILY, new NullProgressMonitor());
        } catch (InterruptedException e) {
           START   throw new RuntimeException(e); END 
        }

        // Differents behavior between win and linux : windows will not
        // display contextual menu if busy cursor while dialog is shown.

        // Fill the context menu
        contextMenuFiller.fillContextMenu(menu, selection);
    }
","    public void fillContextMenu(final IMenuManager menu) {
        super.fillContextMenu(menu);
        final ISelection selection = getContext().getSelection();
        if (selection.isEmpty()) {
            return;
        }

        // Wait the end of the loading of the representations file
        try {
            Job.getJobManager().join(AbstractRepresentationsFileJob.FAMILY, new NullProgressMonitor());
        } catch (InterruptedException e) {
            // Do nothing
        }

        // Differents behavior between win and linux : windows will not
        // display contextual menu if busy cursor while dialog is shown.

        // Fill the context menu
        contextMenuFiller.fillContextMenu(menu, selection);
    }
"
297,Are you sure about that cast operation? You are asking for a service interface and cast it to a concrete implementation without instanceof check. You perform that check in the tracker that is only added to a SaveablesList.,"	public void dispose() {
        // run super.
        super.dispose();

        // remove ourselves as a selection and registry listener
        getSite().getPage().removePostSelectionListener(this);
        RegistryFactory.getRegistry().removeListener(this);
		SaveablesList saveables = (SaveablesList) getSite().getService(ISaveablesLifecycleListener.class);
		if (saveables != null) {
			saveables.removeModelLifecycleListener(saveablesTracker);
		}
        currentPart = null;
        currentSelection = null;
        pinPropertySheetAction = null;
    }
","	public void dispose() {
        // run super.
        super.dispose();

        // remove ourselves as a selection and registry listener
        getSite().getPage().removePostSelectionListener(this);
        RegistryFactory.getRegistry().removeListener(this);
		SaveablesList saveables = START (SaveablesList) getSite().getService(ISaveablesLifecycleListener.class); END 
		if (saveables != null) {
			saveables.removeModelLifecycleListener(saveablesTracker);
		}
        currentPart = null;
        currentSelection = null;
        pinPropertySheetAction = null;
    }
","	public void dispose() {
        // run super.
        super.dispose();

        // remove ourselves as a selection and registry listener
        getSite().getPage().removePostSelectionListener(this);
        RegistryFactory.getRegistry().removeListener(this);
		ISaveablesLifecycleListener saveables = getSite().getService(ISaveablesLifecycleListener.class);
		if (saveables instanceof SaveablesList) {
			((SaveablesList) saveables).removeModelLifecycleListener(saveablesTracker);
		}
        currentPart = null;
        currentSelection = null;
        pinPropertySheetAction = null;
    }
"
298,`String.format()` is no longer necessary here.,"    public void setBaseballCard(BaseballCard card) {
        Locale locale = Locale.getDefault();
        brand.setText(card.brand);
        year.setText(String.format(locale, ""%d"", card.year));
        number.setText(String.format(locale, ""%s"", card.number));
        player.setText(card.playerName);
    }
","    public void setBaseballCard(BaseballCard card) {
        Locale locale = Locale.getDefault();
        brand.setText(card.brand);
        year.setText(String.format(locale, ""%d"", card.year));
START         number.setText(String.format(locale, ""%s"", card.number)); END 
        player.setText(card.playerName);
    }
","    public void setBaseballCard(BaseballCard card) {
        Locale locale = Locale.getDefault();
        brand.setText(card.brand);
        year.setText(String.format(locale, ""%d"", card.year));
        number.setText(card.number);
        player.setText(card.playerName);
    }
"
299,Can be static,"  private String capitalize(String word) {
    return Character.toUpperCase(word.charAt(0)) + word.substring(1);
  }
","START   private String capitalize(String word) { END 
    return Character.toUpperCase(word.charAt(0)) + word.substring(1);
  }
","  private static String capitalize(String word) {
    return Character.toUpperCase(word.charAt(0)) + word.substring(1);
  }
"
300,"instead of this, use (at the callsite where you have the JavaContext)
TypeDescriptor type = context.getType(expression);
return type != null && type.matchesSignature(JavaContext.TYPE_STRING);","    private static boolean isStringParameter(
            @NonNull Expression expression, @NonNull JavaContext context) {
        if (expression instanceof StringLiteral) {
            return true;
        } else {
            JavaParser.ResolvedNode resolvedNode = context.resolve(expression);
            if (resolvedNode instanceof JavaParser.ResolvedField) {
                if (((JavaParser.ResolvedField) resolvedNode).getValue() instanceof String) {
                    return true;
                }
            }
        }
        return false;
    }
","START     private static boolean isStringParameter( END 
            @NonNull Expression expression, @NonNull JavaContext context) {
        if (expression instanceof StringLiteral) {
            return true;
        } else {
            JavaParser.ResolvedNode resolvedNode = context.resolve(expression);
            if (resolvedNode instanceof JavaParser.ResolvedField) {
                if (((JavaParser.ResolvedField) resolvedNode).getValue() instanceof String) {
                    return true;
                }
            }
        }
        return false;
    }
","    private static boolean isStringParameter(
            @NonNull Expression expression, @NonNull JavaContext context) {
        if (expression instanceof StringLiteral) {
            return true;
        } else {
            ResolvedNode resolvedNode = context.resolve(expression);
            if (resolvedNode instanceof ResolvedField) {
                if (((ResolvedField) resolvedNode).getValue() instanceof String) {
                    return true;
                }
            }
        }
        return false;
    }
"
301,Nit: could we inline this to avoid unnecessary object creation,"        protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) {
            TopologyDetails td = getNextHighest();
            return getScore(availableCpu, availableMemory, availableGenericResources, td);
        }
","        protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) {
START             TopologyDetails td = getNextHighest(); END 
            return getScore(availableCpu, availableMemory, availableGenericResources, td);
        }
","        protected double getScore(double availableCpu, double availableMemory, Map<String, Double> availableGenericResources) {
            return getScore(availableCpu, availableMemory, availableGenericResources, getNextHighest());
        }
"
302,"I think this should be reverted, so it would still take into account additions from pre-`TransientActionFactory` implementations.","    public <T extends Action> List<T> getActions(Class<T> type) {
        List<T> _actions = Util.filter(getPersistedActions(), type);
        for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) {
            _actions.addAll(Util.filter(createFor(taf), type));
        }
        return Collections.unmodifiableList(_actions);
    }
","    public <T extends Action> List<T> getActions(Class<T> type) {
START         List<T> _actions = Util.filter(getPersistedActions(), type); END 
        for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) {
            _actions.addAll(Util.filter(createFor(taf), type));
        }
        return Collections.unmodifiableList(_actions);
    }
","    public <T extends Action> List<T> getActions(Class<T> type) {
        List<T> _actions = Util.filter(getActions(), type);
        for (TransientActionFactory<?> taf : TransientActionFactory.factoriesFor(getClass(), type)) {
            _actions.addAll(Util.filter(createFor(taf), type));
        }
        return Collections.unmodifiableList(_actions);
    }
"
303,ImageData for current image needs to be updated in the array?,"public void addRepresentation (ImageData srcImageData, int zoom) {
	if (srcImageData == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);
	int imageSelectorIndex = DPIUtil.mapZoomToImageSelectorIndex(zoom);
	if (imageSelectorIndex == device.getImageSelector ()) {
		init(srcImageData);
		init();
	}
	else {
		data [imageSelectorIndex] = srcImageData;
	}
}
","public void addRepresentation (ImageData srcImageData, int zoom) {
	if (srcImageData == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);
	int imageSelectorIndex = DPIUtil.mapZoomToImageSelectorIndex(zoom);
	if (imageSelectorIndex == device.getImageSelector ()) {
		init(srcImageData);
START 		init(); END 
	}
	else {
		data [imageSelectorIndex] = srcImageData;
	}
}
","public void addRepresentation (ImageData srcImageData, int zoom) {
	if (srcImageData == null) SWT.error(SWT.ERROR_NULL_ARGUMENT);
	int imageSelectorIndex = DPIUtil.mapZoomToImageSelectorIndex(zoom);
	if (imageSelectorIndex == getImageSelector ()) {
		init(srcImageData);
		init();
	}
	data [imageSelectorIndex] = srcImageData;
}
"
304,"you don't need to do that if you're already calling `loadProperties` in the public constructor, right? https://github.com/caelum/vraptor4/pull/973/files#diff-b7b62c45c7478eb642acfb81c12a4227R82","	private DefaultEnvironment buildEnvironment(EnvironmentType environmentType) {
		DefaultEnvironment defaultEnvironment = new DefaultEnvironment(environmentType);
		defaultEnvironment.setup();
		
		return defaultEnvironment;
	}
","	private DefaultEnvironment buildEnvironment(EnvironmentType environmentType) {
		DefaultEnvironment defaultEnvironment = new DefaultEnvironment(environmentType);
START 		defaultEnvironment.setup(); END 
		
		return defaultEnvironment;
	}
","	private DefaultEnvironment buildEnvironment(EnvironmentType environmentType) {
		DefaultEnvironment defaultEnvironment = new DefaultEnvironment(environmentType);
		
		return defaultEnvironment;
	}
"
305,"Style-nit: This is hard to read. Maybe:

  if (getRepositoryName() != null)
    return getRepositoryName().hashCode();
  return System.identityHashCode(this);","	public int hashCode() {
		return getRepositoryName() != null ? getRepositoryName().hashCode() :
				System.identityHashCode(this);
	}
","	public int hashCode() {
START 		return getRepositoryName() != null ? getRepositoryName().hashCode() : END 
				System.identityHashCode(this);
	}
","	public int hashCode() {
		if (getRepositoryName() != null)
			return getRepositoryName().hashCode();
		return System.identityHashCode(this);
	}
"
306,Can be removed and return only extensions without assigning logic.,"  public List<String> getExtensions() {
    return extensions == null ? DEFAULT_EXTS : extensions;
  }
","  public List<String> getExtensions() {
START     return extensions == null ? DEFAULT_EXTS : extensions; END 
  }
","  public List<String> getExtensions() {
    return extensions;
  }
"
307,use final,"	public List<RadiologyOrder> getRadiologyOrdersByPatient(Patient patient) {
		
		Criteria radiologyOrderCriteria = createRadiologyOrderCriteria();
		addRestrictionOnPatient(radiologyOrderCriteria, patient);
		
		List<RadiologyOrder> result = (List<RadiologyOrder>) radiologyOrderCriteria.list();
		return result == null ? new ArrayList<RadiologyOrder>() : result;
	}
","	public List<RadiologyOrder> getRadiologyOrdersByPatient(Patient patient) {
		
		Criteria radiologyOrderCriteria = createRadiologyOrderCriteria();
		addRestrictionOnPatient(radiologyOrderCriteria, patient);
		
START 		List<RadiologyOrder> result = (List<RadiologyOrder>) radiologyOrderCriteria.list(); END 
		return result == null ? new ArrayList<RadiologyOrder>() : result;
	}
","	public List<RadiologyOrder> getRadiologyOrdersByPatient(Patient patient) {
		
		Criteria radiologyOrderCriteria = createRadiologyOrderCriteria();
		addRestrictionOnPatient(radiologyOrderCriteria, patient);
		
		final List<RadiologyOrder> result = (List<RadiologyOrder>) radiologyOrderCriteria.list();
		return result == null ? new ArrayList<RadiologyOrder>() : result;
	}
"
308,This variable is useless in most cases. I would rather pass `new Object[] {}` to log method directly.,"    public Weld addExtensions(Class<? extends Extension>... extensionClasses) {
        Object[] constructorParams = new Object[] {};
        for (Class<? extends Extension> extensionClass : extensionClasses) {
            try {
                Extension extension =  SecurityActions.newInstance(extensionClass);
                addExtension(extension);
            } catch (Exception ex) {
                CommonLogger.LOG.unableToInstantiate(extensionClass, constructorParams, ex);
            }
        }
        return this;
    }
","    public Weld addExtensions(Class<? extends Extension>... extensionClasses) {
START         Object[] constructorParams = new Object[] {}; END 
        for (Class<? extends Extension> extensionClass : extensionClasses) {
            try {
                Extension extension =  SecurityActions.newInstance(extensionClass);
                addExtension(extension);
            } catch (Exception ex) {
                CommonLogger.LOG.unableToInstantiate(extensionClass, constructorParams, ex);
            }
        }
        return this;
    }
","    public Weld addExtensions(Class<? extends Extension>... extensionClasses) {
        for (Class<? extends Extension> extensionClass : extensionClasses) {
            try {
                Extension extension =  SecurityActions.newInstance(extensionClass);
                addExtension(extension);
            } catch (Exception ex) {
                CommonLogger.LOG.unableToInstantiate(extensionClass, new Object[] {}, ex);
            }
        }
        return this;
    }
"
309,If the last parameter is `true` then you need to overwrite `isLineInteresting`.,"	public RTTestsParser() {
		super(Messages._Warnings_RTTests_ParserName(),
			  Messages._Warnings_RTTests_LinkName(),
			  Messages._Warnings_RTTests_TrendName(),
			  CYCLICTEST_WARNING_PATTERN, true);
	}
","	public RTTestsParser() {
		super(Messages._Warnings_RTTests_ParserName(),
			  Messages._Warnings_RTTests_LinkName(),
			  Messages._Warnings_RTTests_TrendName(),
START 			  CYCLICTEST_WARNING_PATTERN, true); END 
	}
","    public RTTestsParser() {
        super(Messages._Warnings_RTTests_ParserName(),
              Messages._Warnings_RTTests_LinkName(),
              Messages._Warnings_RTTests_TrendName(),
              CYCLICTEST_WARNING_PATTERN);
    }
"
310,"You could use ternary if for this:

 return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;","    private ValidationResult hostExists() {
        if (getVds() == null) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        }

        return ValidationResult.VALID;
    }
","    private ValidationResult hostExists() {
START         if (getVds() == null) { END 
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        }

        return ValidationResult.VALID;
    }
","    private ValidationResult hostExists() {
        return getVds() == null ? new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST) : ValidationResult.VALID;
    }
"
311,"You can remove all the requireNonNull due to @NNBD.

I'm surprised we're allowed to use it, doing an explicit null check would be a compilation error...","        public static ToolTipString fromString(String text) {
            Objects.requireNonNull(text, ""fromString cannot take null""); //$NON-NLS-1$
            return new ToolTipString(text, toHtmlString(text));
        }
","        public static ToolTipString fromString(String text) {
START             Objects.requireNonNull(text, ""fromString cannot take null""); //$NON-NLS-1$ END 
            return new ToolTipString(text, toHtmlString(text));
        }
","        public static ToolTipString fromString(String text) {
            return new ToolTipString(text, toHtmlString(text));
        }
"
312,`if (listStations.isEmpty())`,"    public DataRadioStation getNextById(String id) {
        if (listStations.size() == 0)
            return null;

        for (int i = 0; i < listStations.size() - 1; i++) {
            if (listStations.get(i).ID.equals(id)) {
                    return listStations.get(i + 1);
            }
        }
        return listStations.get(0);
    }
","    public DataRadioStation getNextById(String id) {
START         if (listStations.size() == 0) END 
            return null;

        for (int i = 0; i < listStations.size() - 1; i++) {
            if (listStations.get(i).ID.equals(id)) {
                    return listStations.get(i + 1);
            }
        }
        return listStations.get(0);
    }
","    public DataRadioStation getNextById(String id) {
        if (listStations.isEmpty())
            return null;

        for (int i = 0; i < listStations.size() - 1; i++) {
            if (listStations.get(i).ID.equals(id)) {
                    return listStations.get(i + 1);
            }
        }
        return listStations.get(0);
    }
"
313,Please add the `{}` for the one-liner,"	public static void setBiomeArrayMethod(boolean jeidPresent) {
		try {
			if (jeidPresent) {
				biomeArrayMethod = Chunk.class.getMethod(""getIntBiomeArray"");
			}
			else
				biomeArrayMethod = Chunk.class.getMethod(""getBiomeArray"");
		}
		catch (NoSuchMethodException e) { throw new RuntimeException(e); }
	}
","	public static void setBiomeArrayMethod(boolean jeidPresent) {
		try {
			if (jeidPresent) {
				biomeArrayMethod = Chunk.class.getMethod(""getIntBiomeArray"");
			}
			else
START 				biomeArrayMethod = Chunk.class.getMethod(""getBiomeArray""); END 
		}
		catch (NoSuchMethodException e) { throw new RuntimeException(e); }
	}
","	public static void setBiomeArrayMethod(boolean jeidPresent) {
		try {
			if (jeidPresent) {
				biomeArrayMethod = Chunk.class.getMethod(""getIntBiomeArray"");
			}
			else {
				biomeArrayMethod = Chunk.class.getMethod(""getBiomeArray"");
			}
		}
		catch (NoSuchMethodException e) { throw new RuntimeException(e); }
	}
"
314,"I think since this will change in future release, it's better to let it be here so it's easier to update.","  public String getDescription() {
    return ""Transform files representing a structured table under an Alluxio directory.""
        + ""\n\n""
        + ""Files are coalesced and converted to parquet format.""
        + ""\n\n""
        + ""Definition is in format like 'write(hive).option(hive.num.files, 100)',""
        + ""currently, the only modification you can do to the example definition is ""
        + ""the number of files in the option.""
  }
","  public String getDescription() {
    return ""Transform files representing a structured table under an Alluxio directory.""
        + ""\n\n""
        + ""Files are coalesced and converted to parquet format.""
        + ""\n\n""
        + ""Definition is in format like 'write(hive).option(hive.num.files, 100)',""
        + ""currently, the only modification you can do to the example definition is ""
START         + ""the number of files in the option."" END 
  }
","  public String getDescription() {
    return ""Transform files representing a structured table under an Alluxio directory.""
        + ""\n\n""
        + ""Files are coalesced and converted to parquet format.""
        + ""\n\n""
        + ""Definition is in format like 'write(hive).option(hive.num.files, 100)',""
        + ""currently, the only modification you can do to the example definition is ""
        + ""the number of files in the option."";
  }
"
315,"Handling of nulls? You have some in the later methods, but not here...
If null is acceptable, we should return null here. If not, let's either add a lombok ```@NonNull``` or a ```Preconditions.checkNotNull(```. At present, nulls will give a non-useful NPE.","    public static void validateNonNegative(int[] data, String paramName){
        boolean nonnegative = true;

        for(int value : data){
            if(value < 0) {
                nonnegative = false;
            }
        }

        Preconditions.checkArgument(nonnegative,
                ""Values for %s must be >= 0, got: %s"", paramName, data);
    }
","START     public static void validateNonNegative(int[] data, String paramName){ END 
        boolean nonnegative = true;

        for(int value : data){
            if(value < 0) {
                nonnegative = false;
            }
        }

        Preconditions.checkArgument(nonnegative,
                ""Values for %s must be >= 0, got: %s"", paramName, data);
    }
","    public static void validateNonNegative(int[] data, String paramName){

        if(data == null) {
            return;
        }

        boolean nonnegative = true;

        for(int value : data){
            if(value < 0) {
                nonnegative = false;
            }
        }

        Preconditions.checkArgument(nonnegative,
                ""Values for %s must be >= 0, got: %s"", paramName, data);
    }
"
316,"Looking at this (and i realize this is my own crappy code), its really a configuration error for the files to fail to load, and we really don't want to be eating that and just putting something in the log.  Could you either remove the try block and make this constructor throw the IOException, or rethrow an exception with a little extra context?  Up to you which you prefer.","	public SetContentTypeFilter() {
		try {
			mimetypeToExtensionMap = new Properties();
			mimetypeToExtensionMap.load(new InputStreamReader(this.getClass().getResourceAsStream(
					""mimetypeToExtension.txt"")));
			contentTypeProperties = new Properties();
			contentTypeProperties.load(new InputStreamReader(this.getClass().getResourceAsStream(
					""toContentType.properties"")));
		} catch (IOException e) {
			log.error(""Failed to load mimetype mappings"", e);
		}
	}
","START 	public SetContentTypeFilter() { END 
		try {
			mimetypeToExtensionMap = new Properties();
			mimetypeToExtensionMap.load(new InputStreamReader(this.getClass().getResourceAsStream(
					""mimetypeToExtension.txt"")));
			contentTypeProperties = new Properties();
			contentTypeProperties.load(new InputStreamReader(this.getClass().getResourceAsStream(
					""toContentType.properties"")));
		} catch (IOException e) {
			log.error(""Failed to load mimetype mappings"", e);
		}
	}
","    public SetContentTypeFilter() throws IOException {
        mimetypeToExtensionMap = new Properties();
        mimetypeToExtensionMap.load(new InputStreamReader(this.getClass().getResourceAsStream(
                ""mimetypeToExtension.txt"")));
        contentTypeProperties = new Properties();
        contentTypeProperties.load(new InputStreamReader(this.getClass().getResourceAsStream(
                ""toContentType.properties"")));
    }
"
317,"Instead of passing null, remove this check and call this method with a new Properties object.","   private SwiftApi api(String authUrl, Properties overrides) throws IOException {
      if (overrides == null){
         overrides = new Properties();
      }
      overrides.setProperty(CREDENTIAL_TYPE, ""tempAuthCredentials"");
      return ContextBuilder.newBuilder(new SwiftApiMetadata())
            .credentials(""user"", ""password"")
            .endpoint(authUrl)
            .overrides(overrides)
            .modules(ImmutableSet.of(new ExecutorServiceModule(sameThreadExecutor())))
            .buildApi(SwiftApi.class);
   }
","   private SwiftApi api(String authUrl, Properties overrides) throws IOException {
      if (overrides == null){
         overrides = new Properties();
START       } END 
      overrides.setProperty(CREDENTIAL_TYPE, ""tempAuthCredentials"");
      return ContextBuilder.newBuilder(new SwiftApiMetadata())
            .credentials(""user"", ""password"")
            .endpoint(authUrl)
            .overrides(overrides)
            .modules(ImmutableSet.of(new ExecutorServiceModule(sameThreadExecutor())))
            .buildApi(SwiftApi.class);
   }
","   private SwiftApi api(String authUrl, Properties overrides) throws IOException {
      overrides.setProperty(CREDENTIAL_TYPE, ""tempAuthCredentials"");
      return ContextBuilder.newBuilder(new SwiftApiMetadata())
            .credentials(""user"", ""password"")
            .endpoint(authUrl)
            .overrides(overrides)
            .modules(ImmutableSet.of(new ExecutorServiceModule(sameThreadExecutor())))
            .buildApi(SwiftApi.class);
   }
"
318,add null check,"    public void setAcceptableValues(Collection<K> values) {
        buttons.clear();
        panels.clear();
        wrapperPanel.clear();

        for (final K value : values) {
            addValue(value);
        }

        updateButtons();
    }
","    public void setAcceptableValues(Collection<K> values) {
        buttons.clear();
        panels.clear();
        wrapperPanel.clear();

START         for (final K value : values) { END 
            addValue(value);
        }

        updateButtons();
    }
","    public void setAcceptableValues(Collection<K> values) {
        buttons.clear();
        panels.clear();
        wrapperPanel.clear();

        if (values != null) {
            for (final K value : values) {
                addValue(value);
            }
        }

        updateButtons();
    }
"
319,"`StorageException` is a runtime exception, no need to catch and rethrow it (several occurrences).","    public Bucket getOrCreateBucket(String bucketName) {
        try {
            Bucket bucket = storage.get(bucketName);
            if (bucket == null) {
                log.debug(String.format(""Creating a new bucket %s"", bucketName));
                return storage.create(BucketInfo.of(bucketName));
            }
            return bucket;
        } catch (StorageException e) {
            throw new NuxeoException(e);
        }
    }
","    public Bucket getOrCreateBucket(String bucketName) {
        try {
            Bucket bucket = storage.get(bucketName);
            if (bucket == null) {
                log.debug(String.format(""Creating a new bucket %s"", bucketName));
                return storage.create(BucketInfo.of(bucketName));
            }
            return bucket;
        } catch (StorageException e) {
START             throw new NuxeoException(e); END 
        }
    }
","    public Bucket getOrCreateBucket(String bucketName) {
        Bucket bucket = storage.get(bucketName);
        if (bucket == null) {
            log.debug(String.format(""Creating a new bucket %s"", bucketName));
            return storage.create(BucketInfo.of(bucketName));
        }
        return bucket;
    }
"
320,"You need to keep in mind that the sentence construction in other languages could be different, so the query string doesn't always show at the end. You should use %1$s in your string on values/strings.xml and pass the query term as an extra argument to getString()","    private void onFragmentLoaded() {
        if (searchAdapter == null) {
            searchAdapter = new SearchlistAdapter(getActivity(), itemAccess);
            setListAdapter(searchAdapter);
        }
        searchAdapter.notifyDataSetChanged();
        setListShown(true);

        String query = getArguments().getString(ARG_QUERY);
        setEmptyText(getString(R.string.no_results_for_query) + "" \"""" + query + ""\"""");
    }
","    private void onFragmentLoaded() {
        if (searchAdapter == null) {
            searchAdapter = new SearchlistAdapter(getActivity(), itemAccess);
            setListAdapter(searchAdapter);
        }
        searchAdapter.notifyDataSetChanged();
        setListShown(true);

        String query = getArguments().getString(ARG_QUERY);
START         setEmptyText(getString(R.string.no_results_for_query) + "" \"""" + query + ""\""""); END 
    }
","    private void onFragmentLoaded() {
        if (searchAdapter == null) {
            searchAdapter = new SearchlistAdapter(getActivity(), itemAccess);
            setListAdapter(searchAdapter);
        }
        searchAdapter.notifyDataSetChanged();
        setListShown(true);

        String query = getArguments().getString(ARG_QUERY);
        setEmptyText(getString(R.string.no_results_for_query, query));
    }
"
321,Thanks. Marking resolved.,"	private Iterable<Ref> getSortedRefs() throws Exception {
		List<Ref> all = db.getRefDatabase().getRefsByPrefix(ALL);
		if (all instanceof RefMap
				|| (all instanceof SortedMap
						&& ((SortedMap) all).comparator() == null)) {
			return all;
		}
		return RefComparator.sort(all);
	}
","	private Iterable<Ref> getSortedRefs() throws Exception {
		List<Ref> all = db.getRefDatabase().getRefsByPrefix(ALL);
START 		if (all instanceof RefMap END 
				|| (all instanceof SortedMap
						&& ((SortedMap) all).comparator() == null)) {
			return all;
		}
		return RefComparator.sort(all);
	}
","	private Iterable<Ref> getSortedRefs() throws Exception {
		List<Ref> all = db.getRefDatabase().getRefsByPrefix(ALL);
		// TODO(jrn) check if we can reintroduce fast-path by e.g. implementing
		// SortedList
		return RefComparator.sort(all);
	}
"
322,"I don't understand why you need to create a new ArrayList for a collection that is coming from a query - it is necessarily not being used by anyone else.

Also, why cast what's coming from the backend to an ArrayList? This means you're committing to a specific implementation. I think a cast to Collection is more appropriate.

If it's important for you to have the end result in specifically an ArrayList (and not any other kind of collection), then I would create a new ArrayList, but still cast the result from the backend to Collection.","    private static void convertAAAProfilesResult(AsyncQuery aQuery) {
        aQuery.converterCallback = new IAsyncConverter() {
            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery)
            {
                List<String> results = new ArrayList<String>();
                for (ProfileEntry profileEntry : source != null ? new ArrayList<ProfileEntry>((ArrayList<ProfileEntry>) source)
                        : new ArrayList<ProfileEntry>()) {
                    results.add(profileEntry.getProfile());
                }
                return results;
            }
        };
    }
","    private static void convertAAAProfilesResult(AsyncQuery aQuery) {
        aQuery.converterCallback = new IAsyncConverter() {
            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery)
            {
                List<String> results = new ArrayList<String>();
START                 for (ProfileEntry profileEntry : source != null ? new ArrayList<ProfileEntry>((ArrayList<ProfileEntry>) source) END 
                        : new ArrayList<ProfileEntry>()) {
                    results.add(profileEntry.getProfile());
                }
                return results;
            }
        };
    }
","    private static void convertAAAProfilesResult(AsyncQuery aQuery) {
        aQuery.converterCallback = new IAsyncConverter() {
            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery)
            {
                List<String> results = new ArrayList<String>();
                for (ProfileEntry profileEntry : source != null ? (Collection<ProfileEntry>) source
                        : new ArrayList<ProfileEntry>()) {
                    results.add(profileEntry.getProfile());
                }
                return results;
            }
        };
    }
"
323,Since the `class` has _package_ protected access the constructor can probably have _package_ protection too?,"    public FunctionKindRowColumnHeaderMetaData(final Supplier<FunctionDefinition> functionSupplier,
                                               final CellEditorControlsView.Presenter cellEditorControls,
                                               final KindPopoverView.Presenter editor,
                                               final Optional<String> editorTitle,
                                               final FunctionGrid gridWidget) {
        super(cellEditorControls,
              editor,
              editorTitle);

        this.functionSupplier = functionSupplier;
        this.gridWidget = gridWidget;
    }
","START     public FunctionKindRowColumnHeaderMetaData(final Supplier<FunctionDefinition> functionSupplier, END 
                                               final CellEditorControlsView.Presenter cellEditorControls,
                                               final KindPopoverView.Presenter editor,
                                               final Optional<String> editorTitle,
                                               final FunctionGrid gridWidget) {
        super(cellEditorControls,
              editor,
              editorTitle);

        this.functionSupplier = functionSupplier;
        this.gridWidget = gridWidget;
    }
","    FunctionKindRowColumnHeaderMetaData(final Supplier<FunctionDefinition> functionSupplier,
                                        final CellEditorControlsView.Presenter cellEditorControls,
                                        final KindPopoverView.Presenter editor,
                                        final Optional<String> editorTitle,
                                        final FunctionGrid gridWidget) {
        super(cellEditorControls,
              editor,
              editorTitle);

        this.functionSupplier = functionSupplier;
        this.gridWidget = gridWidget;
    }
"
324,Wouldn't starts with make more sense?,"    public List<ProxiedPlayer> matchPlayer(String partialName) {

        List<ProxiedPlayer> matched = new ArrayList<ProxiedPlayer>();

        for (ProxiedPlayer iPlayer : this.getPlayers()) {
            String iterPlayerName = iPlayer.getName();

            if (partialName.equalsIgnoreCase(iterPlayerName)) {
            	matched.add(iPlayer);
                break;
            }
            if (iterPlayerName.toLowerCase().contains(partialName.toLowerCase())) {
            	matched.add(iPlayer);
            }
        }

        return matched;
    }
","    public List<ProxiedPlayer> matchPlayer(String partialName) {

        List<ProxiedPlayer> matched = new ArrayList<ProxiedPlayer>();

        for (ProxiedPlayer iPlayer : this.getPlayers()) {
            String iterPlayerName = iPlayer.getName();

            if (partialName.equalsIgnoreCase(iterPlayerName)) {
            	matched.add(iPlayer);
                break;
            }
START             if (iterPlayerName.toLowerCase().contains(partialName.toLowerCase())) { END 
            	matched.add(iPlayer);
            }
        }

        return matched;
    }
","    public List<ProxiedPlayer> matchPlayer(String partialName) {

        List<ProxiedPlayer> matched = new ArrayList<ProxiedPlayer>();

        for (ProxiedPlayer iPlayer : this.getPlayers()) {
            String iterPlayerName = iPlayer.getName();

            if (partialName.equalsIgnoreCase(iterPlayerName)) {
            	matched.add(iPlayer);
                break;
            }
            if (iterPlayerName.toLowerCase().startsWith(partialName.toLowerCase())) {
            	matched.add(iPlayer);
            }
        }

        return matched;
    }
"
325,"I notice in the unzigzag method below, you use the unsigned right shift operator (`>>>`), but here you're using the signed one (`>>`). Is that intentional?","    private int zigzagDecode(int input) {
        return (input >> 1) ^ (-(input & 1));
    }
","    private int zigzagDecode(int input) {
START         return (input >> 1) ^ (-(input & 1)); END 
    }
","    private int zigzagDecode(int input) {
        return (input >>> 1) ^ (-(input & 1));
    }
"
326,Please create method`doTest() { doTest(GoStringIndexIsByteQuickFix.NAME); }` and maybe same method `doTestNoFix()`,"  public void testEqualsCondition()         { doTest(GoStringIndexIsByteQuickFix.NAME); }
","START   public void testEqualsCondition()         { doTest(GoStringIndexIsByteQuickFix.NAME); } END 
","  public void testEqualsCondition()                 { doTest(); }
"
327,"why do we need try/catch here? It should not fail, and if it fails, junit will take care about the stack etc","	public void testRedrawAfterDispose() {
		LineNumberRulerColumn lineNumberRulerColumn= new LineNumberRulerColumn();
		CompositeRuler ruler= new CompositeRuler();
		ruler.addDecorator(0, lineNumberRulerColumn);
		SourceViewer sourceViewer= new SourceViewer(fParent, ruler, SWT.NONE);
		lineNumberRulerColumn.getControl().setSize(10, 10);

		sourceViewer.getTextWidget().dispose();
		try {
			lineNumberRulerColumn.redraw();
		} catch (Exception notExpected) {
			notExpected.printStackTrace();
			fail();
		}

	}
","	public void testRedrawAfterDispose() {
		LineNumberRulerColumn lineNumberRulerColumn= new LineNumberRulerColumn();
		CompositeRuler ruler= new CompositeRuler();
		ruler.addDecorator(0, lineNumberRulerColumn);
		SourceViewer sourceViewer= new SourceViewer(fParent, ruler, SWT.NONE);
		lineNumberRulerColumn.getControl().setSize(10, 10);

		sourceViewer.getTextWidget().dispose();
		try {
			lineNumberRulerColumn.redraw();
		} START  catch (Exception END  notExpected) {
			notExpected.printStackTrace();
			fail();
		}

	}
","	public void testRedrawAfterDispose() {
		LineNumberRulerColumn lineNumberRulerColumn= new LineNumberRulerColumn();
		CompositeRuler ruler= new CompositeRuler();
		ruler.addDecorator(0, lineNumberRulerColumn);
		SourceViewer sourceViewer= new SourceViewer(fParent, ruler, SWT.NONE);
		lineNumberRulerColumn.getControl().setSize(10, 10);

		sourceViewer.getTextWidget().dispose();

		lineNumberRulerColumn.redraw();
	}
"
328,"Please consider adding an overridden version of the `Script(String, int, Logger)` constructor that accepts `Duration` to encapsulate this type conversion.","    public boolean configureDefaultNetworkRulesForSystemVm(final Connect conn, final String vmName) {
        if (!_canBridgeFirewall) {
            return false;
        }

        final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger);
        cmd.add(""default_network_rules_systemvm"");
        cmd.add(""--vmname"", vmName);
        cmd.add(""--localbrname"", _linkLocalBridgeName);
        final String result = cmd.execute();
        if (result != null) {
            return false;
        }
        return true;
    }
","    public boolean configureDefaultNetworkRulesForSystemVm(final Connect conn, final String vmName) {
        if (!_canBridgeFirewall) {
            return false;
        }

START         final Script cmd = new Script(_securityGroupPath, _timeout.getMillis(), s_logger); END 
        cmd.add(""default_network_rules_systemvm"");
        cmd.add(""--vmname"", vmName);
        cmd.add(""--localbrname"", _linkLocalBridgeName);
        final String result = cmd.execute();
        if (result != null) {
            return false;
        }
        return true;
    }
","    public boolean configureDefaultNetworkRulesForSystemVm(final Connect conn, final String vmName) {
        if (!_canBridgeFirewall) {
            return false;
        }

        final Script cmd = new Script(_securityGroupPath, _timeout, s_logger);
        cmd.add(""default_network_rules_systemvm"");
        cmd.add(""--vmname"", vmName);
        cmd.add(""--localbrname"", _linkLocalBridgeName);
        final String result = cmd.execute();
        if (result != null) {
            return false;
        }
        return true;
    }
"
329,shouldn't it be `> 1`,"    public void testQueryCumulativeTable()
    {
        computeActual(""SELECT * FROM \""*:*\"""");
        computeActual(""SELECT * FROM \""java.util.logging:*\"""");
        assertTrue(computeActual(""SELECT * FROM \""java.lang:*\"""").getRowCount() > 0);
        assertTrue(computeActual(""SELECT * FROM \""jAVA.LANg:*\"""").getRowCount() > 0);
    }
","    public void testQueryCumulativeTable()
    {
        computeActual(""SELECT * FROM \""*:*\"""");
        computeActual(""SELECT * FROM \""java.util.logging:*\"""");
START         assertTrue(computeActual(""SELECT * FROM \""java.lang:*\"""").getRowCount() > 0); END 
        assertTrue(computeActual(""SELECT * FROM \""jAVA.LANg:*\"""").getRowCount() > 0);
    }
","    public void testQueryCumulativeTable()
    {
        computeActual(""SELECT * FROM \""*:*\"""");
        computeActual(""SELECT * FROM \""java.util.logging:*\"""");
        assertTrue(computeActual(""SELECT * FROM \""java.lang:*\"""").getRowCount() > 1);
        assertTrue(computeActual(""SELECT * FROM \""jAVA.LANg:*\"""").getRowCount() > 1);
    }
"
330,should these be `debug` level?,"  public RequestLogger get()
  {
    LoggingRequestLogger logger = new LoggingRequestLogger(mapper, setMDC, setContextMDC);
    log.info(new Exception(""Stack trace""), ""Creating %s at"", logger);
    return logger;
  }
","  public RequestLogger get()
  {
    LoggingRequestLogger logger = new LoggingRequestLogger(mapper, setMDC, setContextMDC);
START     log.info(new Exception(""Stack trace""), ""Creating %s at"", logger); END 
    return logger;
  }
","  public RequestLogger get()
  {
    LoggingRequestLogger logger = new LoggingRequestLogger(mapper, setMDC, setContextMDC);
    log.debug(new Exception(""Stack trace""), ""Creating %s at"", logger);
    return logger;
  }
"
331,shouldn't we wrap the original `e` ?,"    private IllegalReferenceCountException handleIllegalReferenceCountException(IllegalReferenceCountException e) {
        String accessRecord = leak.toString();
        if (StringUtil.isNullOrEmpty(accessRecord)) {
            // means leak has been closed and there is no accessRecord.
            return e;
        }
        return new TrackedIllegalReferenceCountException(e.getMessage(), accessRecord);
    }
","    private IllegalReferenceCountException handleIllegalReferenceCountException(IllegalReferenceCountException e) {
        String accessRecord = leak.toString();
        if (StringUtil.isNullOrEmpty(accessRecord)) {
            // means leak has been closed and there is no accessRecord.
            return e;
        }
START         return new TrackedIllegalReferenceCountException(e.getMessage(), accessRecord); END 
    }
","    private IllegalReferenceCountException handleIllegalReferenceCountException(IllegalReferenceCountException e) {
        String accessRecord = leak.toString();
        if (StringUtil.isNullOrEmpty(accessRecord)) {
            // means leak has been closed and there is no accessRecord.
            return e;
        }
        return new TrackedIllegalReferenceCountException(accessRecord, e);
    }
"
332,The new flag `withAttempts` is not passed (used) the  `paymentProcessor#getAccountPayments`,"    public List<Payment> getAccountPayments(final UUID accountId, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException {
        return paymentProcessor.getAccountPayments(accountId, withPluginInfo, tenantContext, internalCallContextFactory.createInternalTenantContext(accountId, tenantContext));
    }
","    public List<Payment> getAccountPayments(final UUID accountId, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException {
START         return paymentProcessor.getAccountPayments(accountId, withPluginInfo, tenantContext, internalCallContextFactory.createInternalTenantContext(accountId, tenantContext)); END 
    }
","    public List<Payment> getAccountPayments(final UUID accountId, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException {
        return paymentProcessor.getAccountPayments(accountId, withPluginInfo, withAttempts, tenantContext, internalCallContextFactory.createInternalTenantContext(accountId, tenantContext));
    }
"
333,"No need to cast to `String`,  here `getParam` is a generic method `public <T> T getParam(String key)`","        public void startBucket(String bucketKey) {
            BulkCommand command = getCurrentCommand();
            Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER);
            disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString());
            retentionManager = Framework.getService(RetentionManager.class);
            ruleId = (String) command.getParam(PARAM_RULE_ID);
        }
","        public void startBucket(String bucketKey) {
            BulkCommand command = getCurrentCommand();
            Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER);
            disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString());
            retentionManager = Framework.getService(RetentionManager.class);
START             ruleId = (String) command.getParam(PARAM_RULE_ID); END 
        }
","        public void startBucket(String bucketKey) {
            BulkCommand command = getCurrentCommand();
            Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER);
            disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString());
            retentionManager = Framework.getService(RetentionManager.class);
            ruleId = command.getParam(PARAM_RULE_ID);
        }
"
334,should this check that the queue is not 0?  Why acquire a connection if there are no waiting exchanges?,"    public boolean remove(Connection connection)
    {
        boolean removed = connectionPool.remove(connection);

        if (getHttpExchanges().isEmpty())
        {
            tryRemoveIdleDestination();
        }
        else
        {
            // We need to execute queued requests
            // even if this connection was removed.
            // We may create a connection that is not
            // needed, but it will eventually idle timeout.
            if (removed)
                process(true);
        }
        return connectionPool.remove(connection);
    }
","    public boolean remove(Connection connection)
    {
        boolean removed = connectionPool.remove(connection);

        if (getHttpExchanges().isEmpty())
        {
            tryRemoveIdleDestination();
        }
        else
        {
            // We need to execute queued requests
            // even if this connection was removed.
            // We may create a connection that is not
            // needed, but it will eventually idle timeout.
            if (removed)
START                 process(true); END 
        }
        return connectionPool.remove(connection);
    }
","    public boolean remove(Connection connection)
    {
        boolean removed = connectionPool.remove(connection);

        if (getHttpExchanges().isEmpty())
        {
            tryRemoveIdleDestination();
        }
        else if (removed)
        {
            // Process queued requests that may be waiting.
            // We may create a connection that is not
            // needed, but it will eventually idle timeout.
            process(true);
        }
        return removed;
    }
"
335,"return null ? I think you meant 'false', did not you?","    public boolean getRewriteBatchedStatements() {
        final String isRewrite = super.connectionProperties.getProperty(REWRITE_BATCHED_STATEMENTS);
        return isRewrite == null ? null : Boolean.valueOf(isRewrite);
    }
","    public boolean getRewriteBatchedStatements() {
        final String isRewrite = super.connectionProperties.getProperty(REWRITE_BATCHED_STATEMENTS);
START         return isRewrite == null ? null : Boolean.valueOf(isRewrite); END 
    }
","    public boolean getRewriteBatchedStatements() {
        final String isRewrite = super.connectionProperties.getProperty(REWRITE_BATCHED_STATEMENTS);
        return isRewrite == null ? false : Boolean.valueOf(isRewrite);
    }
"
336,"I am little wary about this. coz, all our existing schedulers are using this and setting this might cause them to be removed immediately. Even though ideally we want to be in that position, when rolling this out, don't want to have any unexpected behaviors.","  public static ScheduledExecutorService newScheduler(int numThreads, String threadNamePrefix, boolean isDaemon) {
    ScheduledThreadPoolExecutor scheduler =
        new ScheduledThreadPoolExecutor(numThreads, new SchedulerThreadFactory(threadNamePrefix, isDaemon));
    scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
    scheduler.setRemoveOnCancelPolicy(true);
    return scheduler;
  }
","  public static ScheduledExecutorService newScheduler(int numThreads, String threadNamePrefix, boolean isDaemon) {
    ScheduledThreadPoolExecutor scheduler =
        new ScheduledThreadPoolExecutor(numThreads, new SchedulerThreadFactory(threadNamePrefix, isDaemon));
    scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
START     scheduler.setRemoveOnCancelPolicy(true); END 
    return scheduler;
  }
","  public static ScheduledExecutorService newScheduler(int numThreads, String threadNamePrefix, boolean isDaemon) {
    ScheduledThreadPoolExecutor scheduler =
        new ScheduledThreadPoolExecutor(numThreads, new SchedulerThreadFactory(threadNamePrefix, isDaemon));
    scheduler.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
    return scheduler;
  }
"
337,"Ah, that's what you meant. =)

No, this isn't good: it's too generic, it wouldn't help you debug a failure. The validator itself has to log a warning and then return false, so that the warning can be very specific on what went wrong, i.e. the new value being beyond the maximum value allowed.","    public boolean setValue(T newValue) {
        if (!validator.validate(newValue)) {
            LOGGER.warn(""The passed value {} is invalid."", newValue);
            return false;
        }

        PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue);
        this.value = newValue;
        dispatchChangedEvent(event);

        return true;
    }
","    public boolean setValue(T newValue) {
        if (!validator.validate(newValue)) {
START             LOGGER.warn(""The passed value {} is invalid."", newValue); END 
            return false;
        }

        PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue);
        this.value = newValue;
        dispatchChangedEvent(event);

        return true;
    }
","    public boolean setValue(T newValue) {
        if (!validate(newValue)) {
            return false;
        }

        PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue);
        this.value = newValue;
        dispatchChangedEvent(event);

        return true;
    }
"
338,Do we really want to move this from `trace` to `debug`?,"    public void onMessage(MessageHolderWithTokens message) {
        try {
            logger.debug(""receiving tokens from queue, triggering Notification Dispatcher class to pick the right sender"");
            dequeueEvent.fire(message);
        } catch (DispatchInitiationException e) {
            throw e;
        } catch (Exception e) {
            logger.error(""NotificationDispatcher or PushNotificationSender unexpectedly failed, the message won't be redelivered"", e);
        }
    }
","    public void onMessage(MessageHolderWithTokens message) {
        try {
START             logger.debug(""receiving tokens from queue, triggering Notification Dispatcher class to pick the right sender""); END 
            dequeueEvent.fire(message);
        } catch (DispatchInitiationException e) {
            throw e;
        } catch (Exception e) {
            logger.error(""NotificationDispatcher or PushNotificationSender unexpectedly failed, the message won't be redelivered"", e);
        }
    }
","    public void onMessage(MessageHolderWithTokens message) {
        try {
            logger.trace(""receiving tokens from queue, triggering Notification Dispatcher class to pick the right sender"");
            dequeueEvent.fire(message);
        } catch (DispatchInitiationException e) {
            throw e;
        } catch (Exception e) {
            logger.error(""NotificationDispatcher or PushNotificationSender unexpectedly failed, the message won't be redelivered"", e);
        }
    }
"
339,"why not:

 return result.addAll(cacheMap.keySet());","	private Collection<Key> getRegisteredKeys() {
		List<Key> result = new ArrayList<Key>();
		for (Iterator<Key> i = cacheMap.keySet().iterator(); i.hasNext();) {
			result.add(i.next());
		}
		return result;
	}
","	private Collection<Key> getRegisteredKeys() {
		List<Key> result = new ArrayList<Key>();
START 		for (Iterator<Key> i = cacheMap.keySet().iterator(); i.hasNext();) {
			result.add(i.next());
		}
		return result; END 
	}
","	private Collection<Key> getRegisteredKeys() {
		return new ArrayList<Key>(cacheMap.keySet());
	}
"
340,I would make this constructor `protected` because you cannot directly instantiate abstract classes. See the answers to http://stackoverflow.com/questions/260666/can-an-abstract-class-have-a-constructor for a discussion.,"  public AbstractMetric(String metricName, String metricType, T initialValue, MetricReportManager manager) {
    name = metricName;
    type = metricType;
    value = initialValue;
    metricManager = manager;
  }
","START   public AbstractMetric(String metricName, String metricType, T initialValue, MetricReportManager manager) { END 
    name = metricName;
    type = metricType;
    value = initialValue;
    metricManager = manager;
  }
","  protected AbstractMetric(String metricName, String metricType, T initialValue, MetricReportManager manager) {
    name = metricName;
    type = metricType;
    value = initialValue;
    metricManager = manager;
  }
"
341,Shouldn't this line be something like AssertTrue(allergy.hasSameValues(allergy())); ?,"	public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues() {
		Allergy allergy = allergy();
		allergy.hasSameValues(allergy());
	}
","	public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues() {
		Allergy allergy = allergy();
START 		allergy.hasSameValues(allergy()); END 
	}
","	public void hasSameValues_checkingAgainstSameInstanceOfAllergy_shouldInterpretAsSameValues() {
		Allergy allergy = allergy();
		assertThat(allergy.hasSameValues(allergy()),is(true));
	}
"
342,You are open a stream object without closing it never. Maybe you can use the try-with-resources statement here and avoid / handle the unhandled IOException here.,"    private static String readMapping() throws IOException, ParseException {
        JSONParser parser = new JSONParser();
        ClassLoader classloader = Thread.currentThread().getContextClassLoader();
        InputStream inputStream = classloader.getResourceAsStream(""mapping.json"");
        String mapping = IOUtils.toString(inputStream, ""UTF-8"");
        Object object = parser.parse(mapping);
        JSONObject jsonObject = (JSONObject) object;
        return jsonObject.toJSONString();
    }
","    private static String readMapping() throws IOException, ParseException {
        JSONParser parser = new JSONParser();
        ClassLoader classloader = Thread.currentThread().getContextClassLoader();
START         InputStream inputStream = classloader.getResourceAsStream(""mapping.json""); END 
        String mapping = IOUtils.toString(inputStream, ""UTF-8"");
        Object object = parser.parse(mapping);
        JSONObject jsonObject = (JSONObject) object;
        return jsonObject.toJSONString();
    }
","    private static String readMapping() throws ParseException {
        JSONParser parser = new JSONParser();
        ClassLoader classloader = Thread.currentThread().getContextClassLoader();
        try (InputStream inputStream = classloader.getResourceAsStream(""mapping.json"")) {
            String mapping = IOUtils.toString(inputStream, ""UTF-8"");
            Object object = parser.parse(mapping);
            JSONObject jsonObject = (JSONObject) object;
            return jsonObject.toJSONString();
        } catch (IOException e) {
            logger.error(e);
            return """";
        }
    }
"
343,"@mjwall  I found the bug.  Its my fault, I suggested clearing `observedColumns` and that is a bad thing to do.  `observedColumns` is shared between transactions.  It should be an immutable set, I'll open an issue for that.","  public synchronized void commit() throws CommitException {
    SyncCommitObserver sco = null;
    try {
      sco = new SyncCommitObserver();
      commitAsync(sco);
      sco.waitForCommit();
    } finally {
      updates.clear();
      weakNotification = null;
      observedColumns.clear();
      columnsRead.clear();
    }
  }
","  public synchronized void commit() throws CommitException {
    SyncCommitObserver sco = null;
    try {
      sco = new SyncCommitObserver();
      commitAsync(sco);
      sco.waitForCommit();
    } finally {
      updates.clear();
      weakNotification = null;
START       observedColumns.clear(); END 
      columnsRead.clear();
    }
  }
","  public synchronized void commit() throws CommitException {
    SyncCommitObserver sco = null;
    try {
      sco = new SyncCommitObserver();
      commitAsync(sco);
      sco.waitForCommit();
    } finally {
      updates.clear();
      weakNotification = null;
      columnsRead.clear();
    }
  }
"
344,"I would simplify to ""return isValid(buf,off) && (buf[off] & X_BIT != 0) && (buf[off+1] & I_BIT) != 0)""","        public static boolean hasPictureId(byte[] buf, int off, int len)
        {
            if (!isValid(buf, off))
                return false;

            if ((buf[off] & X_BIT) == 0
                || (buf[off+1] & I_BIT) == 0)
                return false;

            return true;
        }
","        public static boolean hasPictureId(byte[] buf, int off, int len)
        {
            if (!isValid(buf, off))
                return false;

            if ((buf[off] & X_BIT) == 0
                || (buf[off+1] & I_BIT) == 0)
START                 return false; END 

            return true;
        }
","        public static boolean hasPictureId(byte[] buf, int off, int len)
        {
            return isValid(buf, off, len)
                && (buf[off] & X_BIT) != 0 && (buf[off+1] & I_BIT) != 0;
        }
"
345,remove the println,"    public void setEnabled(boolean enabled) {
        this.active = enabled;
        System.out.println(""active state change: "" + active);
        updateButtonState();
    }
","    public void setEnabled(boolean enabled) {
        this.active = enabled;
START         System.out.println(""active state change: "" + active); END 
        updateButtonState();
    }
","    public void setEnabled(boolean enabled) {
        this.active = enabled;
        updateButtonState();
    }
"
346,Same here. I dont think we should be throwing exceptions.We should instead be having empty implementations.,"    default void beforeDataProviderExecution(IDataProviderMethod dataProviderMethod, ITestNGMethod method, ITestContext iTestContext) {
        throw new UnsupportedOperationException(""Method is not implemented"");
    }
","START     default void beforeDataProviderExecution(IDataProviderMethod dataProviderMethod, ITestNGMethod method, ITestContext iTestContext) { END 
        throw new UnsupportedOperationException(""Method is not implemented"");
    }
","    default void beforeDataProviderExecution(IDataProviderMethod dataProviderMethod, ITestNGMethod method, ITestContext iTestContext) {
        // not implemented
    }
"
347,the inner 'if' isn't needed - the conditions can be added to the outer 'if',"    private void handleEndActionJobAndStep() {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
            if (!parentHasCallback() || getExecutionContext().getExecutionMethod() == ExecutionMethod.AsStep) {
                startFinalizingStep();
            }
        }
    }
","    private void handleEndActionJobAndStep() {
        if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
START             if (!parentHasCallback() || getExecutionContext().getExecutionMethod() == ExecutionMethod.AsStep) { END 
                startFinalizingStep();
            }
        }
    }
","    private void handleEndActionJobAndStep() {
        if ((!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) &&
                (!parentHasCallback() || getExecutionContext().getExecutionMethod() == ExecutionMethod.AsStep)) {
            startFinalizingStep();
        }
    }
"
348,why did you change the do ... while into a while do loop. The caller already knows the scan state is not equal to state and since this is a private method it is safe to assume that the caller has already checked (under the lock) that he has to wait for a state change.,"    private boolean waitForScanState(ScanStates state) {
        try {
			while (!getScanState().equals(state)) {
                scanState.wait();
            }

            return true;
        } catch (InterruptedException e) {
            tsLogger.logger.warn(""problem waiting for scanLock whilst in state "" + state.name(), e);
            return false;
        }
    }
","    private boolean waitForScanState(ScanStates state) {
        try {
START 			while (!getScanState().equals(state)) { END 
                scanState.wait();
            }

            return true;
        } catch (InterruptedException e) {
            tsLogger.logger.warn(""problem waiting for scanLock whilst in state "" + state.name(), e);
            return false;
        }
    }
","    private boolean waitForScanState(ScanStates state) {
        try {
            do {
                scanState.wait();
            } while (!getScanState().equals(state));

            return true;
        } catch (InterruptedException e) {
            tsLogger.logger.warn(""problem waiting for scanLock whilst in state "" + state.name(), e);
            return false;
        }
    }
"
349,Could we merge RESTORING and SUSPENDED?,"    private void maybeScheduleCheckpoint() {
        switch (state()) {
            case RESTORING:
                this.checkpoint = checkpointableOffsets();

                break;

            case RUNNING:
                if (!eosEnabled) {
                    this.checkpoint = checkpointableOffsets();
                }

                break;

            case SUSPENDED:
                this.checkpoint = checkpointableOffsets();

                break;

            case CREATED:
            case CLOSED:
                throw new IllegalStateException(""Illegal state "" + state() + "" while scheduling checkpoint for active task "" + id);

            default:
                throw new IllegalStateException(""Unknown state "" + state() + "" while scheduling checkpoint for active task "" + id);
        }
    }
","    private void maybeScheduleCheckpoint() {
        switch (state()) {
START             case RESTORING: END 
                this.checkpoint = checkpointableOffsets();

                break;

            case RUNNING:
                if (!eosEnabled) {
                    this.checkpoint = checkpointableOffsets();
                }

                break;

            case SUSPENDED:
                this.checkpoint = checkpointableOffsets();

                break;

            case CREATED:
            case CLOSED:
                throw new IllegalStateException(""Illegal state "" + state() + "" while scheduling checkpoint for active task "" + id);

            default:
                throw new IllegalStateException(""Unknown state "" + state() + "" while scheduling checkpoint for active task "" + id);
        }
    }
","    private void maybeScheduleCheckpoint() {
        switch (state()) {
            case RESTORING:
            case SUSPENDED:
                this.checkpoint = checkpointableOffsets();

                break;

            case RUNNING:
                if (!eosEnabled) {
                    this.checkpoint = checkpointableOffsets();
                }

                break;

            case CREATED:
            case CLOSED:
                throw new IllegalStateException(""Illegal state "" + state() + "" while scheduling checkpoint for active task "" + id);

            default:
                throw new IllegalStateException(""Unknown state "" + state() + "" while scheduling checkpoint for active task "" + id);
        }
    }
"
350,Why do you cast to HostProviderProxy?,"    protected void executeQueryCommand() {
        Provider hostProvider = getProvider();
        HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(hostProvider));
        getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain()));
    }
","    protected void executeQueryCommand() {
        Provider hostProvider = getProvider();
START         HostProviderProxy proxy = ((HostProviderProxy) ProviderProxyFactory.getInstance().create(hostProvider)); END 
        getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain()));
    }
","    protected void executeQueryCommand() {
        Provider hostProvider = getProvider();
        HostProviderProxy proxy = ProviderProxyFactory.getInstance().create(hostProvider);
        getQueryReturnValue().setReturnValue(chainToString(proxy.getCertificateChain()));
    }
"
351,We could have leveraged `InvokedMethodListener` for this. See [here](https://github.com/cbeust/testng/blob/master/src/test/java/test/InvokedMethodListener.java),"    public void t1() {
        testCaseExecutionOrder.add(new Object() {}.getClass().getEnclosingMethod().getName());
    }
","    public void t1() {
START         testCaseExecutionOrder.add(new Object() {}.getClass().getEnclosingMethod().getName()); END 
    }
","    public void t1() {
    }
"
352,"Currently when the test fails with any error then there is no stacktrace to the original failure, which I think makes pinpointing the culprit easier?

That being said, this is just preference, so feel free to ignore :)","    public void testValidateDataStreamsNoConflicts() {
        Metadata metadata = createIndices(5, 10, ""foo-datastream"").metadata;
        try {
            validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE));
        } catch (Exception e) {
            fail(""did not expect exception when validating a system without indices that would conflict with future backing indices: ""
                + e.getMessage());
        }
    }
","    public void testValidateDataStreamsNoConflicts() {
        Metadata metadata = createIndices(5, 10, ""foo-datastream"").metadata;
        try {
START             validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE)); END 
        } catch (Exception e) {
            fail(""did not expect exception when validating a system without indices that would conflict with future backing indices: ""
                + e.getMessage());
        }
    }
","    public void testValidateDataStreamsNoConflicts() {
        Metadata metadata = createIndices(5, 10, ""foo-datastream"").metadata;
        // don't expect any exception when validating a system without indices that would conflict with future backing indices
        validateDataStreams(metadata.getIndicesLookup(), (DataStreamMetadata) metadata.customs().get(DataStreamMetadata.TYPE));
    }
"
353,"I dont think that this check is needed here (otherwise it will throw an index out of bounds exception, which says the same). https://github.com/libgdx/libgdx/wiki/Contributing#performance-considerations","	public ShaderProvider getPassShaderProvider (int n) {
		if (n >= passShaderProviders.length)
			throw new GdxRuntimeException(""ShaderProvider "" + n + "" doesn't exist in "" + getClass().getName());

		return passShaderProviders[n];
	}
","	public ShaderProvider getPassShaderProvider (int n) {
START 		if (n >= passShaderProviders.length) END 
			throw new GdxRuntimeException(""ShaderProvider "" + n + "" doesn't exist in "" + getClass().getName());

		return passShaderProviders[n];
	}
","	public ShaderProvider getPassShaderProvider (int n) {
		return passShaderProviders[n];
	}
"
354,"stopTimer() нужно поставить где сессия закрывается вообще, а не для конкретного юзера","    public void onConnectionClosedForUser(QBRTCSession qbrtcSession, Integer integer) {
        setStatusForOpponent(integer, getString(R.string.closed));
        stopTimer();
    }
","    public void onConnectionClosedForUser(QBRTCSession qbrtcSession, Integer integer) {
        setStatusForOpponent(integer, getString(R.string.closed));
START         stopTimer(); END 
    }
","    public void onConnectionClosedForUser(QBRTCSession qbrtcSession, Integer integer) {
        setStatusForOpponent(integer, getString(R.string.closed));
    }
"
355,"It would be better to run checks in the constructor to make sure no reconciler is null, or to create an actual list of non-null reconcilers that would be dereferenced here.","	public void install(ITextViewer textViewer) {
		for (IReconciler iReconciler : fReconcilers) {
			if(iReconciler != null) {
				iReconciler.install(textViewer);
			}
		}
	}
","	public void install(ITextViewer textViewer) {
		for (IReconciler iReconciler : fReconcilers) {
START 			if(iReconciler != null) { END 
				iReconciler.install(textViewer);
			}
		}
	}
","	public void install(ITextViewer textViewer) {
		for (IReconciler iReconciler : fReconcilers) {
			iReconciler.install(textViewer);
		}
	}
"
356,а мы разве можем хоть когда-то не захотеть добавлять listener - я бы это унес прям в основной webAppInitializer,"  public JettyServer run(WebApplicationContext baseContext,
      boolean directlyUseAsWebAppRoot,
      Function<Function<Integer, JettyServer>, JettyServer> serverStarter,
      boolean exitOnError) {
    try {
      configureLogger();
      configureSentry(baseContext);
      JettyServer jettyServer = createJettyServer(baseContext, directlyUseAsWebAppRoot, serverStarter,
              v->v.addLifeCycleListener(new JettyLifeCycleListener(baseContext)));
      jettyServer.start();
      logStartupInfo(baseContext);
      return jettyServer;
    } catch (Exception e) {
      return logErrorAndExit(e, exitOnError);
    }
  }
","  public JettyServer run(WebApplicationContext baseContext,
      boolean directlyUseAsWebAppRoot,
      Function<Function<Integer, JettyServer>, JettyServer> serverStarter,
      boolean exitOnError) {
    try {
      configureLogger();
      configureSentry(baseContext);
      JettyServer jettyServer = createJettyServer(baseContext, directlyUseAsWebAppRoot, serverStarter,
START               v->v.addLifeCycleListener(new JettyLifeCycleListener(baseContext))); END 
      jettyServer.start();
      logStartupInfo(baseContext);
      return jettyServer;
    } catch (Exception e) {
      return logErrorAndExit(e, exitOnError);
    }
  }
","  public JettyServer run(WebApplicationContext baseContext,
      boolean directlyUseAsWebAppRoot,
      Function<Function<Integer, JettyServer>, JettyServer> serverStarter,
      boolean exitOnError) {
    try {
      configureLogger();
      configureSentry(baseContext);
      JettyServer jettyServer = createJettyServer(baseContext, directlyUseAsWebAppRoot, serverStarter);
      jettyServer.start();
      logStartupInfo(baseContext);
      return jettyServer;
    } catch (Exception e) {
      return logErrorAndExit(e, exitOnError);
    }
  }
"
357,AFAIK this is redundant.,"    public PlanItem(String id, String definitionRef) {
        super();
        this.id = id;
        this.definitionRef = definitionRef;
    }
","    public PlanItem(String id, String definitionRef) {
START         super(); END 
        this.id = id;
        this.definitionRef = definitionRef;
    }
","    public PlanItem(String id, String definitionRef) {
        this.id = id;
        this.definitionRef = definitionRef;
    }
"
358,"Looking on `QName` class, maybe we should use `return ~~name.hashCode()`.","    public int hashCode() {
        return name.hashCode();
    }
","    public int hashCode() {
START         return name.hashCode(); END 
    }
","    public int hashCode() {
        return ~~name.hashCode();
    }
"
359,`LOG.debug` please to avoid overhead on operations.,"  protected boolean copyObject(String src, String dst) {
    try {
      LOG.info(""Copying {} to {}"", src, dst);
      mClient.copyObject(mBucketNameInternal, src, mBucketNameInternal, dst);
      return true;
    } catch (CosClientException e) {
      LOG.error(""Failed to rename file {} to {}"", src, dst, e);
      return false;
    }
  }
","  protected boolean copyObject(String src, String dst) {
    try {
START       LOG.info(""Copying {} to {}"", src, dst); END 
      mClient.copyObject(mBucketNameInternal, src, mBucketNameInternal, dst);
      return true;
    } catch (CosClientException e) {
      LOG.error(""Failed to rename file {} to {}"", src, dst, e);
      return false;
    }
  }
","  protected boolean copyObject(String src, String dst) {
    try {
      LOG.debug(""Copying {} to {}"", src, dst);
      mClient.copyObject(mBucketNameInternal, src, mBucketNameInternal, dst);
      return true;
    } catch (CosClientException e) {
      LOG.error(""Failed to rename file {} to {}"", src, dst, e);
      return false;
    }
  }
"
360,"Since the logic switch, this should be true (former behavior).","	public RepositorySearchDialog(Collection<String> existingDirs) {
		this(existingDirs, false, false);
	}
","	public RepositorySearchDialog(Collection<String> existingDirs) {
		this(existingDirs, false, START  false); END 
	}
","	public RepositorySearchDialog(Collection<String> existingDirs) {
		this(existingDirs, false, true);
	}
"
361,Aren't the name and description properties already added by the super class?,"    public DelegatingResourceDescription getCreatableProperties() {
        DelegatingResourceDescription description = super.getCreatableProperties();
        description.addProperty(""name"");
        description.addProperty(""location"");
        description.addProperty(""description"");

        return description;
    }
","    public DelegatingResourceDescription getCreatableProperties() {
        DelegatingResourceDescription description = super.getCreatableProperties();
START         description.addProperty(""name""); END 
        description.addProperty(""location"");
        description.addProperty(""description"");

        return description;
    }
","	public DelegatingResourceDescription getCreatableProperties() {
		DelegatingResourceDescription description = super.getCreatableProperties();
		description.addProperty(""location"");
		return description;
	}
"
362,"Character should be ""char""
https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#charAt(int)

This is returning a char (primitive type) and that is why the ""==""test works I think, if it was returning Character (object wrapper for char) we would need to use "".equals""","    private JsonParser getParser(String data) throws IOException {
        // If the first character is { or [, assume this is
        // JSON data and use a JsonParser.  Otherwise assume
        // YAML and use a YAMLParser.
        Character firstChar = data.charAt(0);
        if (firstChar == '{' || firstChar == '[') {
            return this.jsonFactory.createParser(data);
        } else {
            return this.yamlFactory.createParser(data);
        }
    }
","    private JsonParser getParser(String data) throws IOException {
        // If the first character is { or [, assume this is
        // JSON data and use a JsonParser.  Otherwise assume
        // YAML and use a YAMLParser.
START         Character firstChar = data.charAt(0); END 
        if (firstChar == '{' || firstChar == '[') {
            return this.jsonFactory.createParser(data);
        } else {
            return this.yamlFactory.createParser(data);
        }
    }
","    private JsonParser getParser(String data) throws IOException {
        // If the first character is { or [, assume this is
        // JSON data and use a JsonParser.  Otherwise assume
        // YAML and use a YAMLParser.
        char firstChar = data.charAt(0);
        if (firstChar == '{' || firstChar == '[') {
            return this.jsonFactory.createParser(data);
        } else {
            return this.yamlFactory.createParser(data);
        }
    }
"
363,Redundant cast.,"    public void testGenerateDroolsTestOption() {
        ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig();
        assertThat(config.isGenerateDroolsTestOnError()).isNull();
        config.setGenerateDroolsTestOnError(true);
        assertThat((boolean) config.isGenerateDroolsTestOnError()).isTrue();
        config.setGenerateDroolsTestOnError(Boolean.FALSE);
        assertThat((boolean) config.isGenerateDroolsTestOnError()).isFalse();
        config.setGenerateDroolsTestOnError(null);
        assertThat(config.isGenerateDroolsTestOnError()).isNull();
    }
","    public void testGenerateDroolsTestOption() {
        ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig();
        assertThat(config.isGenerateDroolsTestOnError()).isNull();
        config.setGenerateDroolsTestOnError(true);
START         assertThat((boolean) config.isGenerateDroolsTestOnError()).isTrue(); END 
        config.setGenerateDroolsTestOnError(Boolean.FALSE);
        assertThat((boolean) config.isGenerateDroolsTestOnError()).isFalse();
        config.setGenerateDroolsTestOnError(null);
        assertThat(config.isGenerateDroolsTestOnError()).isNull();
    }
","    public void testGenerateDroolsTestOption() {
        ScoreDirectorFactoryConfig config = new ScoreDirectorFactoryConfig();
        assertThat(config.isGenerateDroolsTestOnError()).isNull();
        config.setGenerateDroolsTestOnError(true);
        assertThat(config.isGenerateDroolsTestOnError()).isTrue();
        config.setGenerateDroolsTestOnError(Boolean.FALSE);
        assertThat(config.isGenerateDroolsTestOnError()).isFalse();
        config.setGenerateDroolsTestOnError(null);
        assertThat(config.isGenerateDroolsTestOnError()).isNull();
    }
"
364,Style-nit: Use curly brackets and wrap the return to next line.,"    private RawText getRawText(ObjectId id, Repository repo) throws IOException {
      if (id.equals(ObjectId.zeroId())) return new RawText(new byte[] {});
      return new RawText(repo.openBlob(id).getCachedBytes());
    }
","    private RawText getRawText(ObjectId id, Repository repo) throws IOException {
START       if (id.equals(ObjectId.zeroId())) return new RawText(new byte[] {}); END 
      return new RawText(repo.openBlob(id).getCachedBytes());
    }
","    private RawText getRawText(ObjectId id, Repository repo) throws IOException {
      if (id.equals(ObjectId.zeroId())) {
        return new RawText(new byte[] {});
      }
      return new RawText(repo.openBlob(id).getCachedBytes());
    }
"
365,"We can make this inline. 
```suggestion
        return "";"" + USER_AGENT_SUFFIX;
```","    private static String getUserAgentSuffix() {
        String suffix = "";"" + USER_AGENT_SUFFIX;
        return suffix;
    }
","    private static String getUserAgentSuffix() {
        String suffix = "";"" + USER_AGENT_SUFFIX;
START         return suffix; END 
    }
","    private static String getUserAgentSuffix() {
        return "";"" + USER_AGENT_SUFFIX;
    }
"
366,you don't validate in other builders method (and you don't have to),"        public Builder setDataSize(Estimate dataSize)
        {
            this.dataSize = requireNonNull(dataSize, ""dataSize can not be null"");
            return this;
        }
","        public Builder setDataSize(Estimate dataSize)
        {
START             this.dataSize = requireNonNull(dataSize, ""dataSize can not be null""); END 
            return this;
        }
","        public Builder setDataSize(Estimate dataSize)
        {
            this.dataSize = dataSize;
            return this;
        }
"
367,Statement can be rewritten inline.,"    public boolean isExpired(Date invocationDate) {
        if (getExpires() != null) {
            Date currentInvocationDate = invocationDate == null ? new Date() : invocationDate;
            return getExpires().before(currentInvocationDate);
        }
        return false;
    }
","    public boolean isExpired(Date invocationDate) {
        if (getExpires() != null) {
            Date currentInvocationDate = invocationDate == null ? new Date() : invocationDate;
START             return getExpires().before(currentInvocationDate); END 
        }
        return false;
    }
","    public boolean isExpired(Date invocationDate) {
        if (getExpires() != null) {
            return getExpires().before(invocationDate == null ? new Date() : invocationDate);
        }
        return false;
    }
"
368,Is this really needed?,"	public void stop() {
	   if (isRunning()) {
		   process.destroy();
		   try {
			   if (stdout !=null) {
				   stdout.close();
			   }
			   if (stdin !=null) {
				   stdin.close();
			   }
		   }
		   catch (IOException e) {
			   throw new RuntimeException(e.getMessage(),e);
		   }
		   finally {
			   running.set(false);
		   }
	   }
	}
","	public void stop() {
	   if (isRunning()) {
		   process.destroy();
		   try {
			   if (stdout !=null) {
START 				   stdout.close(); END 
			   }
			   if (stdin !=null) {
				   stdin.close();
			   }
		   }
		   catch (IOException e) {
			   throw new RuntimeException(e.getMessage(),e);
		   }
		   finally {
			   running.set(false);
		   }
	   }
	}
","	public void stop() {
		if (isRunning()) {
			process.destroy();
			running.set(false);
		}
	}
"
369,"Actually since MacroId is not really supposed to be extended you could replace this with a `if (!(object instanceof MacroId))`. Can't be null if it's an instance of MacroId.

Also I would put it after the `if (object == this)` test instead of before.","    public boolean equals(Object object)
    {
        if (object == null || object.getClass() != getClass()) {
            return false;
        }
        if (object == this) {
            return true;
        }
        MacroId rhs = (MacroId) object;
        return new EqualsBuilder()
            .append(getId(), rhs.getId())
            .append(getSyntax(), rhs.getSyntax())
            .isEquals();
    }
","    public boolean equals(Object object)
    {
START         if (object == null || object.getClass() != getClass()) { END 
            return false;
        }
        if (object == this) {
            return true;
        }
        MacroId rhs = (MacroId) object;
        return new EqualsBuilder()
            .append(getId(), rhs.getId())
            .append(getSyntax(), rhs.getSyntax())
            .isEquals();
    }
","    public boolean equals(Object object)
    {
        if (object == this) {
            return true;
        }
        
        if (!(object instanceof MacroId)) {
            return false;
        }
        
        MacroId rhs = (MacroId) object;
        return new EqualsBuilder()
            .append(getId(), rhs.getId())
            .append(getSyntax(), rhs.getSyntax())
            .isEquals();
    }
"
370,"this is public API, we can't lower the visibility without deprecating first","  Map<String, Object> getExtraInformation() {
    return extraInformation;
  }
","START   Map<String, Object> getExtraInformation() { END 
    return extraInformation;
  }
","  public Map<String, Object> getExtraInformation() {
    return extraInformation;
  }
"
371,neat.,"    public int hashCode() {
        return Objects.hash(pointer, ownerName, owner, readers, writers);
    }
","    public int hashCode() {
START         return Objects.hash(pointer, ownerName, owner, readers, writers); END 
    }
","    public int hashCode() {
        return Objects.hash(pointer, ownerName);
    }
"
372,"What about the same when the list is empty, it still adds `-Xfriend-paths=` option?","  private String getFriendsPath(
      SourcePathResolver sourcePathResolver, ImmutableList<SourcePath> friendPathsSourcePaths) {

    // https://youtrack.jetbrains.com/issue/KT-29933
    ImmutableSortedSet<String> absoluteFriendPaths =
        ImmutableSortedSet.copyOf(
            friendPathsSourcePaths
                .stream()
                .map(path -> sourcePathResolver.getAbsolutePath(path).toString())
                .collect(Collectors.toSet()));

    return ""-Xfriend-paths=""
        + absoluteFriendPaths.stream().reduce("""", (path1, path2) -> path1 + "","" + path2);
  }
","  private String getFriendsPath(
      SourcePathResolver sourcePathResolver, ImmutableList<SourcePath> friendPathsSourcePaths) {

    // https://youtrack.jetbrains.com/issue/KT-29933
    ImmutableSortedSet<String> absoluteFriendPaths =
        ImmutableSortedSet.copyOf(
            friendPathsSourcePaths
                .stream()
                .map(path -> sourcePathResolver.getAbsolutePath(path).toString())
                .collect(Collectors.toSet()));

    return ""-Xfriend-paths=""
START         + absoluteFriendPaths.stream().reduce("""", (path1, path2) -> path1 + "","" + path2); END 
  }
","  private String getFriendsPath(
      SourcePathResolver sourcePathResolver, ImmutableList<SourcePath> friendPathsSourcePaths) {
    if (friendPathsSourcePaths.isEmpty()) {
      return """";
    }

    // https://youtrack.jetbrains.com/issue/KT-29933
    ImmutableSortedSet<String> absoluteFriendPaths =
        ImmutableSortedSet.copyOf(
            friendPathsSourcePaths
                .stream()
                .map(path -> sourcePathResolver.getAbsolutePath(path).toString())
                .collect(Collectors.toSet()));

    return ""-Xfriend-paths=""
        + absoluteFriendPaths.stream().reduce("""", (path1, path2) -> path1 + "","" + path2);
  }
"
373,"Do we need super(), if the class is not inheriting from a super class?","	public Target(String targetUriAsString) {
		super();
		Assert.hasText(targetUriAsString, ""The provided targetUriAsString must neither be null nor empty."");
		this.targetUri = URI.create(targetUriAsString);
	}
","	public Target(String targetUriAsString) {
START 		super(); END 
		Assert.hasText(targetUriAsString, ""The provided targetUriAsString must neither be null nor empty."");
		this.targetUri = URI.create(targetUriAsString);
	}
","	public Target(String targetUriAsString) {
		Assert.hasText(targetUriAsString, ""The provided targetUriAsString must neither be null nor empty."");
		this.targetUri = URI.create(targetUriAsString);
	}
"
374,"Minor, but rather than duplicating lines 44 - 51, perhaps put them in a private method invoked by both constructors, or have this constructor invoke the other.","    public PropertyInvertedRegexTester(IPersonAttributesGroupTestDefinition definition) {
        super(definition);
        final String propertyName = definition.getTestValue();
        String regexExpression = PropertiesManager.getProperty
                (propertyName, """");
        if (StringUtils.isBlank(regexExpression)) {
            logger.error(""Unable to find property name {} in portal.properties or has empty value.""
                    + "" PAGS PropertyInvertedRegexTester will always return true for attribute {}"",
                    propertyName, definition.getAttributeName());
        }
        setPattern(regexExpression);
    }
","    public PropertyInvertedRegexTester(IPersonAttributesGroupTestDefinition definition) {
        super(definition);
        final String propertyName = definition.getTestValue();
        String regexExpression = PropertiesManager.getProperty
                (propertyName, """");
        if (StringUtils.isBlank(regexExpression)) {
            logger.error(""Unable to find property name {} in portal.properties or has empty value.""
                    + "" PAGS PropertyInvertedRegexTester will always return true for attribute {}"",
                    propertyName, definition.getAttributeName());
        }
        setPattern(regexExpression);
START     } END 
","    public PropertyInvertedRegexTester(IPersonAttributesGroupTestDefinition definition) {
        super(definition);
        setPattern(definition.getAttributeName(), definition.getTestValue());
    }
"
375,"Looking bad indeed, I fixed later during my work on the branch: https://github.com/apache/wicket/pull/210/commits/b64f2b4b2cb50a594cabb50a0c1eeca43485f6b9#diff-36b11db0d92a540368a080c520de953aL177

The three states looks overcomplicated. There's no place in Wicket core needing to test such flag for the value ""OLD"".","	public final boolean doesProvideNewPage()
	{
		if (provision == null)
		{
			throw new IllegalStateException(""Page instance not yet resolved"");
		}
		return getProvision().doesProvideNewPage();
	}
","	public final boolean doesProvideNewPage()
	{
		if (provision == null)
		{
START 			throw new IllegalStateException(""Page instance not yet resolved""); END 
		}
		return getProvision().doesProvideNewPage();
	}
","	public final boolean doesProvideNewPage()
	{
		return getProvision().doesProvideNewPage();
	}
"
376,This doesn't look thread-safe.,"    private Handler getHandler() {
        if (mHandler == null) {
            // Use current main looper
            mHandler = new Handler(mContext.getMainLooper());
        }

        return mHandler;
    }
","    private Handler getHandler() {
START         if (mHandler == null) { END 
            // Use current main looper
            mHandler = new Handler(mContext.getMainLooper());
        }

        return mHandler;
    }
","    private synchronized Handler getHandler() {
        if (mHandler == null) {
            // Use current main looper
            mHandler = new Handler(mContext.getMainLooper());
        }

        return mHandler;
    }
"
377,Let's remove this behavior. `setDebugging` will only affect the indicators.,"  @SuppressWarnings(""UnusedDeclaration"") @Deprecated public void setDebugging(boolean debugging) {
    setIndicatorsEnabled(debugging);
    setLoggingEnabled(debugging);
  }
","  @SuppressWarnings(""UnusedDeclaration"") @Deprecated public void setDebugging(boolean debugging) {
    setIndicatorsEnabled(debugging);
START     setLoggingEnabled(debugging); END 
  }
","  @SuppressWarnings(""UnusedDeclaration"") @Deprecated public void setDebugging(boolean debugging) {
    setIndicatorsEnabled(debugging);
  }
"
378,I guess we no longer need `store` to be of `ConcurrentHashMap` implementation if we are fully locking it.,"    public List<ServerTemplate> load() {
        synchronized (store) {
            return store.values().stream().map(e -> cloneServerTemplate(e)).collect(Collectors.toList());
        }
    }
","    public List<ServerTemplate> load() {
        synchronized (store) {
            return store.values().stream().map(e -> cloneServerTemplate(e)).collect(Collectors.toList());
START         } END 
    }
","    public List<ServerTemplate> load() {
        synchronized (store) {
            return store.values().stream().map(this::cloneServerTemplate).collect(Collectors.toList());
        }
    }
"
379,if `learnerMaster` is `null` here then you'll get a NPE on the `learnerMaster.addr.getReachableOrOne()` above.,"    public String getLearnerMaster() {
        QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster();
        InetSocketAddress address = learnerMaster.addr.getReachableOrOne();
        if (learnerMaster == null || address == null) {
            return ""Unknown"";
        }
        return address.getAddress().getHostAddress() + "":"" + address.getPort();
    }
","    public String getLearnerMaster() {
        QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster();
        InetSocketAddress address = learnerMaster.addr.getReachableOrOne();
START         if (learnerMaster == null || address == null) { END 
            return ""Unknown"";
        }
        return address.getAddress().getHostAddress() + "":"" + address.getPort();
    }
","    public String getLearnerMaster() {
        QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster();
        if (learnerMaster == null || learnerMaster.addr.isEmpty()) {
            return ""Unknown"";
        }
        InetSocketAddress address = learnerMaster.addr.getReachableOrOne();
        return address.getAddress().getHostAddress() + "":"" + address.getPort();
    }
"
380,"I think we should drop redundant ""Task"" suffix from the task types e.g.:
""nestedTask"" -> ""nested""
""withSideEffectTask"" -> ""withSideEffect""
""timeoutTask"" -> ""timeout""
""withTimeoutTask"" -> ""withTimeout""","  default <R> Task<R> flatMap(final String desc, final Function1<? super T, Task<R>> func) {
    ArgumentUtil.requireNotNull(func, ""function"");
    final Task<Task<R>> nested = map(""map: "" + desc, func);
    nested.getShallowTraceBuilder().setSystemHidden(true);
    nested.getShallowTraceBuilder().setTaskType(""nestedTask"");
    return flatten(desc, nested);
  }
","  default <R> Task<R> flatMap(final String desc, final Function1<? super T, Task<R>> func) {
    ArgumentUtil.requireNotNull(func, ""function"");
    final Task<Task<R>> nested = map(""map: "" + desc, func);
    nested.getShallowTraceBuilder().setSystemHidden(true);
START     nested.getShallowTraceBuilder().setTaskType(""nestedTask""); END 
    return flatten(desc, nested);
  }
","  default <R> Task<R> flatMap(final String desc, final Function1<? super T, Task<R>> func) {
    ArgumentUtil.requireNotNull(func, ""function"");
    final Task<Task<R>> nested = map(""map: "" + desc, func);
    nested.getShallowTraceBuilder().setSystemHidden(true);
    return flatten(desc, nested);
  }
"
381,"As stated above, I don't see the need for this method to throw an exception.","    protected List<String> findStringsInFileCommon(String regexp,
                                                   boolean stopOnFirst, int searchLimit, File fileToSearch)
                    throws Exception {
        return findStringsInFileCommon(regexp, stopOnFirst, searchLimit, fileToSearch, Project.MSG_INFO);
    }
","    protected List<String> findStringsInFileCommon(String regexp,
                                                   boolean stopOnFirst, int searchLimit, File fileToSearch)
START                     throws Exception { END 
        return findStringsInFileCommon(regexp, stopOnFirst, searchLimit, fileToSearch, Project.MSG_INFO);
    }
","    protected List<String> findStringsInFileCommon(String regexp,
                                                   boolean stopOnFirst, int searchLimit, File fileToSearch) {
        return findStringsInFileCommon(regexp, stopOnFirst, searchLimit, fileToSearch, Project.MSG_INFO);
    }
"
382,"can you pass null in here for the status, I recently refactored similar code, and status should not be part of the event.","    public void notifyAboutStartProcess(String id) {
        
        Long processInstanceId = Long.parseLong(id);
        newProcessInstanceEvent.fire(new NewProcessInstanceEvent(serverTemplateId,
                                                                 deploymentId,
                                                                 processInstanceId,
                                                                 processDefId,
                                                                 processName,
                                                                 1));
        final String message = Constants.INSTANCE.ProcessStarted(processInstanceId.longValue());
        notificationEvent.fire(new NotificationEvent(message,
                                                     NotificationEvent.NotificationType.SUCCESS));      
        close();
    }
","    public void notifyAboutStartProcess(String id) {
        
        Long processInstanceId = Long.parseLong(id);
        newProcessInstanceEvent.fire(new NewProcessInstanceEvent(serverTemplateId,
                                                                 deploymentId,
                                                                 processInstanceId,
                                                                 processDefId,
                                                                 processName,
START                                                                  1)); END 
        final String message = Constants.INSTANCE.ProcessStarted(processInstanceId.longValue());
        notificationEvent.fire(new NotificationEvent(message,
                                                     NotificationEvent.NotificationType.SUCCESS));      
        close();
    }
","    public void notifyAboutStartProcess(String id) {
        
        Long processInstanceId = Long.parseLong(id);
        newProcessInstanceEvent.fire(new NewProcessInstanceEvent(serverTemplateId,
                                                                 deploymentId,
                                                                 processInstanceId,
                                                                 processDefId,
                                                                 processName,
                                                                 null));
        final String message = Constants.INSTANCE.ProcessStarted(processInstanceId.longValue());
        notificationEvent.fire(new NotificationEvent(message,
                                                     NotificationEvent.NotificationType.SUCCESS));      
        close();
    }
"
383,I don't understand what this check is doing here. maybeMove is already taking check of checking rights.,"    protected void process(final SpaceReference source, final SpaceReference destination)
    {
        visitDocuments(source, new Visitor<DocumentReference>()
        {
            @Override
            public void visit(DocumentReference oldChildReference)
            {
                DocumentReference newChildReference = oldChildReference.replaceParent(source, destination);
                if (MoveJob.this.hasAccess(Right.VIEW, newChildReference)) {
                    maybeMove(oldChildReference, newChildReference);
                }
            }
        });
    }
","    protected void process(final SpaceReference source, final SpaceReference destination)
    {
        visitDocuments(source, new Visitor<DocumentReference>()
        {
            @Override
            public void visit(DocumentReference oldChildReference)
            {
                DocumentReference newChildReference = oldChildReference.replaceParent(source, destination);
START                 if (MoveJob.this.hasAccess(Right.VIEW, newChildReference)) { END 
                    maybeMove(oldChildReference, newChildReference);
                }
            }
        });
    }
","    protected void process(final SpaceReference source, final SpaceReference destination)
    {
        visitDocuments(source, new Visitor<DocumentReference>()
        {
            @Override
            public void visit(DocumentReference oldChildReference)
            {
                DocumentReference newChildReference = oldChildReference.replaceParent(source, destination);
                maybeMove(oldChildReference, newChildReference);
            }
        });
    }
"
384,"same, we can delete LogReplicationDiscoveryServiceException.java file now.","    public void processEvent(DiscoveryServiceEvent event) throws LogReplicationDiscoveryServiceException {
        log.info(""Process event {}"", event.getType());
        switch (event.type) {
            case DISCOVER_INIT_TOPOLOGY:
                startDiscovery();
                break;

            case ACQUIRE_LOCK:
                processLockAcquire();
                break;

            case RELEASE_LOCK:
                processLockRelease();
                break;

            case DISCOVERED_TOPOLOGY:
                processTopologyChangeNotification(event);
                break;

            case UPGRADE:
                processUpgrade(event);
                break;

            default:
                log.error(""Invalid event type {}"", event.type);
        }
    }
","START     public void processEvent(DiscoveryServiceEvent event) throws LogReplicationDiscoveryServiceException { END 
        log.info(""Process event {}"", event.getType());
        switch (event.type) {
            case DISCOVER_INIT_TOPOLOGY:
                startDiscovery();
                break;

            case ACQUIRE_LOCK:
                processLockAcquire();
                break;

            case RELEASE_LOCK:
                processLockRelease();
                break;

            case DISCOVERED_TOPOLOGY:
                processTopologyChangeNotification(event);
                break;

            case UPGRADE:
                processUpgrade(event);
                break;

            default:
                log.error(""Invalid event type {}"", event.type);
        }
    }
","    public void processEvent(DiscoveryServiceEvent event) {
        log.info(""Process event {}"", event.getType());
        switch (event.getType()) {
            case DISCOVER_INIT_TOPOLOGY:
                startDiscovery();
                break;

            case ACQUIRE_LOCK:
                processLockAcquire();
                break;

            case RELEASE_LOCK:
                processLockRelease();
                break;

            case DISCOVERED_TOPOLOGY:
                processTopologyChangeNotification(event);
                break;

            case UPGRADE:
                processUpgrade(event);
                break;

            default:
                log.error(""Invalid event type {}"", event.getType());
        }
    }
"
385,"Don't really like firing events when holding locks on things... If anything that receives a ProgramErrorDeletedEvent tries to access the ErrorManager (which is not altogether unreasonable!) you'll end up with a nasty deadlock.

Could we just make errors a ConcurrentSkipListSet and drop all the synchronization?","    public void deleteError(final ProgramError error) {
        synchronized (errors) {
            errors.remove(error);
            eventBus.publish(new ProgramErrorDeletedEvent(error));
        }
    }
","    public void deleteError(final ProgramError error) {
        synchronized (errors) {
            errors.remove(error);
START             eventBus.publish(new ProgramErrorDeletedEvent(error)); END 
        }
    }
","    public void deleteError(final ProgramError error) {
        errors.remove(error);
        eventBus.publish(new ProgramErrorDeletedEvent(error));
    }
"
386,"Can remove checkNotNull, we have external @NonNull annotation on Collections.emptyList().","    public LamiTableContentProvider() {
        fCurrentEntries = checkNotNull(Collections.emptyList());
    }
","    public LamiTableContentProvider() {
        fCurrentEntries = START  checkNotNull(Collections.emptyList()); END 
    }
","    public LamiTableContentProvider() {
        fCurrentEntries = Collections.emptyList();
    }
"
387,"in case of switching, in my opinion it's better to us etry/finnally like that:

```
        switchToIFrame();
        try {
            waitForElementByElement(getInfoLink);
            //Opens new tab to Template namespace
            getInfoLink.click();

            return new ArticlePageObject(driver);
        }finally {
            switchOutOfIFrame();
        }
```

it's clearer in reading","	public ArticlePageObject clickGetInfoLink() {
		switchToIFrame();
		waitForElementByElement(getInfoLink);
		//Opens new tab to Template namespace
		getInfoLink.click();
		switchOutOfIFrame();
		return new ArticlePageObject(driver);
	}
","	public ArticlePageObject clickGetInfoLink() {
		switchToIFrame();
		waitForElementByElement(getInfoLink);
		//Opens new tab to Template namespace
		getInfoLink.click();
		switchOutOfIFrame();
START 		return new ArticlePageObject(driver); END 
	}
","	public ArticlePageObject clickGetInfoLink() {
		switchToIFrame();
		try {
			waitForElementByElement(getInfoLink);
			//Opens new tab to Template namespace
			getInfoLink.click();
			return new ArticlePageObject(driver);
		} finally {
			switchOutOfIFrame();
		}
	}
"
388,"would this work? (also removing the import)

```suggestion
      .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice);
```","  @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent() {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setAdviceChain(new CacheInterceptor());

    assertThat(rabbitTracing.decorateSimpleRabbitListenerContainerFactory(factory).getAdviceChain())
      .hasSize(2)
      .matches(adviceArray -> asList(adviceArray).get(0) instanceof TracingRabbitListenerAdvice);
  }
","  @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent() {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setAdviceChain(new CacheInterceptor());

    assertThat(rabbitTracing.decorateSimpleRabbitListenerContainerFactory(factory).getAdviceChain())
      .hasSize(2)
START       .matches(adviceArray -> asList(adviceArray).get(0) instanceof TracingRabbitListenerAdvice); END 
  }
","  @Test public void decorateSimpleRabbitListenerContainerFactory_appends_as_first_when_absent() {
    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
    factory.setAdviceChain(new CacheInterceptor());

    // the order of advices is important for the downstream interceptor to see the tracing context
    assertThat(rabbitTracing.decorateSimpleRabbitListenerContainerFactory(factory).getAdviceChain())
      .hasSize(2)
      .matches(adviceArray -> adviceArray[0] instanceof TracingRabbitListenerAdvice);
  }
"
389,Use ArrayList<>,"	private static List<IResource> getReadonlyFiles(IResource[] resources) {
		List<IResource> readOnlyFiles= new ArrayList<IResource>();
		for (int i= 0; i < resources.length; i++) {
			IResource resource= resources[i];
			ResourceAttributes resourceAttributes= resource.getResourceAttributes();
			if (resource.getType() == IResource.FILE && resourceAttributes != null && resourceAttributes.isReadOnly())	
				readOnlyFiles.add(resource);
		}
		return readOnlyFiles;
	}
","	private static List<IResource> getReadonlyFiles(IResource[] resources) {
START 		List<IResource> readOnlyFiles= new ArrayList<IResource>(); END 
		for (int i= 0; i < resources.length; i++) {
			IResource resource= resources[i];
			ResourceAttributes resourceAttributes= resource.getResourceAttributes();
			if (resource.getType() == IResource.FILE && resourceAttributes != null && resourceAttributes.isReadOnly())	
				readOnlyFiles.add(resource);
		}
		return readOnlyFiles;
	}
","	private static List<IResource> getReadonlyFiles(IResource[] resources) {
		List<IResource> readOnlyFiles= new ArrayList<>();
		for (IResource resource : resources) {
			ResourceAttributes resourceAttributes= resource.getResourceAttributes();
			if (resource.getType() == IResource.FILE && resourceAttributes != null && resourceAttributes.isReadOnly())
				readOnlyFiles.add(resource);
		}
		return readOnlyFiles;
	}
"
390,I think this is not necessary as the GC will remove it as soon as there is no more reference on the Object,"	void clean(K key) {
		List<V> data = getDataMap().get(key);
		if (data != null) {
			data.clear();
		}
		getDataMap().remove(key);
	}
","	void clean(K key) {
		List<V> data = getDataMap().get(key);
		if (data != null) {
START 			data.clear(); END 
		}
		getDataMap().remove(key);
	}
","	void clean(K key) {
		getDataMap().remove(key);
	}
"
391,IllegalArgumentException sounds better here.,"    public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) {
        if (!isMemory(memoryDevice)) {
            throw new RuntimeException(""Memory device expected but device "" + memoryDevice + "" obtained."");
        }
        return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent()
                && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent();
    }
","    public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) {
        if (!isMemory(memoryDevice)) {
START             throw new RuntimeException(""Memory device expected but device "" + memoryDevice + "" obtained.""); END 
        }
        return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent()
                && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent();
    }
","    public static boolean isMemoryDeviceHotUnpluggable(VmDevice memoryDevice) {
        if (!isMemory(memoryDevice)) {
            throw new IllegalArgumentException(""Memory device expected but device "" + memoryDevice + "" obtained."");
        }
        return getSpecParamsIntValue(memoryDevice, SPEC_PARAM_SIZE).isPresent()
                && getSpecParamsIntValue(memoryDevice, SPEC_PARAM_NODE).isPresent();
    }
"
392,"Would be nice if you add here an exception text. Something like ""unable to load the list of connector configurations""","	public boolean connectorExists(String id) {
		try {
            List<ConnectorConfiguration> list =
                configPersistence.load(ImmutableMap.of(Constants.CONNECTOR_PERSISTENT_ID, id));
            if (list.isEmpty()) {
               return false;
            }
           return true;
        } catch (PersistenceException e) {
            throw new RuntimeException(e);
        }
	}
","	public boolean connectorExists(String id) {
		try {
            List<ConnectorConfiguration> list =
                configPersistence.load(ImmutableMap.of(Constants.CONNECTOR_PERSISTENT_ID, id));
            if (list.isEmpty()) {
               return false;
            }
           return true;
        } catch (PersistenceException e) {
START             throw new RuntimeException(e); END 
        }
	}
","    public Boolean connectorExists(String id) {
        try {
            List<ConnectorConfiguration> list =
                configPersistence.load(ImmutableMap.of(Constants.CONNECTOR_PERSISTENT_ID, id));
            return !list.isEmpty();
        } catch (PersistenceException e) {
            throw new RuntimeException(e);
        }
    }
"
393,can we maybe have separate test cases for the returning clause?,"    public void testUpdateStmtBuilder() {
        printStatement(""update foo set \""column['looks_like_nested']\""=1"");
        printStatement(""update foo set foo.a='b'"");
        printStatement(""update bar.foo set bar.foo.t=3"");
        printStatement(""update foo set col['x'] = 3"");
        printStatement(""update foo set col['x'] = 3 where foo['x'] = 2"");
        printStatement(""update schemah.foo set foo.a='b', foo.b=foo.a"");
        printStatement(""update schemah.foo set foo.a=abs(-6.3334), x=true where x=false"");
        printStatement(""update foo set foo='a' returning id"");
        printStatement(""update foo set foo='a' where x=false returning id"");
        printStatement(""update foo set foo='a' returning id AS foo"");
        printStatement(""update foo set foo='a' returning id + 1 AS foo, id -1 as bar"");
    }
","    public void testUpdateStmtBuilder() {
        printStatement(""update foo set \""column['looks_like_nested']\""=1"");
        printStatement(""update foo set foo.a='b'"");
        printStatement(""update bar.foo set bar.foo.t=3"");
        printStatement(""update foo set col['x'] = 3"");
        printStatement(""update foo set col['x'] = 3 where foo['x'] = 2"");
        printStatement(""update schemah.foo set foo.a='b', foo.b=foo.a"");
        printStatement(""update schemah.foo set foo.a=abs(-6.3334), x=true where x=false"");
        printStatement(""update foo set foo='a' returning id"");
        printStatement(""update foo set foo='a' where x=false returning id"");
        printStatement(""update foo set foo='a' returning id AS foo"");
        printStatement(""update foo set foo='a' returning id + 1 AS foo, id -1 as bar"");
START     } END 
","    public void testUpdateStmtBuilder() {
        printStatement(""update foo set \""column['looks_like_nested']\""=1"");
        printStatement(""update foo set foo.a='b'"");
        printStatement(""update bar.foo set bar.foo.t=3"");
        printStatement(""update foo set col['x'] = 3"");
        printStatement(""update foo set col['x'] = 3 where foo['x'] = 2"");
        printStatement(""update schemah.foo set foo.a='b', foo.b=foo.a"");
        printStatement(""update schemah.foo set foo.a=abs(-6.3334), x=true where x=false"");
    }
"
394,"nit: I know that in other parts of this class we put the requireNonNull calls inside another method call, but let's not do it here for the sake of slightly better readability:

```
requireNonNull(path, ""path is null"");
setPath.set(path);
```","    public void setSetPath(String path)
    {
        setPath.set(requireNonNull(path, ""path is null""));
    }
","    public void setSetPath(String path)
    {
START         setPath.set(requireNonNull(path, ""path is null"")); END 
    }
","    public void setSetPath(String path)
    {
        requireNonNull(path, ""path is null"");
        setPath.set(path);
    }
"
395,"Something like this:

```
 public EnvVars getEnvironment() throws IOException, InterruptedException {
        EnvVars cachedEnvironment = this.cachedEnvironment; 
        if (cachedEnvironment != null) {
            return cachedEnvironment;
        cachedEnvironment = EnvVars.getRemote(getChannel());
        // all non-null values should be equivalent so in a race it doesn't matter who wins
        this.cachedEnvironment = cachedEnvironment;
        return cachedEnvironment;
    }
```","    public EnvVars getEnvironment() throws IOException, InterruptedException {
        if (cachedEnvironment != null) {
            return cachedEnvironment;
        }

        cachedEnvironment = EnvVars.getRemote(getChannel());
        return cachedEnvironment;
    }
","    public EnvVars getEnvironment() throws IOException, InterruptedException {
        if (cachedEnvironment != null) {
START             return cachedEnvironment; END 
        }

        cachedEnvironment = EnvVars.getRemote(getChannel());
        return cachedEnvironment;
    }
","    public EnvVars getEnvironment() throws IOException, InterruptedException {
        EnvVars cachedEnvironment = this.cachedEnvironment;
        if (cachedEnvironment != null) {
            return cachedEnvironment;
        }

        cachedEnvironment = EnvVars.getRemote(getChannel());
        this.cachedEnvironment = cachedEnvironment;
        return cachedEnvironment;
    }
"
396,why should add lock here?,"    public int getMaxCapacity() {
        readLock.lock();
        try {
            return maxCapacity;
        } finally {
            readLock.unlock();
        }
    }
","    public int getMaxCapacity() {
START         readLock.lock(); END 
        try {
            return maxCapacity;
        } finally {
            readLock.unlock();
        }
    }
","    public int getMaxCapacity() {
        return maxCapacity;
    }
"
397,Can you use isEmpty()?,"    public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser() {
        List<VDS> result = dao.getAllForVdsGroup(existingVds.getvds_group_id(), UNPRIVILEGED_USER_ID, true);
        assertNotNull(result);
        assertTrue(result.size() == 0);
    }
","    public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser() {
        List<VDS> result = dao.getAllForVdsGroup(existingVds.getvds_group_id(), UNPRIVILEGED_USER_ID, true);
        assertNotNull(result);
START         assertTrue(result.size() == 0); END 
    }
","    public void testGetAllForVdsGroupWithPermissionsForUnpriviligedUser() {
        List<VDS> result = dao.getAllForVdsGroup(existingVds.getvds_group_id(), UNPRIVILEGED_USER_ID, true);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }
"
398,"Я еще люблю в сообщение вставлять изначальный exception, nипа ""Failed to check data source "" + e.toString(), e).","  private static DataSource createC3P0DataSource(String name, Map<Object, Object> properties) {
    ComboPooledDataSource ds = new ComboPooledDataSource(false);
    ds.setDataSourceName(name);
    ds.setIdentityToken(name);
    new BeanMap(ds).putAll(properties);
    C3P0Registry.reregister(ds);
    try {
      checkDataSource(ds, name);
    } catch (SQLException e) {
      throw new RuntimeException(""Failed check data source"", e);
    }

    return ds;
  }
","  private static DataSource createC3P0DataSource(String name, Map<Object, Object> properties) {
    ComboPooledDataSource ds = new ComboPooledDataSource(false);
    ds.setDataSourceName(name);
    ds.setIdentityToken(name);
    new BeanMap(ds).putAll(properties);
    C3P0Registry.reregister(ds);
    try {
      checkDataSource(ds, name);
    } catch (SQLException e) {
START       throw new RuntimeException(""Failed check data source"", e); END 
    }

    return ds;
  }
","  private static DataSource createC3P0DataSource(String name, Map<Object, Object> properties) {
    ComboPooledDataSource ds = new ComboPooledDataSource(false);
    ds.setDataSourceName(name);
    ds.setIdentityToken(name);
    new BeanMap(ds).putAll(properties);
    C3P0Registry.reregister(ds);
    checkDataSource(ds, name);
    return ds;
  }
"
399,"no need to center it, just give it SWT.NONE","	protected Control createPageControls(Composite parent) {

		setTitle(Messages.RemoveReviewerDialog_Remove_Reviewer);

		Label label = new Label(parent, SWT.CENTER);
		label.setText(
				NLS.bind(Messages.RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove, userToRemove.getDisplayName()));

		return parent;
	}
","	protected Control createPageControls(Composite parent) {

		setTitle(Messages.RemoveReviewerDialog_Remove_Reviewer);

START 		Label label = new Label(parent, SWT.CENTER); END 
		label.setText(
				NLS.bind(Messages.RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove, userToRemove.getDisplayName()));

		return parent;
	}
","	protected Control createPageControls(Composite parent) {

		setTitle(Messages.RemoveReviewerDialog_Remove_Reviewer);

		Label label = new Label(parent, SWT.NONE);
		label.setText(
				NLS.bind(Messages.RemoveReviewerDialog_Are_You_Sure_You_Want_To_Remove, userToRemove.getDisplayName()));

		return parent;
	}
"
400,I think you need to call super otherwise you loose the permissions that you need to check by default.,"    public List<PermissionSubject> getPermissionCheckSubjects() {
        List<PermissionSubject> list = new ArrayList<PermissionSubject>();
        Guid storagePoolId =
                getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null
                        : getVdsGroup().getstorage_pool_id().getValue();
        list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId());
        return list;
    }
","    public List<PermissionSubject> getPermissionCheckSubjects() {
        List<PermissionSubject> list = new ArrayList<PermissionSubject>();
        Guid storagePoolId =
                getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null
                        : getVdsGroup().getstorage_pool_id().getValue();
        list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId());
        return list;
START     } END 
","    public List<PermissionSubject> getPermissionCheckSubjects() {
        List<PermissionSubject> list = new ArrayList<PermissionSubject>();
        Guid storagePoolId =
                getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null
                        : getVdsGroup().getstorage_pool_id().getValue();
        list.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        list = QuotaHelper.addQuotaPermissionSubject(list, getStoragePool(), getQuotaId());
        return list;
    }
"
401,This is actually wrong but it is an error that has propagated to all drivers. The init struct has size 2 and not size 1. We are saved by ignoring the struct size when we read the init message.,"    public void onInit( String clientName, Map<String,Object> credentials ) throws IOException
    {
        packer.packStructHeader( 1, INIT.signature() );
        packer.pack( clientName );
        packer.pack( ValueUtils.asMapValue( credentials ) );
        onMessageComplete.onMessageComplete();
    }
","    public void onInit( String clientName, Map<String,Object> credentials ) throws IOException
    {
START         packer.packStructHeader( 1, INIT.signature() ); END 
        packer.pack( clientName );
        packer.pack( ValueUtils.asMapValue( credentials ) );
        onMessageComplete.onMessageComplete();
    }
","    public void onInit( String clientName, Map<String,Object> credentials ) throws IOException
    {
        packer.packStructHeader( 2, INIT.signature() );
        packer.pack( clientName );
        packer.pack( ValueUtils.asMapValue( credentials ) );
        onMessageComplete.onMessageComplete();
    }
"
402,Remove the public modifier,"      public SecurityGroupExtensionProvider(NeutronSecurityGroupExtension neutronSecurityGroupExtension,
                                            NovaSecurityGroupExtension novaSecurityGroupExtension) {
         this.neutronSecurityGroupExtension = neutronSecurityGroupExtension;
         this.novaSecurityGroupExtension = novaSecurityGroupExtension;
      }
","START       public SecurityGroupExtensionProvider(NeutronSecurityGroupExtension neutronSecurityGroupExtension, END 
                                            NovaSecurityGroupExtension novaSecurityGroupExtension) {
         this.neutronSecurityGroupExtension = neutronSecurityGroupExtension;
         this.novaSecurityGroupExtension = novaSecurityGroupExtension;
      }
","      SecurityGroupExtensionProvider(NeutronSecurityGroupExtension neutronSecurityGroupExtension,
                                            NovaSecurityGroupExtension novaSecurityGroupExtension) {
         this.neutronSecurityGroupExtension = neutronSecurityGroupExtension;
         this.novaSecurityGroupExtension = novaSecurityGroupExtension;
      }
"
403,@vilchik-elena Do we need this block?,"  private static ExpressionTree getComparedWithNullExpression(ExpressionTree expression, Tree.Kind kind) {
    ExpressionTree comparedExpression = getExpressionEqualNullWithAnd(expression, kind);

    if (comparedExpression == null) {
      comparedExpression = getExpressionNotEqualNullWithOr(expression, kind);

      if (comparedExpression == null) {
        comparedExpression = getExpressionComparedWithFunction(expression, kind);

        if (comparedExpression == null) {
          return null;
        }
      }
    }

    return comparedExpression;
  }
","  private static ExpressionTree getComparedWithNullExpression(ExpressionTree expression, Tree.Kind kind) {
    ExpressionTree comparedExpression = getExpressionEqualNullWithAnd(expression, kind);

    if (comparedExpression == null) {
      comparedExpression = getExpressionNotEqualNullWithOr(expression, kind);

      if (comparedExpression == null) {
        comparedExpression = getExpressionComparedWithFunction(expression, kind);

START         if (comparedExpression == null) { END 
          return null;
        }
      }
    }

    return comparedExpression;
  }
","  private static ExpressionTree getComparedWithNullExpression(ExpressionTree expression, Tree.Kind kind) {
    ExpressionTree comparedExpression = getExpressionEqualNullWithAnd(expression, kind);

    if (comparedExpression == null) {
      comparedExpression = getExpressionNotEqualNullWithOr(expression, kind);

      if (comparedExpression == null) {
        comparedExpression = getExpressionComparedWithFunction(expression, kind);
      }
    }

    return comparedExpression;
  }
"
404,Is the `(Runnable)` needed?,"    private void scheduleRefresh(Duration delay)
    {
        // already stopped?  avoids rejection exception
        if (executor.isShutdown()) {
            return;
        }
        executor.schedule((Runnable) this::refresh, delay.toMillis(), TimeUnit.MILLISECONDS);
    }
","    private void scheduleRefresh(Duration delay)
    {
        // already stopped?  avoids rejection exception
        if (executor.isShutdown()) {
            return;
        }
START         executor.schedule((Runnable) this::refresh, delay.toMillis(), TimeUnit.MILLISECONDS); END 
    }
","    private void scheduleRefresh(Duration delay)
    {
        // already stopped?  avoids rejection exception
        if (executor.isShutdown()) {
            return;
        }
        executor.schedule(this::refresh, delay.toMillis(), TimeUnit.MILLISECONDS);
    }
"
405,"Technically, you should `queryRunner.close()` (or t-w-r).
This would ensure proper cleanup of any temp files (or whatevers) it might have created","    public static void main(String[] args)
    {
        LocalQueryRunner queryRunner = createLocalQueryRunner(ImmutableMap.of(""reorder_joins"", ""false""));
        new SqlConsecutiveJoinBenchmark(queryRunner).runBenchmark(new SimpleLineBenchmarkResultWriter(System.out));
    }
","    public static void main(String[] args)
    {
START         LocalQueryRunner queryRunner = createLocalQueryRunner(ImmutableMap.of(""reorder_joins"", ""false"")); END 
        new SqlConsecutiveJoinBenchmark(queryRunner).runBenchmark(new SimpleLineBenchmarkResultWriter(System.out));
    }
","    public static void main(String[] args)
    {
        LocalQueryRunner queryRunner = createLocalQueryRunner(ImmutableMap.of(""reorder_joins"", ""false""));
        new SqlConsecutiveJoinBenchmark(queryRunner).runBenchmark(new SimpleLineBenchmarkResultWriter(System.out));
        queryRunner.close();
    }
"
406,Shouldn't they be protected not public?,"  public void beforeStartingVertx(VertxOptions options) {
    
  }
","START   public void beforeStartingVertx(VertxOptions options) { END 
    
  }
","  protected void beforeStartingVertx(VertxOptions options) {
    
  }
"
407,"Ah, so I guess that lack of a Guice context here (and above) is the reason for the system properties? How do we solve that elsewhere in jclouds? Would we inject some kind of factory object via Guice?","      public Builder body(String json) {
         checkNotNull(json, ""body required"");
         checkArgument(json.getBytes().length <= getInteger(MESSAGE_BODY_MAX_IN_BYTES),
               ""json size must be <= %s bytes"", getInteger(MESSAGE_BODY_MAX_IN_BYTES));
         this.body = new JsonBall(json).toString();
         return self();
      }
","      public Builder body(String json) {
         checkNotNull(json, ""body required"");
         checkArgument(json.getBytes().length <= getInteger(MESSAGE_BODY_MAX_IN_BYTES),
START                ""json size must be <= %s bytes"", getInteger(MESSAGE_BODY_MAX_IN_BYTES)); END 
         this.body = new JsonBall(json).toString();
         return self();
      }
","      public Builder body(String json) {
         checkNotNull(json, ""body required"");
         this.body = new JsonBall(json).toString();
         return self();
      }
"
408,"s/""Bearer""/BEARER","    private String getTokenFromHeader(HttpServletRequest request) {
        String token = null;
        String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION);
        if (headerValue != null && headerValue.startsWith(BEARER)) {
            token = headerValue.substring(""Bearer"".length()).trim();
        }
        return token;
    }
","    private String getTokenFromHeader(HttpServletRequest request) {
        String token = null;
        String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION);
        if (headerValue != null && headerValue.startsWith(BEARER)) {
            token = START headerValue.substring(""Bearer"".length()).trim(); END 
        }
        return token;
    }
","    private String getTokenFromHeader(HttpServletRequest request) {
        String token = null;
        String headerValue = request.getHeader(SsoConstants.HEADER_AUTHORIZATION);
        if (headerValue != null && headerValue.startsWith(BEARER)) {
            token = headerValue.substring(BEARER.length()).trim();
        }
        return token;
    }
"
409,This method should not be public or what's the point?,"    public static CDIProvider getCDIProvider() {
        if (configuredProvider != null) {
            return configuredProvider;
        } else {
            // Discover providers and cache
            if (discoveredProviders == null) {
                synchronized (lock) {
                    if (discoveredProviders == null) {
                        findAllProviders();
                    }
                }
            }
            configuredProvider = discoveredProviders.stream()
                    .filter(c -> c.getCDI() != null)
                    .findAny().orElseThrow(() -> new IllegalStateException(""Unable to access CDI""));
            return configuredProvider;
        }
    }
","START     public static CDIProvider getCDIProvider() { END 
        if (configuredProvider != null) {
            return configuredProvider;
        } else {
            // Discover providers and cache
            if (discoveredProviders == null) {
                synchronized (lock) {
                    if (discoveredProviders == null) {
                        findAllProviders();
                    }
                }
            }
            configuredProvider = discoveredProviders.stream()
                    .filter(c -> c.getCDI() != null)
                    .findAny().orElseThrow(() -> new IllegalStateException(""Unable to access CDI""));
            return configuredProvider;
        }
    }
","    private static CDIProvider getCDIProvider() {
        if (configuredProvider != null) {
            return configuredProvider;
        } else {
            // Discover providers and cache
            if (discoveredProviders == null) {
                synchronized (lock) {
                    if (discoveredProviders == null) {
                        findAllProviders();
                    }
                }
            }
            configuredProvider = discoveredProviders.stream()
                    .filter(c -> c.getCDI() != null)
                    .findAny().orElseThrow(() -> new IllegalStateException(""Unable to access CDI""));
            return configuredProvider;
        }
    }
"
410,The Exception is never thrown.,"    public void testIsDrawable_Stage() throws Exception {
        testIsDrawable(CaseManagementDiagram.class, AdHocSubprocess.class, true);
    }
","START     public void testIsDrawable_Stage() throws Exception { END 
        testIsDrawable(CaseManagementDiagram.class, AdHocSubprocess.class, true);
    }
","    public void testIsDrawable_Stage() {
        testIsDrawable(CaseManagementDiagram.class, AdHocSubprocess.class, true);
    }
"
411,"The container exists method should already return false [if the container exists call returns a 404](https://github.com/jclouds/jclouds/blob/master/providers/azureblob/src/main/java/org/jclouds/azureblob/AzureBlobClient.java#L156). Worth removing the catch, as it might be caused by other errors that should be taken into acount?","   public static boolean customImageExists(String storage, String key) {
      final AzureBlobClient azureBlob = ContextBuilder.newBuilder(""azureblob"")
              .credentials(storage, key)
              .buildApi(AzureBlobClient.class);

      try {
         return azureBlob.containerExists(""system"");
      }
      catch (Exception e) {
         e.printStackTrace();
         return false;
      }
      finally {
         Closeables2.closeQuietly(azureBlob);
      }
   }
","   public static boolean customImageExists(String storage, String key) {
      final AzureBlobClient azureBlob = ContextBuilder.newBuilder(""azureblob"")
              .credentials(storage, key)
              .buildApi(AzureBlobClient.class);

      try {
         return azureBlob.containerExists(""system"");
      }
      catch (Exception e) {
         e.printStackTrace();
         return false;
START       } END 
      finally {
         Closeables2.closeQuietly(azureBlob);
      }
   }
","   public static boolean customImageExists(String storage, String key) {
      final AzureBlobClient azureBlob = ContextBuilder.newBuilder(""azureblob"")
              .credentials(storage, key)
              .buildApi(AzureBlobClient.class);

      try {
         return azureBlob.containerExists(""system"");
      }
      finally {
         Closeables2.closeQuietly(azureBlob);
      }
   }
"
412,"Nit: By convention, this is almost always the first thing called, unless there's a explicit reason why it needs to happen after (which is usually a code smell)","        public void enter() {
            mUseEap =
                    (IkeSessionOptions.IKE_AUTH_METHOD_EAP
                            == mIkeSessionOptions.getLocalAuthConfig().mAuthMethod);
            super.enter();
        }
","        public void enter() {
            mUseEap =
                    (IkeSessionOptions.IKE_AUTH_METHOD_EAP
                            == mIkeSessionOptions.getLocalAuthConfig().mAuthMethod);
START             super.enter(); END 
        }
","        public void enter() {
            super.enter();
            mUseEap =
                    (IkeSessionOptions.IKE_AUTH_METHOD_EAP
                            == mIkeSessionOptions.getLocalAuthConfig().mAuthMethod);
        }
"
413,you can static import these functions.,"    public static Predicate<Expression> isInferenceCandidate()
    {
        return expression -> {
            expression = normalizeInPredicateToEquality(expression);
            if (expression instanceof ComparisonExpression &&
                    DeterminismEvaluator.isDeterministic(expression) &&
                    !NullabilityAnalyzer.mayReturnNullOnNonNullInput(expression) &&
                    !isDynamicFilter(expression)) {
                ComparisonExpression comparison = (ComparisonExpression) expression;
                if (comparison.getType() == ComparisonExpressionType.EQUAL) {
                    // We should only consider equalities that have distinct left and right components
                    return !comparison.getLeft().equals(comparison.getRight());
                }
            }
            return false;
        };
    }
","    public static Predicate<Expression> isInferenceCandidate()
    {
        return expression -> {
            expression = normalizeInPredicateToEquality(expression);
            if (expression instanceof ComparisonExpression &&
                    DeterminismEvaluator.isDeterministic(expression) &&
START                     !NullabilityAnalyzer.mayReturnNullOnNonNullInput(expression) && END 
                    !isDynamicFilter(expression)) {
                ComparisonExpression comparison = (ComparisonExpression) expression;
                if (comparison.getType() == ComparisonExpressionType.EQUAL) {
                    // We should only consider equalities that have distinct left and right components
                    return !comparison.getLeft().equals(comparison.getRight());
                }
            }
            return false;
        };
    }
","    public static Predicate<Expression> isInferenceCandidate()
    {
        return expression -> {
            expression = normalizeInPredicateToEquality(expression);
            if (expression instanceof ComparisonExpression &&
                    isDeterministic(expression) &&
                    !mayReturnNullOnNonNullInput(expression) &&
                    !isDynamicFilter(expression)) {
                ComparisonExpression comparison = (ComparisonExpression) expression;
                if (comparison.getType() == ComparisonExpressionType.EQUAL) {
                    // We should only consider equalities that have distinct left and right components
                    return !comparison.getLeft().equals(comparison.getRight());
                }
            }
            return false;
        };
    }
"
414,why is this needed?,"  public void startMasters() throws Exception {
    mMaster = LocalAlluxioMaster.create(mWorkDirectory, true);
    mMaster.start();
    CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.CLIENT);
  }
","  public void startMasters() throws Exception {
    mMaster = LocalAlluxioMaster.create(mWorkDirectory, true);
    mMaster.start();
START     CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.CLIENT); END 
  }
","  public void startMasters() throws Exception {
    mMaster = LocalAlluxioMaster.create(mWorkDirectory, true);
    mMaster.start();
  }
"
415,mind the code style,"    public Proxy getProxy() {
        if (mProxyHost == null) return null;

        Proxy.Type type = null;
        switch (mProxyType) {
            case TYPE_HTTP:
                type = Proxy.Type.HTTP;
                break;
            case TYPE_SOCKS:
                type = Proxy.Type.SOCKS;
                break;
        }
        return new Proxy(type, new InetSocketAddress(mProxyHost, mProxyPort));
    }
","    public Proxy getProxy() {
START         if (mProxyHost == null) return null; END 

        Proxy.Type type = null;
        switch (mProxyType) {
            case TYPE_HTTP:
                type = Proxy.Type.HTTP;
                break;
            case TYPE_SOCKS:
                type = Proxy.Type.SOCKS;
                break;
        }
        return new Proxy(type, new InetSocketAddress(mProxyHost, mProxyPort));
    }
","    public Proxy getProxy() {
        if (mProxyHost == null) {
            return null;
        }

        return new Proxy(mProxyType, new InetSocketAddress(mProxyHost, mProxyPort));
    }
"
416,nit: you can merge both lines above as `checkNotNull` will return the given argument,"    public HttpRequest setMethod(HttpMethod method) {
        ObjectUtil.checkNotNull(method, ""method"");
        this.method = method;
        return this;
    }
","    public HttpRequest setMethod(HttpMethod method) {
        ObjectUtil.checkNotNull(method, ""method"");
START         this.method = method; END 
        return this;
    }
","    public HttpRequest setMethod(HttpMethod method) {
        this.method = ObjectUtil.checkNotNull(method, ""method"");
        return this;
    }
"
417,a matter of taste - types can be avoided for the sake of return statements from the if-else block.,"    public Set<VmDeviceGeneralType> getDeviceTypesWithProperties(Version version) {
        if (!FeatureSupported.deviceCustomProperties(version)) {
            return Collections.emptySet();
        }

        Set<VmDeviceGeneralType> types;
        EnumMap<VmDeviceGeneralType, Map<String, Pattern>> map = deviceProperties.get(version);
        if (map.isEmpty()) {
            // no device type has any properities
            types = Collections.emptySet();
        } else {
            // prevent client to modify
            types = Collections.unmodifiableSet(map.keySet());
        }
        return types;
    }
","    public Set<VmDeviceGeneralType> getDeviceTypesWithProperties(Version version) {
        if (!FeatureSupported.deviceCustomProperties(version)) {
            return Collections.emptySet();
        }

START         Set<VmDeviceGeneralType> types; END 
        EnumMap<VmDeviceGeneralType, Map<String, Pattern>> map = deviceProperties.get(version);
        if (map.isEmpty()) {
            // no device type has any properities
            types = Collections.emptySet();
        } else {
            // prevent client to modify
            types = Collections.unmodifiableSet(map.keySet());
        }
        return types;
    }
","    public Set<VmDeviceGeneralType> getDeviceTypesWithProperties(Version version) {
        if (!FeatureSupported.deviceCustomProperties(version)) {
            return Collections.emptySet();
        }

        EnumMap<VmDeviceGeneralType, Map<String, Pattern>> map = deviceProperties.get(version);
        if (map.isEmpty()) {
            // no device type has any properties
            return Collections.emptySet();
        } else {
            // prevent client to modify
            return Collections.unmodifiableSet(map.keySet());
        }
    }
"
418,generic has come with mars. Consequently that code won't compile against previous platform,"    public SWTBotSiriusDiagramEditor(final IEditorReference reference, final SWTWorkbenchBot bot) throws WidgetNotFoundException {
        super(reference, bot);

        GraphicalViewer graphicalViewer = UIThreadRunnable.syncExec(new Result<GraphicalViewer>() {
            @Override
            public GraphicalViewer run() {

                final IEditorPart editor = partReference.getEditor(true);
                return editor.getAdapter(GraphicalViewer.class);
            }
        });

        ReflectionHelper.setFieldValueWithoutException(this, ""viewer"", new SWTBotSiriusGefViewer(graphicalViewer), this.getClass().getSuperclass());
    }
","    public SWTBotSiriusDiagramEditor(final IEditorReference reference, final SWTWorkbenchBot bot) throws WidgetNotFoundException {
        super(reference, bot);

        GraphicalViewer graphicalViewer = UIThreadRunnable.syncExec(new Result<GraphicalViewer>() {
            @Override
            public GraphicalViewer run() {

                final IEditorPart editor = partReference.getEditor(true);
START                 return editor.getAdapter(GraphicalViewer.class); END 
            }
        });

        ReflectionHelper.setFieldValueWithoutException(this, ""viewer"", new SWTBotSiriusGefViewer(graphicalViewer), this.getClass().getSuperclass());
    }
","    public SWTBotSiriusDiagramEditor(final IEditorReference reference, final SWTWorkbenchBot bot) throws WidgetNotFoundException {
        super(reference, bot);

        GraphicalViewer graphicalViewer = UIThreadRunnable.syncExec(new Result<GraphicalViewer>() {
            @Override
            public GraphicalViewer run() {

                final IEditorPart editor = partReference.getEditor(true);
                return (GraphicalViewer) editor.getAdapter(GraphicalViewer.class);
            }
        });

        ReflectionHelper.setFieldValueWithoutException(this, ""viewer"", new SWTBotSiriusGefViewer(graphicalViewer), this.getClass().getSuperclass());
    }
"
419,I'd prefer that we handled it (the snapshot type) in a separate change.,"    public CreateAllSnapshotsFromVmParameters() {
        needsLocking = true;
        snapshotType = SnapshotType.REGULAR;
        saveMemory = true;
        diskIdsToIgnoreInChecks = Collections.emptySet();
    }
","    public CreateAllSnapshotsFromVmParameters() {
        needsLocking = true;
START         snapshotType = SnapshotType.REGULAR; END 
        saveMemory = true;
        diskIdsToIgnoreInChecks = Collections.emptySet();
    }
","    public CreateAllSnapshotsFromVmParameters() {
        needsLocking = true;
        saveMemory = true;
        diskIdsToIgnoreInChecks = Collections.emptySet();
    }
"
420,afacit vvv is all noise,"    public SchedulerTask<?> createTaskInstance( String taskType )
        throws IllegalArgumentException
    {
        try
        {
            return lookupTask( taskType );
        }
        catch ( ComponentLookupException e )
        {
            this.logger.debug( ""Failed to load Schedule Task: "" + taskType, e );
            throw new IllegalArgumentException( ""Could not create task of type"" + taskType, e );
        }
    }
","    public SchedulerTask<?> createTaskInstance( String taskType )
        throws IllegalArgumentException
START     { END 
        try
        {
            return lookupTask( taskType );
        }
        catch ( ComponentLookupException e )
        {
            this.logger.debug( ""Failed to load Schedule Task: "" + taskType, e );
            throw new IllegalArgumentException( ""Could not create task of type"" + taskType, e );
        }
    }
","    public SchedulerTask<?> createTaskInstance( String taskType )
        throws IllegalArgumentException
    {
        try
        {
            return lookupTask( taskType );
        }
        catch ( ComponentLookupException e )
        {
            throw new IllegalArgumentException( ""Could not create task of type"" + taskType, e );
        }
    }
"
421,"It worries me a bit to imagine that _each_ decorator will start its own service (whatever that means, I'm not familiar with papyrus services)

Can you check whether this is a common way of using services?
Would it be possible to share a common instance somehow between decorators?","	public PapyrusStereotypedElementItemProviderDecorator(ComposeableAdapterFactory adapterFactory) {
		super(adapterFactory);
		labelProviderService = new LabelProviderServiceImpl();
		try {
			labelProviderService.startService();
		} catch (ServiceException ex) {
			Activator.getDefault().getLog().log(
					new Status(IStatus.WARNING, Activator.PLUGIN_ID,
							""Unable to start Papyrus Label Provider Service"", ex)); //$NON-NLS-1$
		}
	}
","	public PapyrusStereotypedElementItemProviderDecorator(ComposeableAdapterFactory adapterFactory) {
		super(adapterFactory);
START 		labelProviderService = new LabelProviderServiceImpl(); END 
		try {
			labelProviderService.startService();
		} catch (ServiceException ex) {
			Activator.getDefault().getLog().log(
					new Status(IStatus.WARNING, Activator.PLUGIN_ID,
							""Unable to start Papyrus Label Provider Service"", ex)); //$NON-NLS-1$
		}
	}
","	public PapyrusStereotypedElementItemProviderDecorator(ComposeableAdapterFactory adapterFactory) {
		super(adapterFactory);
	}
"
422,"Why not rely on `Optional`, rather than introducing another method which could lead to NPEs?","  default SourceMap sourceMap() {
    return null;
  }
","START   default SourceMap sourceMap() { END 
    return null;
  }
","  default Optional<SourceMap> sourceMap() {
    return Optional.empty();
  }
"
423,Why do we create empty directory for all tests that extend this class? I guess need to create it only for those tests that need it.,"  public static void setupDefaultTestCluster() throws Exception {
    config = DrillConfig.create(cloneDefaultTestConfigProperties());
    classpathScan = ClassPathScanner.fromPrescan(config);
    openClient();
    // turns on the verbose errors in tests
    // sever side stacktraces are added to the message before sending back to the client
    test(""ALTER SESSION SET `exec.errors.verbose` = true"");
    emptyDirCreating();
  }
","  public static void setupDefaultTestCluster() throws Exception {
    config = DrillConfig.create(cloneDefaultTestConfigProperties());
    classpathScan = ClassPathScanner.fromPrescan(config);
    openClient();
    // turns on the verbose errors in tests
    // sever side stacktraces are added to the message before sending back to the client
    test(""ALTER SESSION SET `exec.errors.verbose` = true"");
START     emptyDirCreating(); END 
  }
","  public static void setupDefaultTestCluster() throws Exception {
    config = DrillConfig.create(cloneDefaultTestConfigProperties());
    classpathScan = ClassPathScanner.fromPrescan(config);
    openClient();
    // turns on the verbose errors in tests
    // sever side stacktraces are added to the message before sending back to the client
    test(""ALTER SESSION SET `exec.errors.verbose` = true"");
  }
"
424,"As I am looking at the code, this is not necessary wrong, but maybe it would be better to throw new RuntimeException() in the end of the method. It's up to you what do you prefer.","    private static String parseAnnotationFieldTypeName(final Supplier<Class<?>> theTypeSupplier,
                                                       final String errorMessage) {
        try {
            theTypeSupplier.get();
            throw new RuntimeException(errorMessage);
        } catch (MirroredTypeException mte) {
            return mte.getTypeMirror().toString();
        }
    }
","    private static String parseAnnotationFieldTypeName(final Supplier<Class<?>> theTypeSupplier,
                                                       final String errorMessage) {
        try {
            theTypeSupplier.get();
START             throw new RuntimeException(errorMessage); END 
        } catch (MirroredTypeException mte) {
            return mte.getTypeMirror().toString();
        }
    }
","    private static String parseAnnotationFieldTypeName(final Supplier<Class<?>> theTypeSupplier,
                                                       final String errorMessage) {
        try {
            theTypeSupplier.get();
        } catch (MirroredTypeException mte) {
            return mte.getTypeMirror().toString();
        }

        // Failed to parse the field type name
        throw new RuntimeException(errorMessage);
    }
"
425,return `null` instead when there is no priority,"  default StreamPriority getStreamPriority() {
      return StreamPriority.DEFAULT;
  }
","  default StreamPriority getStreamPriority() {
START       return StreamPriority.DEFAULT; END 
  }
","  default StreamPriority getStreamPriority() {
      return null;
  }
"
426,?? Pourquoi cette ligne. Bootstrap est déjà une classe concrète...,"    protected void configure() {
        bind(EventDao.class).to(EventDaoInMemory.class).asEagerSingleton();
        bind(Bootstrap.class);
    }
","    protected void configure() {
        bind(EventDao.class).to(EventDaoInMemory.class).asEagerSingleton();
START         bind(Bootstrap.class); END 
    }
","    protected void configure() {
        bind(EventDao.class).to(EventDaoInMemory.class).asEagerSingleton();
    }
"
427,Second `ENABLED` check is not necessary if you have the first one.,"    public static void onAdvancementEvent(AdvancementEvent event)
    {
        if (ENABLED && event.getAdvancement().getDisplay() != null && event.getAdvancement().getDisplay().shouldAnnounceToChat())
        {
            logger.info(""{} got the {} advancement"", event.getEntityPlayer().getDisplayNameString(), event.getAdvancement().getDisplayText().getUnformattedText());
        }
    }
","    public static void onAdvancementEvent(AdvancementEvent event)
    {
START         if (ENABLED && event.getAdvancement().getDisplay() != null && event.getAdvancement().getDisplay().shouldAnnounceToChat()) END 
        {
            logger.info(""{} got the {} advancement"", event.getEntityPlayer().getDisplayNameString(), event.getAdvancement().getDisplayText().getUnformattedText());
        }
    }
","    public static void onAdvancementEvent(AdvancementEvent event)
    {
        if (event.getAdvancement().getDisplay() != null && event.getAdvancement().getDisplay().shouldAnnounceToChat())
        {
            logger.info(""{} got the {} advancement"", event.getEntityPlayer().getDisplayNameString(), event.getAdvancement().getDisplayText().getUnformattedText());
        }
    }
"
428,let's use URI.create and avoid try/catch,"    public ExampleEndpointsProvider() {
        // Put custom code here to get endpoints
        // In our case they will be hardcoded
        try {
            JHttpEndpoint httpEndpoint = new JHttpEndpoint(new URI(""https://jagger.griddynamics.net:443""));
            endpoints.add(httpEndpoint);
        } catch (URISyntaxException e) {
            throw new IllegalStateException(e);
        }
    }
","    public ExampleEndpointsProvider() {
        // Put custom code here to get endpoints
        // In our case they will be hardcoded
        try {
            JHttpEndpoint httpEndpoint = new JHttpEndpoint(new URI(""https://jagger.griddynamics.net:443""));
START             endpoints.add(httpEndpoint); END 
        } catch (URISyntaxException e) {
            throw new IllegalStateException(e);
        }
    }
","    public ExampleEndpointsProvider() {
        // Put custom code here to get endpoints
        // In our case they will be hardcoded
        JHttpEndpoint httpEndpoint = new JHttpEndpoint(URI.create(""https://jagger.griddynamics.net:443""));
        endpoints.add(httpEndpoint);
    }
"
429,do we need any content in this constructor at all?,"    public SlackUserProperty() {
        this.userId = null;
        this.disableNotifications = false;
    }
","    public SlackUserProperty() {
START         this.userId = null; END 
        this.disableNotifications = false;
    }
","    public SlackUserProperty() {
    }
"
430,do return,"	public void onStreamCreate(IMediaStream stream) {
		if (!stream.isTranscodeResult()) {
			PacketListener listener = new PacketListener();
			WMSProperties props = stream.getProperties();
			synchronized (props) {
				props.setProperty(STREAM_ACTION_LISTENER_PROPERTY, listener);
			}
			stream.addLivePacketListener(listener);
		}
	}
","	public void onStreamCreate(IMediaStream stream) {
START 		if (!stream.isTranscodeResult()) { END 
			PacketListener listener = new PacketListener();
			WMSProperties props = stream.getProperties();
			synchronized (props) {
				props.setProperty(STREAM_ACTION_LISTENER_PROPERTY, listener);
			}
			stream.addLivePacketListener(listener);
		}
	}
","	public void onStreamCreate(IMediaStream stream) {
		if (stream.isTranscodeResult()) {
			return;
		}
		PacketListener listener = new PacketListener();
		WMSProperties props = stream.getProperties();
		synchronized (props) {
			props.setProperty(STREAM_ACTION_LISTENER_PROPERTY, listener);
		}
		stream.addLivePacketListener(listener);

	}
"
431,result -> size,"    public long getEstimatedSizeInBytes()
    {
        int result = INSTANCE_SIZE;
        result += sizeOf(levelOffsets);
        result += tree.sizeOf();
        for (T item : items) {
            result += item.getEstimatedSizeInBytes();
        }
        return result;
    }
","    public long getEstimatedSizeInBytes()
    {
START         int result = INSTANCE_SIZE; END 
        result += sizeOf(levelOffsets);
        result += tree.sizeOf();
        for (T item : items) {
            result += item.getEstimatedSizeInBytes();
        }
        return result;
    }
","    public long getEstimatedSizeInBytes()
    {
        long result = INSTANCE_SIZE + sizeOf(levelOffsets) + tree.sizeOf();
        for (T item : items) {
            result += item.getEstimatedSizeInBytes();
        }
        return result;
    }
"
432,`==` instead of `.equals` (in both instances) would make this null-safe,"  public boolean respondsTo(RunEvent event) {
    Run r = event.getEventObject();
    if (event.getEventType().equals(MisoEventType.RUN_FAILED) && r.getHealth().equals(HealthType.Failed)) {

      log.info(""Run "" + r.getAlias() + "": "" + event.getEventMessage());
      return true;
    }
    return false;
  }
","  public boolean respondsTo(RunEvent event) {
    Run r = event.getEventObject();
START     if (event.getEventType().equals(MisoEventType.RUN_FAILED) && r.getHealth().equals(HealthType.Failed)) { END 

      log.info(""Run "" + r.getAlias() + "": "" + event.getEventMessage());
      return true;
    }
    return false;
  }
","  public boolean respondsTo(RunEvent event) {
    Run r = event.getEventObject();
    if (event.getEventType() == MisoEventType.RUN_FAILED && r.getHealth() == HealthType.Failed) {
      log.info(""Run "" + r.getAlias() + "": "" + event.getEventMessage());
      return true;
    }
    return false;
  }
"
433,en profiter pour  enlever cette variable intermédiaire?,"    public boolean isEnabled() {
        final boolean res = super.isEnabled() || isDirty();
        return res;
    }
","    public boolean isEnabled() {
START         final boolean res = super.isEnabled() || isDirty(); END 
        return res;
    }
","    public boolean isEnabled() {
        return super.isEnabled() || isDirty();
    }
"
434,"If I understand this change correctly, this shouldn't be needed anymore?","	private void updateSslVerifyUser(boolean value) {
		StoredConfig userConfig = GlobalConfigCache.getInstance()
				.getUserConfig();
		try {
			userConfig.load();
			updateSslVerify(userConfig, value);
		} catch (IOException | ConfigInvalidException e) {
			// Log it, but otherwise ignore here.
			LOG.error(MessageFormat.format(JGitText.get().userConfigFileInvalid,
					userConfig, e));
		}
	}
","	private void updateSslVerifyUser(boolean value) {
		StoredConfig userConfig = GlobalConfigCache.getInstance()
				.getUserConfig();
		try {
START 			userConfig.load(); END 
			updateSslVerify(userConfig, value);
		} catch (IOException | ConfigInvalidException e) {
			// Log it, but otherwise ignore here.
			LOG.error(MessageFormat.format(JGitText.get().userConfigFileInvalid,
					userConfig, e));
		}
	}
","	private void updateSslVerifyUser(boolean value) {
		StoredConfig userConfig = null;
		try {
			userConfig = GlobalConfigCache.getInstance().getUserConfig();
			updateSslVerify(userConfig, value);
		} catch (IOException | ConfigInvalidException e) {
			// Log it, but otherwise ignore here.
			LOG.error(MessageFormat.format(JGitText.get().userConfigFileInvalid,
					userConfig, e));
		}
	}
"
435,"this method could be static i guess?
more relevant: is this method necessary? i only see one usage","	private boolean isUserBrickAdapter(BaseAdapter baseAdapter) {
		return baseAdapter instanceof UserBrickAdapter;
	}
","START 	private boolean isUserBrickAdapter(BaseAdapter baseAdapter) { END 
		return baseAdapter instanceof UserBrickAdapter;
	}
","	private static boolean isUserBrickAdapter(BaseAdapter baseAdapter) {
		return baseAdapter instanceof UserBrickAdapter;
	}
"
436,Please check if the fragment exists. It could lead to a null-pointer exception.,"	private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor(CategoryListItem categoryListItem) {
		FormulaEditorFragment formulaEditorFragment = ((FormulaEditorFragment) getFragmentManager()
				.findFragmentByTag(FormulaEditorFragment.FORMULA_EDITOR_FRAGMENT_TAG));
		formulaEditorFragment.addResourceToActiveFormula(categoryListItem.nameResId);
		return formulaEditorFragment;
	}
","	private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor(CategoryListItem categoryListItem) {
		FormulaEditorFragment formulaEditorFragment = ((FormulaEditorFragment) getFragmentManager()
				.findFragmentByTag(FormulaEditorFragment.FORMULA_EDITOR_FRAGMENT_TAG));
START 		formulaEditorFragment.addResourceToActiveFormula(categoryListItem.nameResId); END 
		return formulaEditorFragment;
	}
","	private FormulaEditorFragment addResourceToActiveFormulaInFormulaEditor(CategoryListItem categoryListItem) {
		FormulaEditorFragment formulaEditorFragment = null;
		if (getFragmentManager() != null) {
			formulaEditorFragment = ((FormulaEditorFragment) getFragmentManager()
					.findFragmentByTag(FormulaEditorFragment.FORMULA_EDITOR_FRAGMENT_TAG));
			if (formulaEditorFragment != null) {
				formulaEditorFragment.addResourceToActiveFormula(categoryListItem.nameResId);
			}
		}
		return formulaEditorFragment;
	}
"
437,Shouldn't this return ReviewCategoryStrategy.NONE? Otherwise why do we have ReviewCategoryStrategy.NONE if null means NONE too?,"  public final ReviewCategoryStrategy reviewCategoryStrategy() {
    String s = reviewCategeoryStrategyRaw();
    return s != null ? ReviewCategoryStrategy.valueOf(s) : null;
  }
","  public final ReviewCategoryStrategy reviewCategoryStrategy() {
    String s = reviewCategeoryStrategyRaw();
    return s != null ? ReviewCategoryStrategy.valueOf(s) : START  null; END 
  }
","  public final ReviewCategoryStrategy reviewCategoryStrategy() {
    String s = reviewCategeoryStrategyRaw();
    return s != null ? ReviewCategoryStrategy.valueOf(s) : ReviewCategoryStrategy.NONE;
  }
"
438,`metastore` is nullable here,"    public Iterable<ConnectorFactory> getConnectorFactories()
    {
        return ImmutableList.of(new HiveConnectorFactory(name, getClassLoader(), Optional.of(metastore)));
    }
","    public Iterable<ConnectorFactory> getConnectorFactories()
    {
START         return ImmutableList.of(new HiveConnectorFactory(name, getClassLoader(), Optional.of(metastore))); END 
    }
","    public Iterable<ConnectorFactory> getConnectorFactories()
    {
        return ImmutableList.of(new HiveConnectorFactory(name, getClassLoader(), metastore));
    }
"
439,Did you apply saveaction?,"  public void testDBConnectionTimeMetrics() {
    metrics.setDBConnectionTime(14);
    assertEquals(14, testUtil.getGaugeValue(""dbConnectionTime""));
  }
","  public void testDBConnectionTimeMetrics() {
START     metrics.setDBConnectionTime(14); END 
    assertEquals(14, testUtil.getGaugeValue(""dbConnectionTime""));
  }
","  public void testDBConnectionTimeMetrics() {
    this.metrics.setDBConnectionTime(14);
    assertEquals(14, this.testUtil.getGaugeValue(""dbConnectionTime""));
  }
"
440,"I think I like 20 better, to exercise the key migration code more.","   protected void createCacheManagers() throws Throwable {
      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(getCacheMode(), true);
      builder.clustering().stateTransfer().chunkSize(200).sync().replTimeout(45, TimeUnit.SECONDS);
      createClusteredCaches(4, cacheName(), builder);
   }
","   protected void createCacheManagers() throws Throwable {
      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(getCacheMode(), true);
START       builder.clustering().stateTransfer().chunkSize(200).sync().replTimeout(45, TimeUnit.SECONDS); END 
      createClusteredCaches(4, cacheName(), builder);
   }
","   protected void createCacheManagers() throws Throwable {
      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(getCacheMode(), true);
      builder.clustering().stateTransfer().sync().replTimeout(45, TimeUnit.SECONDS);
      createClusteredCaches(4, cacheName(), builder);
   }
"
441,getFullName(),"  private String getByAccountName(CodeReviewCommit codeReviewCommit) {
    Account account = getAccount(codeReviewCommit);
    if (account != null && account.getFullName() != null) {
      return "" by "" + account.getUserName();
    }
    return """";
  }
","  private String getByAccountName(CodeReviewCommit codeReviewCommit) {
    Account account = getAccount(codeReviewCommit);
    if (account != null && account.getFullName() != null) {
      return "" by "" + START account.getUserName(); END 
    }
    return """";
  }
","  private String getByAccountName(CodeReviewCommit codeReviewCommit) {
    Account account = getAccount(codeReviewCommit);
    if (account != null && account.getFullName() != null) {
      return "" by "" + account.getFullName();
    }
    return """";
  }
"
442,I believe the Auth system should remain on in this method.,"    public void findByUndefinedSchema() throws Exception {
        context.turnOffAuthorisationSystem();

        getClient().perform(get(""/api/core/metadatafields/search/bySchema"")
                        .param(""schema"", ""undefined""))
                   .andExpect(status().isOk())
                   .andExpect(content().contentType(contentType))
                   .andExpect(jsonPath(""$.page.size"", is(20)))
                   .andExpect(jsonPath(""$.page.totalElements"", is(0)));
    }
","    public void findByUndefinedSchema() throws Exception {
START         context.turnOffAuthorisationSystem(); END 

        getClient().perform(get(""/api/core/metadatafields/search/bySchema"")
                        .param(""schema"", ""undefined""))
                   .andExpect(status().isOk())
                   .andExpect(content().contentType(contentType))
                   .andExpect(jsonPath(""$.page.size"", is(20)))
                   .andExpect(jsonPath(""$.page.totalElements"", is(0)));
    }
","    public void findByUndefinedSchema() throws Exception {

        getClient().perform(get(""/api/core/metadatafields/search/bySchema"")
                                .param(""schema"", ""undefined""))
                   .andExpect(status().isOk())
                   .andExpect(content().contentType(contentType))
                   .andExpect(jsonPath(""$.page.size"", is(20)))
                   .andExpect(jsonPath(""$.page.totalElements"", is(0)));
    }
"
443,private static,"    private void addAll(QuantileDigest digest, long... values)
    {
        requireNonNull(values, ""values is null"");
        for (long value : values) {
            digest.add(value);
        }
    }
","START     private void addAll(QuantileDigest digest, long... values) END 
    {
        requireNonNull(values, ""values is null"");
        for (long value : values) {
            digest.add(value);
        }
    }
","    private static void addAll(QuantileDigest digest, long... values)
    {
        requireNonNull(values, ""values is null"");
        for (long value : values) {
            digest.add(value);
        }
    }
"
444,Move this to default.,"    protected Object encodeCommand(Command command) {

        initDevicePassword(command, LaipacProtocolDecoder.DEFAULT_DEVICE_PASSWORD);

        switch (command.getType()) {
            case Command.TYPE_CUSTOM:
                return formatCommand(command, ""{%s}"",
                    Command.KEY_DATA);
            case Command.TYPE_POSITION_SINGLE:
                return formatCommand(command, ""AVREQ,{%s},1"",
                    Command.KEY_DEVICE_PASSWORD);
            case Command.TYPE_REBOOT_DEVICE:
                return formatCommand(command, ""AVRESET,{%s},{%s}"",
                    Command.KEY_UNIQUE_ID, Command.KEY_DEVICE_PASSWORD);
            default:
                break;
        }

        return null;
    }
","    protected Object encodeCommand(Command command) {

        initDevicePassword(command, LaipacProtocolDecoder.DEFAULT_DEVICE_PASSWORD);

        switch (command.getType()) {
            case Command.TYPE_CUSTOM:
                return formatCommand(command, ""{%s}"",
                    Command.KEY_DATA);
            case Command.TYPE_POSITION_SINGLE:
                return formatCommand(command, ""AVREQ,{%s},1"",
                    Command.KEY_DEVICE_PASSWORD);
            case Command.TYPE_REBOOT_DEVICE:
                return formatCommand(command, ""AVRESET,{%s},{%s}"",
                    Command.KEY_UNIQUE_ID, Command.KEY_DEVICE_PASSWORD);
            default:
                break;
        }

START         return null; END 
    }
","    protected Object encodeCommand(Command command) {

        initDevicePassword(command, LaipacProtocolDecoder.DEFAULT_DEVICE_PASSWORD);

        switch (command.getType()) {
            case Command.TYPE_CUSTOM:
                return formatCommand(command, ""{%s}"",
                    Command.KEY_DATA);
            case Command.TYPE_POSITION_SINGLE:
                return formatCommand(command, ""AVREQ,{%s},1"",
                    Command.KEY_DEVICE_PASSWORD);
            case Command.TYPE_REBOOT_DEVICE:
                return formatCommand(command, ""AVRESET,{%s},{%s}"",
                    Command.KEY_UNIQUE_ID, Command.KEY_DEVICE_PASSWORD);
            default:
                return null;
        }

    }
"
445,"We shouldn't need to check or clear any fields here, as `SelectObjectContentResult` is a `Closeable` which guarantees that `close()` is idempotent:

> If the stream is already closed then invoking this method has no effect.","    public void close()
            throws IOException
    {
        if (selectObjectContentResult != null) {
            selectObjectContentResult.close();
            selectObjectContentResult = null;
            selectObjectRequest = null;
        }
    }
","    public void close()
            throws IOException
    {
START         if (selectObjectContentResult != null) { END 
            selectObjectContentResult.close();
            selectObjectContentResult = null;
            selectObjectRequest = null;
        }
    }
","    public void close()
            throws IOException
    {
        selectObjectContentResult.close();
    }
"
446,"`get()`. (Btw since `inner` is plain, this check may end up hoisted and you'd never see it turning null).","        @Override public boolean isDisposed() {
            return inner == null;
        }
","        @Override public boolean isDisposed() {
START             return inner == null; END 
        }
","        @Override public boolean isDisposed() {
            return get();
        }
"
447,I think that we need `super.close()` here.,"    public void close() throws IOException {
        if (s3Object != null) {
            s3Object.close();
        }
    }
","    public void close() throws IOException {
        if (s3Object != null) {
START             s3Object.close(); END 
        }
    }
","    public void close() throws IOException {
        super.close();
        if (s3Object != null) {
            s3Object.close();
        }
    }
"
448,"(z, z) certainly doesn't look right.","	public void loadChunk(int x, int z) {
		w.loadChunk(z, z);
	}
","	public void loadChunk(int x, int z) {
START 		w.loadChunk(z, z); END 
	}
","	public void loadChunk(int x, int z) {
		w.loadChunk(x, z);
	}
"
449,rm public,"    public GeneratorUtil(TypeOracle typeOracle,
                         Logger logger,
                         GeneratorContext generatorContext) {
        this.typeOracle = typeOracle;
        this.logger = logger;
        this.generatorContext = generatorContext;
    }
","START     public GeneratorUtil(TypeOracle typeOracle, END 
                         Logger logger,
                         GeneratorContext generatorContext) {
        this.typeOracle = typeOracle;
        this.logger = logger;
        this.generatorContext = generatorContext;
    }
","    GeneratorUtil(TypeOracle typeOracle,
                  Logger logger,
                  GeneratorContext generatorContext) {
        this.typeOracle = typeOracle;
        this.logger = logger;
        this.generatorContext = generatorContext;
    }
"
450,replace equals with == for enums.,"    protected boolean failPassthroughVnicHotPlug() {
        if (VmInterfaceType.pciPassthrough.equals(VmInterfaceType.forValue(getParameters().getNic().getType()))) {
            addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED);
            return true;
        }
        return false;
    }
","    protected boolean failPassthroughVnicHotPlug() {
        if START (VmInterfaceType.pciPassthrough.equals(VmInterfaceType.forValue(getParameters().getNic().getType()))) END  {
            addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED);
            return true;
        }
        return false;
    }
","    protected boolean failPassthroughVnicHotPlug() {
        if (VmInterfaceType.pciPassthrough == VmInterfaceType.forValue(getParameters().getNic().getType())) {
            addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED);
            return true;
        }
        return false;
    }
"
451,It would be great if this map could use generics so we know what it contains.,"    public List<Map> getStageReachedCounts(Context context) throws SQLException {
        return workspaceItemDAO.getStageReachedCounts(context);
    }
","START     public List<Map> getStageReachedCounts(Context context) throws SQLException { END 
        return workspaceItemDAO.getStageReachedCounts(context);
    }
","    public List<Map.Entry<Integer, Long>> getStageReachedCounts(Context context) throws SQLException {
        return workspaceItemDAO.getStageReachedCounts(context);
    }
"
452,usually this `) {` is on the next line,"        Evaluator(
            final ObjectMapper mapper,
            final AsyncTaskExecutor asyncTaskExecutor,
            final long timeoutLength) {
            this.mapper = mapper;
            this.asyncTaskExecutor = asyncTaskExecutor;
            this.timeoutLength = timeoutLength;
        }
","        Evaluator(
            final ObjectMapper mapper,
            final AsyncTaskExecutor asyncTaskExecutor,
START             final long timeoutLength) { END 
            this.mapper = mapper;
            this.asyncTaskExecutor = asyncTaskExecutor;
            this.timeoutLength = timeoutLength;
        }
","        protected Evaluator(
            final ObjectMapper mapper,
            final AsyncTaskExecutor asyncTaskExecutor,
            final long timeoutLength
        ) {
            this.mapper = mapper;
            this.asyncTaskExecutor = asyncTaskExecutor;
            this.timeoutLength = timeoutLength;
        }
"
453,"do we still need to throw exception here? if not, you can remove the next TODO","  public MetaMasterSync(Address masterAddress, MetaMasterMasterClient masterClient)
      throws IOException {
    // TODO(lu) should avoid throw exception in Java constructor to avoid half-baked class instances
    mMasterAddress = masterAddress;
    mMasterClient = masterClient;
    mHeartbeatTimeoutMs = (int) Configuration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT_MS);
    mLastSuccessfulHeartbeatMs = System.currentTimeMillis() - mHeartbeatTimeoutMs;
  }
","  public MetaMasterSync(Address masterAddress, MetaMasterMasterClient masterClient)
START       throws IOException { END 
    // TODO(lu) should avoid throw exception in Java constructor to avoid half-baked class instances
    mMasterAddress = masterAddress;
    mMasterClient = masterClient;
    mHeartbeatTimeoutMs = (int) Configuration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT_MS);
    mLastSuccessfulHeartbeatMs = System.currentTimeMillis() - mHeartbeatTimeoutMs;
  }
","  public MetaMasterSync(Address masterAddress, MetaMasterMasterClient masterClient) {
    mMasterAddress = masterAddress;
    mMasterClient = masterClient;
    mHeartbeatTimeoutMs = (int) Configuration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT_MS);
    mLastSuccessfulHeartbeatMs = System.currentTimeMillis() - mHeartbeatTimeoutMs;
  }
"
454,"Seems me a 

````
listeners.forEach(listener -> layerDeleted(layerName));
````

would have been at the same time more compact, readable, and faster (streams are very slow)","    public void sendLayerDeleted(String layerName) {
        listeners.stream().forEachOrdered(listener->{
            listener.layerDeleted(layerName);
        });
    }
","    public void sendLayerDeleted(String layerName) {
START         listeners.stream().forEachOrdered(listener->{ END 
            listener.layerDeleted(layerName);
        });
    }
","    public void sendLayerDeleted(String layerName) {
        listeners.forEach(listener->{
            listener.layerDeleted(layerName);
        });
    }
"
455,Please immutable collection.,"  public List<SqlIdentifier> getProjectionFields(MetadataType metadataLevel, OptionManager options) {
    List<SqlIdentifier> columnList = new ArrayList<>();
    columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_FQN_COLUMN_LABEL), SqlParserPos.ZERO));
    columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL), SqlParserPos.ZERO));
    return columnList;
  }
","  public List<SqlIdentifier> getProjectionFields(MetadataType metadataLevel, OptionManager options) {
START     List<SqlIdentifier> columnList = new ArrayList<>(); END 
    columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_FQN_COLUMN_LABEL), SqlParserPos.ZERO));
    columnList.add(new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL), SqlParserPos.ZERO));
    return columnList;
  }
","  public List<SqlIdentifier> getProjectionFields(MetadataType metadataLevel, OptionManager options) {
    return Arrays.asList(
        new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_FQN_COLUMN_LABEL), SqlParserPos.ZERO),
        new SqlIdentifier(options.getString(ExecConstants.IMPLICIT_LAST_MODIFIED_TIME_COLUMN_LABEL), SqlParserPos.ZERO));
  }
"
456,can TypedSnapshotBase constructor take SnapshotBase instead of Snapshot?,"  protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) {
    super((Snapshot)tx, encoder, tl);
    this.tx = tx;
    this.encoder = encoder;
    this.tl = tl;
  }
","  protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) {
START     super((Snapshot)tx, encoder, tl); END 
    this.tx = tx;
    this.encoder = encoder;
    this.tl = tl;
  }
","  protected TypedTransaction(Transaction tx, Encoder encoder, TypeLayer tl) {
    super(tx, encoder, tl);
    this.tx = tx;
    this.encoder = encoder;
    this.tl = tl;
  }
"
457,"`permissions` can't be `null`, otherwise the constructor would throw a NPE.","   public int hashCode() {
      int result = name != null ? name.hashCode() : 0;
      result = 31 * result + (permissions != null ? permissions.hashCode() : 0);
      result = 31 * result + mask;
      return result;
   }
","   public int hashCode() {
      int result = name != null ? name.hashCode() : 0;
START       result = 31 * result + (permissions != null ? permissions.hashCode() : 0); END 
      result = 31 * result + mask;
      return result;
   }
","   public int hashCode() {
      int result = name.hashCode();
      result = 31 * result + permissions.hashCode();
      result = 31 * result + mask;
      return result;
   }
"
458,this.contributor,"	public EEFTabbedPropertySheetPage(Object contributor, String contributorId) {
		if (contributor instanceof IEEFTabbedPropertySheetPageContributor) {
			this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor;
		} else {
			this.contributor = new ContributorWrapper(contributor, contributorId);
		}
		this.registry = EEFTabbedPropertyRegistry.getDefault(this.contributor.getContributorId());
	}
","	public EEFTabbedPropertySheetPage(Object contributor, String contributorId) {
		if (contributor instanceof IEEFTabbedPropertySheetPageContributor) {
			this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor;
		} else {
			this.contributor = new ContributorWrapper(contributor, contributorId);
		}
		this.registry = START EEFTabbedPropertyRegistry.getDefault(this.contributor.getContributorId()); END 
	}
","	public EEFTabbedPropertySheetPage(Object contributor, String contributorId) {
		if (contributor instanceof IEEFTabbedPropertySheetPageContributor) {
			this.contributor = (IEEFTabbedPropertySheetPageContributor) contributor;
		} else {
			this.contributor = new ContributorWrapper(contributor, contributorId);
		}
		this.registry = EEFTabbedPropertyRegistry.getDefault(this.contributor);
	}
"
459,You should probably extract the world-stream extraction to its own method.,"    public List<String> getSuggestions(String input) {
        return WorldEdit.getInstance().getPlatformManager()
                .queryCapability(Capability.GAME_HOOKS).getWorlds().stream()
                .map(World::getId)
                .filter(world -> world.startsWith(input))
                .collect(Collectors.toList());
    }
","    public List<String> getSuggestions(String input) {
START         return WorldEdit.getInstance().getPlatformManager() END 
                .queryCapability(Capability.GAME_HOOKS).getWorlds().stream()
                .map(World::getId)
                .filter(world -> world.startsWith(input))
                .collect(Collectors.toList());
    }
","    public List<String> getSuggestions(String input) {
        return getWorlds()
                .map(World::getId)
                .filter(world -> world.startsWith(input))
                .collect(Collectors.toList());
    }
"
460,"I don't understand something - now we will perform the this command for one host and then the connection will be removed from db, how we will perform the disconnect for other hosts? the load of connection will return null..no?  you should take care of that i guess.","    protected void executeCommand() {
       //disconnect the connection from vdsm
       boolean isStorageDisconnectSucceeded = disconnectStorage();

       if(isStorageDisconnectSucceeded) {
             String connectionId = getConnection().getid();
             if(StringUtils.isNotEmpty(connectionId)) {
                 //remove the connection record from db
                 getDbFacade().getStorageServerConnectionDao().remove(connectionId);
                 setSucceeded(true);
             }
       }
    }
","START     protected void executeCommand() { END 
       //disconnect the connection from vdsm
       boolean isStorageDisconnectSucceeded = disconnectStorage();

       if(isStorageDisconnectSucceeded) {
             String connectionId = getConnection().getid();
             if(StringUtils.isNotEmpty(connectionId)) {
                 //remove the connection record from db
                 getDbFacade().getStorageServerConnectionDao().remove(connectionId);
                 setSucceeded(true);
             }
       }
    }
","    protected void executeCommand() {
       //disconnect the connection from vdsm
       boolean isStorageDisconnectSucceeded = disconnectStorage();

       if(isStorageDisconnectSucceeded) {
             String connectionId = getConnection().getid();
             if(StringUtils.isNotEmpty(connectionId)) {
                 //remove the connection record from db
                 getDbFacade().getStorageServerConnectionDao().remove(connectionId);
             }
             setSucceeded(true);
       }
    }
"
461,curious: why remove `anyTree`?,"    public void testNotEliminateSorts()
    {
        @Language(""SQL"") String sql = ""SELECT quantity, row_number() OVER (ORDER BY quantity) FROM lineitem ORDER BY tax"";

        PlanMatchPattern pattern =
                anyTree(
                        sort(
                                window(windowMatcherBuilder -> windowMatcherBuilder
                                                .specification(windowSpec)
                                                .addFunction(functionCall(""row_number"", Optional.empty(), ImmutableList.of())),
                                        anyTree(LINEITEM_TABLESCAN_Q))));
        assertUnitPlan(sql, pattern);
    }
","    public void testNotEliminateSorts()
    {
        @Language(""SQL"") String sql = ""SELECT quantity, row_number() OVER (ORDER BY quantity) FROM lineitem ORDER BY tax"";

        PlanMatchPattern pattern =
                anyTree(
                        sort(
START                                 window(windowMatcherBuilder -> windowMatcherBuilder END 
                                                .specification(windowSpec)
                                                .addFunction(functionCall(""row_number"", Optional.empty(), ImmutableList.of())),
                                        anyTree(LINEITEM_TABLESCAN_Q))));
        assertUnitPlan(sql, pattern);
    }
","    public void testNotEliminateSorts()
    {
        @Language(""SQL"") String sql = ""SELECT quantity, row_number() OVER (ORDER BY quantity) FROM lineitem ORDER BY tax"";

        PlanMatchPattern pattern =
                anyTree(
                        sort(
                                anyTree(
                                        window(windowMatcherBuilder -> windowMatcherBuilder
                                                        .specification(windowSpec)
                                                        .addFunction(functionCall(""row_number"", Optional.empty(), ImmutableList.of())),
                                                anyTree(LINEITEM_TABLESCAN_Q)))));

        assertUnitPlan(sql, pattern);
    }
"
462,Perform this operation in the custom ProgramFinder.findProgram() method instead.,"   public Program getAssociatedProgram(Artifact artifact) {
      String extension = getAssociatedExtension(artifact);
      Program program = ProgramFinder.findProgram(extension.toLowerCase());
      if (program == null) {
         throw new OseeArgumentException(""No program associated with the extension [%s] found on your local machine."",
            extension);
      }
      return program;
   }
","   public Program getAssociatedProgram(Artifact artifact) {
      String extension = getAssociatedExtension(artifact);
      Program program = START ProgramFinder.findProgram(extension.toLowerCase()); END 
      if (program == null) {
         throw new OseeArgumentException(""No program associated with the extension [%s] found on your local machine."",
            extension);
      }
      return program;
   }
","   public Program getAssociatedProgram(Artifact artifact) {
      String extension = getAssociatedExtension(artifact);
      Program program = ProgramFinder.findProgram(extension);
      if (program == null) {
         throw new OseeArgumentException(""No program associated with the extension [%s] found on your local machine."",
            extension);
      }
      return program;
   }
"
463,"Please replace all the occurrences of `AbstractTree.this`. Indeed, the code style we are using does not recommend to add `this` as a prefix of a function call when the function is in the current object.","	public final Iterable<N> toDepthFirstIterable() {
		return () ->  AbstractTree.this.depthFirstIterator();
	}
","	public final Iterable<N> toDepthFirstIterable() {
START 		return () ->  AbstractTree.this.depthFirstIterator(); END 
	}
","	public final Iterable<N> toDepthFirstIterable() {
		return () ->  this.depthFirstIterator();
	}
"
464,This is definitely a leftover that must be removed.,"   void put(final K key, final V value) {
      clusterRegistry.put(scope, key, value);
      System.out.println(""putting key ""+key+"" ffrom thread ""+Thread.currentThread().getName());
      localCacheInsert(key, value);
   }
","   void put(final K key, final V value) {
      clusterRegistry.put(scope, key, value);
START       System.out.println(""putting key ""+key+"" ffrom thread ""+Thread.currentThread().getName()); END 
      localCacheInsert(key, value);
   }
","   void put(final K key, final V value) {
      clusterRegistry.put(scope, key, value);
      localCacheInsert(key, value);
   }
"
465,Missed a space here between the `)` and `{`,"  public static String getWarningMessages(String filename){
    String warningMessage = """";
    if (getErrorMessage(filename).length() == 0 && filename.length() > 0) {
      if (!filename.matches(""[A-Za-z][A-Za-z0-9_]*"")) {
        // check to make sure if filename has no spaces
        String errorMessage = MESSAGES.whitespaceProjectNameError();
        filename = filename.replaceAll(""( )+"", "" "").replace("" "",""_"");
        warningMessage = errorMessage + "". \n '"" + filename + ""' will be used if continued."";
      }
    }
    return warningMessage;
  }
","START   public static String getWarningMessages(String filename){ END 
    String warningMessage = """";
    if (getErrorMessage(filename).length() == 0 && filename.length() > 0) {
      if (!filename.matches(""[A-Za-z][A-Za-z0-9_]*"")) {
        // check to make sure if filename has no spaces
        String errorMessage = MESSAGES.whitespaceProjectNameError();
        filename = filename.replaceAll(""( )+"", "" "").replace("" "",""_"");
        warningMessage = errorMessage + "". \n '"" + filename + ""' will be used if continued."";
      }
    }
    return warningMessage;
  }
","  public static String getWarningMessages(String filename) {
    String warningMessage = """";
    if (getErrorMessage(filename).length() == 0 && filename.trim().length() > 0) {
      if (!filename.matches(""[A-Za-z][A-Za-z0-9_]*"")) {
        // check to make sure if filename has no spaces
        String errorMessage = MESSAGES.whitespaceProjectNameError();
        filename = filename.trim().replaceAll(""( )+"", "" "").replace("" "",""_"");
        warningMessage = errorMessage + "". \n '"" + filename + ""' will be used if continued."";
      }
    }
    return warningMessage;
  }
"
466,this doesn't seem to change anything for me?,"    public @NonNull TraceSessionComponent[] getSessions() {
        List<ITraceControlComponent> compenents = getChildren(TraceSessionGroup.class);
        if (compenents.size() > 0) {
            TraceSessionGroup group = (TraceSessionGroup)compenents.get(0);
            List<ITraceControlComponent> sessions = group.getChildren(TraceSessionComponent.class);
            return sessions.toArray(new @NonNull TraceSessionComponent[sessions.size()]);
        }
        return new @NonNull TraceSessionComponent[0];
    }
","    public @NonNull TraceSessionComponent[] getSessions() {
        List<ITraceControlComponent> compenents = getChildren(TraceSessionGroup.class);
        if (compenents.size() > 0) {
            TraceSessionGroup group = (TraceSessionGroup)compenents.get(0);
            List<ITraceControlComponent> sessions = group.getChildren(TraceSessionComponent.class);
            return sessions.toArray(new @NonNull TraceSessionComponent[sessions.size()]);
        }
        return new START @NonNull TraceSessionComponent[0]; END 
    }
","    public @NonNull TraceSessionComponent[] getSessions() {
        List<ITraceControlComponent> compenents = getChildren(TraceSessionGroup.class);
        if (compenents.size() > 0) {
            TraceSessionGroup group = (TraceSessionGroup)compenents.get(0);
            List<ITraceControlComponent> sessions = group.getChildren(TraceSessionComponent.class);
            return sessions.toArray(new @NonNull TraceSessionComponent[sessions.size()]);
        }
        return new TraceSessionComponent[0];
    }
"
467,Minor: Move declaration before the if block where it is used?,"	private static void cacheColors(Display display) {
		BG_COLOR_RGB= JFaceColors.getInformationViewerBackgroundColor(display).getRGB();
		FG_COLOR_RGB= JFaceColors.getInformationViewerForegroundColor(display).getRGB();
		Color hyperlinkText= JFaceColors.getHyperlinkText(display);
		Color activeHyperlinkText= JFaceColors.getActiveHyperlinkText(display);
		if (hyperlinkText != null) {
			LINK_COLOR_RGB= hyperlinkText.getRGB();
		}
		if (activeHyperlinkText != null) {
			ACTIVE_LINK_COLOR_RGB= activeHyperlinkText.getRGB();
		}
	}
","	private static void cacheColors(Display display) {
		BG_COLOR_RGB= JFaceColors.getInformationViewerBackgroundColor(display).getRGB();
		FG_COLOR_RGB= JFaceColors.getInformationViewerForegroundColor(display).getRGB();
		Color hyperlinkText= JFaceColors.getHyperlinkText(display);
START 		Color activeHyperlinkText= JFaceColors.getActiveHyperlinkText(display); END 
		if (hyperlinkText != null) {
			LINK_COLOR_RGB= hyperlinkText.getRGB();
		}
		if (activeHyperlinkText != null) {
			ACTIVE_LINK_COLOR_RGB= activeHyperlinkText.getRGB();
		}
	}
","	private static void cacheColors(Display display) {
		BG_COLOR_RGB= JFaceColors.getInformationViewerBackgroundColor(display).getRGB();
		FG_COLOR_RGB= JFaceColors.getInformationViewerForegroundColor(display).getRGB();
		Color hyperlinkText= JFaceColors.getHyperlinkText(display);
		if (hyperlinkText != null) {
			LINK_COLOR_RGB= hyperlinkText.getRGB();
		}
		Color activeHyperlinkText= JFaceColors.getActiveHyperlinkText(display);
		if (activeHyperlinkText != null) {
			ACTIVE_LINK_COLOR_RGB= activeHyperlinkText.getRGB();
		}
	}
"
468,"you can use TypeCastUtility.getGenericsParameterClass(getClass(), IHolder.class); to check the type parameter","  private IRadioButton<T> findFirstButtonInFieldTree(IFormField f) {
    if (f instanceof IRadioButton) {
      return (IRadioButton<T>) f; //TODO: mnick
    }
    else if (f instanceof ICompositeField) {
      for (IFormField sub : ((ICompositeField) f).getFields()) {
        IRadioButton<T> b = findFirstButtonInFieldTree(sub);
        if (b != null) {
          return b;
        }
      }
    }
    return null;
  }
","  private IRadioButton<T> findFirstButtonInFieldTree(IFormField f) {
    if (f instanceof IRadioButton) {
START       return (IRadioButton<T>) f; //TODO: mnick END 
    }
    else if (f instanceof ICompositeField) {
      for (IFormField sub : ((ICompositeField) f).getFields()) {
        IRadioButton<T> b = findFirstButtonInFieldTree(sub);
        if (b != null) {
          return b;
        }
      }
    }
    return null;
  }
","  private IRadioButton<T> findFirstButtonInFieldTree(IFormField f) {
    if (f instanceof IRadioButton) {
      return (IRadioButton) f;
    }
    else if (f instanceof ICompositeField) {
      for (IFormField sub : ((ICompositeField) f).getFields()) {
        IRadioButton<T> b = findFirstButtonInFieldTree(sub);
        if (b != null) {
          return b;
        }
      }
    }
    return null;
  }
"
469,fix name,"    public void testGenerateXpathSuppressionOptionEmptyConfig() throws Exception {
        final String expected = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n""
                + ""<!DOCTYPE suppressions PUBLIC\n""
                + ""    \""-//Puppy Crawl//DTD Suppressions Xpath Experimental 1.2//EN\""\n""
                + ""    \""http://checkstyle.sourceforge.net/dtds/""
                + ""suppressions_1_2_xpath_experimental.dtd\"">\n""
                + ""<suppressions>\n""
                + ""</suppressions>\n"";

        exit.checkAssertionAfterwards(() -> {
            assertEquals(""Unexpected output log"",
                    expected, systemOut.getLog());
            assertEquals(""Unexpected system error log"",
                    """", systemErr.getLog());
        });
        Main.main(""-c"", getPath(""InputMainConfig-empty.xml""), ""--generate-xpath-suppression"",
                getPath(""InputMainComplexityOverflow.java""));
    }
","    public void testGenerateXpathSuppressionOptionEmptyConfig() throws Exception {
        final String expected = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n""
                + ""<!DOCTYPE suppressions PUBLIC\n""
START                 + ""    \""-//Puppy Crawl//DTD Suppressions Xpath Experimental 1.2//EN\""\n"" END 
                + ""    \""http://checkstyle.sourceforge.net/dtds/""
                + ""suppressions_1_2_xpath_experimental.dtd\"">\n""
                + ""<suppressions>\n""
                + ""</suppressions>\n"";

        exit.checkAssertionAfterwards(() -> {
            assertEquals(""Unexpected output log"",
                    expected, systemOut.getLog());
            assertEquals(""Unexpected system error log"",
                    """", systemErr.getLog());
        });
        Main.main(""-c"", getPath(""InputMainConfig-empty.xml""), ""--generate-xpath-suppression"",
                getPath(""InputMainComplexityOverflow.java""));
    }
","    public void testGenerateXpathSuppressionOptionEmptyConfig() throws Exception {
        final String expected = """";

        exit.checkAssertionAfterwards(() -> {
            assertEquals(""Unexpected output log"",
                    expected, systemOut.getLog());
            assertEquals(""Unexpected system error log"",
                    """", systemErr.getLog());
        });
        Main.main(""-c"", getPath(""InputMainConfig-empty.xml""), ""--generate-xpath-suppression"",
                getPath(""InputMainComplexityOverflow.java""));
    }
"
470,Can this method return null? Or should it return empty string?,"    public String getPackageName() {
        if (clazz.getPackage() != null) {
            return clazz.getPackage().getName();
        }
        return null;
    }
","    public String getPackageName() {
        if (clazz.getPackage() != null) {
            return clazz.getPackage().getName();
        }
START         return null; END 
    }
","    public String getPackageName() {
        if (clazz.getPackage() != null) {
            return clazz.getPackage().getName();
        }
        return """";
    }
"
471,This could also be `java.lang.String`.,"    public void testIsStringLiteral() {
        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST1);
        ASTLiteral literal = literals.iterator().next();
        assertTrue(literal.isStringLiteral());
        assertEquals(""String"", literal.getTypeImage());
    }
","    public void testIsStringLiteral() {
        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST1);
        ASTLiteral literal = literals.iterator().next();
        assertTrue(literal.isStringLiteral());
START         assertEquals(""String"", literal.getTypeImage()); END 
    }
","    public void testIsStringLiteral() {
        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST1);
        assertTrue((literals.iterator().next()).isStringLiteral());
    }
"
472,formatting weird,"  public ImmutableMap<K, V> getAllPresent(final Iterable<K> keys)
  {
    ImmutableMap.Builder builder = ImmutableMap.builder();
    for (K key : keys
        ) {
      V value = getIfPresent(key);
      if (value != null) {
        builder.put(key, value);
      }
    }
    return builder.build();
  }
","  public ImmutableMap<K, V> getAllPresent(final Iterable<K> keys)
  {
    ImmutableMap.Builder builder = ImmutableMap.builder();
    for (K key : keys
START         ) { END 
      V value = getIfPresent(key);
      if (value != null) {
        builder.put(key, value);
      }
    }
    return builder.build();
  }
","  public Map<K, V> getAllPresent(final Iterable<K> keys)
  {
    ImmutableMap.Builder builder = ImmutableMap.builder();
    for (K key : keys
        ) {
      V value = getIfPresent(key);
      if (value != null) {
        builder.put(key, value);
      }
    }
    return builder.build();
  }
"
473,Please make this protected to avoid exposing methods that consumers of the API do not care about.,"		public void configure(ServerHttpSecurity http) {
			ReactiveAuthenticationManager authenticationManager = getAuthenticationManager();
			X509PrincipalExtractor principalExtractor = getPrincipalExtractor();

			AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager);
			filter.setServerAuthenticationConverter(new ServerX509AuthenticationConverter(principalExtractor));
			http.addFilterAt(filter, SecurityWebFiltersOrder.AUTHENTICATION);
		}
","START 		public void configure(ServerHttpSecurity http) { END 
			ReactiveAuthenticationManager authenticationManager = getAuthenticationManager();
			X509PrincipalExtractor principalExtractor = getPrincipalExtractor();

			AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager);
			filter.setServerAuthenticationConverter(new ServerX509AuthenticationConverter(principalExtractor));
			http.addFilterAt(filter, SecurityWebFiltersOrder.AUTHENTICATION);
		}
","		protected void configure(ServerHttpSecurity http) {
			ReactiveAuthenticationManager authenticationManager = getAuthenticationManager();
			X509PrincipalExtractor principalExtractor = getPrincipalExtractor();

			AuthenticationWebFilter filter = new AuthenticationWebFilter(authenticationManager);
			filter.setServerAuthenticationConverter(new ServerX509AuthenticationConverter(principalExtractor));
			http.addFilterAt(filter, SecurityWebFiltersOrder.AUTHENTICATION);
		}
"
474,Would it not be better to obtain this from the session? With this approach it's not pluggable.,"    public void action(AuthenticationFlowContext context) {
        if (DisplayUtils.isConsole(context)) {
            ConsoleOTPFormAuthenticator.SINGLETON.action(context);
            return;
        }
        validateOTP(context);
    }
","    public void action(AuthenticationFlowContext context) {
        if (DisplayUtils.isConsole(context)) {
START             ConsoleOTPFormAuthenticator.SINGLETON.action(context); END 
            return;
        }
        validateOTP(context);
    }
","    public void action(AuthenticationFlowContext context) {
        validateOTP(context);
    }
"
475,"A null check is needed also. An NPE will be thrown if reopening a very large project.

java.lang.NullPointerException
	at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.handleResourceChange(GitSubscriberMergeContext.java:141)
	at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext.access$1(GitSubscriberMergeContext.java:137)
	at org.eclipse.egit.core.synchronize.GitSubscriberMergeContext$2.indexDiffChanged(GitSubscriberMergeContext.java:69)
	at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.notifyListeners(IndexDiffCache.java:94)
	at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache.access$0(IndexDiffCache.java:86)
	at org.eclipse.egit.core.internal.indexdiff.IndexDiffCache$1.indexDiffChanged(IndexDiffCache.java:81)
	at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.notifyListeners(IndexDiffCacheEntry.java:313)
	at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry.access$6(IndexDiffCacheEntry.java:306)
	at org.eclipse.egit.core.internal.indexdiff.IndexDiffCacheEntry$3.run(IndexDiffCacheEntry.java:171)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)","	private void handleResourceChange(GitResourceVariantTreeSubscriber subscriber,
			Repository which, Collection<IFile> resources) {
		for (GitSynchronizeData gsd : gsds) {
			if (which.equals(gsd.getRepository())) {
				if (!resources.isEmpty())
					refreshResources(subscriber, resources);
				else
					refreshRepository(subscriber);
			}
		}
	}
","	private void handleResourceChange(GitResourceVariantTreeSubscriber subscriber,
			Repository which, Collection<IFile> resources) {
		for (GitSynchronizeData gsd : gsds) {
			if (which.equals(gsd.getRepository())) {
START 				if (!resources.isEmpty()) END 
					refreshResources(subscriber, resources);
				else
					refreshRepository(subscriber);
			}
		}
	}
","	private void handleResourceChange(GitResourceVariantTreeSubscriber subscriber,
			Repository which, Collection<IFile> resources) {
		for (GitSynchronizeData gsd : gsds) {
			if (which.equals(gsd.getRepository()) && resources != null
					&& !resources.isEmpty())
				refreshResources(subscriber, resources);
		}
	}
"
476,Don't necessarily need the type info in the right hand assignment anymore.  Only mention it because you use both ways throughout.,"    public static Set<Path> getIncludedFieldsOfRootEntityForSort(CompositeMetadata root,
                                                                 Sort rootSort) {
        Set<Path> ret=new HashSet<Path>();
        if(rootSort!=null) {
            SortFieldInfo[] sfi=SortFieldInfo.buildSortFields(rootSort,root.getFieldTreeRoot());
            for(SortFieldInfo fi:sfi)
                ret.add(fi.getName());
        }
        return ret;
    }
","    public static Set<Path> getIncludedFieldsOfRootEntityForSort(CompositeMetadata root,
                                                                 Sort rootSort) {
START         Set<Path> ret=new HashSet<Path>(); END 
        if(rootSort!=null) {
            SortFieldInfo[] sfi=SortFieldInfo.buildSortFields(rootSort,root.getFieldTreeRoot());
            for(SortFieldInfo fi:sfi)
                ret.add(fi.getName());
        }
        return ret;
    }
","    public static Set<Path> getIncludedFieldsOfRootEntityForSort(CompositeMetadata root,
                                                                 Sort rootSort) {
        Set<Path> ret=new HashSet<>();
        if(rootSort!=null) {
            SortFieldInfo[] sfi=SortFieldInfo.buildSortFields(rootSort,root.getFieldTreeRoot());
            for(SortFieldInfo fi:sfi)
                ret.add(fi.getName());
        }
        return ret;
    }
"
477,Why remove unused at only one level below if its not used at all remove all together.,"    public LocalCluster(String jarFileName,
            int siteCount,
            int hostCount,
            int kfactor,
            int clusterId,
            BackendTarget target,
            FailureState failureState,
            boolean debug,
            boolean isRejoinTest,
            Map<String, String> env) {
        // NOTE: isRejoinTest is unused
        this(null, null, jarFileName, siteCount, hostCount, kfactor, clusterId, target, failureState, debug, env);
    }
","    public LocalCluster(String jarFileName,
            int siteCount,
            int hostCount,
            int kfactor,
            int clusterId,
            BackendTarget target,
            FailureState failureState,
            boolean debug,
            boolean isRejoinTest,
            Map<String, String> env) {
        // NOTE: isRejoinTest is unused
START         this(null, null, jarFileName, siteCount, hostCount, kfactor, clusterId, target, failureState, debug, env); END 
    }
","    public LocalCluster(String jarFileName,
            int siteCount,
            int hostCount,
            int kfactor,
            int clusterId,
            BackendTarget target,
            FailureState failureState,
            boolean debug,
            boolean isRejoinTest,
            Map<String, String> env) {
        this(null, null, jarFileName, siteCount, hostCount, kfactor, clusterId, target, failureState, debug, isRejoinTest, env);
    }
"
478,I would prefer to move this logic into the `FollowModeManager`,"  public void execute(String userName) {
    FollowModeManager currentFollowModeManager = followModeManager;
    User userToFollow = findUser(userName);

    if (currentFollowModeManager == null) {
      return;
    }

    User currentlyFollowedUser = followModeManager.getFollowedUser();

    if ((currentlyFollowedUser != null && !currentlyFollowedUser.equals(userToFollow))
        || (currentlyFollowedUser == null && userToFollow != null)) {

      currentFollowModeManager.follow(userToFollow);
    }

    actionPerformed();
  }
","  public void execute(String userName) {
    FollowModeManager currentFollowModeManager = followModeManager;
    User userToFollow = findUser(userName);

    if (currentFollowModeManager == null) {
      return;
    }

START     User currentlyFollowedUser = followModeManager.getFollowedUser(); END 

    if ((currentlyFollowedUser != null && !currentlyFollowedUser.equals(userToFollow))
        || (currentlyFollowedUser == null && userToFollow != null)) {

      currentFollowModeManager.follow(userToFollow);
    }

    actionPerformed();
  }
","  public void execute(String userName) {
    FollowModeManager currentFollowModeManager = followModeManager;
    User userToFollow = findUser(userName);

    if (currentFollowModeManager == null) {
      return;
    }

    currentFollowModeManager.follow(userToFollow);

    actionPerformed();
  }
"
479,nit: `sep` –> `separator` ?,"  @Override public Appendable write(Appendable appendable, Context context) throws IOException {
    String sep = """";
    for (TypeName className : typeNames) {
      appendable.append(sep);
      className.write(appendable, context);
      sep = "" & "";
    }
    return appendable;
  }
","  @Override public Appendable write(Appendable appendable, Context context) throws IOException {
START     String sep = """"; END 
    for (TypeName className : typeNames) {
      appendable.append(sep);
      className.write(appendable, context);
      sep = "" & "";
    }
    return appendable;
  }
","  @Override public Appendable write(Appendable appendable, Context context) throws IOException {
    Iterator<TypeName> iterator = typeNames.iterator();
    if (iterator.hasNext()) {
      iterator.next().write(appendable, context);
      while (iterator.hasNext()) {
        appendable.append("" & "");
        iterator.next().write(appendable, context);
      }
    }
    return appendable;
  }
"
480,"for single-log manager, it is better to flush `rotated logs` before flushing `current logs`, because the way how it rotates files and do the checkpoint. I would prefer keeping existing logic unchanged to reduce the risks.

besides that, why not provide `flush` method in EntryLogManager? so different entry log manager implementation can implement its own flushing logic rather than exposing this knowledge to EntryLogger. If you provide `flush` method, it is possible that you don't need to expose `flushCurrentLogs` and `flushRotatedLogs`.","    public void flush() throws IOException {
        entryLogManager.flushCurrentLogs();
        entryLogManager.flushRotatedLogs();
    }
","    public void flush() throws IOException {
START         entryLogManager.flushCurrentLogs(); END 
        entryLogManager.flushRotatedLogs();
    }
","    public void flush() throws IOException {
        entryLogManager.flush();
    }
"
481,Also notice OpaqueObjectsNode.java needs the same treatment.,"    public void disableWireframe() {
        boolean refreshTaskList = false;

        EnableFaceCulling faceCullingStateChange = new EnableFaceCulling();
        if (!getDesiredStateChanges().contains(faceCullingStateChange)) {
            addDesiredStateChange(faceCullingStateChange);
            refreshTaskList = true;
        }

        if (getDesiredStateChanges().contains(wireframeStateChange)) {
            removeDesiredStateChange(wireframeStateChange);
            refreshTaskList = true;
        }

        if (refreshTaskList) {
            worldRenderer.requestTaskListRefresh();
        }
    }
","    public void disableWireframe() {
        boolean refreshTaskList = false;

        EnableFaceCulling faceCullingStateChange = new EnableFaceCulling();
START         if (!getDesiredStateChanges().contains(faceCullingStateChange)) { END 
            addDesiredStateChange(faceCullingStateChange);
            refreshTaskList = true;
        }

        if (getDesiredStateChanges().contains(wireframeStateChange)) {
            removeDesiredStateChange(wireframeStateChange);
            refreshTaskList = true;
        }

        if (refreshTaskList) {
            worldRenderer.requestTaskListRefresh();
        }
    }
","    public void disableWireframe() {
        if (getDesiredStateChanges().contains(wireframeStateChange)) {
            addDesiredStateChange(faceCullingStateChange);
            removeDesiredStateChange(wireframeStateChange);
            worldRenderer.requestTaskListRefresh();
        }
    }
"
482,What's the point of this return value if it's always true?,"    public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) {
        List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId());
        connections.clear();
        connections.addAll(res);
        return true;
    }
","    public boolean prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) {
        List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId());
        connections.clear();
        connections.addAll(res);
START         return true; END 
    }
","    public void prepareConnectHostToStoragePoolServers(ConnectHostToStoragePoolServersParameters parameters, List<StorageServerConnections> connections) {
        List<StorageServerConnections> res = updateIfaces(connections, parameters.getVds().getId());
        connections.clear();
        connections.addAll(res);
    }
"
483,I am not sure that converter should be part of DAO.  Given we still using save on single entity I would  suggest i would move that code to Service layer.,"    public HibernateErrorReportingServiceDao()
    {
        this.errorOccurrenceConverter = new ErrorOccurrenceConverter();
    }
","    public HibernateErrorReportingServiceDao()
    {
START         this.errorOccurrenceConverter = new ErrorOccurrenceConverter(); END 
    }
","    public HibernateErrorReportingServiceDao()
    {
    }
"
484,"Would much rather use the ternary operator here.  Or even Optional, since we're on Java8 now.

```
Optional.ofNullable(jettyConfig).orElse(() -> new DefaultJettyConfig());
```","        public JettyConfig getJettyConfig() {
            if(jettyConfig != null)
            {
                return jettyConfig;
            }
            else {
                return new DefaultJettyConfig();
            }
        }
","        public JettyConfig getJettyConfig() {
START             if(jettyConfig != null) END 
            {
                return jettyConfig;
            }
            else {
                return new DefaultJettyConfig();
            }
        }
","        public JettyConfig getJettyConfig() {
           return jettyConfig != null ? jettyConfig : new DefaultJettyConfig();
        }
"
485,Why do we not allow this field to be null?,"    public void setNumThreads(final Integer numThreads) {
        m_threads = ConfigUtils.assertNotNull(numThreads, ""threads"");
    }
","    public void setNumThreads(final Integer numThreads) {
START         m_threads = ConfigUtils.assertNotNull(numThreads, ""threads""); END 
    }
","    public void setNumThreads(final Integer numThreads) {
        m_threads = numThreads;
    }
"
486,change to private,"	public String getModeName() {
		String header = getHeader();
		return header.substring(0, header.indexOf('""') - 1);
	}
","START 	public String getModeName() { END 
		String header = getHeader();
		return header.substring(0, header.indexOf('""') - 1);
	}
","	private String getModeName() {
		String header = getHeader();
		return header.substring(0, header.indexOf('""') - 1);
	}
"
487,"If you make the getIdsToDelete() to return a list of blob Ids, we can avoid idsToDelete.clear(). We can just call idsToDelete = putManager.getIdsToDelete() everytime.","    private List<RequestInfo> pollForRequests() {
      // these are ids that were successfully put for an operation that eventually failed
      idsToDelete.clear();
      putManager.getIdsToDelete(idsToDelete);
      // this is a best effort to delete ids for cleanup purposes (these may fail and we will
      // not do anything about it at this time).
      for (String blobId : idsToDelete) {
        // possibly add a batch api going forward.
        deleteManager
            .submitDeleteBlobOperation(operationIdGenerator.incrementAndGet(), blobId, new FutureResult<Void>(), null);
      }
      List<RequestInfo> requests = new ArrayList<RequestInfo>();
      putManager.poll(requests);
      getManager.poll(requests);
      deleteManager.poll(requests);
      return requests;
    }
","    private List<RequestInfo> pollForRequests() {
      // these are ids that were successfully put for an operation that eventually failed
      idsToDelete.clear();
START       putManager.getIdsToDelete(idsToDelete); END 
      // this is a best effort to delete ids for cleanup purposes (these may fail and we will
      // not do anything about it at this time).
      for (String blobId : idsToDelete) {
        // possibly add a batch api going forward.
        deleteManager
            .submitDeleteBlobOperation(operationIdGenerator.incrementAndGet(), blobId, new FutureResult<Void>(), null);
      }
      List<RequestInfo> requests = new ArrayList<RequestInfo>();
      putManager.poll(requests);
      getManager.poll(requests);
      deleteManager.poll(requests);
      return requests;
    }
","    private List<RequestInfo> pollForRequests() {
      // these are ids that were successfully put for an operation that eventually failed
      idsToDelete.clear();
      putManager.getIdsToDelete(idsToDelete);
      // this is a best effort to delete ids for cleanup purposes (these may fail and we will
      // not do anything about it at this time).
      for (String blobId : idsToDelete) {
        // possibly add a batch api going forward.
        deleteManager.submitDeleteBlobOperation(blobId, new FutureResult<Void>(), null);
      }
      List<RequestInfo> requests = new ArrayList<RequestInfo>();
      putManager.poll(requests);
      getManager.poll(requests);
      deleteManager.poll(requests);
      return requests;
    }
"
488,Static import `fromTypes`.,"    public InternalAggregationFunction specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionManager functionManager)
    {
        Type type = boundVariables.getTypeVariable(""E"");
        MethodHandle compareMethodHandle = functionManager.getScalarFunctionImplementation(
                functionManager.resolveOperator(operatorType, TypeSignatureProvider.fromTypes(ImmutableList.of(type, type)))).getMethodHandle();
        return generateAggregation(type, compareMethodHandle);
    }
","    public InternalAggregationFunction specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionManager functionManager)
    {
        Type type = boundVariables.getTypeVariable(""E"");
        MethodHandle compareMethodHandle = functionManager.getScalarFunctionImplementation(
START                 functionManager.resolveOperator(operatorType, TypeSignatureProvider.fromTypes(ImmutableList.of(type, type)))).getMethodHandle(); END 
        return generateAggregation(type, compareMethodHandle);
    }
","    public InternalAggregationFunction specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionManager functionManager)
    {
        Type type = boundVariables.getTypeVariable(""E"");
        MethodHandle compareMethodHandle = functionManager.getScalarFunctionImplementation(
                functionManager.resolveOperator(operatorType, fromTypes(ImmutableList.of(type, type)))).getMethodHandle();
        return generateAggregation(type, compareMethodHandle);
    }
"
489,"it would be easier to read if would surround the entire method with this type of try / catch like:

```
  @Override
  public AccountInfo getAccountInfo() throws IOException {
    try {
      CoingiBalances coingiBalances = getCoingiBalance();
      return CoingiAdapters.adaptAccountInfo(
        coingiBalances, exchange.getExchangeSpecification().getUserName());
    } catch (CoingiException e) {
      throw CoingiErrorAdapter.adapt(e);
    }
  }
```

please apply this hint to all the methods that have this type of try catch","  public AccountInfo getAccountInfo() throws IOException {
    CoingiBalances coingiBalances;
    try {
      coingiBalances = getCoingiBalance();
    } catch (CoingiException e) {
      throw CoingiErrorAdapter.adapt(e);
    }
    
    return CoingiAdapters.adaptAccountInfo(
        coingiBalances, exchange.getExchangeSpecification().getUserName());
  }
","  public AccountInfo getAccountInfo() throws IOException {
    CoingiBalances coingiBalances;
    try {
      coingiBalances = getCoingiBalance();
    } catch (CoingiException e) {
      throw CoingiErrorAdapter.adapt(e);
    }
    
    return CoingiAdapters.adaptAccountInfo(
        coingiBalances, exchange.getExchangeSpecification().getUserName());
START   } END 
","  public AccountInfo getAccountInfo() throws IOException {
    try {
      CoingiBalances coingiBalances = getCoingiBalance();
      return CoingiAdapters.adaptAccountInfo(
          coingiBalances, exchange.getExchangeSpecification().getUserName());
    } catch (CoingiException e) {
      throw CoingiErrorAdapter.adapt(e);
    }
  }
"
490,"`Map<TableScanNode, Void> result = new IdentityHashMap<>();`","        public IdentityHashMap<TableScanNode, Void> visitPlan(PlanNode node, Void context)
        {
            IdentityHashMap<TableScanNode, Void> ret = new IdentityHashMap<>();
            node.getSources().forEach(source -> ret.putAll(source.accept(this, context)));
            return ret;
        }
","        public IdentityHashMap<TableScanNode, Void> visitPlan(PlanNode node, Void context)
        {
START             IdentityHashMap<TableScanNode, Void> ret = new IdentityHashMap<>(); END 
            node.getSources().forEach(source -> ret.putAll(source.accept(this, context)));
            return ret;
        }
","        public Map<TableScanNode, Void> visitPlan(PlanNode node, Void context)
        {
            Map<TableScanNode, Void> ret = new IdentityHashMap<>();
            node.getSources().forEach(source -> ret.putAll(source.accept(this, context)));
            return ret;
        }
"
491,"you handle all these exceptions in the same way so you can use multi-catch:

 } catch (RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException | IOException e) {","	protected RevCommit findHead(Repository repo) {
		try (RevWalk walk = new RevWalk(repo)) {
			try {
				ObjectId head = repo.resolve(HEAD);
				return walk.parseCommit(head);
			} catch (RevisionSyntaxException e) {
				throw new RuntimeException(e);
			} catch (AmbiguousObjectException e) {
				throw new RuntimeException(e);
			} catch (IncorrectObjectTypeException e) {
				throw new RuntimeException(e);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
","	protected RevCommit findHead(Repository repo) {
		try (RevWalk walk = new RevWalk(repo)) {
			try {
				ObjectId head = repo.resolve(HEAD);
				return walk.parseCommit(head);
START 			} catch (RevisionSyntaxException e) { END 
				throw new RuntimeException(e);
			} catch (AmbiguousObjectException e) {
				throw new RuntimeException(e);
			} catch (IncorrectObjectTypeException e) {
				throw new RuntimeException(e);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
","	protected RevCommit findHead(Repository repo) {
		try (RevWalk walk = new RevWalk(repo)) {
			try {
				ObjectId head = repo.resolve(HEAD);
				return walk.parseCommit(head);
			} catch (RevisionSyntaxException | IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
"
492,You're not passing in the message even though you have a marker there. Think that might throw weird RTEs.,"    public void process(EquivalentContentUpdatedMessage message) throws RecoverableException {
        Id contentId = message.getContentRef().getId();

        log.debug(""Processing message on id {}, took PT{}S, message: {}"",
                contentId, getTimeToProcessInSeconds(message));

        Timer.Context time = timer.time();
        try {
            Content content = getContent(contentId);
            neo4JContentStore.writeContent(content);

            time.stop();
        } catch (Exception e) {
            failureMeter.mark();
            throw Throwables.propagate(e);
        }
    }
","    public void process(EquivalentContentUpdatedMessage message) throws RecoverableException {
        Id contentId = message.getContentRef().getId();

START         log.debug(""Processing message on id {}, took PT{}S, message: {}"", END 
                contentId, getTimeToProcessInSeconds(message));

        Timer.Context time = timer.time();
        try {
            Content content = getContent(contentId);
            neo4JContentStore.writeContent(content);

            time.stop();
        } catch (Exception e) {
            failureMeter.mark();
            throw Throwables.propagate(e);
        }
    }
","    public void process(EquivalentContentUpdatedMessage message) throws RecoverableException {
        Id contentId = message.getContentRef().getId();

        log.debug(""Processing message on id {}, took PT{}S, message: {}"",
                contentId, getTimeToProcessInSeconds(message), message);

        Timer.Context time = timer.time();
        try {
            Content content = getContent(contentId);
            neo4JContentStore.writeContent(content);

            time.stop();
        } catch (Exception e) {
            failureMeter.mark();
            throw Throwables.propagate(e);
        }
    }
"
493,"Internally Druid treats nulls and empty strings as similar values. So I think one workaround here is to  do
dimValue == null ? """" : dimValue

Druid's handling of nulls and empty strings could definitely be better though.","  public String apply(String dimValue)
  {
    if (dimValue == null) return null;
    Matcher matcher = pattern.matcher(dimValue);
    return matcher.find() ? dimValue : null;
  }
","  public String apply(String dimValue)
  {
START     if (dimValue == null) return null; END 
    Matcher matcher = pattern.matcher(dimValue);
    return matcher.find() ? dimValue : null;
  }
","  public String apply(String dimValue)
  {
    dimValue = (dimValue == null) ? """" : dimValue;
    Matcher matcher = pattern.matcher(dimValue);
    return matcher.find() ? dimValue : null;
  }
"
494,"default:
throw new IllegalArgumentException...","	private void writeSubscribeCommands(
			String repoName, List<SubscribeCommand> commands)
			throws IOException {
		write(""repository "" + repoName);
		for (SubscribeCommand cmd : commands) {
			switch (cmd.getCommand()) {
			case SUBSCRIBE:
				write(""want "" + cmd.getSpec());
				break;
			case UNSUBSCRIBE:
				write(""stop "" + cmd.getSpec());
				break;
			}
		}
	}
","	private void writeSubscribeCommands(
			String repoName, List<SubscribeCommand> commands)
			throws IOException {
		write(""repository "" + repoName);
		for (SubscribeCommand cmd : commands) {
			switch (cmd.getCommand()) {
			case SUBSCRIBE:
				write(""want "" + cmd.getSpec());
				break;
			case UNSUBSCRIBE:
				write(""stop "" + cmd.getSpec());
				break;
START 			} END 
		}
	}
","	private void writeSubscribeCommands(
			String repoName, List<SubscribeCommand> commands)
			throws IOException {
		write(""repository "" + repoName);
		for (SubscribeCommand cmd : commands) {
			switch (cmd.getCommand()) {
			case SUBSCRIBE:
				write(""want "" + cmd.getSpec());
				break;
			case UNSUBSCRIBE:
				write(""stop "" + cmd.getSpec());
				break;
			default:
				throw new IllegalArgumentException();
			}
		}
	}
"
495,consider !existingServes.isEmpty(),"    private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) {
        Set<GlusterServerInfo> fetchedServers = null;
        while (fetchedServers == null && existingServers.size() > 0) {
            fetchedServers = fetchServers(upServer);
            if (fetchedServers == null) {
                logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
                // Couldn't fetch servers from the up server. Mark it as non-operational
                setNonOperational(upServer);
                existingServers.remove(upServer);
                upServer = getNewUpServer(existingServers, upServer);
            }
        }
        return fetchedServers;
    }
","    private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) {
        Set<GlusterServerInfo> fetchedServers = null;
START         while (fetchedServers == null && existingServers.size() > 0) { END 
            fetchedServers = fetchServers(upServer);
            if (fetchedServers == null) {
                logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
                // Couldn't fetch servers from the up server. Mark it as non-operational
                setNonOperational(upServer);
                existingServers.remove(upServer);
                upServer = getNewUpServer(existingServers, upServer);
            }
        }
        return fetchedServers;
    }
","    private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) {
        Set<GlusterServerInfo> fetchedServers = null;
        while (fetchedServers == null && !existingServers.isEmpty()) {
            fetchedServers = fetchServers(upServer);
            if (fetchedServers == null) {
                logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
                // Couldn't fetch servers from the up server. Mark it as non-operational
                setNonOperational(upServer);
                existingServers.remove(upServer);
                upServer = getNewUpServer(existingServers, upServer);
            }
        }
        return fetchedServers;
    }
"
496,![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck),"    public static String sanitizeSecondCachedKey(final Contentlet vanityUrl)
            throws DotDataException, DotRuntimeException, DotSecurityException {
        Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),
                APILocator.systemUser(), false);
        return sanitizeSecondCacheKey(host.getIdentifier(), vanityUrl.getLanguageId());
    }
","    public static String sanitizeSecondCachedKey(final Contentlet vanityUrl)
START             throws DotDataException, DotRuntimeException, DotSecurityException { END 
        Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),
                APILocator.systemUser(), false);
        return sanitizeSecondCacheKey(host.getIdentifier(), vanityUrl.getLanguageId());
    }
","    public static String sanitizeSecondCachedKey(final Contentlet vanityUrl)
            throws DotDataException, DotSecurityException {
        Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),
                APILocator.systemUser(), false);
        return sanitizeSecondCacheKey(host.getIdentifier(), vanityUrl.getLanguageId());
    }
"
497,please keep the body of an `if` on its own line,"        void remove(I key)
        {
            Integer prev = this.identityMap.remove(key);
            if (prev != null) this.objectList.set(prev, null);
        }
","        void remove(I key)
        {
            Integer prev = this.identityMap.remove(key);
START             if (prev != null) this.objectList.set(prev, null); END 
        }
","        void remove(I key)
        {
            Integer prev = this.identityMap.remove(key);
            if (prev != null)
            {
                this.objectList.set(prev, null);
            }
        }
"
498,This is always FALSE. since name is `static final`,"    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof TaskPropertyType)) {
            return false;
        }
        TaskPropertyType that = (TaskPropertyType) o;
        if (!name.equals(that.name)) {
            return false;
        }
        return true;
    }
","    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof TaskPropertyType)) {
            return false;
        }
        TaskPropertyType that = (TaskPropertyType) o;
START         if (!name.equals(that.name)) { END 
            return false;
        }
        return true;
    }
","    public boolean equals(Object o) {
        return this == o || o instanceof TaskPropertyType;
    }
"
499,This could be `private` right?,"	protected long obtainEntityId() {
		return nextEntityId++;
	}
","START 	protected long obtainEntityId() { END 
		return nextEntityId++;
	}
","	private long obtainEntityId() {
		return nextEntityId++;
	}
"
500,I'm not sure that this INFO message is helpful to users.,"    public void markInCatalog() {
        exportLog.info(""ExportDataSource for table "" + m_tableName + "" partition "" + m_partitionId + "" marked as in catalog."");
        m_isInCatalog = true;
    }
","    public void markInCatalog() {
START         exportLog.info(""ExportDataSource for table "" + m_tableName + "" partition "" + m_partitionId + "" marked as in catalog.""); END 
        m_isInCatalog = true;
    }
","    public void markInCatalog() {
        m_isInCatalog = true;
    }
"
501,"This results conversion will be applyed also to subclass of `StringParameterValue`.
It would be better applied to exact `StringParameterValue`.","    private static boolean canConvert(ParameterDefinition def, ParameterValue v) {
        return def instanceof SimpleParameterDefinition &&
            !(def instanceof StringParameterDefinition) &&
            v instanceof StringParameterValue;
    }
","    private static boolean canConvert(ParameterDefinition def, ParameterValue v) {
        return def instanceof SimpleParameterDefinition &&
            !(def instanceof StringParameterDefinition) &&
            v instanceof StringParameterValue;
START     } END 
","    private static boolean canConvert(ParameterDefinition def, ParameterValue v) {
        return def instanceof SimpleParameterDefinition &&
            !(def instanceof StringParameterDefinition) &&
            v.getClass().equals(StringParameterValue.class);
    }
"
502,Why are you using `EventHandlerTest` here? It has nothing to do with filtering.,"    public void setUp() {
        deviceHandler = new EventHandlerTest();
        passingHandler = new FilterHandler();
        filtingHandler = new FilterHandler();
        filtingHandler.setFilterInvalid(true);
        filtingHandler.setFilterZero(true);
        filtingHandler.setFilterDuplicate(true);
        filtingHandler.setFilterFuture(true);
        filtingHandler.setFilterApproximate(true);
        filtingHandler.setFilterStatic(true);
        filtingHandler.setFilterDistance(10);
        filtingHandler.setFilterLimit(10);
    }
","    public void setUp() {
START         deviceHandler = new EventHandlerTest(); END 
        passingHandler = new FilterHandler();
        filtingHandler = new FilterHandler();
        filtingHandler.setFilterInvalid(true);
        filtingHandler.setFilterZero(true);
        filtingHandler.setFilterDuplicate(true);
        filtingHandler.setFilterFuture(true);
        filtingHandler.setFilterApproximate(true);
        filtingHandler.setFilterStatic(true);
        filtingHandler.setFilterDistance(10);
        filtingHandler.setFilterLimit(10);
    }
","    public void setUp() {
        passingHandler = new FilterHandler();
        filtingHandler = new FilterHandler();
        filtingHandler.setFilterInvalid(true);
        filtingHandler.setFilterZero(true);
        filtingHandler.setFilterDuplicate(true);
        filtingHandler.setFilterFuture(true);
        filtingHandler.setFilterApproximate(true);
        filtingHandler.setFilterStatic(true);
        filtingHandler.setFilterDistance(10);
        filtingHandler.setFilterLimit(10);
    }
"
503,The connector setup should fail when an exception occurs.,"    public void download(String url, String downloadPath) {
        InputStream in = null;
        try {
            in = new URL(url).openStream();
            FileUtils.writeByteArrayToFile(new File(downloadPath), IOUtils.toByteArray(in));
            System.out.println(IOUtils.toString(in));
        } catch (IOException e) {
            log.error(e);
        } finally {
            IOUtils.closeQuietly(in);
        }
    }
","    public void download(String url, String downloadPath) {
        InputStream in = null;
        try {
            in = new URL(url).openStream();
            FileUtils.writeByteArrayToFile(new File(downloadPath), IOUtils.toByteArray(in));
            System.out.println(IOUtils.toString(in));
        } catch (IOException e) {
START             log.error(e); END 
        } finally {
            IOUtils.closeQuietly(in);
        }
    }
","    public boolean download(String url, String downloadPath) {
        InputStream in = null;
        try {
            in = new URL(url).openStream();
            FileUtils.writeByteArrayToFile(new File(downloadPath), IOUtils.toByteArray(in));
            return true;
        } catch (IOException e) {
            log.error(e);
            return false;
        } finally {
            IOUtils.closeQuietly(in);
        }
    }
"
504,Simpler: oldChildValue != && oldChildValue.booleanValue(),"	private boolean getOldChildStale(IObservable child) {
		Boolean oldChildValue = staleMap.get(child);
		boolean oldChildStale = oldChildValue == null ? false : oldChildValue
				.booleanValue();
		return oldChildStale;
	}
","	private boolean getOldChildStale(IObservable child) {
		Boolean oldChildValue = staleMap.get(child);
		boolean oldChildStale = START  oldChildValue == null ? false : oldChildValue
				.booleanValue(); END 
		return oldChildStale;
	}
","	private boolean getOldChildStale(IObservable child) {
		Boolean oldChildValue = staleMap.get(child);
		boolean oldChildStale = oldChildValue != null && oldChildValue;
		return oldChildStale;
	}
"
505,Add tooltip,"  public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) {
    if (!CommonRefactoringUtil.checkReadOnlyStatus(file)) return;
    if (editor.getSettings().isVariableInplaceRenameEnabled()) {
      final TemplateState templateState = TemplateManagerImpl.getTemplateState(editor);
      if (templateState != null && !templateState.isFinished()) return;
    }
    performAction(new GoIntroduceOperation(project, editor, file));
  }
","  public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) {
    if (!CommonRefactoringUtil.checkReadOnlyStatus(file)) return;
    if (editor.getSettings().isVariableInplaceRenameEnabled()) {
      final TemplateState templateState = TemplateManagerImpl.getTemplateState(editor);
START       if (templateState != null && !templateState.isFinished()) return; END 
    }
    performAction(new GoIntroduceOperation(project, editor, file));
  }
","  public void invoke(@NotNull final Project project, final Editor editor, PsiFile file, DataContext dataContext) {
    if (!CommonRefactoringUtil.checkReadOnlyStatus(file)) return;
    performAction(new GoIntroduceOperation(project, editor, file));
  }
"
506,but you removed the static from there as well.,"    private List<String> getListOfIsoFiles(File directory, OVirtNodeInfo info) {
        List<String> isoFileList = new ArrayList<String>();
        File[] filterOvirtFiles = filterOvirtFiles(directory, getIsoPattern(info));
        for (File file : filterOvirtFiles) {
            isoFileList.add(file.getName());
        }
        return isoFileList;
    }
","START     private List<String> getListOfIsoFiles(File directory, OVirtNodeInfo info) { END 
        List<String> isoFileList = new ArrayList<String>();
        File[] filterOvirtFiles = filterOvirtFiles(directory, getIsoPattern(info));
        for (File file : filterOvirtFiles) {
            isoFileList.add(file.getName());
        }
        return isoFileList;
    }
","    private static List<String> getListOfIsoFiles(File directory, OVirtNodeInfo info) {
        List<String> isoFileList = new ArrayList<String>();
        File[] filterOvirtFiles = filterOvirtFiles(directory, getIsoPattern(info));
        for (File file : filterOvirtFiles) {
            isoFileList.add(file.getName());
        }
        return isoFileList;
    }
"
507,nit: jgit spells this for (;;),"		EWAHCompressedBitmap getBitmap() {
			// Fast path to immediately return the expanded result.
			Object r = bitmapContainer;
			if (r instanceof EWAHCompressedBitmap)
				return (EWAHCompressedBitmap) r;

			// Expand the bitmap and cache the result.
			XorCompressedBitmap xb = (XorCompressedBitmap) r;
			EWAHCompressedBitmap out = xb.bitmap;
			while (true) {
				r = xb.xorBitmap.bitmapContainer;
				if (r instanceof EWAHCompressedBitmap) {
					bitmapContainer = out = out.xor((EWAHCompressedBitmap) r);
					return out;
				}
				xb = (XorCompressedBitmap) r;
				out = out.xor(xb.bitmap);
			}
		}
","		EWAHCompressedBitmap getBitmap() {
			// Fast path to immediately return the expanded result.
			Object r = bitmapContainer;
			if (r instanceof EWAHCompressedBitmap)
				return (EWAHCompressedBitmap) r;

			// Expand the bitmap and cache the result.
			XorCompressedBitmap xb = (XorCompressedBitmap) r;
			EWAHCompressedBitmap out = xb.bitmap;
START 			while (true) { END 
				r = xb.xorBitmap.bitmapContainer;
				if (r instanceof EWAHCompressedBitmap) {
					bitmapContainer = out = out.xor((EWAHCompressedBitmap) r);
					return out;
				}
				xb = (XorCompressedBitmap) r;
				out = out.xor(xb.bitmap);
			}
		}
","		EWAHCompressedBitmap getBitmap() {
			// Fast path to immediately return the expanded result.
			Object r = bitmapContainer;
			if (r instanceof EWAHCompressedBitmap)
				return (EWAHCompressedBitmap) r;

			// Expand the bitmap and cache the result.
			XorCompressedBitmap xb = (XorCompressedBitmap) r;
			EWAHCompressedBitmap out = xb.bitmap;
			for (;;) {
				r = xb.xorBitmap.bitmapContainer;
				if (r instanceof EWAHCompressedBitmap) {
					out = out.xor((EWAHCompressedBitmap) r);
					bitmapContainer = out;
					return out;
				}
				xb = (XorCompressedBitmap) r;
				out = out.xor(xb.bitmap);
			}
		}
"
508,"??? 
`this.` of course. That's why I said to revert those all changes for the `messagingTemplate` and PR is becoming clear","	public AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store,
									 CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) {
		Assert.notNull(processor);

		Assert.notNull(store);
		setMessageStore(store);
		this.outputProcessor = processor;
		this.correlationStrategy = correlationStrategy == null ?
				new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy;
		this.releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy() : releaseStrategy;
		super.messagingTemplate.setSendTimeout(DEFAULT_SEND_TIMEOUT);
		sequenceAware = this.releaseStrategy instanceof SequenceSizeReleaseStrategy;
	}
","	public AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store,
									 CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) {
		Assert.notNull(processor);

		Assert.notNull(store);
		setMessageStore(store);
		this.outputProcessor = processor;
		this.correlationStrategy = correlationStrategy == null ?
				new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy;
		this.releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy() : releaseStrategy;
START 		super.messagingTemplate.setSendTimeout(DEFAULT_SEND_TIMEOUT); END 
		sequenceAware = this.releaseStrategy instanceof SequenceSizeReleaseStrategy;
	}
","	public AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store,
									 CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) {
		Assert.notNull(processor);

		Assert.notNull(store);
		setMessageStore(store);
		this.outputProcessor = processor;
		this.correlationStrategy = correlationStrategy == null ?
				new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy;
		this.releaseStrategy = releaseStrategy == null ? new SequenceSizeReleaseStrategy() : releaseStrategy;
		this.messagingTemplate.setSendTimeout(DEFAULT_SEND_TIMEOUT);
		sequenceAware = this.releaseStrategy instanceof SequenceSizeReleaseStrategy;
	}
"
509,"Hmmm this is wrong now? There should be two methods, one passing null and the other one passing the nodeName.","   public Statement createBootstrapScriptForGroup(String group, @Nullable String nodeName) {
      return groupToBootScript.apply(group, null);
   }
","   public Statement createBootstrapScriptForGroup(String group, @Nullable String nodeName) {
START       return groupToBootScript.apply(group, null); END 
   }
","   public Statement createBootstrapScriptForGroup(String group, @Nullable String nodeName) {
      return groupToBootScript.apply(group, nodeName);
   }
"
510,No need for result variable,"    public boolean create(Personname personnameRecord) {
        LOG.trace(""PersonnameDAO.create() - Begin"");
        boolean result = true;
        if (personnameRecord != null) {
            result = super.create(personnameRecord);
        }
        LOG.trace(""PersonnameDAO.create() - End"");
        return result;
    }
","    public boolean create(Personname personnameRecord) {
        LOG.trace(""PersonnameDAO.create() - Begin"");
START         boolean result = true; END 
        if (personnameRecord != null) {
            result = super.create(personnameRecord);
        }
        LOG.trace(""PersonnameDAO.create() - End"");
        return result;
    }
","    public boolean create(Personname personnameRecord) {
        LOG.trace(""PersonnameDAO.create() - Begin"");
        return personnameRecord != null ? super.create(personnameRecord) : true;
    }
"
511,Please only log at debug or trace,"  public void handleInvocation(EJBClientInvocationContext context) throws Exception {

    log.info(""In the client interceptor handleInvocation : "" + this.getClass().getName() + "" "" + context.getViewClass() + "" "" + context.getLocator());
    context.getContextData().put(""ClientInterceptorInvoked"", this.getClass().getName() + "" "" + context.getViewClass() + "" "" + context.getLocator());

    // Must make this call
    context.sendRequest();
  }
","  public void handleInvocation(EJBClientInvocationContext context) throws Exception {

START     log.info(""In the client interceptor handleInvocation : "" + this.getClass().getName() + "" "" + context.getViewClass() + "" "" + context.getLocator()); END 
    context.getContextData().put(""ClientInterceptorInvoked"", this.getClass().getName() + "" "" + context.getViewClass() + "" "" + context.getLocator());

    // Must make this call
    context.sendRequest();
  }
","  public void handleInvocation(EJBClientInvocationContext context) throws Exception {
    log.debug(""In the client interceptor handleInvocation : "" + this.getClass().getName() + "" "" + context.getViewClass() + "" "" + context.getLocator());

    // Must make this call
    context.sendRequest();
  }
"
512,"If I'm not mistaken, it shouldn't be possible for subnet.getNetwork() to be null, so you can drop the check.","    public void edit(final NewExternalSubnetModel subnet) {
        driver.edit(subnet);

        if (subnet.getNetwork().getEntity() != null){
            networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName());
        }
    }
","    public void edit(final NewExternalSubnetModel subnet) {
        driver.edit(subnet);

START         if (subnet.getNetwork().getEntity() != null){ END 
            networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName());
        }
    }
","    public void edit(final NewExternalSubnetModel subnet) {
        driver.edit(subnet);
        networkEditor.asValueBox().setValue(subnet.getNetwork().getEntity().getName());
    }
"
513,this is probably simple enough to be inlined...,"    protected AddVmFromTemplateCommand<AddVmParameters> createCommand() {
        initVM();
        AddVmParameters param = new AddVmParameters(vm);
        return new AddVmFromTemplateCommand<>(param, null);
    }
","    protected AddVmFromTemplateCommand<AddVmParameters> createCommand() {
        initVM();
        AddVmParameters START  param = END  new AddVmParameters(vm);
        return new AddVmFromTemplateCommand<>(param, null);
    }
","    protected AddVmFromTemplateCommand<AddVmParameters> createCommand() {
        initVM();
        return new AddVmFromTemplateCommand<>(new AddVmParameters(vm), null);
    }
"
514,"Please split this test into several, testing each case separately.","  public void testGetNameFromPath() {
    String path1 = ""/group1"";
    String path2 = ""/group1/group2/group3"";
    String emptyPath = """";
    String nullPath = null;
    String rootPath = ""/"";

    assertEquals(HDF5Utils.getNameFromPath(path1), ""group1"");
    assertEquals(HDF5Utils.getNameFromPath(path2), ""group3"");
    assertEquals(HDF5Utils.getNameFromPath(emptyPath), """");
    assertNull(HDF5Utils.getNameFromPath(nullPath));
    assertEquals(HDF5Utils.getNameFromPath(rootPath), """");
  }
","  public void testGetNameFromPath() {
START     String path1 = ""/group1""; END 
    String path2 = ""/group1/group2/group3"";
    String emptyPath = """";
    String nullPath = null;
    String rootPath = ""/"";

    assertEquals(HDF5Utils.getNameFromPath(path1), ""group1"");
    assertEquals(HDF5Utils.getNameFromPath(path2), ""group3"");
    assertEquals(HDF5Utils.getNameFromPath(emptyPath), """");
    assertNull(HDF5Utils.getNameFromPath(nullPath));
    assertEquals(HDF5Utils.getNameFromPath(rootPath), """");
  }
","  public void testGetNameFromPath() {
    String path1 = ""/group1"";
    assertEquals(HDF5Utils.getNameFromPath(path1), ""group1"");
  }
"
515,Coding conventions: Let's have the @Override on its own line please,"    @Override public GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList() {
        JsonRpcRequest request = new RequestBuilder(""GlusterHost.logicalVolumeList"").build();
        Map<String, Object> response =
                new FutureMap(this.client, request).withIgnoreResponseKey();
        return new GlusterLocalLogicalVolumeListReturn(response);

    }
","  START    @Override public END  GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList() {
        JsonRpcRequest request = new RequestBuilder(""GlusterHost.logicalVolumeList"").build();
        Map<String, Object> response =
                new FutureMap(this.client, request).withIgnoreResponseKey();
        return new GlusterLocalLogicalVolumeListReturn(response);

    }
","    public GlusterLocalLogicalVolumeListReturn glusterLogicalVolumeList() {
        JsonRpcRequest request = new RequestBuilder(""GlusterHost.logicalVolumeList"").build();
        Map<String, Object> response =
                new FutureMap(this.client, request).withIgnoreResponseKey();
        return new GlusterLocalLogicalVolumeListReturn(response);

    }
"
516,needs `@Override`,"  public String toString() {
    return ""TypedByteArray[length="" + length() + ""]"";
  }
","START   public String toString() { END 
    return ""TypedByteArray[length="" + length() + ""]"";
  }
","  @Override public String toString() {
    return ""TypedByteArray[length="" + length() + ""]"";
  }
"
517,"Not an issue, but could be rewritten as

``` java
if (entity.isPersistent()) {
   // do stuff
}
```

to avoid multiple points of return from the method (and save a line of code).","    public void onEntityDestroyed(EntityRef entity) {
        if (!entity.isPersistent()) {
            return; // ignore
        }
        entityDeltas.remove(entity.getId());
        destroyedEntities.add(entity.getId());
    }
","    public void onEntityDestroyed(EntityRef entity) {
START         if (!entity.isPersistent()) { END 
            return; // ignore
        }
        entityDeltas.remove(entity.getId());
        destroyedEntities.add(entity.getId());
    }
","    public void onEntityDestroyed(EntityRef entity) {
        if (entity.isPersistent()) {
            entityDeltas.remove(entity.getId());
            destroyedEntities.add(entity.getId());
        }
    }
"
518,Isn't this use of `Optional` and returning `null` contradictory? Surely checking `isPresent(..)` in `getDefaultOrganizationalUnit(..)` would be better?,"    private OrganizationalUnit getOU( String ouIdentifier, Collection<OrganizationalUnit> organizationalUnits ) {
        Optional<OrganizationalUnit> targetOU = organizationalUnits.stream()
                .filter( p -> p.getIdentifier().equalsIgnoreCase( ouIdentifier ) ).findFirst();
        if ( targetOU.isPresent() ) {
            return targetOU.get();
        }
        return null;
    }
","    private OrganizationalUnit getOU( String ouIdentifier, Collection<OrganizationalUnit> organizationalUnits ) {
        Optional<OrganizationalUnit> targetOU = organizationalUnits.stream()
                .filter( p -> p.getIdentifier().equalsIgnoreCase( ouIdentifier ) ).findFirst();
START         if ( targetOU.isPresent() ) { END 
            return targetOU.get();
        }
        return null;
    }
","    private Optional<OrganizationalUnit> getOU( String ouIdentifier, Collection<OrganizationalUnit> organizationalUnits ) {
        Optional<OrganizationalUnit> targetOU = organizationalUnits.stream()
                .filter( p -> p.getIdentifier().equalsIgnoreCase( ouIdentifier ) ).findFirst();
        return targetOU;
    }
"
519,"to keep code consistency, you may use `testK(""v2"");`","   public void testPutAsync() throws Exception {
      // put
      Future<String> f = c.putAsync(""k"", ""v"");
      testFuture(f, null);
      testK(""v"");

      f = c.putAsync(""k"", ""v2"");
      testFuture(f, ""v"");
      assertEquals(""v2"", c.get(""k""));
   }
","   public void testPutAsync() throws Exception {
      // put
      Future<String> f = c.putAsync(""k"", ""v"");
      testFuture(f, null);
      testK(""v"");

      f = c.putAsync(""k"", ""v2"");
      testFuture(f, ""v"");
START       assertEquals(""v2"", c.get(""k"")); END 
   }
","   public void testPutAsync() throws Exception {
      // put
      Future<String> f = c.putAsync(""k"", ""v"");
      testFuture(f, null);
      testK(""v"");

      f = c.putAsync(""k"", ""v2"");
      testFuture(f, ""v"");
      testK(""v2"");
   }
"
520,should this return true instead ?,"    public boolean isReady(TaskActionClient taskActionClient) throws Exception
    {
      return false;
    }
","    public boolean isReady(TaskActionClient taskActionClient) throws Exception
    {
START       return false; END 
    }
","    public boolean isReady(TaskActionClient taskActionClient) throws Exception
    {
      return true;
    }
"
521,why not public,"    static Map<String, EntryValue> convertBeanToEntryMap(Object bean) {
        Map<String, Object> buildAttributeValueMap = BeanUtilsExtended.buildObjectAttributeMap(bean);
        return Maps.transformEntries(buildAttributeValueMap, new ObjectToEntryValueTransformer());
    }
","START     static Map<String, EntryValue> convertBeanToEntryMap(Object bean) { END 
        Map<String, Object> buildAttributeValueMap = BeanUtilsExtended.buildObjectAttributeMap(bean);
        return Maps.transformEntries(buildAttributeValueMap, new ObjectToEntryValueTransformer());
    }
","    public static Map<String, EntryValue> convertBeanToEntryMap(Object bean) {
        Map<String, Object> buildAttributeValueMap = BeanUtilsExtended.buildObjectAttributeMap(bean);
        return Maps.transformEntries(buildAttributeValueMap, new ObjectToEntryValueTransformer());
    }
"
522,"nit: replace with `this(new RequestHeaderData(struct, headerVersion), headerVersion)`. Consolidates c'tor logic to one place.","    public RequestHeader(Struct struct, short headerVersion) {
        this.data = new RequestHeaderData(struct, headerVersion);
        this.headerVersion = headerVersion;
    }
","    public RequestHeader(Struct struct, short headerVersion) {
        this.data = new RequestHeaderData(struct, headerVersion);
START         this.headerVersion = headerVersion; END 
    }
","    public RequestHeader(Struct struct, short headerVersion) {
        this(new RequestHeaderData(struct, headerVersion), headerVersion);
    }
"
523,Please add braces to conditionals (like `if { }`).,"    public void accountSession(String username, String password) throws TmdbInvalidParametersException {
        if (username == null || password==null)
            throw new TmdbInvalidParametersException(401,""Username and Password may not be null"");

        this.username = username;
        this.password = password;
        hasAccountSession = true;
    }
","    public void accountSession(String username, String password) throws TmdbInvalidParametersException {
START         if (username == null || password==null) END 
            throw new TmdbInvalidParametersException(401,""Username and Password may not be null"");

        this.username = username;
        this.password = password;
        hasAccountSession = true;
    }
","    public void accountSession(String username, String password) throws TmdbInvalidParametersException {
        if (username == null || password == null) {
            throw new TmdbInvalidParametersException(401, ""Username and Password may not be null"");
        }

        this.username = username;
        this.password = password;
        hasAccountSession = true;
    }
"
524,Use if (!fRemoteDirSelected) {,"	public void setProjectName(String projectName) {
		fProjectName = projectName;
		// If remote directory field is empty
		if(fLocationText.getText().equals(EMPTY_STRING)) {
			fRemoteDirSelected = false;
		}
		// If remote directory was not selected yet
		if (fRemoteDirSelected == false) {
			fLocationText.setText(getDefaultPathDisplayString());
		}
	}
","	public void setProjectName(String projectName) {
		fProjectName = projectName;
		// If remote directory field is empty
		if(fLocationText.getText().equals(EMPTY_STRING)) {
			fRemoteDirSelected = false;
		}
		// If remote directory was not selected yet
START 		if (fRemoteDirSelected == false) { END 
			fLocationText.setText(getDefaultPathDisplayString());
		}
	}
","	public void setProjectName(String projectName) {
		fProjectName = projectName;
		// If remote directory field is empty
		if(fLocationText.getText().equals(EMPTY_STRING)) {
			fRemoteDirSelected = false;
		}
		// If remote directory was not selected yet
		if (!fRemoteDirSelected) {
			fLocationText.setText(getDefaultPathDisplayString());
		}
	}
"
525,unreachable. Maybe you should remove.,"    public void testAddChildCycle3() {
        assertNotNull(fFixture);
        assertNotNull(f42Fixture);
        assertNotNull(fHiFixture);
        ((CalledFunction) f42Fixture).addChild(fHiFixture);
        assertEquals(Collections.singletonList(fHiFixture), f42Fixture.getChildren());
    }
","    public void testAddChildCycle3() {
        assertNotNull(fFixture);
        assertNotNull(f42Fixture);
        assertNotNull(fHiFixture);
        ((CalledFunction) f42Fixture).addChild(fHiFixture);
        START  assertEquals(Collections.singletonList(fHiFixture), f42Fixture.getChildren()); END 
    }
","    public void testAddChildCycle3() {
        assertNotNull(fFixture);
        assertNotNull(f42Fixture);
        assertNotNull(fHiFixture);
        ((CalledFunction) f42Fixture).addChild(fHiFixture);
    }
"
526,"I think the condition needs top start as `fieldName.length() > 1` instead  of `fieldName.length() > 2 `.

I think the generated code getters/setters has same rules for fields **aField** and **aF**. Or am I wrong?","        private char formatFieldFirstCharacterToFitDroolsCoreStandards(final String fieldName) {
            if (fieldName.length() > 2 && Character.isLowerCase(fieldName.charAt(0)) && Character.isUpperCase(fieldName.charAt(1))) {
                return fieldName.charAt(0);
            } else {
                return Character.toUpperCase(fieldName.charAt(0));
            }
        }
","        private char formatFieldFirstCharacterToFitDroolsCoreStandards(final String fieldName) {
START             if (fieldName.length() > 2 && Character.isLowerCase(fieldName.charAt(0)) && Character.isUpperCase(fieldName.charAt(1))) { END 
                return fieldName.charAt(0);
            } else {
                return Character.toUpperCase(fieldName.charAt(0));
            }
        }
","        private char formatFieldFirstCharacterToFitDroolsCoreStandards(final String fieldName) {
            if (fieldName.length() > 1 && Character.isLowerCase(fieldName.charAt(0)) && Character.isUpperCase(fieldName.charAt(1))) {
                return fieldName.charAt(0);
            } else {
                return Character.toUpperCase(fieldName.charAt(0));
            }
        }
"
527,Are these logging statements really needed?,"	public void start() {
		logger.debug(""start()"");
		for (final Class<?> stepDefinitionType : cachedStepsInstances.keySet()) {
			cachedStepsInstances.put(stepDefinitionType, createStepsInstance(stepDefinitionType));
		}
	}
","	public void start() {
START 		logger.debug(""start()""); END 
		for (final Class<?> stepDefinitionType : cachedStepsInstances.keySet()) {
			cachedStepsInstances.put(stepDefinitionType, createStepsInstance(stepDefinitionType));
		}
	}
","    public void start() {
        logger.trace(""start()"");
        for (final Class<?> stepDefinitionType : cachedStepsInstances.keySet()) {
            cachedStepsInstances.put(stepDefinitionType, createStepsInstance(stepDefinitionType));
        }
    }
"
528,"I don't have the code now but if the contract od sselection is to return null on getFirstElement() if sselection is empty, the code can be changed to simply return the first element, without the if.","	private WorkingSetDescriptor getSelectedWorkingSet() {
		IStructuredSelection selection = typesListViewer.getStructuredSelection();

        WorkingSetDescriptor descriptor = null;
		if (!selection.isEmpty()) {
			descriptor = (WorkingSetDescriptor) selection.getFirstElement();
        }
		return descriptor;
	}
","	private WorkingSetDescriptor getSelectedWorkingSet() {
		IStructuredSelection selection = typesListViewer.getStructuredSelection();

        WorkingSetDescriptor descriptor = null;
		if (!selection.isEmpty()) {
			descriptor = (WorkingSetDescriptor) START selection.getFirstElement(); END 
        }
		return descriptor;
	}
","	private WorkingSetDescriptor getSelectedWorkingSet() {
		return (WorkingSetDescriptor) typesListViewer.getStructuredSelection().getFirstElement();
	}
"
529,"Is it reasonable for the caller to pass in a null value for previous into the constructor? If not, then the constructor should throw a `NullPointerException` if it is null.","    public void evaluate() throws Throwable {
        if (null != previous) {
            previous.evaluate();
        }
        for (FrameworkMethod before : befores) {
            before.invokeExplosively(target);
        }
        next.evaluate();
    }
","    public void evaluate() throws Throwable {
START         if (null != previous) { END 
            previous.evaluate();
        }
        for (FrameworkMethod before : befores) {
            before.invokeExplosively(target);
        }
        next.evaluate();
    }
","    public void evaluate() throws Throwable {
        for (FrameworkMethod before : befores) {
            before.invokeExplosively(target);
        }
        next.evaluate();
    }
"
530,"It is a bit weird to create here an empty ""StoragePool"" to indicate that there is no storage pool to use. Can't we just pass ""null"" to the backend in that case?","    public Response add(OpenStackVolumeProvider provider) {
        validateParameters(provider, ""name"");
        StoragePool storagePool = provider.isSetDataCenter() ?
                getStoragePool(provider.getDataCenter()) : new StoragePool();
        provider.setDataCenter(DataCenterMapper.map(storagePool, null));
        return performCreate(
                VdcActionType.AddProvider,
                new ProviderParameters(map(provider)),
                new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class)
        );
    }
","    public Response add(OpenStackVolumeProvider provider) {
        validateParameters(provider, ""name"");
        StoragePool storagePool = provider.isSetDataCenter() ?
START                 getStoragePool(provider.getDataCenter()) : new StoragePool(); END 
        provider.setDataCenter(DataCenterMapper.map(storagePool, null));
        return performCreate(
                VdcActionType.AddProvider,
                new ProviderParameters(map(provider)),
                new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class)
        );
    }
","    public Response add(OpenStackVolumeProvider provider) {
        validateParameters(provider, ""name"");
        if (provider.isSetDataCenter()) {
            StoragePool storagePool = getStoragePool(provider.getDataCenter());
            provider.setDataCenter(DataCenterMapper.map(storagePool, null));
        }
        return performCreate(
                VdcActionType.AddProvider,
                new ProviderParameters(map(provider)),
                new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class)
        );
    }
"
531,private,"    protected void doStoreUsers()
    {
        try
        {
            usersFileManager.store(new UsersDto(new HashSet<>(userMap.values())));
        }
        catch (IOException e)
        {
            throw new UndeclaredThrowableException(e);
        }
    }
","START     protected void doStoreUsers() END 
    {
        try
        {
            usersFileManager.store(new UsersDto(new HashSet<>(userMap.values())));
        }
        catch (IOException e)
        {
            throw new UndeclaredThrowableException(e);
        }
    }
","    private void doStoreUsers()
    {
        try
        {
            usersFileManager.store(new UsersDto(new HashSet<>(userMap.values())));
        }
        catch (IOException e)
        {
            throw new UndeclaredThrowableException(e);
        }
    }
"
532,Why is this needed now?,"    public void tearDown() throws IOException, SQLException {
        try {
            globalScheduler.shutdown();
        } catch (Exception e) {
            
        }   
        cleanup();
        tearDownOnce();
    }
","START     public void tearDown() throws IOException, SQLException { END 
        try {
            globalScheduler.shutdown();
        } catch (Exception e) {
            
        }   
        cleanup();
        tearDownOnce();
    }
","    public void tearDown(){
        try {
            globalScheduler.shutdown();
        } catch (Exception e) {
            
        }   
        cleanup();
        tearDownOnce();
    }
"
533,"This shouldn't call `getAllConfigBag()`. It should use the `config` passed in, otherwise we lose the local values passed in to the obtain() method. Do you agree?","    private CloudMachineNamer getCloudMachineNamer(ConfigBag config) {
        String namerClass = config.get(LocationConfigKeys.CLOUD_MACHINE_NAMER_CLASS);
        if (namerClass != null) {
            try {
                return (CloudMachineNamer) getManagementContext().getCatalog().getRootClassLoader().loadClass(namerClass)
                        .getDeclaredConstructor(ConfigBag.class).newInstance(config);
            } catch (Exception e) {
                throw Exceptions.propagate(e);
            }
        } else {
            return new JcloudsMachineNamer(getAllConfigBag());
        }
    }
","    private CloudMachineNamer getCloudMachineNamer(ConfigBag config) {
        String namerClass = config.get(LocationConfigKeys.CLOUD_MACHINE_NAMER_CLASS);
        if (namerClass != null) {
            try {
                return (CloudMachineNamer) getManagementContext().getCatalog().getRootClassLoader().loadClass(namerClass)
                        .getDeclaredConstructor(ConfigBag.class).newInstance(config);
            } catch (Exception e) {
                throw Exceptions.propagate(e);
            }
        } else {
START             return new JcloudsMachineNamer(getAllConfigBag()); END 
        }
    }
","    private CloudMachineNamer getCloudMachineNamer(ConfigBag config) {
        String namerClass = config.get(LocationConfigKeys.CLOUD_MACHINE_NAMER_CLASS);
        if (namerClass != null) {
            try {
                return (CloudMachineNamer) getManagementContext().getCatalog().getRootClassLoader().loadClass(namerClass)
                        .getDeclaredConstructor(ConfigBag.class).newInstance(config);
            } catch (Exception e) {
                throw Exceptions.propagate(e);
            }
        } else {
            return new JcloudsMachineNamer(config);
        }
    }
"
534,Missing JavaDoc.,"    public IllustratedSelectItem(Object value, String label, String image) {
        super(value, label);
        this.image = image;
    }
","START     public IllustratedSelectItem(Object value, String label, String image) { END 
        super(value, label);
        this.image = image;
    }
","    IllustratedSelectItem(Object value, String label, String image) {
        super(value, label);
        this.image = image;
    }
"
535,"The last six lines can be squashed into: return ""WMS"".equalsIgnoreCase(service) || ""gwc"".equalsIgnoreCase(service);","    private boolean layerGroupContainmentCheckRequired() {
        // first, is it WMS?
        Request request = Dispatcher.REQUEST.get();
        if(request == null) {
            return false;
        }
        
        // layer groups are used only in WMS
        final String service = request.getService();
        boolean isMapService = ""WMS"".equalsIgnoreCase(service) || ""gwc"".equalsIgnoreCase(service);
        if(!isMapService) {
            return false;
        }
        
        return true;
    }
","    private boolean layerGroupContainmentCheckRequired() {
        // first, is it WMS?
        Request request = Dispatcher.REQUEST.get();
        if(request == null) {
            return false;
        }
        
        // layer groups are used only in WMS
        final String service = request.getService();
        boolean isMapService = ""WMS"".equalsIgnoreCase(service) || ""gwc"".equalsIgnoreCase(service);
        if(!isMapService) {
            return false;
        }
        
START         return true; END 
    }
","    private boolean layerGroupContainmentCheckRequired() {
        // first, is it WMS?
        Request request = Dispatcher.REQUEST.get();
        if(request == null) {
            return false;
        }
        
        // layer groups are used only in WMS
        final String service = request.getService();
        return ""WMS"".equalsIgnoreCase(service) || ""gwc"".equalsIgnoreCase(service);
    }
"
536,"I would do this instead:
``initialize(absoluteUri, contextPath, (initData != null && InitData.canBeCached(absoluteUri)) ? initData : null);``
IOW, no point in spending time on checking if the cache can be used if there's no ``initData`` provided.","   public ResteasyUriInfo(final String absoluteUri, final String contextPath, final InitData initData) {
      initialize(absoluteUri, contextPath, InitData.canBeCached(absoluteUri) ? initData : null);
   }
","   public ResteasyUriInfo(final String absoluteUri, final String contextPath, final InitData initData) {
START       initialize(absoluteUri, contextPath, InitData.canBeCached(absoluteUri) ? initData : null); END 
   }
","   public ResteasyUriInfo(final String absoluteUri, final String contextPath, final InitData initData) {
      initialize(absoluteUri, contextPath, initData != null && InitData.canBeCached(absoluteUri) ? initData : null);
   }
"
537,"@benzonico The fact that postfix operators return value before modification shouldn't change order in CFG, because loading of value should anyway happen before operation, i.e. order should be the same.","  private void buildUnaryExpression(UnaryExpressionTree tree) {
    if(tree.is(Tree.Kind.PREFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT)) {
      build(tree.expression());
      currentBlock.elements.add(tree);
    } else {
      currentBlock.elements.add(tree);
      build(tree.expression());
    }
  }
","  private void buildUnaryExpression(UnaryExpressionTree tree) {
START     if(tree.is(Tree.Kind.PREFIX_DECREMENT, Tree.Kind.PREFIX_INCREMENT)) { END 
      build(tree.expression());
      currentBlock.elements.add(tree);
    } else {
      currentBlock.elements.add(tree);
      build(tree.expression());
    }
  }
","  private void buildUnaryExpression(UnaryExpressionTree tree) {
    currentBlock.elements.add(tree);
    build(tree.expression());
  }
"
538,Class<?>,"    public Class getRealClass() {
        return testNGMethod.getRealClass();
    }
","START     public Class getRealClass() { END 
        return testNGMethod.getRealClass();
    }
","    public Class<?> getRealClass() {
        return testNGMethod.getRealClass();
    }
"
539,Good it is the way,"    private KeyStore getSecretsStore() {
        final File secretStoreFile = createStoreIfNeeded();
        try {
            final KeyStore keyStore = KeyStore.getInstance(SECRETS_STORE_KEYSTORE_TYPE);
            try (InputStream inputStream = Files.newInputStream(secretStoreFile.toPath())) {
                keyStore.load(inputStream, loadStorePassword());
            }

            return keyStore;

        } catch (Exception e) {
            Logger.warn(this.getClass(), ""unable to load secrets store "" + SECRETS_STORE_FILE + "": "" + e);
            throw new DotRuntimeException(e);
        }

    }
","    private KeyStore getSecretsStore() {
        final File secretStoreFile = createStoreIfNeeded();
        try {
            final KeyStore keyStore = KeyStore.getInstance(SECRETS_STORE_KEYSTORE_TYPE);
START             try (InputStream inputStream = Files.newInputStream(secretStoreFile.toPath())) { END 
                keyStore.load(inputStream, loadStorePassword());
            }

            return keyStore;

        } catch (Exception e) {
            Logger.warn(this.getClass(), ""unable to load secrets store "" + SECRETS_STORE_FILE + "": "" + e);
            throw new DotRuntimeException(e);
        }

    }
","    private KeyStore getSecretsStore() {
        final File secretStoreFile = createStoreIfNeeded();
        try {
            final KeyStore keyStore = KeyStore.getInstance(SECRETS_STORE_KEYSTORE_TYPE);
            try (InputStream inputStream = Files.newInputStream(secretStoreFile.toPath())) {
                keyStore.load(inputStream, loadStorePassword());
            }

            return keyStore;

        } catch (Exception e) {
            Logger.error(this.getClass(), ""unable to load secrets store "" + SECRETS_STORE_FILE + "": "" + e);
            throw new DotRuntimeException(e);
        }

    }
"
540,This should be ROLE_ANONYMOUS. However given the defaults in AnonymousSpec you should just delete it,"	public AnonymousSpec anonymous(){
		if (this.anonymous == null) {
			this.anonymous = new AnonymousSpec();
		}
		return this.anonymous.authorities(""ROLE_USER"");
	}
","	public AnonymousSpec anonymous(){
		if (this.anonymous == null) {
			this.anonymous = new AnonymousSpec();
		}
START 		return this.anonymous.authorities(""ROLE_USER""); END 
	}
","	public AnonymousSpec anonymous(){
		if (this.anonymous == null) {
			this.anonymous = new AnonymousSpec();
		}
		return this.anonymous;
	}
"
541,"```suggestion
    return this.connectionPool.getNumWaiters();
```","  public int getNumWaiters() {
    return this.connectionPool.getNumActive();
  }
","  public int getNumWaiters() {
START     return this.connectionPool.getNumActive(); END 
  }
","  public int getNumWaiters() {
    return this.connectionPool.getNumWaiters();
  }
"
542,can we do this atomically?,"    private void store() throws IOException {
        byte[] serialized = state.toCbor().serialize();
        System.out.println(""Writing ""+ serialized.length +"" bytes to ""+ statePath);
        Files.write(
            statePath,
            serialized,
            StandardOpenOption.CREATE);
    }
","    private void store() throws IOException {
        byte[] serialized = state.toCbor().serialize();
        System.out.println(""Writing ""+ serialized.length +"" bytes to ""+ statePath);
        Files.write(
            statePath,
            serialized,
START             StandardOpenOption.CREATE); END 
    }
","    private synchronized void store() throws IOException {
        byte[] serialized = state.toCbor().serialize();
        System.out.println(""Writing ""+ serialized.length +"" bytes to ""+ statePath);
        Files.write(
            statePath,
            serialized,
            StandardOpenOption.CREATE);
    }
"
543,Please add curlies here,"    private static void initFacets(@CheckForNull Fingerprint fingerprint){
        if (fingerprint==null) return;

        for (FingerprintFacet facet : fingerprint.facets)
            facet._setOwner(fingerprint);
    }
","    private static void initFacets(@CheckForNull Fingerprint fingerprint){
        if (fingerprint==null) return;

START         for (FingerprintFacet facet : fingerprint.facets) END 
            facet._setOwner(fingerprint);
    }
","    private static void initFacets(@CheckForNull Fingerprint fingerprint) {
        if (fingerprint == null) {
            return;
        }

        for (FingerprintFacet facet : fingerprint.facets) {
            facet._setOwner(fingerprint);
        }
    }
"
544,For clarity it's preferable: Map.Entry,"	public Map<FactoryContainer, Attributes> getEnabledContainers() {
		Map<FactoryContainer, Attributes> map = new LinkedHashMap<>();
		synchronized(_path) {
			for (Entry<FactoryContainer, Attributes> entry : getReversed(_path.entrySet())) {
				Attributes attr = entry.getValue();
				if (attr.isEnabled()) {
					Attributes attrClone = new Attributes(attr);
					map.put(entry.getKey(), attrClone);
				}
			}
		}
		return map;
	}
","	public Map<FactoryContainer, Attributes> getEnabledContainers() {
		Map<FactoryContainer, Attributes> map = new LinkedHashMap<>();
		synchronized(_path) {
			for START (Entry<FactoryContainer, END  Attributes> entry : getReversed(_path.entrySet())) {
				Attributes attr = entry.getValue();
				if (attr.isEnabled()) {
					Attributes attrClone = new Attributes(attr);
					map.put(entry.getKey(), attrClone);
				}
			}
		}
		return map;
	}
","	public Map<FactoryContainer, Attributes> getEnabledContainers() {
		Map<FactoryContainer, Attributes> map = new LinkedHashMap<>();
		synchronized(_path) {
			for (Map.Entry<FactoryContainer, Attributes> entry : getReversed(_path.entrySet())) {
				Attributes attr = entry.getValue();
				if (attr.isEnabled()) {
					Attributes attrClone = new Attributes(attr);
					map.put(entry.getKey(), attrClone);
				}
			}
		}
		return map;
	}
"
545,"I'm concerned about this lock.. it doesn't seem necessary as each operation invoking this private method is guarded already, and whenever a thread needs to acquire two locks I have an alarm bell ringing in my head.","   private FileListCacheValue getFileList() {
      readLock.lock();
      try {
         FileListCacheValue fileList = (FileListCacheValue) cache.get(fileListCacheKey);
         if (fileList == null) {
            fileList = new FileListCacheValue();
            FileListCacheValue prev = (FileListCacheValue) cache.putIfAbsent(fileListCacheKey, fileList);
            if (prev != null) {
               fileList = prev;
            }
         }
         if (trace)
            log.trace(""Refreshed file listing view"");
         return fileList;
      } finally {
         readLock.unlock();
      }
   }
","   private FileListCacheValue getFileList() {
START       readLock.lock(); END 
      try {
         FileListCacheValue fileList = (FileListCacheValue) cache.get(fileListCacheKey);
         if (fileList == null) {
            fileList = new FileListCacheValue();
            FileListCacheValue prev = (FileListCacheValue) cache.putIfAbsent(fileListCacheKey, fileList);
            if (prev != null) {
               fileList = prev;
            }
         }
         if (trace)
            log.trace(""Refreshed file listing view"");
         return fileList;
      } finally {
         readLock.unlock();
      }
   }
","   private FileListCacheValue getFileList() {
      FileListCacheValue fileList = (FileListCacheValue) cache.get(fileListCacheKey);
      if (fileList == null) {
         fileList = new FileListCacheValue();
         FileListCacheValue prev = (FileListCacheValue) cache.putIfAbsent(fileListCacheKey, fileList);
         if (prev != null) {
            fileList = prev;
         }
      }
      if (trace)
         log.trace(""Refreshed file listing view"");
      return fileList;
   }
"
546,What happens when one of these `TypedOutput` instances return `-1` because they don't know their length?,"        public long size() {
            build();
            return body.length() + partBoundary.length + partHeader.length;
        }
","        public long size() {
            build();
START             return body.length() + partBoundary.length + partHeader.length; END 
        }
","    public long size() {
      build();
      if (body.length() > -1) {
        return body.length() + partBoundary.length + partHeader.length;
      } else {
        return -1;
      }
    }
"
547,Performance gezien is het natuurlijk handiger eerst een boolean check te hebben en dan extra logica..,"	public boolean canStreamToNextPipe() {
		return super.canStreamToNextPipe() && !isCollectResults(); // when collectResults is false, streaming is not necessary or useful
	}
","	public boolean canStreamToNextPipe() {
START 		return super.canStreamToNextPipe() && !isCollectResults(); // when collectResults is false, streaming is not necessary or useful END 
	}
","	public boolean canStreamToNextPipe() {
		return !isCollectResults() && super.canStreamToNextPipe(); // when collectResults is false, streaming is not necessary or useful
	}
"
548,Where do you handle this now?,"	public FoundViewHolder getFoundViewHolder(JFieldRef idRef, AbstractJClass viewClass) {
		String idRefString = idRef.name();
		FoundViewHolder foundViewHolder = (FoundViewHolder) foundHolders.get(idRefString);
		if (foundViewHolder == null) {
			foundViewHolder = createFoundViewAndIfNotNullBlock(idRef, viewClass);
			foundHolders.put(idRefString, foundViewHolder);
		}
		return foundViewHolder;
	}
","	public FoundViewHolder getFoundViewHolder(JFieldRef idRef, AbstractJClass viewClass) {
		String idRefString = idRef.name();
		FoundViewHolder foundViewHolder = (FoundViewHolder) foundHolders.get(idRefString);
		if (foundViewHolder == null) {
			foundViewHolder = createFoundViewAndIfNotNullBlock(idRef, viewClass);
START 			foundHolders.put(idRefString, foundViewHolder); END 
		}
		return foundViewHolder;
	}
","	public FoundViewHolder getFoundViewHolder(JFieldRef idRef, AbstractJClass viewClass) {
		return getFoundViewHolder(idRef, viewClass, null);
	}
"
549,`finally` is not really needed. If `close` throws the test will fail anyway and we won't care whether `queryRunner` is `null` or not.,"    public void tearDown()
    {
        try {
            queryRunner.close();
        }
        finally {
            queryRunner = null;
        }
    }
","    public void tearDown()
    {
        try {
            queryRunner.close();
        }
START         finally { END 
            queryRunner = null;
        }
    }
","    public void tearDown()
    {
        queryRunner.close();
    }
"
550,"What if this throws an exception? Should probably be mapped to a ConfigInvalidException, and the caller should report the error.","	private CommitConfig(Config rc) {
		commitTemplatePath = rc.getString(ConfigConstants.CONFIG_COMMIT_SECTION,
				null, ConfigConstants.CONFIG_KEY_COMMIT_TEMPLATE);

		String i18nCommitEncoding = rc.getString(
				ConfigConstants.CONFIG_SECTION_I18N, null,
				ConfigConstants.CONFIG_KEY_COMMIT_ENCODING);

		if (i18nCommitEncoding != null) {
			commitMessageEncoding = Charset.forName(i18nCommitEncoding);
		}
	}
","	private CommitConfig(Config rc) {
		commitTemplatePath = rc.getString(ConfigConstants.CONFIG_COMMIT_SECTION,
				null, ConfigConstants.CONFIG_KEY_COMMIT_TEMPLATE);

		String i18nCommitEncoding = rc.getString(
				ConfigConstants.CONFIG_SECTION_I18N, null,
				ConfigConstants.CONFIG_KEY_COMMIT_ENCODING);

		if (i18nCommitEncoding != null) {
START 			commitMessageEncoding = Charset.forName(i18nCommitEncoding); END 
		}
	}
","	private CommitConfig(Config rc) {
		commitTemplatePath = rc.getString(ConfigConstants.CONFIG_COMMIT_SECTION,
				null, ConfigConstants.CONFIG_KEY_COMMIT_TEMPLATE);

		i18nCommitEncoding = rc.getString(ConfigConstants.CONFIG_SECTION_I18N,
				null, ConfigConstants.CONFIG_KEY_COMMIT_ENCODING);

	}
"
551,What's broken (add some details in the commit message)? This is not very obvious.,"    public int decompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength)
            throws MalformedInputException
    {
        try {
            Inflater inflater = new Inflater(true);
            inflater.setInput(input, inputOffset, inputLength);
            int resultLength = inflater.inflate(output, outputOffset, maxOutputLength);
            inflater.end();
            return resultLength;
        }
        catch (DataFormatException e) {
            throw Throwables.propagate(e);
        }
    }
","    public int decompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength)
            throws MalformedInputException
    {
START         try { END 
            Inflater inflater = new Inflater(true);
            inflater.setInput(input, inputOffset, inputLength);
            int resultLength = inflater.inflate(output, outputOffset, maxOutputLength);
            inflater.end();
            return resultLength;
        }
        catch (DataFormatException e) {
            throw Throwables.propagate(e);
        }
    }
","    public int decompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset, int maxOutputLength)
            throws MalformedInputException
    {
        try {
            Inflater inflater = new Inflater(true);
            inflater.setInput(input, inputOffset, inputLength);
            int resultLength = inflater.inflate(output, outputOffset, maxOutputLength);
            inflater.end();
            return resultLength;
        }
        catch (DataFormatException e) {
            throw new RuntimeException(e);
        }
    }
"
552,we should return an ImmutableList if we don't intend for users of this method to edit the list.,"  public List<OutputLine> getLog() {
    return this.log;
  }
","START   public List<OutputLine> getLog() { END 
    return this.log;
  }
","  public List<OutputLine> getLog() {
    return new ArrayList<>(this.log);
  }
"
553,`!this.closeStreamAfterSend || this.isSingleUse` ?,"	protected void doInit() {
		super.doInit();
		if (!this.evaluationContextSet) {
			this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory());
		}
		Assert.state(this.closeStreamAfterSend ? this.isSingleUse : true,
				""Single use connection needed with closeStreamAfterSend"");
	}
","	protected void doInit() {
		super.doInit();
		if (!this.evaluationContextSet) {
			this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory());
		}
START 		Assert.state(this.closeStreamAfterSend ? this.isSingleUse : true, END 
				""Single use connection needed with closeStreamAfterSend"");
	}
","	protected void doInit() {
		super.doInit();
		if (!this.evaluationContextSet) {
			this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory());
		}
		Assert.state(!this.closeStreamAfterSend || this.isSingleUse,
				""Single use connection needed with closeStreamAfterSend"");
	}
"
554,"I'm reworking this code in the context of the class, also to avoid potential NPE if the extensionRegisters field might have not been initialized, from the no-args constructor.","    public ExtensionElementsConverter(XStream xStream, List<DMNExtensionRegister> extensionRegisters) {
        super(xStream);
        this.extensionRegisters = new ArrayList<DMNExtensionRegister>();
        if(extensionRegisters != null && extensionRegisters.size() > 0)
            this.extensionRegisters.addAll(extensionRegisters);
    }
","    public ExtensionElementsConverter(XStream xStream, List<DMNExtensionRegister> extensionRegisters) {
        super(xStream);
        this.extensionRegisters = new ArrayList<DMNExtensionRegister>();
        if(extensionRegisters != null && extensionRegisters.size() > 0)
START             this.extensionRegisters.addAll(extensionRegisters); END 
    }
","    public ExtensionElementsConverter(XStream xStream, List<DMNExtensionRegister> extensionRegisters) {
        super(xStream);
        if ( !extensionRegisters.isEmpty() ) {
            this.extensionRegisters.addAll(extensionRegisters);
        }
    }
"
555,"Maybe we should move that inside the `if` body, since we won't always execute the batch... ?","	public void executeBatch(OperationsQueue operationsQueue) {
		log.tracef( ""Executing batch"" );

		try {
			if ( GridDialects.hasFacet( getGridDialect(), BatchableGridDialect.class )
					|| GridDialects.hasFacet( getGridDialect(), GroupingByEntityDialect.class ) ) {
				super.executeBatch( operationsQueue );
			}
		}
		catch ( TupleAlreadyExistsException taee ) {
			// TODO: Ideally, we should log the entity name + id here; For now we trust the datastore to provide this
			// information via the original exception; It'd require a fair bit of changes to obtain the entity name here
			// (we'd have to obtain the persister matching the given entity key metadata which in turn would require
			// access to the session factory which is not easily available here)
			throw log.mustNotInsertSameEntityTwice( taee.getMessage(), taee );
		}
	}
","	public void executeBatch(OperationsQueue operationsQueue) {
START 		log.tracef( ""Executing batch"" ); END 

		try {
			if ( GridDialects.hasFacet( getGridDialect(), BatchableGridDialect.class )
					|| GridDialects.hasFacet( getGridDialect(), GroupingByEntityDialect.class ) ) {
				super.executeBatch( operationsQueue );
			}
		}
		catch ( TupleAlreadyExistsException taee ) {
			// TODO: Ideally, we should log the entity name + id here; For now we trust the datastore to provide this
			// information via the original exception; It'd require a fair bit of changes to obtain the entity name here
			// (we'd have to obtain the persister matching the given entity key metadata which in turn would require
			// access to the session factory which is not easily available here)
			throw log.mustNotInsertSameEntityTwice( taee.getMessage(), taee );
		}
	}
","	public void executeBatch(OperationsQueue operationsQueue) {
		try {
			if ( GridDialects.hasFacet( getGridDialect(), BatchableGridDialect.class )
					|| GridDialects.hasFacet( getGridDialect(), GroupingByEntityDialect.class ) ) {
				log.tracef( ""Executing batch"" );
				super.executeBatch( operationsQueue );
			}
		}
		catch ( TupleAlreadyExistsException taee ) {
			// TODO: Ideally, we should log the entity name + id here; For now we trust the datastore to provide this
			// information via the original exception; It'd require a fair bit of changes to obtain the entity name here
			// (we'd have to obtain the persister matching the given entity key metadata which in turn would require
			// access to the session factory which is not easily available here)
			throw log.mustNotInsertSameEntityTwice( taee.getMessage(), taee );
		}
	}
"
556,nit-pick: startCommit.hashCode can just be xored/added in since it is well distributed,"	public int hashCode() {
		return (((startCommit.hashCode() * 31) + numbers.length) * 31)
				+ getNumber();
	}
","	public int hashCode() {
START 		return (((startCommit.hashCode() * 31) + numbers.length) * 31) END 
				+ getNumber();
	}
","	public int hashCode() {
		return ((startCommit.hashCode() + numbers.length) * 31) + getNumber();
	}
"
557,can this function now throw NoSuchAlgorithmException,"    private void prepareAuthForBrokerCall() throws NoSuchAlgorithmException {
        AuthenticationSettings.INSTANCE.setUseBroker(true);
    }
","START     private void prepareAuthForBrokerCall() throws NoSuchAlgorithmException { END 
        AuthenticationSettings.INSTANCE.setUseBroker(true);
    }
","    private void prepareAuthForBrokerCall() {
        AuthenticationSettings.INSTANCE.setUseBroker(true);
    }
"
558,"I woudl remove this else, if the gridCoverage is a wrapper and says ""false"" but iface is ""GridCoverage2D"" you want to fall back on the isInstance check anyways.","        public boolean isWrapperFor(Class<?> iface) {
            if (gridCoverage instanceof Wrapper)
                return ((Wrapper) gridCoverage).isWrapperFor(iface);
            else if (iface.isInstance(gridCoverage)) return true;
            else return false;
        }
","        public boolean isWrapperFor(Class<?> iface) {
            if (gridCoverage instanceof Wrapper)
                return ((Wrapper) gridCoverage).isWrapperFor(iface);
START             else if (iface.isInstance(gridCoverage)) return true; END 
            else return false;
        }
","        public boolean isWrapperFor(Class<?> iface) {
            if (gridCoverage instanceof Wrapper) {
                return ((Wrapper) gridCoverage).isWrapperFor(iface);
            }
            return iface.isInstance(gridCoverage);
        }
"
559,Would you change the log level to debug? it doesn't look worth to be the info level.,"  DataSegment uploadDataSegment(
      DataSegment segment,
      final int binaryVersion,
      final long size,
      final File compressedSegmentData,
      final String azurePath
  )
      throws StorageException, IOException, URISyntaxException
  {
    azureStorage.uploadBlob(compressedSegmentData, config.getContainer(), azurePath);

    final DataSegment outSegment = segment
        .withSize(size)
        .withLoadSpec(this.makeLoadSpec(new URI(azurePath)))
        .withBinaryVersion(binaryVersion);

    log.info(""Deleting file [%s]"", compressedSegmentData);
    compressedSegmentData.delete();

    return outSegment;
  }
","  DataSegment uploadDataSegment(
      DataSegment segment,
      final int binaryVersion,
      final long size,
      final File compressedSegmentData,
      final String azurePath
  )
      throws StorageException, IOException, URISyntaxException
  {
    azureStorage.uploadBlob(compressedSegmentData, config.getContainer(), azurePath);

    final DataSegment outSegment = segment
        .withSize(size)
        .withLoadSpec(this.makeLoadSpec(new URI(azurePath)))
        .withBinaryVersion(binaryVersion);

START     log.info(""Deleting file [%s]"", compressedSegmentData); END 
    compressedSegmentData.delete();

    return outSegment;
  }
","  DataSegment uploadDataSegment(
      DataSegment segment,
      final int binaryVersion,
      final long size,
      final File compressedSegmentData,
      final String azurePath
  )
      throws StorageException, IOException, URISyntaxException
  {
    azureStorage.uploadBlob(compressedSegmentData, config.getContainer(), azurePath);

    final DataSegment outSegment = segment
        .withSize(size)
        .withLoadSpec(this.makeLoadSpec(new URI(azurePath)))
        .withBinaryVersion(binaryVersion);

    log.debug(""Deleting file [%s]"", compressedSegmentData);
    compressedSegmentData.delete();

    return outSegment;
  }
"
560,not done,"	public EEFButtonLifecycleManager(EEFButtonDescription description, IVariableManager variableManager, IInterpreter interpreter,
			TransactionalEditingDomain editingDomain) {
		super(description, variableManager, interpreter, editingDomain);
		this.description = description;
	}
","	public EEFButtonLifecycleManager(EEFButtonDescription description, IVariableManager variableManager, IInterpreter interpreter,
			TransactionalEditingDomain editingDomain) {
START 		super(description, variableManager, END  interpreter, editingDomain);
		this.description = description;
	}
","	public EEFButtonLifecycleManager(EEFButtonDescription description, IVariableManager variableManager, IInterpreter interpreter,
			TransactionalEditingDomain editingDomain) {
		super(variableManager, interpreter, editingDomain);
		this.description = description;
	}
"
561,useless parenthesis,"  private static boolean isProbablyLog4jFormatterLogger(MethodInvocationTree mit, String formatString) {
    return mit.symbol().owner().type().is(ORG_APACHE_LOGGING_LOG4J_LOGGER) &&
          (!formatString.contains(""{}"") && formatString.contains(""%""));
  }
","  private static boolean isProbablyLog4jFormatterLogger(MethodInvocationTree mit, String formatString) {
    return mit.symbol().owner().type().is(ORG_APACHE_LOGGING_LOG4J_LOGGER) &&
START           (!formatString.contains(""{}"") && formatString.contains(""%"")); END 
  }
","  private static boolean isProbablyLog4jFormatterLogger(MethodInvocationTree mit, String formatString) {
    return mit.symbol().owner().type().is(ORG_APACHE_LOGGING_LOG4J_LOGGER) &&
      !formatString.contains(""{}"") &&
      formatString.contains(""%"");
  }
"
562,PatchUtil.M,"  void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    if (checkAndUpdateArrows()) {
      upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
      downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
    skipNum.setText(PatchUtil.C.patchSkipRegion(Integer
        .toString(length)));
  }
","  void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    if (checkAndUpdateArrows()) {
      upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
      downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
    START skipNum.setText(PatchUtil.C.patchSkipRegion(Integer END 
        .toString(length)));
  }
","  void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    if (checkAndUpdateArrows()) {
      upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
      downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
    skipNum.setText(PatchUtil.M.patchSkipRegion(Integer
        .toString(length)));
  }
"
563,Wouldn't be better to directly call the new constructor? Just for easier maintenance in the future.,"    public ExtendedEmailPublisherContext(ExtendedEmailPublisher publisher, AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) {
        this.publisher = publisher;
        this.run = build;
        this.workspace = build.getWorkspace();
        this.launcher = launcher;
        this.listener = listener;
    }
","    public ExtendedEmailPublisherContext(ExtendedEmailPublisher publisher, AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) {
        this.publisher = publisher;
        this.run = build;
        this.workspace = build.getWorkspace();
        this.launcher = launcher;
START         this.listener = listener; END 
    }
","    public ExtendedEmailPublisherContext(ExtendedEmailPublisher publisher, AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) {
        this(publisher, build, build.getWorkspace(), launcher, listener);
    }
"
564,this might be obsolete if `isValueValid`is implemented...,"    public void testWrongFormatNumber() throws Exception {
        NumberCellEditor editor;
        editor = new NumberCellEditor(shell, Integer.class);
        
        //empty string
        editor.setValue("" "");
        editor.getValue();
        assertNull(editor.getValue() );
        
        //not parsable number
        editor.setValue(""aa"");
        editor.getValue();
        assertNull(editor.getValue() );
    }
","    public void testWrongFormatNumber() throws Exception {
        NumberCellEditor editor;
        editor = new NumberCellEditor(shell, Integer.class);
        
        //empty string
        editor.setValue("" "");
        editor.getValue();
        assertNull(editor.getValue() );
        
        //not parsable number
        editor.setValue(""aa"");
START         editor.getValue(); END 
        assertNull(editor.getValue() );
    }
","    public void testWrongFormatNumber() throws Exception {
        NumberCellEditor editor;
        editor = new NumberCellEditor(shell, Integer.class);

        // empty string
        editor.getValue();
        assertNull(editor.getValue());

        // not parsable number
        editor.setValue(""aa"");
        editor.getValue();
        assertNull(editor.getValue());
    }
"
565,else if on one line.,"  public void onReloadPlugin(Plugin oldPlugin, Plugin newPlugin) {
    if (hasAvatarProvider(newPlugin)) {
      avatarSupport = true;
    } else {
      if (avatarSupport && hasAvatarProvider(oldPlugin)) {
        avatarSupport = false;
      }
    }
  }
","  public void onReloadPlugin(Plugin oldPlugin, Plugin newPlugin) {
    if (hasAvatarProvider(newPlugin)) {
      avatarSupport = true;
    START  } else {
      if (avatarSupport END  && hasAvatarProvider(oldPlugin)) {
        avatarSupport = false;
      }
    }
  }
","  public void onReloadPlugin(Plugin oldPlugin, Plugin newPlugin) {
    update();
  }
"
566,`Class<?>`,"    public Class getRealClass() {
        return clazz;
    }
","START     public Class getRealClass() { END 
        return clazz;
    }
","    public Class<?> getRealClass() {
        return clazz;
    }
"
567,I suppose close() is already done in Util.read(..),"   private String read(String resourcePath) throws IOException {
      InputStream is = getClass().getResourceAsStream(resourcePath);
      try {
         return Util.read(is);
      } finally {
         if (is != null) {
            is.close();
         }
      }
   }
","   private String read(String resourcePath) throws IOException {
      InputStream is = getClass().getResourceAsStream(resourcePath);
      try {
         return Util.read(is);
      } finally {
         if (is != null) {
START             is.close(); END 
         }
      }
   }
","   private String read(String resourcePath) throws IOException {
      InputStream is = getClass().getResourceAsStream(resourcePath);
      return Util.read(is);

   }
"
568,"I don't see why I need this cast. The group and artifact IDs are accessible even at interface level. Also the version is accessible, but I don't think you should add it here: this is for multimodule project compilaton and afaik you cannot have different modules with same GA and different version in the same project.","    public static String getModelFileWithGAV(ReleaseId releaseId) {
        ReleaseIdImpl releaseIdImpl = (ReleaseIdImpl) releaseId;
        return Paths.get(MODEL_FILE_DIRECTORY,
                              releaseIdImpl.getGroupId(),
                              releaseIdImpl.getArtifactId(),
                              releaseIdImpl.getVersion(),
                              MODEL_FILE_NAME).toString();
    }
","    public static String getModelFileWithGAV(ReleaseId releaseId) {
START         ReleaseIdImpl releaseIdImpl = (ReleaseIdImpl) releaseId; END 
        return Paths.get(MODEL_FILE_DIRECTORY,
                              releaseIdImpl.getGroupId(),
                              releaseIdImpl.getArtifactId(),
                              releaseIdImpl.getVersion(),
                              MODEL_FILE_NAME).toString();
    }
","    public static String getModelFileWithGAV(ReleaseId releaseId) {
        return Paths.get(MODEL_FILE_DIRECTORY,
                              releaseId.getGroupId(),
                              releaseId.getArtifactId(),
                              MODEL_FILE_NAME).toString();
    }
"
569,"This operation can be O(n), though the size of the list may be small. Making sense to use a set instead?","    void removeConnection(String connectionId) {
      if (availableConnections.remove(connectionId)) {
        availableCount--;
      }
      poolCount--;
    }
","    void removeConnection(String connectionId) {
START       if (availableConnections.remove(connectionId)) { END 
        availableCount--;
      }
      poolCount--;
    }
","    void removeConnection(String connectionId) {
      availableConnections.remove(connectionId);
      poolCount--;
    }
"
570,return before instantiating the map?,"    private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) {
        Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>();
        if (!desiredColumns.isEmpty()) {
            for (Long columnsId : desiredColumns) {
                ISegmentAspect segmentAspect = fAspectMap.get(columnsId);
                if (segmentAspect != null) {
                    aspects.put(columnsId, segmentAspect);
                }
            }
            return aspects;
        }

        return fAspectMap;
    }
","    private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) {
        Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>();
        if START (!desiredColumns.isEmpty()) END  {
            for (Long columnsId : desiredColumns) {
                ISegmentAspect segmentAspect = fAspectMap.get(columnsId);
                if (segmentAspect != null) {
                    aspects.put(columnsId, segmentAspect);
                }
            }
            return aspects;
        }

        return fAspectMap;
    }
","    private Map<Long, ISegmentAspect> getAspectsFromColumnsId(List<Long> desiredColumns) {
        if (!desiredColumns.isEmpty()) {
            Map<Long, ISegmentAspect> aspects = new LinkedHashMap<>();
            for (Long columnsId : desiredColumns) {
                ISegmentAspect segmentAspect = fAspectMap.get(columnsId);
                if (segmentAspect != null) {
                    aspects.put(columnsId, segmentAspect);
                }
            }
            return aspects;
        }

        return fAspectMap;
    }
"
571,Why Objects.nonNull instead of != null?,"	static boolean isValidMining(ICodeMining mining) {
		return Objects.nonNull(mining) && mining.getLabel() != null && !mining.getLabel().isEmpty();
	}
","	static boolean isValidMining(ICodeMining mining) {
START 		return Objects.nonNull(mining) && mining.getLabel() != null && !mining.getLabel().isEmpty(); END 
	}
","	static boolean isValidMining(ICodeMining mining) {
		return mining != null && mining.getLabel() != null && !mining.getLabel().isEmpty();
	}
"
572,`-1` would be more correct. AFAIC you can skip this.,"    public void addInput(Page page)
    {
        verify(probe == null);
        probe = page;
        probePosition = 0;

        joinAddresses = null;
        joinAddressIndex = 0;
    }
","    public void addInput(Page page)
    {
        verify(probe == null);
        probe = page;
        probePosition = 0;

        joinAddresses = null;
START         joinAddressIndex = 0; END 
    }
","    public void addInput(Page page)
    {
        verify(probe == null);
        probe = page;
        probePosition = 0;

        joinAddresses = null;
    }
"
573,Simpler to just rename the field. Then XStream will discard the old data automatically.,"        public DescriptorImpl() {
            super(ThrottleJobProperty.class);
            synchronized(propertiesByCategoryLock) {
                load();
                // Explictly drop queue items loaded from 1.8.1 version
                if (!propertiesByCategory.isEmpty()) {
                    propertiesByCategory = new HashMap<String,Map<ThrottleJobProperty,Void>>();
                    save(); // Save the configuration to remove obsolete data
                }
            }
        }
","        public DescriptorImpl() {
            super(ThrottleJobProperty.class);
            synchronized(propertiesByCategoryLock) {
                load();
                // Explictly drop queue items loaded from 1.8.1 version
                if (!propertiesByCategory.isEmpty()) {
                    propertiesByCategory = new HashMap<String,Map<ThrottleJobProperty,Void>>();
                    save(); // Save the configuration to remove obsolete data
                }
START             } END 
        }
","        public DescriptorImpl() {
            super(ThrottleJobProperty.class);
            synchronized(propertiesByCategoryLock) {
                load();
                // Explictly handle the persisted data from the version 1.8.1
                if (propertiesByCategory == null) {
                    propertiesByCategory = new HashMap<String,Map<ThrottleJobProperty,Void>>();
                }
                if (!propertiesByCategory.isEmpty()) {
                    propertiesByCategory.clear();
                    save(); // Save the configuration to remove obsolete data
                }
            }
        }
"
574,"you don't need this.
the ""+"" operator does this for you.","    public String toString() {
        // Since the static data arrives from external source it's not guarenteed not to be null so a null check is
        // mandatory in order to avoid NPE when invoking toString by the logger
        String domainName = staticData.getName() == null ? ""null"" : staticData.getName();
        String domainId = staticData.getId() == null ? ""null"" : staticData.getId().toString();
        return ""StorageDomain["" + domainName + "", "" + domainId + ""]"";
    }
","    public String toString() {
        // Since the static data arrives from external source it's not guarenteed not to be null so a null check is
        // mandatory in order to avoid NPE when invoking toString by the logger
        String domainName = staticData.getName() == null ? ""null"" : staticData.getName();
START         String domainId = staticData.getId() == null ? ""null"" : staticData.getId().toString(); END 
        return ""StorageDomain["" + domainName + "", "" + domainId + ""]"";
    }
","    public String toString() {
        // Since the static data arrives from external source it's not guarenteed not to be null so a null check is
        // mandatory in order to avoid NPE when invoking toString by the logger
        String domainName = staticData == null ? ""null"" : staticData.getName();
        Guid domainId = staticData == null ? null : staticData.getId();
        return ""StorageDomain["" + domainName + "", "" + domainId + ""]"";
    }
"
575,"Can this be simplified to:

```java
    return input -> range == null || range.contains(input.getKey());
```","    Predicate<Entry<Key,Value>> getScanPredicate() {
      final Range range = getRange();

      return input -> {
        if (range != null && !range.contains(input.getKey()))
          return false;

        return true;
      };
    }
","    Predicate<Entry<Key,Value>> getScanPredicate() {
      final Range range = getRange();

START       return input -> {
        if (range != null && !range.contains(input.getKey()))
          return false;

        return true;
      }; END 
    }
","    Predicate<Entry<Key,Value>> getScanPredicate() {
      final Range range = getRange();

      return input -> range == null || range.contains(input.getKey());
    }
"
576,"nit
```java
this.client = requireNonNull(client, ""client is null"");","    public AlluxioHiveMetastore(TableMasterClient client)
    {
        requireNonNull(client, ""client is null"");
        this.client = client;
    }
","    public AlluxioHiveMetastore(TableMasterClient client)
    {
START         requireNonNull(client, ""client is null""); END 
        this.client = client;
    }
","    public AlluxioHiveMetastore(TableMasterClient client)
    {
        this.client = requireNonNull(client, ""client is null"");
    }
"
577,"Should this be above ""isColorTeamMatch""? For example, on line #755.","   private void addWorkPackageCriteria() {
      if (isWorkPackageSpecified()) {
         ArtifactId workPackArt = atsApi.getQueryService().getArtifactOrSentinel(workPackageId);

         if (isColorTeamMatch(workPackArt)) {
            if (workPackArt.isValid()) {
               queryAnd(AtsAttributeTypes.WorkPackageReference, workPackArt.getIdString());
            }
         }
      }
   }
","   private void addWorkPackageCriteria() {
      if (isWorkPackageSpecified()) {
         ArtifactId workPackArt = atsApi.getQueryService().getArtifactOrSentinel(workPackageId);

         if (isColorTeamMatch(workPackArt)) {
            START  if (workPackArt.isValid()) END  {
               queryAnd(AtsAttributeTypes.WorkPackageReference, workPackArt.getIdString());
            }
         }
      }
   }
","   private void addWorkPackageCriteria() {
      if (isWorkPackageSpecified()) {
         ArtifactId workPackArt = atsApi.getQueryService().getArtifactOrSentinel(workPackageId);
         if (workPackArt.isValid()) {
            if (isColorTeamMatch(workPackArt)) {

               queryAnd(AtsAttributeTypes.WorkPackageReference, workPackArt.getIdString());
            }
         }
      }
   }
"
578,"you directly use the member variable tcpSocket, but shouldnt it be the parameter socket?","    private void sendToSocket(Socket socket, String cmdString) throws IOException {
        // remove spaces at beginning and end and replace double spaces in
        // string with single space
        byte[] sendBytes = (""A"" + cmdString.trim().replaceAll(""\\s+"", "" "") + ""\n"").getBytes();
        socket.getInputStream().skip(tcpSocket.getInputStream().available());
        socket.getOutputStream().write(sendBytes);
        socket.getOutputStream().flush();
        AstericsErrorHandling.instance.reportInfo(this, ""IRTrans sent data: "" + cmdString);
    }
","    private void sendToSocket(Socket socket, String cmdString) throws IOException {
        // remove spaces at beginning and end and replace double spaces in
        // string with single space
        byte[] sendBytes = (""A"" + cmdString.trim().replaceAll(""\\s+"", "" "") + ""\n"").getBytes();
START         socket.getInputStream().skip(tcpSocket.getInputStream().available()); END 
        socket.getOutputStream().write(sendBytes);
        socket.getOutputStream().flush();
        AstericsErrorHandling.instance.reportInfo(this, ""IRTrans sent data: "" + cmdString);
    }
","    private void sendToSocket(Socket socket, String cmdString) throws IOException {
        // remove spaces at beginning and end and replace double spaces in
        // string with single space
        byte[] sendBytes = (""A"" + cmdString.trim().replaceAll(""\\s+"", "" "") + ""\n"").getBytes();
        socket.getInputStream().skip(socket.getInputStream().available());
        socket.getOutputStream().write(sendBytes);
        socket.getOutputStream().flush();
        AstericsErrorHandling.instance.reportInfo(this, ""IRTrans sent data: "" + cmdString);
    }
"
579,can you explain why this is necessary?,"  public int hashCode()
  {
    return getClass().hashCode();
  }
","  public int hashCode()
  {
START     return getClass().hashCode(); END 
  }
","  public int hashCode()
  {
    return 1;
  }
"
580,i do not think we need to save this line better make it more readable,"    private void reset()
    {
        setId( next = NO_ID );
    }
","    private void reset()
    {
START         setId( next = NO_ID ); END 
    }
","    private void reset()
    {
        next = NO_ID;
        setId( NO_ID );
    }
"
581,"so now you can drop the ""toString()""","    public String getActualDowntime() {
        return (actualDowntime == null) ? ""(N/A)"" : actualDowntime.toString() + ""ms"";
    }
","    public String getActualDowntime() {
START         return (actualDowntime == null) ? ""(N/A)"" : actualDowntime.toString() + ""ms""; END 
    }
","    public String getActualDowntime() {
        return (actualDowntime == null) ? ""(N/A)"" : actualDowntime + ""ms"";
    }
"
582,"@wezell , missing return statement... This is breaking when compiling the code","	String resolveTemplatePath(final Context context, final Writer writer, final RenderParams params,
			final String argument) {
		if (argument.contains(""/"")) {
			
		}else{
		
			return (params.live) ? ""/live/"" + argument + ""."" + EXTENSION : ""/working/"" + argument + ""."" + EXTENSION;
		}
	}
","	String resolveTemplatePath(final Context context, final Writer writer, final RenderParams params,
			final String argument) {
		if (argument.contains(""/"")) {
START 			 END 
		}else{
		
			return (params.live) ? ""/live/"" + argument + ""."" + EXTENSION : ""/working/"" + argument + ""."" + EXTENSION;
		}
	}
","	String resolveTemplatePath(final Context context, final Writer writer, final RenderParams params,
			final String argument) {
		return (params.live) ? ""/live/"" + argument + ""."" + EXTENSION : ""/working/"" + argument + ""."" + EXTENSION;
	}
"
583,andNameEquals is un-needed and probably undesired incase name ever changes,"   public DispoConfig findDispoConfig(DispoProgram program) {
      ArtifactReadable config =
         getQuery().fromBranch(program.getUuid()).andNameEquals(""Program Config"").getResults().getOneOrNull();

      if (config == null) {
         DispoUtil.getDefaultConfig();
      }
      return DispoUtil.configArtToConfigData(new DispoConfigArtifact(config));
   }
","   public DispoConfig findDispoConfig(DispoProgram program) {
START       ArtifactReadable config = END 
         getQuery().fromBranch(program.getUuid()).andNameEquals(""Program Config"").getResults().getOneOrNull();

      if (config == null) {
         DispoUtil.getDefaultConfig();
      }
      return DispoUtil.configArtToConfigData(new DispoConfigArtifact(config));
   }
","   public DispoConfig findDispoConfig(DispoProgram program) {
      ArtifactReadable config =
         getQuery().fromBranch(program.getUuid()).andNameEquals(""Program Config"").getResults().getOneOrNull();

      if (config == null) {
         return DispoUtil.getDefaultConfig();
      }
      return DispoUtil.configArtToConfigData(new DispoConfigArtifact(config));
   }
"
584,"This is wrong, should be `entry.getValue()`","    public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) {
        // Indexing on signatures optimises this type of request
        for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) {
            if (mask.covers(entry.getKey())) {
                if (operations.get(entry.getKey()).contains(name)) {
                    return true;
                }
            }
        }
        return false;
    }
","    public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) {
        // Indexing on signatures optimises this type of request
        for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) {
            if (mask.covers(entry.getKey())) {
START                 if (operations.get(entry.getKey()).contains(name)) { END 
                    return true;
                }
            }
        }
        return false;
    }
","    public boolean hasMatchingOpSig(String name, JavaOperationSigMask mask) {
        // Indexing on signatures optimises this type of request
        for (Entry<JavaOperationSignature, Set<String>> entry : operations.entrySet()) {
            if (mask.covers(entry.getKey())) {
                if (entry.getValue().contains(name)) {
                    return true;
                }
            }
        }
        return false;
    }
"
585,"Make these methods public since they are part of the public API of the class. If we want to restrict access to the class, we would make the class itself package private.","    IonSqlQueryBuilder(TypeManager typeManager)
    {
        this.typeManager = requireNonNull(typeManager, ""typeManager is null"");
    }
","START     IonSqlQueryBuilder(TypeManager typeManager) END 
    {
        this.typeManager = requireNonNull(typeManager, ""typeManager is null"");
    }
","    public IonSqlQueryBuilder(TypeManager typeManager)
    {
        this.typeManager = requireNonNull(typeManager, ""typeManager is null"");
    }
"
586,"Should we abstract this. I mean the way we choose the operation controller. What in case in future, we wish to choose the one which is less loaded compared to others?","  protected OperationController getOperationController() {
    return ocList.get(ThreadLocalRandom.current().nextInt(ocList.size()));
  }
","  protected OperationController getOperationController() {
START     return ocList.get(ThreadLocalRandom.current().nextInt(ocList.size())); END 
  }
","  private OperationController getOperationController() {
    return ocList.get(ThreadLocalRandom.current().nextInt(ocList.size()));
  }
"
587,"So I believe the only way this could be null is if a configuration was saved without the <jdks> entry and then reloaded.
I don't see how that could happen - but there may be some old version of Jenkins that could have done it.

Would probably make sense to modify a `readResolve()` to set it to an empty list and remove this check and the theoretical possibility?","    public List<JDK> getJDKs() {
        if(jdks==null)
            jdks = new ArrayList<JDK>();
        return jdks;
    }
","    public List<JDK> getJDKs() {
START         if(jdks==null) END 
            jdks = new ArrayList<JDK>();
        return jdks;
    }
","    public List<JDK> getJDKs() {
        return jdks;
    }
"
588,same as above: please pass on the original exception so that we retain the stacktrace and message.,"	public boolean addAll(int index, Collection<? extends T> c) {
		Collection<T> uniqueValuesToAdd = getUniqueValues(c);
		if (uniqueValuesToAdd.isEmpty()) {
			return false;
		}

		try {
			return super.addAll(index, uniqueValuesToAdd);
		} catch (IndexOutOfBoundsException ioobException) {
			comparingSet.removeAll(uniqueValuesToAdd);
			throw new IndexOutOfBoundsException();
		}
	}
","	public boolean addAll(int index, Collection<? extends T> c) {
		Collection<T> uniqueValuesToAdd = getUniqueValues(c);
		if (uniqueValuesToAdd.isEmpty()) {
			return false;
		}

		try {
			return super.addAll(index, uniqueValuesToAdd);
		} catch (IndexOutOfBoundsException ioobException) {
			comparingSet.removeAll(uniqueValuesToAdd);
START 			throw new IndexOutOfBoundsException(); END 
		}
	}
","	public boolean addAll(int index, Collection<? extends T> c) {
		Collection<T> uniqueValuesToAdd = getUniqueValues(c);
		if (uniqueValuesToAdd.isEmpty()) {
			return false;
		}

		try {
			return super.addAll(index, uniqueValuesToAdd);
		} catch (IndexOutOfBoundsException ioobException) {
			comparingSet.removeAll(uniqueValuesToAdd);
			throw ioobException;
		}
	}
"
589,why sdk version hardcoded?,"    public Context getContext() {
        if (sdkName == null) {
            sdkName = this.getClass().getPackage().getName();
        }
        return new Context(""Sdk-Name"", sdkName)
            .addData(""Sdk-Version"", SDK_VERSION);
    }
","    public Context getContext() {
        if (sdkName == null) {
            sdkName = this.getClass().getPackage().getName();
        }
        return new Context(""Sdk-Name"", sdkName)
START             .addData(""Sdk-Version"", SDK_VERSION); END 
    }
","    public Context getContext() {
        return new Context(""Sdk-Name"", sdkName)
            .addData(""Sdk-Version"", SDK_VERSION);
    }
"
590,Can this be protected. I assume only the ListModel is using it,"    public void setSelectedDevices(List<StorageDevice> selectedDevices) {
        getStorageDevices().setSelectedItems(selectedDevices);
    }
","START     public void setSelectedDevices(List<StorageDevice> selectedDevices) { END 
        getStorageDevices().setSelectedItems(selectedDevices);
    }
","    protected void setSelectedDevices(List<StorageDevice> selectedDevices) {
        getStorageDevices().setSelectedItems(selectedDevices);
    }
"
591,Why US?,"  private JsonObject toJson(Timer timer, TimeUnit rateUnit, TimeUnit durationUnit) {
    Snapshot snapshot = timer.getSnapshot();
    JsonObject json = new JsonObject();

    // Meter
    populateMetered(json, timer, rateUnit);

    // Snapshot
    double factor = 1.0 / durationUnit.toNanos(1);
    populateSnapshot(json, snapshot, factor);

    // Duration rate
    String duration = durationUnit.toString().toLowerCase(Locale.US);
    json.putString(""durationRate"", duration);

    return json;
  }
","  private JsonObject toJson(Timer timer, TimeUnit rateUnit, TimeUnit durationUnit) {
    Snapshot snapshot = timer.getSnapshot();
    JsonObject json = new JsonObject();

    // Meter
    populateMetered(json, timer, rateUnit);

    // Snapshot
    double factor = 1.0 / durationUnit.toNanos(1);
    populateSnapshot(json, snapshot, factor);

    // Duration rate
START     String duration = durationUnit.toString().toLowerCase(Locale.US); END 
    json.putString(""durationRate"", duration);

    return json;
  }
","  private JsonObject toJson(Timer timer, TimeUnit rateUnit, TimeUnit durationUnit) {
    Snapshot snapshot = timer.getSnapshot();
    JsonObject json = new JsonObject();

    // Meter
    populateMetered(json, timer, rateUnit);

    // Snapshot
    double factor = 1.0 / durationUnit.toNanos(1);
    populateSnapshot(json, snapshot, factor);

    // Duration rate
    String duration = durationUnit.toString().toLowerCase();
    json.putString(""durationRate"", duration);

    return json;
  }
"
592,Should be ResourceDoesNotSupportOperationException,"    protected void delete(LogEntry delegate, String reason, RequestContext context)
            throws ResourceDoesNotSupportOperationException {
        throw new UnsupportedOperationException(""delete not supported"");
    }
","    protected void delete(LogEntry delegate, String reason, RequestContext context)
            throws ResourceDoesNotSupportOperationException {
START         throw new UnsupportedOperationException(""delete not supported""); END 
    }
","	protected void delete(LogEntry delegate, String reason, RequestContext context)
			throws ResourceDoesNotSupportOperationException {
		throw new ResourceDoesNotSupportOperationException();
	}
"
593,Why is this `protected` ? Are you going to detect this option internally by the `@RabbitListener(Handler)` method signature?,"	protected void setConsumerBatchEnabled(boolean consumerBatchEnabled) {
		this.consumerBatchEnabled = consumerBatchEnabled;
	}
","START 	protected void setConsumerBatchEnabled(boolean consumerBatchEnabled) { END 
		this.consumerBatchEnabled = consumerBatchEnabled;
	}
","	public void setConsumerBatchEnabled(boolean consumerBatchEnabled) {
		this.consumerBatchEnabled = consumerBatchEnabled;
	}
"
594,"old code seems to indicate this should be ""level"" not ""toclevel""?

Could be causing failure of getLevel() calls being compared in SectionsFetchTask.processResult?","    public int getLevel() {
        return data.optInt(""toclevel"");
    }
","    public int getLevel() {
START         return data.optInt(""toclevel""); END 
    }
","    public int getLevel() {
        return data.optInt(""toclevel"", 1);
    }
"
595,use getContext() instead of this.getContext() ?,"    private void setPagesRecycler(OnThisDayCard card) {
        if (card.pages() != null) {
            RecyclerAdapter recyclerAdapter = new RecyclerAdapter(card.pages(), card.wiki(), true, (Activity) this.getContext());
            recyclerAdapter.setCallback(new ItemCallback());
            pagesRecycler.setAdapter(recyclerAdapter);
        } else {
            pagesRecycler.setVisibility(GONE);
        }
    }
","    private void setPagesRecycler(OnThisDayCard card) {
        if (card.pages() != null) {
            RecyclerAdapter recyclerAdapter = new RecyclerAdapter(card.pages(), card.wiki(), true, (Activity) START  this.getContext()); END 
            recyclerAdapter.setCallback(new ItemCallback());
            pagesRecycler.setAdapter(recyclerAdapter);
        } else {
            pagesRecycler.setVisibility(GONE);
        }
    }
","    private void setPagesRecycler(OnThisDayCard card) {
        if (card.pages() != null) {
            RecyclerAdapter recyclerAdapter = new RecyclerAdapter(card.pages(), card.wiki(), true, (Activity) getContext());
            recyclerAdapter.setCallback(new ItemCallback());
            pagesRecycler.setAdapter(recyclerAdapter);
        } else {
            pagesRecycler.setVisibility(GONE);
        }
    }
"
596,Add a getExtendedLabelsForVSM(IConfigurationElement) method to avoid duplication,"    public String getExtendedLabelForVSM(String providedShapeURI) {
        for (IConfigurationElement configurationElement : extensions) {
            String identifier = ((ExtensionHandle) configurationElement.getParent()).getSimpleIdentifier();
            if (identifier != null && identifier.equals(providedShapeURI)) {
                return configurationElement.getAttribute(LABEL_ATTRIBUTE) + "" - "" + configurationElement.getNamespaceIdentifier(); //$NON-NLS-1$
            }
        }
        return ""Unknown URI""; //$NON-NLS-1$
    }
","    public String getExtendedLabelForVSM(String providedShapeURI) {
        for (IConfigurationElement configurationElement : extensions) {
            String identifier = ((ExtensionHandle) configurationElement.getParent()).getSimpleIdentifier();
            if (identifier != null && identifier.equals(providedShapeURI)) {
                return START  configurationElement.getAttribute(LABEL_ATTRIBUTE) + "" - "" + configurationElement.getNamespaceIdentifier(); //$NON-NLS-1$ END 
            }
        }
        return ""Unknown URI""; //$NON-NLS-1$
    }
","    public String getExtendedLabelForVSM(String providedShapeURI) {
        for (IConfigurationElement configurationElement : extensions) {
            String identifier = ((ExtensionHandle) configurationElement.getParent()).getSimpleIdentifier();
            if (identifier != null && identifier.equals(providedShapeURI)) {
                return getExtendedLabelForVSM(configurationElement);
            }
        }
        return ""Unknown URI""; //$NON-NLS-1$
    }
"
597,I would not use setCleanIdleConnections as the name of the function without parmeters. Maybe add a parameter.,"    public void stopServer()
    {
        if (server instanceof GrizzlyServer)
        {
            ((GrizzlyServer) server).setCleanIdleConnections();
        }
        server.stop();
    }
","    public void stopServer()
    {
        if (server instanceof GrizzlyServer)
        {
START             ((GrizzlyServer) server).setCleanIdleConnections(); END 
        }
        server.stop();
    }
","    public void stopServer()
    {
        if (server instanceof GrizzlyServer)
        {
            ((GrizzlyServer) server).setCleanIdleConnections(true);
        }
        server.stop();
    }
"
598,"We can make `DestroyProxyMessageTask` implement the Supplier, so that this method will no create a lamda but return `this` instead.","    protected Supplier<Operation> createOperationSupplier() {
        return () -> new DistributedObjectDestroyOperation(parameters.serviceName, parameters.name);
    }
","    protected Supplier<Operation> createOperationSupplier() {
START         return () -> new DistributedObjectDestroyOperation(parameters.serviceName, parameters.name); END 
    }
","    protected Supplier<Operation> createOperationSupplier() {
        return this;
    }
"
599,"So model change listener will be called twice for single modification? I do not like it. 
@monperrus Could you explain why it is good?","	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
		if (type != null) {
			type.setParent(this);
		}
		// even if the setter delegates to getExecutable, it makes sense to create an event
		getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, getExecutable().getType());
		if (getExecutable() != null) {
			getExecutable().setType(type);
		}
		return (C) this;
	}
","	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
		if (type != null) {
			type.setParent(this);
		}
		// even if the setter delegates to getExecutable, it makes sense to create an event
START 		getFactory().getEnvironment().getModelChangeListener().onObjectUpdate(this, TYPE, type, getExecutable().getType()); END 
		if (getExecutable() != null) {
			getExecutable().setType(type);
		}
		return (C) this;
	}
","	public <C extends CtTypedElement> C setType(CtTypeReference<T> type) {
		if (type != null) {
			type.setParent(this);
		}
		if (getExecutable() != null) {
			getExecutable().setType(type);
		}
		return (C) this;
	}
"
600,I do not understand the above two... but for ut it will be hell.,"    public static AuthenticationProfileRepository getInstance() {
        return instance;
    }
","    public static AuthenticationProfileRepository getInstance() {
        return instance;
START     } END 
","    public static AuthenticationProfileRepository getInstance() {
        if (instance == null) {
            synchronized (AuthenticationProfileRepository.class) {
                if (instance == null) {
                    instance = new AuthenticationProfileRepository();
                }
            }
        }
        return instance;
    }
"
601,"```suggestion
```","   public HttpRequest filterKey(HttpRequest request) throws HttpException {
      request = replaceDateHeader(request);
      String signature = calculateSignature(createStringToSign(request));
      request = replaceAuthorizationHeader(request, signature);
	  return request;
   }
","   public HttpRequest filterKey(HttpRequest request) throws HttpException {
      request = replaceDateHeader(request);
      String signature = calculateSignature(createStringToSign(request));
START       request = replaceAuthorizationHeader(request, signature); END 
	  return request;
   }
","   public HttpRequest filterKey(HttpRequest request) throws HttpException {
      request = replaceDateHeader(request);
      String signature = calculateSignature(createStringToSign(request));
      return replaceAuthorizationHeader(request, signature);
   }
"
602,"Again, should just return the value if not null.","    public ScreenshotSize get() {
        if (config.getScreenshotSize() == ScreenshotSize.DOUBLE_SIZE) {
            return ScreenshotSize.DOUBLE_SIZE;
        } else if (config.getScreenshotSize() == ScreenshotSize.NORMAL_SIZE) {
            return ScreenshotSize.NORMAL_SIZE;
        } else if (config.getScreenshotSize() == ScreenshotSize.HALF_SIZE) {
            return ScreenshotSize.HALF_SIZE;
        } else if (config.getScreenshotSize() == ScreenshotSize.QUARTER_SIZE) {
            return ScreenshotSize.QUARTER_SIZE;
        } else {
            return ScreenshotSize.NORMAL_SIZE;
        }
    }
","    public ScreenshotSize get() {
START         if (config.getScreenshotSize() == ScreenshotSize.DOUBLE_SIZE) { END 
            return ScreenshotSize.DOUBLE_SIZE;
        } else if (config.getScreenshotSize() == ScreenshotSize.NORMAL_SIZE) {
            return ScreenshotSize.NORMAL_SIZE;
        } else if (config.getScreenshotSize() == ScreenshotSize.HALF_SIZE) {
            return ScreenshotSize.HALF_SIZE;
        } else if (config.getScreenshotSize() == ScreenshotSize.QUARTER_SIZE) {
            return ScreenshotSize.QUARTER_SIZE;
        } else {
            return ScreenshotSize.NORMAL_SIZE;
        }
    }
","    public ScreenshotSize get() {
        if(config.getScreenshotSize() != null) {
            return config.getScreenshotSize();
        } else {
            return ScreenshotSize.NORMAL_SIZE;
        }
    }
"
603,"Why make this non-final? Given how important this method is for its serialization/internal representation, it's pretty important that it not be overridden.","  public String canonicalID() {
    return canonical;
  }
","START   public String canonicalID() { END 
    return canonical;
  }
","  public final String canonicalID() {
    return canonical;
  }
"
604,close does an implicit flush,"        protected void close() {
            try {
                m_sout.flush();
                m_sout.close();
            } catch (IOException ex) {
            }
        }
","        protected void close() {
            try {
START                 m_sout.flush(); END 
                m_sout.close();
            } catch (IOException ex) {
            }
        }
","        protected void close() {
            try {
                m_sout.close();
            } catch (IOException ex) {
            }
        }
"
605,No need for parentheses.,"    protected boolean isProcessed(ChronicleLogOffsetTracker tracker, long offset) {
        long last = tracker.readLastCommittedOffset();
        return (last > 0) && (last >= offset);
    }
","    protected boolean isProcessed(ChronicleLogOffsetTracker tracker, long offset) {
        long last = tracker.readLastCommittedOffset();
START         return (last > 0) && (last >= offset); END 
    }
","    protected boolean isProcessed(ChronicleLogOffsetTracker tracker, long offset) {
        long last = tracker.readLastCommittedOffset();
        return last > 0 && last >= offset;
    }
"
606,"Please don't create a new list on every call of getDifferences(), but create the list once, e.g., on the first call, and then return the same instance. You might want to use an UnmodifiableEList instead, to fail early, if someone tries to modify it.","			public EList<Diff> getDifferences() {
				return new BasicEList<Diff>(this.diffs);
			}
","			public EList<Diff> getDifferences() {
START 				return new BasicEList<Diff>(this.diffs); END 
			}
","			public EList<Diff> getDifferences() {
				return this.diffs;
			}
"
607,@clevertension Why do we need to expose `IOWorkers.Selector`? Looks completely unnecessary to me.,"    public IOWorkers.Selector getWorkerSelector() {
        return workerSelector;
    }
","START     public IOWorkers.Selector getWorkerSelector() { END 
        return workerSelector;
    }
","    IOWorkers.Selector getWorkerSelector() {
        return workerSelector;
    }
"
608,`super.children().forEach(res::add);` ?,"  public Iterable<Tree> children() {
    List<Tree> result = new ArrayList<>();
    if(openParenToken != null) {
      result.add(openParenToken);
    }
    for (Tree tree : super.children()) {
      result.add(tree);
    }
    if(closeParenToken != null) {
        result.add(closeParenToken);
    }
    return result;
  }
","  public Iterable<Tree> children() {
    List<Tree> result = new ArrayList<>();
    if(openParenToken != null) {
      result.add(openParenToken);
    }
START     for (Tree tree : super.children()) { END 
      result.add(tree);
    }
    if(closeParenToken != null) {
        result.add(closeParenToken);
    }
    return result;
  }
","  public Iterable<Tree> children() {
    List<Tree> result = new ArrayList<>();
    if(openParenToken != null) {
      result.add(openParenToken);
    }
    super.children().forEach(result::add);
    if (closeParenToken != null) {
      result.add(closeParenToken);
    }
    return result;
  }
"
609,`requireNonNull` could be on same line than affectation.,"    public void setName(String name) {
        Objects.requireNonNull(name);
        this.name = name;
    }
","    public void setName(String name) {
        Objects.requireNonNull(name);
START         this.name = name; END 
    }
","    public void setName(String name) {
        this.name = requireNonNull(name);
    }
"
610,I believe it should be `omitNorms() || indexOptions() != IndexOptions.NONE`,"    public Query existsQuery(QueryShardContext context) {
        if (hasDocValues()) {
            return new DocValuesFieldExistsQuery(name());
        } else if (omitNorms()) {
            return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));
        } else {
            return new NormsFieldExistsQuery(name());
        }
    }
","    public Query existsQuery(QueryShardContext context) {
        if (hasDocValues()) {
            return new DocValuesFieldExistsQuery(name());
START         } else if (omitNorms()) { END 
            return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));
        } else {
            return new NormsFieldExistsQuery(name());
        }
    }
","    public Query existsQuery(QueryShardContext context) {
        if (hasDocValues()) {
            return new DocValuesFieldExistsQuery(name());
        } else {
            return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name()));
        }
    }
"
611,This method should be static,"  private void handleYieldExpression(SubscriptionContext ctx, PyYieldExpressionTree yieldExpr) {
    if (yieldExpr.fromKeyword() == null && yieldExpr.expressions().size() == 1) {
      yieldExpr.expressions().forEach(e -> checkExpr(e, ctx, ""yield""));
    }
  }
","START   private void handleYieldExpression(SubscriptionContext ctx, PyYieldExpressionTree yieldExpr) { END 
    if (yieldExpr.fromKeyword() == null && yieldExpr.expressions().size() == 1) {
      yieldExpr.expressions().forEach(e -> checkExpr(e, ctx, ""yield""));
    }
  }
","  private static void handleYieldExpression(SubscriptionContext ctx, PyYieldExpressionTree yieldExpr) {
    if (yieldExpr.fromKeyword() == null && yieldExpr.expressions().size() == 1) {
      yieldExpr.expressions().forEach(e -> checkExpr(e, ctx, ""yield""));
    }
  }
"
612,We do not need to declare that this throws an `LDAPException`.,"	private void importLdif(InMemoryDirectoryServer directoryServer) throws LDAPException {
		if (StringUtils.hasText(this.ldif)) {
			try {

				Resource resource = locateResource();
				try (InputStream inputStream = resource.getInputStream()) {
					directoryServer.importFromLDIF(false, new LDIFReader(inputStream));
				}
			} catch (Exception ex) {
				throw new IllegalStateException(""Unable to load LDIF "" + this.ldif, ex);
			}
		}

	}
","START 	private void importLdif(InMemoryDirectoryServer directoryServer) throws LDAPException { END 
		if (StringUtils.hasText(this.ldif)) {
			try {

				Resource resource = locateResource();
				try (InputStream inputStream = resource.getInputStream()) {
					directoryServer.importFromLDIF(false, new LDIFReader(inputStream));
				}
			} catch (Exception ex) {
				throw new IllegalStateException(""Unable to load LDIF "" + this.ldif, ex);
			}
		}

	}
","	private void importLdif(InMemoryDirectoryServer directoryServer) {
		if (StringUtils.hasText(this.ldif)) {
			try {
				Resource resource = locateResource();
				try (InputStream inputStream = resource.getInputStream()) {
					directoryServer.importFromLDIF(false, new LDIFReader(inputStream));
				}
			} catch (Exception ex) {
				throw new IllegalStateException(""Unable to load LDIF "" + this.ldif, ex);
			}
		}

	}
"
613,I would insist in having all methods that use a `CT*` parameter to be annotated as `@Internal` when they are not private.,"    public XSSFTableColumn(XSSFTable table, CTTableColumn ctTableColumn) {
        this.table = table;
        this.ctTableColumn = ctTableColumn;
    }
","START     public XSSFTableColumn(XSSFTable table, CTTableColumn ctTableColumn) { END 
        this.table = table;
        this.ctTableColumn = ctTableColumn;
    }
","    protected XSSFTableColumn(XSSFTable table, CTTableColumn ctTableColumn) {
        this.table = table;
        this.ctTableColumn = ctTableColumn;
    }
"
614,We'd use `{` and `}` here or just fold the conditional into a single `return` statement.,"  private boolean isDateSelectable(Date date) {
    if (isCheckDayInSelectableCals && !containsDate(selectableCals, date)) return false;
    return dateConfiguredListener == null || dateConfiguredListener.isDateSelectable(date);
  }
","  private boolean isDateSelectable(Date date) {
START     if (isCheckDayInSelectableCals && !containsDate(selectableCals, date)) return false; END 
    return dateConfiguredListener == null || dateConfiguredListener.isDateSelectable(date);
  }
","  private boolean isDateSelectable(Date date) {
    if (isCheckDayInSelectableCals && !containsDate(selectableCals, date)) {
        return false;
    }
    return dateConfiguredListener == null || dateConfiguredListener.isDateSelectable(date);
  }
"
615,make static,"	public void updatePathGroup(List<Variable> variables, IPath node, IPath selection) {
		final int segmentsSelection = selection.segmentCount();
		for (final Variable variable : variables)
			if (variable.getPath().uptoSegment(segmentsSelection).equals(selection.makeAbsolute())) {
				final IPath oldPath = variable.getPath();
				final int count = selection.segmentCount();
				variable.setPath(buildPath(oldPath, node, count));
			}
	}
","START 	public void updatePathGroup(List<Variable> END  variables, IPath node, IPath selection) {
		final int segmentsSelection = selection.segmentCount();
		for (final Variable variable : variables)
			if (variable.getPath().uptoSegment(segmentsSelection).equals(selection.makeAbsolute())) {
				final IPath oldPath = variable.getPath();
				final int count = selection.segmentCount();
				variable.setPath(buildPath(oldPath, node, count));
			}
	}
","	public static void updatePathGroup(List<Variable> variables, IPath node, IPath selection) {
		final int segmentsSelection = selection.segmentCount();
		for (final Variable variable : variables)
			if (variable.getPath().uptoSegment(segmentsSelection).equals(selection.makeAbsolute())) {
				final IPath oldPath = variable.getPath();
				final int count = selection.segmentCount();
				variable.setPath(buildPath(oldPath, node, count));
			}
	}
"
616,is this necessary?,"  private FactorComparator(String factorName, int weight, Comparator<T> comparator){
    this.factorName = factorName;
    this.weight = weight;
    this.comparator = comparator;
    logger.info(""comparator created for "" + this.factorName);
  }
","  private FactorComparator(String factorName, int weight, Comparator<T> comparator){
    this.factorName = factorName;
    this.weight = weight;
    this.comparator = comparator;
START     logger.info(""comparator created for "" + this.factorName); END 
  }
","  private FactorComparator(String factorName, int weight, Comparator<T> comparator){
    this.factorName = factorName;
    this.weight = weight;
    this.comparator = comparator;
  }
"
617,why was this done?,"    public PatternMatcher(TermContext context) {
        this.termContext = context;
        multiSubstitutions = new ArrayList<java.util.Collection<Map<Variable, Term>>>();
    }
","START     public PatternMatcher(TermContext context) { END 
        this.termContext = context;
        multiSubstitutions = new ArrayList<java.util.Collection<Map<Variable, Term>>>();
    }
","    private PatternMatcher(TermContext context) {
        this.termContext = context;
        multiSubstitutions = new ArrayList<Collection<Map<Variable, Term>>>();
    }
"
618,"result = prime * result + getBranchId().hashCode();

can use BranchId's hashCode method directly since branchId is not allowed to be null and it will work whether the id is valid or not","   public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + ((getArtUuid() == null) ? 0 : getArtUuid().hashCode());
      result = prime * result + ((getBranchId().isInvalid()) ? 0 : getBranchId().hashCode());
      return result;
   }
","   public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + ((getArtUuid() == null) ? 0 : getArtUuid().hashCode());
START       result = prime * result + ((getBranchId().isInvalid()) ? 0 : getBranchId().hashCode()); END 
      return result;
   }
","   public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + ((getArtUuid() == null) ? 0 : getArtUuid().hashCode());
      result = prime * result + getBranchId().hashCode();
      return result;
   }
"
619,Can be private,"    protected void setUpGetUnregisteredVmTemplateExpectations(boolean notFound) {
        setUpEntityQueryExpectations(
                QueryType.GetUnregisteredVmTemplate,
                GetUnregisteredEntityQueryParameters.class,
                new String[] { ""StorageDomainId"", ""EntityId"" },
                new Object[] { STORAGE_DOMAIN_ID, TEMPLATE_ID },
                notFound ? null : getEntity(1));
    }
","    START  protected void END  setUpGetUnregisteredVmTemplateExpectations(boolean notFound) {
        setUpEntityQueryExpectations(
                QueryType.GetUnregisteredVmTemplate,
                GetUnregisteredEntityQueryParameters.class,
                new String[] { ""StorageDomainId"", ""EntityId"" },
                new Object[] { STORAGE_DOMAIN_ID, TEMPLATE_ID },
                notFound ? null : getEntity(1));
    }
","    private void setUpGetUnregisteredVmTemplateExpectations(boolean notFound) {
        setUpEntityQueryExpectations(
                QueryType.GetUnregisteredVmTemplate,
                GetUnregisteredEntityQueryParameters.class,
                new String[] { ""StorageDomainId"", ""EntityId"" },
                new Object[] { STORAGE_DOMAIN_ID, TEMPLATE_ID },
                notFound ? null : getEntity(1));
    }
"
620,The whole purpose of FullListAdapter is to abstract the implementation details of querying the device list from the caller - so how about moving the changes that are done in VmDevicesMonitoring to FullListVDSCommand ?,"    public boolean isDomainXmlEnabledForVds(Guid vdsId) {
        return FeatureSupported.isDomainXMLSupported(getVdsManager(vdsId).getCompatibilityVersion());
    }
","START     public boolean isDomainXmlEnabledForVds(Guid vdsId) { END 
        return FeatureSupported.isDomainXMLSupported(getVdsManager(vdsId).getCompatibilityVersion());
    }
","    private boolean isDomainXmlEnabledForVds(Guid vdsId) {
        return FeatureSupported.isDomainXMLSupported(getVdsManager(vdsId).getCompatibilityVersion());
    }
"
621,Please add {} also for `if` blocks with only one statement.,"  public void mousePressed(MouseEvent e) {
    if (e.isPopupTrigger())
      doPop(e);
  }
","  public void mousePressed(MouseEvent e) {
START     if (e.isPopupTrigger()) END 
      doPop(e);
  }
","  public void mousePressed(MouseEvent e) {
    if (e.isPopupTrigger()) {
      doPop(e);
    }
  }
"
622,Use .getSize to see if element is on page,"  public boolean isSuggestionListDisplayed() {
    try {
      waitForElementByElement(searchSuggestions.get(0));
      return searchSuggestions.get(0).isDisplayed();
    } catch (NoSuchElementException|IndexOutOfBoundsException e) {}
    return false;
  }
","  public boolean isSuggestionListDisplayed() {
    try {
START       waitForElementByElement(searchSuggestions.get(0)); END 
      return searchSuggestions.get(0).isDisplayed();
    } catch (NoSuchElementException|IndexOutOfBoundsException e) {}
    return false;
  }
","  public boolean isSuggestionListDisplayed() {
    try {
      if (searchSuggestions.size() > 0) {
        waitForElementByElement(searchSuggestions.get(0));
        return searchSuggestions.get(0).isDisplayed();
      }
    } catch (NoSuchElementException e) {}
    return false;
  }
"
623,"no need to use String.format as there is no parameter.
Either provide directly throw new IllegalArgumentException(""Port must be greater than 0"");
or maybe improve message with somethign like:
throw new IllegalArgumentException(String.format(""Port must be greater than 0 (provided {0})"", port));","    public ConnectionId(final String host, final int port, final String connectionId) {
        Objects.requireNonNull(host);

        if (port <= 0) {
            throw new IllegalArgumentException(String.format(""Port must be greater than 0""));
        }

        this.host = host;
        this.port = port;
        this.connectionId = connectionId;
    }
","    public ConnectionId(final String host, final int port, final String connectionId) {
        Objects.requireNonNull(host);

        if (port <= 0) {
START             throw new IllegalArgumentException(String.format(""Port must be greater than 0"")); END 
        }

        this.host = host;
        this.port = port;
        this.connectionId = connectionId;
    }
","    public ConnectionId(final String host, final int port, final String connectionId) {
        Objects.requireNonNull(host);

        if (port <= 0) {
            throw new IllegalArgumentException(""Port must be greater than 0"");
        }

        this.host = host;
        this.port = port;
        this.connectionId = connectionId;
    }
"
624,use static import.,"  public RecursiveLoggerContextInstantiationException(String message) {
    super(I18nMessageFactory.createStaticMessage(message));
  }
","  public RecursiveLoggerContextInstantiationException(String message) {
START     super(I18nMessageFactory.createStaticMessage(message)); END 
  }
","  public RecursiveLoggerContextInstantiationException(String message) {
    super(createStaticMessage(message));
  }
"
625,why is it public?,"    public Map<String, MetricPlotDTOs> createTaskPlots() {
        sessionId = getSessionIdProvider().getSessionId();

        // check new model
        List<MetricPointEntity> metricDetails = getHibernateTemplate().find(
                ""select m from MetricPointEntity m where m.metricDescription.taskData.sessionId=?"", sessionId);

        if (metricDetails == null || metricDetails.isEmpty()) {
            return oldWay();
        } else {
            return newWay(metricDetails);
        }
    }
","START     public Map<String, MetricPlotDTOs> createTaskPlots() { END 
        sessionId = getSessionIdProvider().getSessionId();

        // check new model
        List<MetricPointEntity> metricDetails = getHibernateTemplate().find(
                ""select m from MetricPointEntity m where m.metricDescription.taskData.sessionId=?"", sessionId);

        if (metricDetails == null || metricDetails.isEmpty()) {
            return oldWay();
        } else {
            return newWay(metricDetails);
        }
    }
","    private Map<String, MetricPlotDTOs> createTaskPlots() {
        // check new model
        List<MetricPointEntity> metricDetails = getHibernateTemplate().find(
                ""select m from MetricPointEntity m where m.metricDescription.taskData.sessionId=?"", sessionId);

        if (metricDetails == null || metricDetails.isEmpty()) {
            return oldWay();
        } else {
            return newWay(metricDetails);
        }
    }
"
626,Why not inline this variable?,"	public void testDeadlock() throws Exception {
		doTest(1000 * 30); // 30 secs almost always locks
		boolean interrupted = Thread.interrupted();
		if (interrupted) {
			fail(""Thread was interrupted at end of test"");
		}
	}
","	public void testDeadlock() throws Exception {
		doTest(1000 * 30); // 30 secs almost always locks
		boolean START  interrupted = END  Thread.interrupted();
		if (interrupted) {
			fail(""Thread was interrupted at end of test"");
		}
	}
","	public void testDeadlock() throws Exception {
		doTest(1000 * 30); // 30 secs almost always locks
		if (Thread.interrupted()) {
			fail(""Thread was interrupted at end of test"");
		}
	}
"
627,"instead of creating a new object every time, it might make more sense to store constants for each predefined granularity string","  public static QueryGranularity fromString(String str)
  {
    String name = str.toUpperCase();
    if(name.equals(""ALL""))
    {
      return QueryGranularity.ALL;
    }
    else if(name.equals(""NONE""))
    {
      return QueryGranularity.NONE;
    }
    else if(CALENDRIC_GRANULARITIES.containsKey(name))
    {
      return new PeriodGranularity(CALENDRIC_GRANULARITIES.get(name), null, null);
    }
    return new DurationGranularity(convertValue(str), 0);
  }
","  public static QueryGranularity fromString(String str)
  {
    String name = str.toUpperCase();
    if(name.equals(""ALL""))
    {
      return QueryGranularity.ALL;
    }
    else if(name.equals(""NONE""))
    {
      return QueryGranularity.NONE;
    }
    else if(CALENDRIC_GRANULARITIES.containsKey(name))
    {
START       return new PeriodGranularity(CALENDRIC_GRANULARITIES.get(name), null, null); END 
    }
    return new DurationGranularity(convertValue(str), 0);
  }
","  public static QueryGranularity fromString(String str)
  {
    String name = str.toUpperCase();
    if(name.equals(""ALL""))
    {
      return QueryGranularity.ALL;
    }
    else if(name.equals(""NONE""))
    {
      return QueryGranularity.NONE;
    }
    else if(CALENDRIC_GRANULARITIES.containsKey(name))
    {
      return CALENDRIC_GRANULARITIES.get(name);
    }
    return new DurationGranularity(convertValue(str), 0);
  }
"
628,style nit: we don't use braces around single line blocks,"		public Object[] getElements(Object element) {
			if (element instanceof Object[]) {
				return (Object[]) element;
			}
			if (element instanceof Collection) {
				return ((Collection) element).toArray();
			}
			return new Object[0];
		}
","		public Object[] getElements(Object element) {
START 			if (element instanceof Object[]) { END 
				return (Object[]) element;
			}
			if (element instanceof Collection) {
				return ((Collection) element).toArray();
			}
			return new Object[0];
		}
","		public Object[] getElements(Object element) {
			if (element instanceof Object[])
				return (Object[]) element;
			if (element instanceof Collection)
				return ((Collection) element).toArray();
			return new Object[0];
		}
"
629,maybe we should create a common utility function to build EventLoopGroups and do not duplicate this kind of code,"    public void setUp() throws Exception {
        super.setUp();
        if (SystemUtils.IS_OS_LINUX) {
            try {
                eventLoopGroup = new EpollEventLoopGroup();
            } catch (Throwable t) {
                LOG.warn(""Could not use Netty Epoll event loop {}"", t.getMessage());
                eventLoopGroup = new NioEventLoopGroup();
            }
        } else {
            eventLoopGroup = new NioEventLoopGroup();
        }

        executor = OrderedSafeExecutor.newBuilder()
                .name(""BKClientOrderedSafeExecutor"")
                .numThreads(2)
                .build();
    }
","    public void setUp() throws Exception {
        super.setUp();
START         if (SystemUtils.IS_OS_LINUX) { END 
            try {
                eventLoopGroup = new EpollEventLoopGroup();
            } catch (Throwable t) {
                LOG.warn(""Could not use Netty Epoll event loop {}"", t.getMessage());
                eventLoopGroup = new NioEventLoopGroup();
            }
        } else {
            eventLoopGroup = new NioEventLoopGroup();
        }

        executor = OrderedSafeExecutor.newBuilder()
                .name(""BKClientOrderedSafeExecutor"")
                .numThreads(2)
                .build();
    }
","    public void setUp() throws Exception {
        super.setUp();
        eventLoopGroup = new NioEventLoopGroup();

        executor = OrderedSafeExecutor.newBuilder()
                .name(""BKClientOrderedSafeExecutor"")
                .numThreads(2)
                .build();
    }
"
630,Don't need the `toString` call.,"    private void readInternal(long position, byte[] buffer, int bufferOffset, int bufferLength)
    {
        try {
            long readStart = System.nanoTime();
            inputStream.readFully(position, buffer, bufferOffset, bufferLength);
            stats.readDataBytesPerSecond(bufferLength, System.nanoTime() - readStart);
        }
        catch (PrestoException e) {
            // just in case there is a Presto wrapper or hook
            throw e;
        }
        catch (Exception e) {
            throw new PrestoException(HIVE_FILESYSTEM_ERROR, format(""Error reading from %s at position %s"", id.toString(), position), e);
        }
    }
","    private void readInternal(long position, byte[] buffer, int bufferOffset, int bufferLength)
    {
        try {
            long readStart = System.nanoTime();
            inputStream.readFully(position, buffer, bufferOffset, bufferLength);
            stats.readDataBytesPerSecond(bufferLength, System.nanoTime() - readStart);
        }
        catch (PrestoException e) {
            // just in case there is a Presto wrapper or hook
            throw e;
        }
        catch (Exception e) {
START             throw new PrestoException(HIVE_FILESYSTEM_ERROR, format(""Error reading from %s at position %s"", id.toString(), position), e); END 
        }
    }
","    private void readInternal(long position, byte[] buffer, int bufferOffset, int bufferLength)
    {
        try {
            long readStart = System.nanoTime();
            inputStream.readFully(position, buffer, bufferOffset, bufferLength);
            stats.readDataBytesPerSecond(bufferLength, System.nanoTime() - readStart);
        }
        catch (PrestoException e) {
            // just in case there is a Presto wrapper or hook
            throw e;
        }
        catch (Exception e) {
            throw new PrestoException(HIVE_FILESYSTEM_ERROR, format(""Error reading from %s at position %s"", id, position), e);
        }
    }
"
631,Don't you prefer to use assertEquals?,"    public void invalidPropertiesFormat() {
        VmDevice device = new VmDevice();
        device.setType(VmDeviceGeneralType.DISK);
        device.setCustomProperties(""bootable"");

        DevicePropertiesUtils utils = mockDevicePropertiesUtils();
        List<ValidationError> errors = utils.validateDeviceProperties(Version.v3_3, device);

        assertFalse(errors.isEmpty());
        assertTrue(errors.get(0).getReason() == ValidationFailureReason.SYNTAX_ERROR);
    }
","    public void invalidPropertiesFormat() {
        VmDevice device = new VmDevice();
        device.setType(VmDeviceGeneralType.DISK);
        device.setCustomProperties(""bootable"");

        DevicePropertiesUtils utils = mockDevicePropertiesUtils();
        List<ValidationError> errors = utils.validateDeviceProperties(Version.v3_3, device);

        assertFalse(errors.isEmpty());
START         assertTrue(errors.get(0).getReason() == ValidationFailureReason.SYNTAX_ERROR); END 
    }
","    public void invalidPropertiesFormat() {
        VmDevice device = new VmDevice();
        device.setType(VmDeviceGeneralType.DISK);
        device.setCustomProperties(""bootable"");

        DevicePropertiesUtils utils = mockDevicePropertiesUtils();
        List<ValidationError> errors = utils.validateDeviceProperties(Version.v3_3, device);

        assertFalse(errors.isEmpty());
        assertEquals(ValidationFailureReason.SYNTAX_ERROR, errors.get(0).getReason());
    }
"
632,"If this is the use of the ""MANDATORY"" constant then you may want to define it as a ""Name"" instead of ""String"":

  privates static final Name MANDATORY = NameParser.parseUsingCase(""Mandatory"");

Then you can compare it easily:

  return expression.getMethod().equals(MANDATORY);","    private boolean isMandatory(MethodExpression expression) {
        return expression.getMethod().getWords().get(0).equals(MANDATORY) ? true : false;
    }
","    private boolean isMandatory(MethodExpression expression) {
START         return expression.getMethod().getWords().get(0).equals(MANDATORY) ? true : false; END 
    }
","    private boolean isMandatory(MethodExpression expression) {
        return expression.getMethod().equals(MANDATORY) ? true : false;
    }
"
633,"Good change making this an instance member, thanks.","		private DeltaVisit next() {
			// If our parent has no more children, discard it.
			if (parent != null && parent.nextChild == null) {
				parent.data = null;
				parent = parent.parent;
			}

			if (nextChild != null)
				return new DeltaVisit(this);

			// If we have no child ourselves, our parent must (if it exists),
			// due to the discard rule above. With no parent, we are done.
			if (parent != null)
				return new DeltaVisit(parent);
			return null;
		}
","START 		private DeltaVisit next() { END 
			// If our parent has no more children, discard it.
			if (parent != null && parent.nextChild == null) {
				parent.data = null;
				parent = parent.parent;
			}

			if (nextChild != null)
				return new DeltaVisit(this);

			// If we have no child ourselves, our parent must (if it exists),
			// due to the discard rule above. With no parent, we are done.
			if (parent != null)
				return new DeltaVisit(parent);
			return null;
		}
","		DeltaVisit next() {
			// If our parent has no more children, discard it.
			if (parent != null && parent.nextChild == null) {
				parent.data = null;
				parent = parent.parent;
			}

			if (nextChild != null)
				return new DeltaVisit(this);

			// If we have no child ourselves, our parent must (if it exists),
			// due to the discard rule above. With no parent, we are done.
			if (parent != null)
				return new DeltaVisit(parent);
			return null;
		}
"
634,"we can do something like:
numOfSkips = ++numOfSkips % MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM;
return numOfSkips == 0;

and remove clearSkipCounter, no?
if this was already properly verified, we can merge this and think about the change above on master-only","        boolean delayNextTimeToRun(Date timeToRunTheVm) {
            this.timeToRunTheVm = timeToRunTheVm;
            return ++numOfSkips < MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM;
        }
","        boolean delayNextTimeToRun(Date timeToRunTheVm) {
            this.timeToRunTheVm = timeToRunTheVm;
START             return ++numOfSkips < MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM; END 
        }
","        boolean delayNextTimeToRun(Date timeToRunTheVm) {
            this.timeToRunTheVm = timeToRunTheVm;
            numOfSkips = ++numOfSkips % MAXIMUM_NUM_OF_SKIPS_BEFORE_AUTO_START_VM;
            return numOfSkips != 0;
        }
"
635,"Of the ""53"" class of errors, I think only ""53300"" might be transient, no?","  protected boolean isTransientException(Throwable e)
  {
    if(e instanceof SQLException) {
      final String sqlState = ((SQLException) e).getSQLState();
      // retry on connection errors and insufficient resources
      // (see http://www.postgresql.org/docs/current/static/errcodes-appendix.html)
      return sqlState.startsWith(""08"") || sqlState.startsWith(""53"");
    }
    return false;
  }
","  protected boolean isTransientException(Throwable e)
  {
    if(e instanceof SQLException) {
      final String sqlState = ((SQLException) e).getSQLState();
      // retry on connection errors and insufficient resources
      // (see http://www.postgresql.org/docs/current/static/errcodes-appendix.html)
START       return sqlState.startsWith(""08"") || sqlState.startsWith(""53""); END 
    }
    return false;
  }
","  protected boolean isTransientException(Throwable e)
  {
    if(e instanceof SQLException) {
      final String sqlState = ((SQLException) e).getSQLState();
      // limited to errors that are likely to be resolved within a few retries
      // retry on connection errors and insufficient resources
      // see http://www.postgresql.org/docs/current/static/errcodes-appendix.html for details
      return sqlState != null && (sqlState.startsWith(""08"") || sqlState.startsWith(""53""));
    }
    return false;
  }
"
636,So you pointed me to this line and what is the problem here ? The problem is that discardAcknowledgedOperations is never called. This was never done in this method anyway.,"  public JupiterActivity generateJupiterActivity(Operation op, User source, SPath editor) {

    // send(op, myMsgs, otherMsgs);
    JupiterActivity jupiterActivity = new JupiterActivity(this.vectorTime, op, source, editor);

    // add(op, myMsgs) to outgoing;
    if (!(op instanceof TimestampOperation)) {
      this.ackJupiterActivityList.add(
          new OperationWrapper(op, this.vectorTime.getLocalOperationCount()));
    }

    // myMsgs = myMsgs + 1;
    this.vectorTime = this.vectorTime.incrementLocalOperationCount();

    return jupiterActivity;
  }
","  public JupiterActivity generateJupiterActivity(Operation op, User source, SPath editor) {

    // send(op, myMsgs, otherMsgs);
    JupiterActivity jupiterActivity = new JupiterActivity(this.vectorTime, op, source, editor);

    // add(op, myMsgs) to outgoing;
START     if (!(op instanceof TimestampOperation)) { END 
      this.ackJupiterActivityList.add(
          new OperationWrapper(op, this.vectorTime.getLocalOperationCount()));
    }

    // myMsgs = myMsgs + 1;
    this.vectorTime = this.vectorTime.incrementLocalOperationCount();

    return jupiterActivity;
  }
","  public JupiterActivity generateJupiterActivity(Operation op, User source, SPath editor) {

    // send(op, myMsgs, otherMsgs);
    JupiterActivity jupiterActivity = new JupiterActivity(this.vectorTime, op, source, editor);

    // add(op, myMsgs) to outgoing;
    this.ackJupiterActivityList.add(
        new OperationWrapper(op, this.vectorTime.getLocalOperationCount()));

    // myMsgs = myMsgs + 1;
    this.vectorTime = this.vectorTime.incrementLocalOperationCount();

    return jupiterActivity;
  }
"
637,"Should it be assignExecutor(1, flow.getExecutionId())? Also how do you know 1 is a non-existent executor?","  public void testAssignExecutorInvalidExecutor() throws Exception {
    final ExecutableFlow flow = TestUtils.createExecutableFlow(""exectest1"", ""exec1"");
    this.executionFlowDao.uploadExecutableFlow(flow);

    assertThatThrownBy(
        () -> this.assignExecutor.assignExecutor(flow.getExecutionId(), 1))
            .isInstanceOf(ExecutorManagerException.class)
            .hasMessageContaining(""non-existent executor"");
  }
","  public void testAssignExecutorInvalidExecutor() throws Exception {
    final ExecutableFlow flow = TestUtils.createExecutableFlow(""exectest1"", ""exec1"");
    this.executionFlowDao.uploadExecutableFlow(flow);

    assertThatThrownBy(
START         () -> this.assignExecutor.assignExecutor(flow.getExecutionId(), 1)) END 
            .isInstanceOf(ExecutorManagerException.class)
            .hasMessageContaining(""non-existent executor"");
  }
","  public void testAssignExecutorInvalidExecutor() throws Exception {
    final ExecutableFlow flow = TestUtils.createExecutableFlow(""exectest1"", ""exec1"");
    this.executionFlowDao.uploadExecutableFlow(flow);

    // Since we haven't inserted any executors, 1 should be non-existent executor id.
    assertThatThrownBy(
        () -> this.assignExecutor.assignExecutor(1, flow.getExecutionId()))
            .isInstanceOf(ExecutorManagerException.class)
            .hasMessageContaining(""non-existent executor"");
  }
"
638,no `Exception` is thrown here,"    private static BackgroundHiveSplitLoader backgroundHiveSplitLoaderOfflinePartitions()
            throws Exception
    {
        ConnectorSession connectorSession = new TestingConnectorSession(
                new HiveSessionProperties(new HiveClientConfig().setMaxSplitSize(new DataSize(1.0, GIGABYTE))).getSessionProperties());

        return new BackgroundHiveSplitLoader(
                SIMPLE_TABLE,
                createPartitionMetadataWithOfflinePartitions(),
                TupleDomain.all(),
                createBucketSplitInfo(Optional.empty(), ImmutableList.of()),
                connectorSession,
                new TestingHdfsEnvironment(),
                new NamenodeStats(),
                new TestingDirectoryLister(TEST_FILES),
                directExecutor(),
                2,
                false);
    }
","    private static BackgroundHiveSplitLoader backgroundHiveSplitLoaderOfflinePartitions()
START             throws Exception END 
    {
        ConnectorSession connectorSession = new TestingConnectorSession(
                new HiveSessionProperties(new HiveClientConfig().setMaxSplitSize(new DataSize(1.0, GIGABYTE))).getSessionProperties());

        return new BackgroundHiveSplitLoader(
                SIMPLE_TABLE,
                createPartitionMetadataWithOfflinePartitions(),
                TupleDomain.all(),
                createBucketSplitInfo(Optional.empty(), ImmutableList.of()),
                connectorSession,
                new TestingHdfsEnvironment(),
                new NamenodeStats(),
                new TestingDirectoryLister(TEST_FILES),
                directExecutor(),
                2,
                false);
    }
","    private static BackgroundHiveSplitLoader backgroundHiveSplitLoaderOfflinePartitions()
    {
        ConnectorSession connectorSession = new TestingConnectorSession(
                new HiveSessionProperties(new HiveClientConfig().setMaxSplitSize(new DataSize(1.0, GIGABYTE))).getSessionProperties());

        return new BackgroundHiveSplitLoader(
                SIMPLE_TABLE,
                createPartitionMetadataWithOfflinePartitions(),
                TupleDomain.all(),
                createBucketSplitInfo(Optional.empty(), ImmutableList.of()),
                connectorSession,
                new TestingHdfsEnvironment(),
                new NamenodeStats(),
                new TestingDirectoryLister(TEST_FILES),
                directExecutor(),
                2,
                false);
    }
"
639,'methodPrefix.toString()' is redundant,"        public String toString() {
            return methodPrefix.toString();
        }
","        public String toString() {
START             return methodPrefix.toString(); END 
        }
","        public String toString() {
            return methodPrefix;
        }
"
640,TCM is an optional Android system service. Check for null.,"    private void setPlatformTextClassifier(@Nullable TextClassifier textClassifier) {
        android.view.textclassifier.TextClassificationManager textClassificationManager =
                (android.view.textclassifier.TextClassificationManager)
                        mContext.getSystemService(Context.TEXT_CLASSIFICATION_SERVICE);

        android.view.textclassifier.TextClassifier platformTextClassifier =
                textClassifier == null
                        ? null
                        : new PlatformTextClassifier(mContext, textClassifier);
        textClassificationManager.setTextClassifier(platformTextClassifier);
    }
","    private void setPlatformTextClassifier(@Nullable TextClassifier textClassifier) {
        android.view.textclassifier.TextClassificationManager START  textClassificationManager = END 
                (android.view.textclassifier.TextClassificationManager)
                        mContext.getSystemService(Context.TEXT_CLASSIFICATION_SERVICE);

        android.view.textclassifier.TextClassifier platformTextClassifier =
                textClassifier == null
                        ? null
                        : new PlatformTextClassifier(mContext, textClassifier);
        textClassificationManager.setTextClassifier(platformTextClassifier);
    }
","    private void setPlatformTextClassifier(@Nullable TextClassifier textClassifier) {
        android.view.textclassifier.TextClassificationManager textClassificationManager =
                (android.view.textclassifier.TextClassificationManager)
                        mContext.getSystemService(Context.TEXT_CLASSIFICATION_SERVICE);
        if (textClassificationManager == null) {
            return;
        }
        android.view.textclassifier.TextClassifier platformTextClassifier =
                textClassifier == null
                        ? null
                        : new PlatformTextClassifier(mContext, textClassifier);
        textClassificationManager.setTextClassifier(platformTextClassifier);
    }
"
641,mime type is mandatory,"	Object loadServiceCapabilities(String serviceUrl) throws IOException {
		HttpGet request = new HttpGet(serviceUrl);
		request.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_SERVICE_CAPABILITIES));
		CloseableHttpResponse httpResponse = execute(request, serviceUrl, ""retrieve help"");
		validateResponse(httpResponse, serviceUrl);
		HttpEntity httpEntity = httpResponse.getEntity();
		ContentType contentType = ContentType.getOrDefault(httpEntity);
		if (""text/plain"".equals(contentType.getMimeType())) {
			return getContent(httpEntity);
		}
		return parseJsonMetadata(httpEntity);
	}
","	Object loadServiceCapabilities(String serviceUrl) throws IOException {
		HttpGet request = new HttpGet(serviceUrl);
		request.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_SERVICE_CAPABILITIES));
		CloseableHttpResponse httpResponse = execute(request, serviceUrl, ""retrieve help"");
		validateResponse(httpResponse, serviceUrl);
		HttpEntity httpEntity = httpResponse.getEntity();
		ContentType contentType = ContentType.getOrDefault(httpEntity);
START 		if (""text/plain"".equals(contentType.getMimeType())) { END 
			return getContent(httpEntity);
		}
		return parseJsonMetadata(httpEntity);
	}
","	Object loadServiceCapabilities(String serviceUrl) throws IOException {
		HttpGet request = new HttpGet(serviceUrl);
		request.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_SERVICE_CAPABILITIES));
		CloseableHttpResponse httpResponse = execute(request, serviceUrl, ""retrieve help"");
		validateResponse(httpResponse, serviceUrl);
		HttpEntity httpEntity = httpResponse.getEntity();
		ContentType contentType = ContentType.getOrDefault(httpEntity);
		if (contentType.getMimeType().equals(""text/plain"")) {
			return getContent(httpEntity);
		}
		return parseJsonMetadata(httpEntity);
	}
"
642,I think it is the boss who should be shut down if (!datagram),"    protected void doStop() {
        log.info(""Stopping Netty server"");
        boss.shutdownGracefully();
        if(!datagram) {
            wrkr.shutdownGracefully();
        }
        try {
            sock.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            log.warn(""Netty server stop interrupted"");
            Thread.currentThread().interrupt();
        }
        log.info(""Netty server stopped"");
        notifyStopped();
    }
","    protected void doStop() {
        log.info(""Stopping Netty server"");
        boss.shutdownGracefully();
        if(!datagram) {
START             wrkr.shutdownGracefully(); END 
        }
        try {
            sock.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            log.warn(""Netty server stop interrupted"");
            Thread.currentThread().interrupt();
        }
        log.info(""Netty server stopped"");
        notifyStopped();
    }
","    protected void doStop() {
        log.info(""Stopping Netty server"");
        wrkr.shutdownGracefully();
        if(!datagram) {
            boss.shutdownGracefully();
        }
        try {
            sock.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            log.warn(""Netty server stop interrupted"");
            Thread.currentThread().interrupt();
        }
        log.info(""Netty server stopped"");
        notifyStopped();
    }
"
643,Maybe pass the layout inflater as a param to the adapter.,"    public ChannelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        LayoutInflater inflater = LayoutInflater.from(parent.getContext());
        return new ChannelViewHolder((ChannelView) inflater.inflate(R.layout.channel_item_layout, parent, false));
    }
","    public ChannelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
START         LayoutInflater inflater = LayoutInflater.from(parent.getContext()); END 
        return new ChannelViewHolder((ChannelView) inflater.inflate(R.layout.channel_item_layout, parent, false));
    }
","    public ChannelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        return new ChannelViewHolder((ChannelView) inflater.inflate(R.layout.channel_item_layout, parent, false));
    }
"
644,"is there a reason that this is displayed everytime? since this is shown when the second project is selected, it will always be there.","	public void onSelectionChanged(int selectedItemCnt) {
		int numberMergeSelections = adapter.numberMergeSelections;
		if (adapter.isMergeSelection && selectedItemCnt >= numberMergeSelections) {
			ToastUtil.showError(getContext(), ""We can only merge "" + numberMergeSelections + "" projects"");
		}

		updateSelectionToggle(actionMode.getMenu().findItem(R.id.toggle_selection));
		actionMode.setTitle(getResources()
				.getQuantityString(getActionModeTitleId(actionModeType), selectedItemCnt, selectedItemCnt));
	}
","	public void onSelectionChanged(int selectedItemCnt) {
		int numberMergeSelections = adapter.numberMergeSelections;
		if (adapter.isMergeSelection && selectedItemCnt >= numberMergeSelections) {
START 			ToastUtil.showError(getContext(), ""We can only merge "" + numberMergeSelections + "" projects""); END 
		}

		updateSelectionToggle(actionMode.getMenu().findItem(R.id.toggle_selection));
		actionMode.setTitle(getResources()
				.getQuantityString(getActionModeTitleId(actionModeType), selectedItemCnt, selectedItemCnt));
	}
","	public void onSelectionChanged(int selectedItemCnt) {
		updateSelectionToggle(actionMode.getMenu().findItem(R.id.toggle_selection));
		actionMode.setTitle(getResources()
				.getQuantityString(getActionModeTitleId(actionModeType), selectedItemCnt, selectedItemCnt));
	}
"
645,"The method will grow (i once already wanted to add something here), so what about putting this in a more lengthy but more readable way? (Note, I also changed TopNNode's condition)

```
if (planNode instanceof JoinNode) {
    return true;
}

if (planNode instanceof AggregationNode) {
    return true; // here you could differentiate between partial/...
}

if (planNode instanceof TopNNode) {
    return ((TopNNode) planNode).getStep() != TopNNode.Step.FINAL;
}

return false;
```","    private boolean shouldBeDistributed(PlanNode planNode)
    {
        return planNode instanceof AggregationNode ||
                planNode instanceof JoinNode ||
                (planNode instanceof TopNNode && ((TopNNode) planNode).getStep().equals(TopNNode.Step.PARTIAL));
    }
","    private boolean shouldBeDistributed(PlanNode planNode)
    {
        return planNode instanceof AggregationNode ||
                planNode instanceof JoinNode ||
START                 (planNode instanceof TopNNode && ((TopNNode) planNode).getStep().equals(TopNNode.Step.PARTIAL)); END 
    }
","    private boolean shouldBeDistributed(PlanNode planNode)
    {
        if (planNode instanceof JoinNode) {
            return true;
        }
        if (planNode instanceof AggregationNode) {
            // TODO: differentiate aggregation with empty grouping set
            return true;
        }
        if (planNode instanceof TopNNode) {
            return ((TopNNode) planNode).getStep() == TopNNode.Step.PARTIAL;
        }
        return false;
    }
"
646,"```suggestion
        assertNotNull(response);
```","    public void testConcurrency() {
        final ServerTemplate serverTemplate = templateStorage.load(serverTemplateId);
        marshal(""application/xml"", serverTemplate);

        Thread disconnect = new Thread(() -> disconnect());
        disconnect.start();

        String response = marshal(""application/xml"", serverTemplate);
        LOGGER.info(response);
    }
","    public void testConcurrency() {
        final ServerTemplate serverTemplate = templateStorage.load(serverTemplateId);
        marshal(""application/xml"", serverTemplate);

        Thread disconnect = new Thread(() -> disconnect());
        disconnect.start();

        String response = marshal(""application/xml"", serverTemplate);
START         LOGGER.info(response); END 
    }
","    public void testConcurrency() {
        final ServerTemplate serverTemplate = templateStorage.load(serverTemplateId);
        marshal(""application/xml"", serverTemplate);

        Thread disconnect = new Thread(() -> disconnect());
        disconnect.start();

        String response = marshal(""application/xml"", serverTemplate);
        assertNotNull(response);
    }
"
647,"```suggestion
            builder.append(Integer.toString(node.getValue()));
```

Cheaper than going through `String.format`","        protected Void visitIntegerLiteral(IntegerLiteral node, Integer indent) {
            builder.append(String.format(Locale.ENGLISH, ""%d"", node.getValue()));
            return null;
        }
","        protected Void visitIntegerLiteral(IntegerLiteral node, Integer indent) {
START             builder.append(String.format(Locale.ENGLISH, ""%d"", node.getValue())); END 
            return null;
        }
","        protected Void visitIntegerLiteral(IntegerLiteral node, Integer indent) {
            builder.append(node.getValue());
            return null;
        }
"
648,"This is essentially one line of code, I'd prefer to inline this.","	private List<GerritQueryResult> executeQueryRest(String query) throws GerritException {
		List<GerritQueryResult> results = null;
		results = client.executeQueryRest(new NullProgressMonitor(), query);
		return results;
	}
","START 	private List<GerritQueryResult> executeQueryRest(String query) throws GerritException { END 
		List<GerritQueryResult> results = null;
		results = client.executeQueryRest(new NullProgressMonitor(), query);
		return results;
	}
","	private List<GerritQueryResult> executeQueryRest(String query) throws GerritException {
		return client.executeQueryRest(new NullProgressMonitor(), query);
	}
"
649,"to avoid redundant pattern check : 
```suggestion
    this(query, queryType, null);
```","  public QueryWrapper(@JsonProperty(""query"") String query, @JsonProperty(""queryType"") String queryType) {
    this(query, queryType, """");
  }
","  public QueryWrapper(@JsonProperty(""query"") String query, @JsonProperty(""queryType"") String queryType) {
START     this(query, queryType, """"); END 
  }
","  public QueryWrapper(@JsonProperty(""query"") String query, @JsonProperty(""queryType"") String queryType) {
    this(query, queryType, null);
  }
"
650,Why not `return ImmutableList.of(compactSegments);` instead?,"  private List<CoordinatorDuty> makeCompactSegmentsDuty()
  {
    List<CoordinatorDuty> duties = new ArrayList<>();
    duties.add(compactSegments);
    return ImmutableList.copyOf(duties);
  }
","  private List<CoordinatorDuty> makeCompactSegmentsDuty()
  {
START     List<CoordinatorDuty> duties = new ArrayList<>();
    duties.add(compactSegments);
    return ImmutableList.copyOf(duties); END 
  }
","  private List<CoordinatorDuty> makeCompactSegmentsDuty()
  {
    return ImmutableList.of(compactSegments);
  }
"
651,"The ""standard"" jclouds pattern would be `checkNotNull(networks, ""networks"")`, but in this case it's not doing the expected thing since a varargs argument cannot be `null`, it will be an empty array instead.

If we want to enforce this check, it probably should be:

```
checkArgument(networks.length > 0, ""networks should not be empty"");
return networks(ImmutableSet.copyOf(networks));
```

but since `networks(Iterable<String> networks)` already checks I don't think we need the check here.","   public CreateServerOptions networks(String... networks) {
      return networks(ImmutableSet.copyOf(checkNotNull(networks, ""network should not be empty"")));
   }
","   public CreateServerOptions networks(String... networks) {
START       return networks(ImmutableSet.copyOf(checkNotNull(networks, ""network should not be empty""))); END 
   }
","   public CreateServerOptions networks(String... networks) {
      return networks(ImmutableSet.copyOf(networks));
   }
"
652,Style-nit: We don't put () around ?: in a return.,"	private static AbbreviatedObjectId id(DiffEntry de) {
		return (de.changeType == ChangeType.DELETE ? de.oldId : de.newId);
	}
","	private static AbbreviatedObjectId id(DiffEntry de) {
START 		return (de.changeType == ChangeType.DELETE ? de.oldId : de.newId); END 
	}
","	private static AbbreviatedObjectId id(DiffEntry de) {
		return de.changeType == ChangeType.DELETE ? de.oldId : de.newId;
	}
"
653,private,"        protected VariableReferenceExpression getVariableReference(RowExpression expression)
        {
            if (expression instanceof VariableReferenceExpression) {
                return ((VariableReferenceExpression) expression);
            }
            else {
                throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), ""Expected a variable reference but got "" + expression);
            }
        }
","        protected VariableReferenceExpression getVariableReference(RowExpression expression)
        {
            if (expression instanceof VariableReferenceExpression) {
                return ((VariableReferenceExpression) expression);
            }
            else {
START                 throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), ""Expected a variable reference but got "" + expression); END 
            }
        }
","        protected VariableReferenceExpression getVariableReference(RowExpression expression)
        {
            if (expression instanceof VariableReferenceExpression) {
                return ((VariableReferenceExpression) expression);
            }
            throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), ""Expected a variable reference but got "" + expression);
        }
"
654,it could be simpler `return this == LOCAL`,"   public boolean isLocalOnly() {
      switch (this) {
         case LOCAL:
            return true;
         default:
            return false;
      }
   }
","   public boolean isLocalOnly() {
START       switch (this) { END 
         case LOCAL:
            return true;
         default:
            return false;
      }
   }
","   public boolean isLocalOnly() {
      return this == LOCAL;
   }
"
655,Done,"    protected void findUsers(String searchString, AsyncQuery query) {
        Frontend.getInstance()
                .runQuery(VdcQueryType.Search,
                        new DirectorySearchParameters(""ADUSER@"" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + "": "" + searchString, SearchType.DirectoryUser, (String) getNamespace().getSelectedItem()), query); //$NON-NLS-1$ //$NON-NLS-2$
    }
","    protected void findUsers(String searchString, AsyncQuery query) {
        Frontend.getInstance()
                .runQuery(VdcQueryType.Search,
START                         new DirectorySearchParameters(""ADUSER@"" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + "": "" + searchString, SearchType.DirectoryUser, (String) getNamespace().getSelectedItem()), query); //$NON-NLS-1$ //$NON-NLS-2$ END 
    }
","    protected void findUsers(String searchString, AsyncQuery query) {
        Frontend.getInstance()
                .runQuery(VdcQueryType.Search,
                        new DirectorySearchParameters(""ADUSER@"" + ((ProfileEntry) getProfile().getSelectedItem()).getAuthz() + "": "" + searchString, SearchType.DirectoryUser, getNamespace().getSelectedItem()), query); //$NON-NLS-1$ //$NON-NLS-2$
    }
"
656,"if it's v2 older hosts won't work since they use HEAD, no?","    public String getImageUrl(String id) {
        return getProvider().getUrl() + API_VERSION  + ""/images/"" + id + ""/file"";
    }
","    public String getImageUrl(String id) {
        return getProvider().getUrl() + API_VERSION  + ""/images/"" + id + START  ""/file""; END 
    }
","    public String getImageUrl(String id) {
        return getProvider().getUrl() + API_VERSION  + ""/images/"" + id;
    }
"
657,I recommend using Collections.emptyMap() instead,"    public User(@NonNull String username, @NonNull String password) {
        this(username, password, new HashMap<String, Integer>(), null);
    }
","    public User(@NonNull String username, @NonNull String password) {
        this(username, password, START  new HashMap<String, Integer>(), null); END 
    }
","    public User(@NonNull String username, @NonNull String password) {
        this(username, password, null, null);
    }
"
658,"no... this can be relative as well...

see: frontend/webadmin/modules/uicommonweb/src/main/java/org/ovirt/engine/ui/uicommonweb/ReportInit.java","    public final String consoleClientResourcesUrl() {
        String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL);
        boolean isAbsolute = url.contains(""://"");

        return isAbsolute
                 ? url
                 : Window.Location.getProtocol() + ""//"" + Window.Location.getHost() + //$NON-NLS-1$
                    ""/"" + BaseContextPathData.getInstance().getRelativePath() + url; //$NON-NLS-1$
    }
","    public final String consoleClientResourcesUrl() {
        String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL);
        boolean isAbsolute = url.contains(""://"");

        return isAbsolute
                 ? url
                 : Window.Location.getProtocol() + ""//"" + Window.Location.getHost() + //$NON-NLS-1$
START                     ""/"" + BaseContextPathData.getInstance().getRelativePath() + url; //$NON-NLS-1$ END 
    }
","    public final String consoleClientResourcesUrl() {
        String url = getString(DynamicMessageKey.CONSOLE_CLIENT_RESOURCES_URL);
        boolean isAbsolute = url.contains(""://"");

        return isAbsolute
                 ? url
                 : ""/"" + BaseContextPathData.getInstance().getRelativePath() + url; //$NON-NLS-1$
    }
"
659,don't need this. Just refer to entry.getName() in both places,"  private boolean isFileEntryPackageable(ZipEntry entry) {
    String entryName = entry.getName();
    return ApkBuilder.checkFileForPackaging(entry.getName()) && isValidMetaInfEntry(entryName);
  }
","  private boolean isFileEntryPackageable(ZipEntry entry) {
START     String entryName = entry.getName(); END 
    return ApkBuilder.checkFileForPackaging(entry.getName()) && isValidMetaInfEntry(entryName);
  }
","  private boolean isFileEntryPackageable(ZipEntry entry) {
    return ApkBuilder.checkFileForPackaging(entry.getName()) && isValidMetaInfEntry(entry.getName());
  }
"
660,I'd just assert that it contains the created VM.,"   public void testList() {
      List<VirtualMachine> list = api().list();
      for (VirtualMachine machine : list) {
         assertTrue(!machine.name().isEmpty());
      }
   }
","   public void testList() {
      List<VirtualMachine> list = api().list();
START       for (VirtualMachine machine : list) { END 
         assertTrue(!machine.name().isEmpty());
      }
   }
","   public void testList() {
      List<VirtualMachine> list = api().list();
      VirtualMachine vm = api().get(getName());
      assertTrue(list.contains(vm));
   }
"
661,package-private?,"    void addLayer(String id, StyleLayer layer) {
        layersById.put(id, layer);
    }
","START     void addLayer(String id, StyleLayer layer) { END 
        layersById.put(id, layer);
    }
","    public void addLayer(String id, StyleLayer layer) {
        layersById.put(id, layer);
    }
"
662,idem,"    public void setSelection(ITimeGraphEntry trace) {
        /* if there is a pending selection, ignore this one */
        synchronized (fListenerNotifierLock) {
            if (fListenerNotifier != null && fListenerNotifier.hasSelectionChanged()) {
                return;
            }
        }
        fSelectedEntry = trace;
        fTimeGraphCtrl.selectItem(trace, false);
        adjustVerticalScrollBar();
    }
","    public void setSelection(ITimeGraphEntry trace) {
        /* if there is a pending selection, ignore this one */
        synchronized (fListenerNotifierLock) {
START             if (fListenerNotifier != null && fListenerNotifier.hasSelectionChanged()) { END 
                return;
            }
        }
        fSelectedEntry = trace;
        fTimeGraphCtrl.selectItem(trace, false);
        adjustVerticalScrollBar();
    }
","    public void setSelection(ITimeGraphEntry trace) {
        /* if there is a pending selection, ignore this one */
        if (fListenerNotifier != null && fListenerNotifier.hasSelectionChanged()) {
            return;
        }
        fSelectedEntry = trace;
        fTimeGraphCtrl.selectItem(trace, false);
        adjustVerticalScrollBar();
    }
"
663,"Why not use the constructor right away, i.e. without reflection?","    private ClassFile newClassFile(String name, int accessFlags, String superclass, String... interfaces) {
        try {
            return SecurityActions.getConstructor(ClassFile.class, String.class, int.class, String.class, ClassLoader.class, Arrays2.EMPTY_STRING_ARRAY.getClass())
                .newInstance(name, accessFlags, superclass, classLoader, interfaces);
        } catch (Exception e) {
            throw BeanLogger.LOG.unableToCreateClassFile(name, e.getCause());
        }
    }
","    private ClassFile newClassFile(String name, int accessFlags, String superclass, String... interfaces) {
        try {
START             return SecurityActions.getConstructor(ClassFile.class, String.class, int.class, String.class, ClassLoader.class, Arrays2.EMPTY_STRING_ARRAY.getClass()) END 
                .newInstance(name, accessFlags, superclass, classLoader, interfaces);
        } catch (Exception e) {
            throw BeanLogger.LOG.unableToCreateClassFile(name, e.getCause());
        }
    }
","    private ClassFile newClassFile(String name, int accessFlags, String superclass, String... interfaces) {
        try {
            return new ClassFile(name, accessFlags, superclass, classLoader, interfaces);
        } catch (Exception e) {
            throw BeanLogger.LOG.unableToCreateClassFile(name, e.getCause());
        }
    }
"
664,We can change the return type of getLocalClassLoader only in the implementation to avoid the cast.,"    public boolean addListener(String type, long id, ClassLoaderListener classLoaderListener) {
        final VirtualClassLoader localClassLoader = ((VirtualClassLoader) getLocalClassLoader(type, id));
        return localClassLoader.addListener(classLoaderListener);
    }
","    public boolean addListener(String type, long id, ClassLoaderListener classLoaderListener) {
START         final VirtualClassLoader localClassLoader = ((VirtualClassLoader) getLocalClassLoader(type, id)); END 
        return localClassLoader.addListener(classLoaderListener);
    }
","    public boolean addListener(String type, long id, ClassLoaderListener classLoaderListener) {
        final VirtualClassLoader localClassLoader = getLocalClassLoader(type, id);
        return localClassLoader.addListener(classLoaderListener);
    }
"
665,"JDT uses compact assignement, e.g. i= 3;","	public static final void setPreferenceNodeId (String id) {
		if (fgPreferenceNodeId == null) {
			fgPreferenceNodeId = id;
		}
	}
","	public static final void setPreferenceNodeId (String id) {
		if (fgPreferenceNodeId == null) {
START 			fgPreferenceNodeId = END  id;
		}
	}
","	public static final boolean setPreferenceNodeId (String id) {
		if (fgPreferenceNodeId == null || id == null) {
			fgPreferenceNodeId= id;
			return true;
		}

		return false;
	}
"
666,Please remove this. This is probably due to an incorrect /etc/hosts file in your test environment,"  private void init() {
    // get the localhost.
    try {
      hostname = InetAddress.getLocalHost().getHostName();
      hostname = ""localhost"";
    } catch (UnknownHostException e) {
      logger.warn(""Error getting the value of localhost. "" +
          ""Proceeding with 'localhost'."", e);
    }
  }
","  private void init() {
    // get the localhost.
    try {
      hostname = InetAddress.getLocalHost().getHostName();
START       hostname = ""localhost""; END 
    } catch (UnknownHostException e) {
      logger.warn(""Error getting the value of localhost. "" +
          ""Proceeding with 'localhost'."", e);
    }
  }
","  private void init() {
    // get the localhost.
    try {
      hostname = InetAddress.getLocalHost().getHostName();
    } catch (UnknownHostException e) {
      logger.warn(""Error getting the value of localhost. "" +
          ""Proceeding with 'localhost'."", e);
    }
  }
"
667,Make it package private by removing the `protected` modifier.,"   protected OSImageToImage(JustProvider provider) {
      this.provider = provider;
   }
","START    protected OSImageToImage(JustProvider provider) { END 
      this.provider = provider;
   }
","   OSImageToImage(JustProvider provider) {
      this.provider = provider;
   }
"
668,"return immediately, no need to store it in a local var","	private Optional<Cookie> findCookieWithName(String cookieName, HttpClient httpClient) {
		Optional<Cookie> cookie = Arrays.stream(httpClient.getState().getCookies())
				.filter(c -> cookieName.equals(c.getName()))
				.findFirst();
		return cookie;
	}
","	private Optional<Cookie> findCookieWithName(String cookieName, HttpClient httpClient) {
START 		Optional<Cookie> cookie = END  Arrays.stream(httpClient.getState().getCookies())
				.filter(c -> cookieName.equals(c.getName()))
				.findFirst();
		return cookie;
	}
","	private Optional<Cookie> findCookieWithName(String cookieName, HttpClient httpClient) {
		return Arrays.stream(httpClient.getState().getCookies())
				.filter(c -> cookieName.equals(c.getName()))
				.findFirst();
	}
"
669,"This class is effectively a provider. Instead of doing the export directly, we should bind the JMX export when we bind IO pool and let the export happen the normal way.","        public void destroy()
        {
            // clients must be destroyed before the pools or
            // you will create a several second busy wait loop
            for (JettyHttpClient client : clients) {
                client.close();
            }
            if (pool != null) {
                pool.close();
                pool = null;
                if(injector.getExistingBinding(Key.get(MBeanExporter.class)) != null) {
                    injector.getInstance(MBeanExporter.class)
                            .unexport(generatedNameOf(QueuedThreadPoolMBean.class) + ""_"" + name);
                }
            }
            destroyed.set(true);
        }
","        public void destroy()
        {
            // clients must be destroyed before the pools or
            // you will create a several second busy wait loop
            for (JettyHttpClient client : clients) {
                client.close();
            }
            if (pool != null) {
                pool.close();
                pool = null;
START                 if(injector.getExistingBinding(Key.get(MBeanExporter.class)) != null) { END 
                    injector.getInstance(MBeanExporter.class)
                            .unexport(generatedNameOf(QueuedThreadPoolMBean.class) + ""_"" + name);
                }
            }
            destroyed.set(true);
        }
","        public void destroy()
        {
            // clients must be destroyed before the pools or
            // you will create a several second busy wait loop
            for (JettyHttpClient client : clients) {
                client.close();
            }
            if (pool != null) {
                pool.close();
                pool = null;
            }
            destroyed.set(true);
        }
"
670,"you could do the difference and return in inside the if, and save 2 checks.","    private Set<String> expandRegionalChannelUris(String channelUri) {
        Set<String> expandedUris = null;
        if (BBC1_TXLOG_CHANNEL_URIS.contains(channelUri)) {
            expandedUris = BBC1_TXLOG_CHANNEL_URIS;
        }
        if (BBC2_TXLOG_CHANNEL_URIS.contains(channelUri)) {
            expandedUris = BBC2_TXLOG_CHANNEL_URIS;
        }
        return expandedUris == null ? null : Sets.difference(expandedUris, ImmutableSet.of(channelUri));
    }
","    private Set<String> expandRegionalChannelUris(String channelUri) {
        Set<String> expandedUris = null;
        if (BBC1_TXLOG_CHANNEL_URIS.contains(channelUri)) {
            expandedUris = BBC1_TXLOG_CHANNEL_URIS;
        }
        if (BBC2_TXLOG_CHANNEL_URIS.contains(channelUri)) {
            expandedUris = BBC2_TXLOG_CHANNEL_URIS;
        }
START         return expandedUris == null ? null : Sets.difference(expandedUris, ImmutableSet.of(channelUri)); END 
    }
","    private Set<String> expandRegionalChannelUris(String channelUri) {
        if (BBC1_TXLOG_CHANNEL_URIS.contains(channelUri)) {
            return Sets.difference(BBC1_TXLOG_CHANNEL_URIS, ImmutableSet.of(channelUri));
        } else if (BBC2_TXLOG_CHANNEL_URIS.contains(channelUri)) {
            return Sets.difference(BBC2_TXLOG_CHANNEL_URIS, ImmutableSet.of(channelUri));
        }
        return null;
    }
"
671,"Should ""planner.enable_hashagg"" be set to **false** ?  ""planner.enable_streamagg"" defaults to **true** anyway.","  public void testMultipleBatchesLateral_WithStreamingAgg() throws Exception {
    String sql = ""SELECT t2.maxprice FROM (SELECT customer.c_orders AS c_orders FROM ""
        + ""dfs.`lateraljoin/multipleFiles/` customer) t1, LATERAL (SELECT CAST(MAX(t.ord.o_totalprice)""
        + "" AS int) AS maxprice FROM UNNEST(t1.c_orders) t(ord) GROUP BY t.ord.o_orderstatus) t2"";

    testBuilder()
        .optionSettingQueriesForTestQuery(""alter session set `%s` = true"",
            PlannerSettings.STREAMAGG.getOptionName())
        .sqlQuery(sql)
        .unOrdered()
        .baselineColumns(""maxprice"")
        .baselineValues(367190)
        .baselineValues(316347)
        .baselineValues(146610)
        .baselineValues(306996)
        .baselineValues(235695)
        .baselineValues(177819)
        .build().run();
  }
","  public void testMultipleBatchesLateral_WithStreamingAgg() throws Exception {
    String sql = ""SELECT t2.maxprice FROM (SELECT customer.c_orders AS c_orders FROM ""
        + ""dfs.`lateraljoin/multipleFiles/` customer) t1, LATERAL (SELECT CAST(MAX(t.ord.o_totalprice)""
        + "" AS int) AS maxprice FROM UNNEST(t1.c_orders) t(ord) GROUP BY t.ord.o_orderstatus) t2"";

    testBuilder()
        .optionSettingQueriesForTestQuery(""alter session set `%s` = true"",
START             PlannerSettings.STREAMAGG.getOptionName()) END 
        .sqlQuery(sql)
        .unOrdered()
        .baselineColumns(""maxprice"")
        .baselineValues(367190)
        .baselineValues(316347)
        .baselineValues(146610)
        .baselineValues(306996)
        .baselineValues(235695)
        .baselineValues(177819)
        .build().run();
  }
","  public void testMultipleBatchesLateral_WithStreamingAgg() throws Exception {
    String sql = ""SELECT t2.maxprice FROM (SELECT customer.c_orders AS c_orders FROM ""
        + ""dfs.`lateraljoin/multipleFiles/` customer) t1, LATERAL (SELECT CAST(MAX(t.ord.o_totalprice)""
        + "" AS int) AS maxprice FROM UNNEST(t1.c_orders) t(ord) GROUP BY t.ord.o_orderstatus) t2"";

    testBuilder()
        .sqlQuery(sql)
        .unOrdered()
        .baselineColumns(""maxprice"")
        .baselineValues(367190)
        .baselineValues(316347)
        .baselineValues(146610)
        .baselineValues(306996)
        .baselineValues(235695)
        .baselineValues(177819)
        .build().run();
  }
"
672,"This might throw IllegalArgumentException in case `value` doesn't match any enum constant.

It's much easier to compare `value` to name() of enum constants:

 for (GlusterStatus status : values) {
   if (status.name().equals(value)) {
     return true;
   }
 }
 return false;","    public boolean isType(String value) {
        GlusterStatus volStatus = GlusterStatus.valueOf(value);
        for (GlusterStatus status : values) {
            if (status.equals(volStatus)) {
                return true;
            }
        }
        return false;
    }
","    public boolean isType(String value) {
        GlusterStatus volStatus = START  GlusterStatus.valueOf(value); END 
        for (GlusterStatus status : values) {
            if (status.equals(volStatus)) {
                return true;
            }
        }
        return false;
    }
","    public boolean isType(String value) {
        for (GlusterStatus status : values) {
            if (status.name().equals(value)) {
                return true;
            }
        }
        return false;
    }
"
673,`ctx.close()`,"    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.channel().close();
    }
","    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
START         ctx.channel().close(); END 
    }
","    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
"
674,remove public,"        public CloseNoOpServerProtocolHandler(String websocketPath) {
            super(websocketPath, null, false);
        }
","START         public CloseNoOpServerProtocolHandler(String websocketPath) { END 
            super(websocketPath, null, false);
        }
","        CloseNoOpServerProtocolHandler(String websocketPath) {
            super(websocketPath, null, false);
        }
"
675,"Since you are forcing the orientation, it might be a good idea to use the `super.setOrientation()` instead, override the `setOrientation()` method and only print a log or throw an exception if someone tries to mess with it","    public MessageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        setOrientation(VERTICAL);
    }
","    public MessageView(Context context, AttributeSet attrs) {
        super(context, attrs);
START         setOrientation(VERTICAL); END 
    }
","    public MessageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        super.setOrientation(VERTICAL);
    }
"
676,Shouldn't it be a part of `shape#setUUID` method?,"    public Canvas addShapeIntoView(final Shape shape) {
        if (shape.getUUID() == null) {
            shape.setUUID(UUID.uuid());
        }
        shape.getShapeView().setUUID(shape.getUUID());
        getView().add(shape.getShapeView());
        return this;
    }
","    public Canvas addShapeIntoView(final Shape shape) {
        if (shape.getUUID() == null) {
            shape.setUUID(UUID.uuid());
        }
START         shape.getShapeView().setUUID(shape.getUUID()); END 
        getView().add(shape.getShapeView());
        return this;
    }
","    public Canvas addShapeIntoView(final Shape shape) {
        if (shape.getUUID() == null) {
            shape.setUUID(UUID.uuid());
        }
        getView().add(shape.getShapeView());
        return this;
    }
"
677,You don't need to give this string (even as other similar do) since it's the default message for getRequiredParam(key).,"    public boolean getRequiredParamBoolean(final String key) throws ActionParamsException {
        final String errMsg = ""Required parameter '"" + key + ""' missing!"";
        final String val = getRequiredParam(key, errMsg);

        try {
            return Boolean.parseBoolean(val);
        } catch (Exception e) {
            throw new ActionParamsException(errMsg);
        }
    }
","    public boolean getRequiredParamBoolean(final String key) throws ActionParamsException {
START         final String errMsg = ""Required parameter '"" + key + ""' missing!""; END 
        final String val = getRequiredParam(key, errMsg);

        try {
            return Boolean.parseBoolean(val);
        } catch (Exception e) {
            throw new ActionParamsException(errMsg);
        }
    }
","    public boolean getRequiredParamBoolean(final String key) throws ActionParamsException {
        final String val = getRequiredParam(key);

        try {
            return Boolean.parseBoolean(val);
        } catch (Exception e) {
            throw new ActionParamsException(e.getMessage());
        }
    }
"
678,In the `@ReceiveEvent` annotation and in the `@RegisterSystem` annotation you can specify if a event handler / all event handlers of that class are for a server or client. So you don't need to check the mode of networkSystem.,"    public void onPingFromClient(PingFromClientEvent event, EntityRef entity){
        if (networkSystem.getMode().isServer()) {
            Instant end = Instant.now();
            endMap.put(entity, end);
            updatePing(entity);
        }
    }
","    public void onPingFromClient(PingFromClientEvent event, EntityRef entity){
START         if (networkSystem.getMode().isServer()) { END 
            Instant end = Instant.now();
            endMap.put(entity, end);
            updatePing(entity);
        }
    }
","    public void onPingFromClient(PingFromClientEvent event, EntityRef entity) {
        Instant end = Instant.now();
        endMap.put(entity, end);
        updatePing(entity);
    }
"
679,This block is useless.,"		public boolean areEqual(MapObject o1, MapObject o2) {
			if (o1 == null ^ o2 == null) {
				return false;
			} else if (o1 == o2) {
				return true;
			} else {
				return o1.id.equals(o2.id);
			}
		}
","		public boolean areEqual(MapObject o1, MapObject o2) {
			if (o1 == null ^ o2 == null) {
				return false;
START 			} else if (o1 == o2) { END 
				return true;
			} else {
				return o1.id.equals(o2.id);
			}
		}
","		public boolean areEqual(MapObject o1, MapObject o2) {
			if (o1 == null) {
				return o2 == null;
			} else {
				return o1.id.equals(o2.id);
			}
		}
"
680,`StringRedisTemplate` constructor takes care of it.,"	public RedisMetadataStore(RedisConnectionFactory connectionFactory) {
		Assert.notNull(connectionFactory, ""'connectionFactory' must not be null."");
		this.redisTemplate = new StringRedisTemplate(connectionFactory);
		this.redisTemplate.afterPropertiesSet();
	}
","	public RedisMetadataStore(RedisConnectionFactory connectionFactory) {
		Assert.notNull(connectionFactory, ""'connectionFactory' must not be null."");
		this.redisTemplate = new StringRedisTemplate(connectionFactory);
START 		this.redisTemplate.afterPropertiesSet(); END 
	}
","	public RedisMetadataStore(RedisConnectionFactory connectionFactory) {
		Assert.notNull(connectionFactory, ""'connectionFactory' must not be null."");
		this.redisTemplate = new StringRedisTemplate(connectionFactory);
	}
"
681,"Can you use the inherited ""m_isLeaderToReplica"" instead of adding a new ""m_toLeader""? The message is either from leader to replica or from MPI to leader?","    public CompleteTransactionMessage(long initiatorHSId, long coordinatorHSId,
                                      long txnId, boolean isReadOnly, int hash,
                                      boolean isRollback, boolean requiresAck,
                                      boolean isRestart, boolean isForReplay)
    {
        super(initiatorHSId, coordinatorHSId, txnId, 0, isReadOnly, isForReplay);
        m_hash = hash;
        setBit(ISROLLBACK, isRollback);
        setBit(REQUIRESACK, requiresAck);
        setBit(ISRESTART, isRestart);
        m_toLeader = false;
        m_ackRequestedFromSender = true;
    }
","    public CompleteTransactionMessage(long initiatorHSId, long coordinatorHSId,
                                      long txnId, boolean isReadOnly, int hash,
                                      boolean isRollback, boolean requiresAck,
                                      boolean isRestart, boolean isForReplay)
    {
        super(initiatorHSId, coordinatorHSId, txnId, 0, isReadOnly, isForReplay);
        m_hash = hash;
        setBit(ISROLLBACK, isRollback);
        setBit(REQUIRESACK, requiresAck);
        setBit(ISRESTART, isRestart);
START         m_toLeader = false; END 
        m_ackRequestedFromSender = true;
    }
","    public CompleteTransactionMessage(long initiatorHSId, long coordinatorHSId,
                                      long txnId, boolean isReadOnly, int hash,
                                      boolean isRollback, boolean requiresAck,
                                      boolean isRestart, boolean isForReplay)
    {
        super(initiatorHSId, coordinatorHSId, txnId, 0, isReadOnly, isForReplay);
        m_hash = hash;
        setBit(ISROLLBACK, isRollback);
        setBit(REQUIRESACK, requiresAck);
        setBit(ISRESTART, isRestart);
    }
"
682,"This will always return true, did you want cuEinvoiceDao instead of null here","    private CuEinvoiceDao getCuEinvoiceDao() {
        if (ObjectUtils.isNull(null)) {
            cuEinvoiceDao = SpringContext.getBean(CuEinvoiceDaoOjb.class);
        }
        return cuEinvoiceDao;
    }
","    private CuEinvoiceDao getCuEinvoiceDao() {
START         if (ObjectUtils.isNull(null)) { END 
            cuEinvoiceDao = SpringContext.getBean(CuEinvoiceDaoOjb.class);
        }
        return cuEinvoiceDao;
    }
","    private CuEinvoiceDao getCuEinvoiceDao() {
        if (ObjectUtils.isNull(cuEinvoiceDao)) {
            cuEinvoiceDao = SpringContext.getBean(CuEinvoiceDaoOjb.class);
        }
        return cuEinvoiceDao;
    }
"
683,Can we make this method private?,"  public static EchoTagStatementTree newEchoTagStatement(ExpressionTree expression, InternalSyntaxToken eosToken) {
    SeparatedList<ExpressionTree> expressionList = new SeparatedListImpl(Collections.singletonList(expression), Collections.emptyList());
    return newEchoTagStatement(expressionList, eosToken);
  }
","START   public static EchoTagStatementTree newEchoTagStatement(ExpressionTree expression, InternalSyntaxToken eosToken) { END 
    SeparatedList<ExpressionTree> expressionList = new SeparatedListImpl(Collections.singletonList(expression), Collections.emptyList());
    return newEchoTagStatement(expressionList, eosToken);
  }
","  private static EchoTagStatementTree newEchoTagStatement(ExpressionTree expression, InternalSyntaxToken eosToken) {
    SeparatedList<ExpressionTree> expressionList = new SeparatedListImpl<>(Collections.singletonList(expression), Collections.emptyList());
    return newEchoTagStatement(expressionList, eosToken);
  }
"
684,Perhaps it would be better to return null instead of throwing an exception? Nothing has really gone wrong. And then you wouldn't need that empty catch block.,"    private static TextSummarizer getLocalSummarizer() throws IOException {
        Collection<? extends TextSummarizer> summarizers
                = Lookup.getDefault().lookupAll(TextSummarizer.class
                );
        if (!summarizers.isEmpty()) {
            summarizerToUse = summarizers.iterator().next();
            return summarizerToUse;
        }
        throw new IOException(""No summarizers found"");
    }
","    private static TextSummarizer getLocalSummarizer() throws IOException {
        Collection<? extends TextSummarizer> summarizers
                = Lookup.getDefault().lookupAll(TextSummarizer.class
                );
        if (!summarizers.isEmpty()) {
            summarizerToUse = summarizers.iterator().next();
            return summarizerToUse;
        }
START         throw new IOException(""No summarizers found""); END 
    }
","    private static TextSummarizer getLocalSummarizer() {
        Collection<? extends TextSummarizer> summarizers
                = Lookup.getDefault().lookupAll(TextSummarizer.class
                );
        if (!summarizers.isEmpty()) {
            summarizerToUse = summarizers.iterator().next();
            return summarizerToUse;
        }
        return null;
    }
"
685,could you please put it in brackets to make it easier to read?,"	public void verifyNoVideo() {
		if(checkIfElementOnPage(mediaNode))
			throw new AssertionError(""Media Node is still on the page"");
		else
			PageObjectLogging.log(""verifyNoVideo"", ""Verified no video is on page"", true, driver);
	}
","	public void verifyNoVideo() {
		if(checkIfElementOnPage(mediaNode))
START 			throw new AssertionError(""Media Node is still on the page""); END 
		else
			PageObjectLogging.log(""verifyNoVideo"", ""Verified no video is on page"", true, driver);
	}
","	public void verifyNoVideo() {
		if(checkIfElementOnPage(mediaNode)) {
			throw new AssertionError(""Media Node is still on the page"");
		} else {
			PageObjectLogging.log(""verifyNoVideo"", ""Verified no video is on page"", true, driver);
		}
	}
"
686,Is it save to assign a new subscription here without unsubscribing a potentially existing previous subscription? Or to ask different: Can you guarantee this is not called two times in a row in the activity lifecycle with requireGeodata==true?,"    private void startOrStopGeoDataListener() {
        if (requireGeodata) {
            geoDataSubscription = locationUpdater.start(GeoDirHandler.UPDATE_GEODATA);
        } else {
            geoDataSubscription.unsubscribe();
        }
    }
","    private void startOrStopGeoDataListener() {
        if (requireGeodata) {
START             geoDataSubscription = locationUpdater.start(GeoDirHandler.UPDATE_GEODATA); END 
        } else {
            geoDataSubscription.unsubscribe();
        }
    }
","    private void startOrStopGeoDataListener() {
        geoDataSubscription.unsubscribe();
        if (requireGeodata) {
            geoDataSubscription = locationUpdater.start(GeoDirHandler.UPDATE_GEODATA);
        }
    }
"
687,not needed.,"  ZipFormatter(
      Formatters formatters,
      FormatterUtil formatterUtil,
      HtmlBuilder html) {
    this.formatters = formatters;
    this.util = formatterUtil;
    this.html = html;
  }
","  ZipFormatter(
      START  Formatters formatters, END 
      FormatterUtil formatterUtil,
      HtmlBuilder html) {
    this.formatters = formatters;
    this.util = formatterUtil;
    this.html = html;
  }
","  ZipFormatter(
      Formatters formatters,
      FormatterUtil formatterUtil,
      HtmlBuilder html) {
    this.util = formatterUtil;
    this.html = html;
  }
"
688,"I think I saw multiple ppc types in the enum: ppc, ppc64, ppcle, ppc64le","    private boolean clusterHasPpcArchitecture() {
        Cluster cluster = getModel().getSelectedCluster();

        return cluster != null
                && cluster.getArchitecture() != null
                && ArchitectureType.ppc.getFamily() == cluster.getArchitecture().getFamily();
    }
","    private boolean clusterHasPpcArchitecture() {
        Cluster cluster = getModel().getSelectedCluster();

        return cluster != null
                && cluster.getArchitecture() != null
START                 && ArchitectureType.ppc.getFamily() == cluster.getArchitecture().getFamily(); END 
    }
","    private boolean clusterHasPpcArchitecture() {
        Cluster cluster = getModel().getSelectedCluster();

        return cluster != null
                && cluster.getArchitecture() != null
                && ArchitectureType.ppc == cluster.getArchitecture().getFamily();
    }
"
689,We can make this private,"   protected void createIndex(Connection conn, String indexExt, String columnName) throws PersistenceException {
      if (metaData.isIndexingDisabled()) return;

      boolean indexExists = indexExists(getIndexName(false, indexExt), conn);
      if (!indexExists) {
         String ddl = String.format(""CREATE INDEX %s ON %s (%s)"", getIndexName(true, indexExt), getTableName(), columnName);
         if (log.isTraceEnabled()) {
            log.tracef(""Adding index with following DDL: '%s'."", ddl);
         }
         executeUpdateSql(conn, ddl);
      }
   }
","START    protected void createIndex(Connection conn, String indexExt, String columnName) throws PersistenceException { END 
      if (metaData.isIndexingDisabled()) return;

      boolean indexExists = indexExists(getIndexName(false, indexExt), conn);
      if (!indexExists) {
         String ddl = String.format(""CREATE INDEX %s ON %s (%s)"", getIndexName(true, indexExt), getTableName(), columnName);
         if (log.isTraceEnabled()) {
            log.tracef(""Adding index with following DDL: '%s'."", ddl);
         }
         executeUpdateSql(conn, ddl);
      }
   }
","   private void createIndex(Connection conn, String indexExt, String columnName) throws PersistenceException {
      if (metaData.isIndexingDisabled()) return;

      boolean indexExists = indexExists(getIndexName(false, indexExt), conn);
      if (!indexExists) {
         String ddl = String.format(""CREATE INDEX %s ON %s (%s)"", getIndexName(true, indexExt), getTableName(), columnName);
         if (log.isTraceEnabled()) {
            log.tracef(""Adding index with following DDL: '%s'."", ddl);
         }
         executeUpdateSql(conn, ddl);
      }
   }
"
690,"This should be simplified to just:
>return value;","    public Object getValue() {
        if (value == null) {
            return null;
        } else {
            return value;
        }
    }
","    public Object getValue() {
START         if (value == null) { END 
            return null;
        } else {
            return value;
        }
    }
","    public Object getValue() {
        return value;
    }
"
691,"`false ==` is a peculiar way to express `!`.
BTW, `peculiar` is a polite way to say `wrong`.","    private boolean needProjectionNode (AbstractPlanNode root) {
        if ( false == root.planNodeClassNeedsProjectionNode()) {
            return false;
        }
        // If there is a complexGroupby at his point, it means that
        // display columns contain all the order by columns and
        // does not require another projection node on top of sort node.

        // If there is a complex aggregation case, the projection plan node is already added
        // right above the group by plan node. In future, we may inline that projection node.
        if (m_parsedSelect.hasComplexGroupby() || m_parsedSelect.hasComplexAgg()) {
            return false;
        }

        if (root instanceof AbstractReceivePlanNode &&
                m_parsedSelect.hasPartitionColumnInGroupby()) {
            // Top aggregate has been removed, its schema is exactly the same to
            // its local aggregate node.
            return false;
        }

        return true;
    }
","    private boolean needProjectionNode (AbstractPlanNode root) {
START         if ( false == root.planNodeClassNeedsProjectionNode()) { END 
            return false;
        }
        // If there is a complexGroupby at his point, it means that
        // display columns contain all the order by columns and
        // does not require another projection node on top of sort node.

        // If there is a complex aggregation case, the projection plan node is already added
        // right above the group by plan node. In future, we may inline that projection node.
        if (m_parsedSelect.hasComplexGroupby() || m_parsedSelect.hasComplexAgg()) {
            return false;
        }

        if (root instanceof AbstractReceivePlanNode &&
                m_parsedSelect.hasPartitionColumnInGroupby()) {
            // Top aggregate has been removed, its schema is exactly the same to
            // its local aggregate node.
            return false;
        }

        return true;
    }
","    private boolean needProjectionNode (AbstractPlanNode root) {
        if (!root.planNodeClassNeedsProjectionNode()) {
            return false;
        }
        // If there is a complexGroupby at his point, it means that
        // display columns contain all the order by columns and
        // does not require another projection node on top of sort node.

        // If there is a complex aggregation case, the projection plan node is already added
        // right above the group by plan node. In future, we may inline that projection node.
        if (m_parsedSelect.hasComplexGroupby() || m_parsedSelect.hasComplexAgg()) {
            return false;
        }

        if (root instanceof AbstractReceivePlanNode &&
                m_parsedSelect.hasPartitionColumnInGroupby()) {
            // Top aggregate has been removed, its schema is exactly the same to
            // its local aggregate node.
            return false;
        }

        return true;
    }
"
692,just one cell please,"    public void isExecutable_HeaderCellSelected() {
        when(scenarioGridModelMock.getSelectedCells()).thenReturn(Collections.emptyList());
        when(scenarioGridModelMock.getSelectedHeaderCells()).thenReturn(Lists.create(selectedCell, selectedCell2));
        assertTrue(handler.isExecutable(scenarioGridMock));
    }
","    public void isExecutable_HeaderCellSelected() {
        when(scenarioGridModelMock.getSelectedCells()).thenReturn(Collections.emptyList());
START         when(scenarioGridModelMock.getSelectedHeaderCells()).thenReturn(Lists.create(selectedCell, selectedCell2)); END 
        assertTrue(handler.isExecutable(scenarioGridMock));
    }
","    public void isExecutable_HeaderCellSelected() {
        when(scenarioGridModelMock.getSelectedCells()).thenReturn(Collections.emptyList());
        when(scenarioGridModelMock.getSelectedHeaderCells()).thenReturn(Arrays.asList(selectedCell, selectedCell2));
        assertTrue(handler.isExecutable(scenarioGridMock));
    }
"
693,"This is not really relevant IMO. It's not data of that rules, just an internal helper. In practice this is always going to be true anyway since it's a singleton component.","    public boolean equals(Object object)
    {
        if (object == this) {
            return true;
        }
        if (!(object instanceof XarSecurityRule)) {
            return false;
        }

        XarSecurityRule rhs = (XarSecurityRule) object;
        return new EqualsBuilder()
                .append(this.right, rhs.right)
                .append(this.simple, rhs.simple)
                .append(this.securityTool, rhs.securityTool)
                .isEquals();
    }
","    public boolean equals(Object object)
    {
        if (object == this) {
            return true;
        }
        if (!(object instanceof XarSecurityRule)) {
            return false;
        }

        XarSecurityRule rhs = (XarSecurityRule) object;
        return new EqualsBuilder()
                .append(this.right, rhs.right)
                .append(this.simple, rhs.simple)
START                 .append(this.securityTool, rhs.securityTool) END 
                .isEquals();
    }
","    public boolean equals(Object object)
    {
        if (object == this) {
            return true;
        }
        if (!(object instanceof XarSecurityRule)) {
            return false;
        }

        XarSecurityRule rhs = (XarSecurityRule) object;
        return new EqualsBuilder()
                .append(this.right, rhs.right)
                .append(this.simple, rhs.simple)
                .isEquals();
    }
"
694,Any reason why you added `ReflectionHelper.`? Might as well remove it so that we see it's a method of this very class?,"	public static boolean containsSearchAnnotations(XClass mappedClass) {
		List<XClass> hierarchy = ReflectionHelper.createXClassHierarchy( mappedClass );

		for ( XClass clazz : hierarchy ) {
			if ( containsLocalSearchAnnotation( clazz ) ) {
				return true;
			}
		}

		return false;
	}
","	public static boolean containsSearchAnnotations(XClass mappedClass) {
START 		List<XClass> hierarchy = ReflectionHelper.createXClassHierarchy( mappedClass ); END 

		for ( XClass clazz : hierarchy ) {
			if ( containsLocalSearchAnnotation( clazz ) ) {
				return true;
			}
		}

		return false;
	}
","	public static boolean containsSearchAnnotations(XClass mappedClass) {
		List<XClass> hierarchy = createXClassHierarchy( mappedClass );

		for ( XClass clazz : hierarchy ) {
			if ( containsLocalSearchAnnotation( clazz ) ) {
				return true;
			}
		}

		return false;
	}
"
695,"`Math.max(newUsedCapacity, currentCapacity)` would be a little bit clearer here.","  private static int computeNewVectorCapacity(int usedCapacity, int newPayload, int currentCapacity) {
    int newUsedCapacity = BaseAllocator.nextPowerOfTwo(usedCapacity + newPayload);
    assert newUsedCapacity >= 0;

    return newUsedCapacity <= currentCapacity ? currentCapacity : newUsedCapacity;
  }
","  private static int computeNewVectorCapacity(int usedCapacity, int newPayload, int currentCapacity) {
    int newUsedCapacity = BaseAllocator.nextPowerOfTwo(usedCapacity + newPayload);
    assert newUsedCapacity >= 0;

START     return newUsedCapacity <= currentCapacity ? currentCapacity : newUsedCapacity; END 
  }
","  private static int computeNewVectorCapacity(int usedCapacity, int newPayload, int currentCapacity) {
    int newUsedCapacity = BaseAllocator.nextPowerOfTwo(usedCapacity + newPayload);
    assert newUsedCapacity >= 0;

    return Math.max(currentCapacity, newUsedCapacity);
  }
"
696,"This doesn't help at all, I suspect it can even cause loss of the logs.
Logback already have solved the problem, and we have it enabled https://github.com/CorfuDB/CorfuDB/blob/30c8d154f59dfe22d4cc16b94ab9e2c51851c2e5/infrastructure/src/main/resources/logback.prod.xml#L5","    private static void cleanShutdown() {
        log.info(""CleanShutdown: Starting Cleanup."");
        shutdownServer = true;
        try {
            CorfuServerNode current = activeServer;
            if (current != null) {
                activeServer.close();
            }
        } catch (Throwable th) {
            log.error(""cleanShutdown: failed during shutdown"", th);
        }

        // Flush the async appender before exiting to prevent the loss of logs
        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
        loggerContext.stop();
    }
","    private static void cleanShutdown() {
        log.info(""CleanShutdown: Starting Cleanup."");
        shutdownServer = true;
        try {
            CorfuServerNode current = activeServer;
            if (current != null) {
                activeServer.close();
            }
        } catch (Throwable th) {
            log.error(""cleanShutdown: failed during shutdown"", th);
        }

        // Flush the async appender before exiting to prevent the loss of logs
START         LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory(); END 
        loggerContext.stop();
    }
","    private static void cleanShutdown() {
        log.info(""CleanShutdown: Starting Cleanup."");
        shutdownServer = true;
        try {
            CorfuServerNode current = activeServer;
            if (current != null) {
                current.close();
            }
        } catch (Throwable th) {
            log.error(""cleanShutdown: failed during shutdown"", th);
        }

        // Flush the async appender before exiting to prevent the loss of logs
        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
        loggerContext.stop();
    }
"
697,"As I said in the last PR (https://github.com/AntiqueAtlasTeam/AntiqueAtlas/pull/205) that did something like this, this should use `LogManager.getLogger(...)`. 

Honestly, `Log#modLog` should just be changed to 

```java
private static final Logger LOGGER = LogManager.getLogger(AntiqueAtlasMod.ID);
```","	public void preInit(FMLPreInitializationEvent event) {
		Log.setModLog(event.getModLog());
		configDir = new File(event.getModConfigurationDirectory(), ""antiqueatlas"");
		configDir.mkdir();
		extTileIdMap = ExtTileIdMap.instance();
		extTileConfig = new ExtTileConfig(new File(configDir, ""tileids.json""));
		extTileConfig.load(extTileIdMap);
		// Assign default values AFTER the config file loads, so that the old saved values are kept:
		registerVanillaCustomTiles();
		checkSaveConfig();
	}
","	public void preInit(FMLPreInitializationEvent event) {
START 		Log.setModLog(event.getModLog()); END 
		configDir = new File(event.getModConfigurationDirectory(), ""antiqueatlas"");
		configDir.mkdir();
		extTileIdMap = ExtTileIdMap.instance();
		extTileConfig = new ExtTileConfig(new File(configDir, ""tileids.json""));
		extTileConfig.load(extTileIdMap);
		// Assign default values AFTER the config file loads, so that the old saved values are kept:
		registerVanillaCustomTiles();
		checkSaveConfig();
	}
","	public void preInit(FMLPreInitializationEvent event) {
		configDir = new File(event.getModConfigurationDirectory(), ""antiqueatlas"");
		configDir.mkdir();
		extTileIdMap = ExtTileIdMap.instance();
		extTileConfig = new ExtTileConfig(new File(configDir, ""tileids.json""));
		extTileConfig.load(extTileIdMap);
		// Assign default values AFTER the config file loads, so that the old saved values are kept:
		registerVanillaCustomTiles();
		checkSaveConfig();
	}
"
698,"Checkstyle violation:
```
[ant:checkstyle] [ERROR] /home/travis/build/spring-projects/spring-integration/spring-integration-ftp/src/main/java/org/springframework/integration/ftp/session/FtpSession.java:157: 'if' construct must use '{}'s. [NeedBraces]
```

You can verify yourself locally using `gradlew clean :spring-integration-ftp:check`","	public void close() {
		try {
			if (this.readingRaw.get() && !finalizeRaw() && LOGGER.isWarnEnabled()) {
				LOGGER.warn(""Finalize on readRaw() returned false for "" + this);
			}
			if (this.client.isConnected())
				this.client.logout();
			this.client.disconnect();
		}
		catch (Exception e) {
			LOGGER.warn(""failed to disconnect FTPClient"", e);
		}
	}
","	public void close() {
		try {
			if (this.readingRaw.get() && !finalizeRaw() && LOGGER.isWarnEnabled()) {
				LOGGER.warn(""Finalize on readRaw() returned false for "" + this);
			}
START 			if (this.client.isConnected()) END 
				this.client.logout();
			this.client.disconnect();
		}
		catch (Exception e) {
			LOGGER.warn(""failed to disconnect FTPClient"", e);
		}
	}
","	public void close() {
		try {
			if (this.readingRaw.get() && !finalizeRaw() && LOGGER.isWarnEnabled()) {
				LOGGER.warn(""Finalize on readRaw() returned false for "" + this);
			}
			if (this.client.isConnected()) {
				this.client.logout();
			}
			this.client.disconnect();
		}
		catch (Exception e) {
			LOGGER.warn(""failed to disconnect FTPClient"", e);
		}
	}
"
699,No extra (clutter) please.,"  protected FileType doGetType() throws Exception {
    return (this.stat == null) ? FileType.IMAGINARY : FileType.FILE_OR_FOLDER;
  }
","  protected FileType doGetType() throws Exception {
START     return (this.stat == null) ? FileType.IMAGINARY : FileType.FILE_OR_FOLDER; END 
  }
","  protected FileType doGetType() throws Exception {
    return this.stat == null ? FileType.IMAGINARY : FileType.FILE_OR_FOLDER;
  }
"
700,`capacity * loadFactor` maybe?,"   public EquivalentHashMap(
         int initialCapacity, float loadFactor,
         Equivalence<K> keyEq, Equivalence<V> valueEq) {
      int capacity = 1;
      while (capacity < initialCapacity)
         capacity <<= 1;

      this.loadFactor = loadFactor;
      threshold = (int)(capacity * DEFAULT_LOAD_FACTOR);
      table = new Node[capacity];
      this.keyEq = keyEq;
      this.valueEq = valueEq;
   }
","   public EquivalentHashMap(
         int initialCapacity, float loadFactor,
         Equivalence<K> keyEq, Equivalence<V> valueEq) {
      int capacity = 1;
      while (capacity < initialCapacity)
         capacity <<= 1;

      this.loadFactor = loadFactor;
START       threshold = (int)(capacity * DEFAULT_LOAD_FACTOR); END 
      table = new Node[capacity];
      this.keyEq = keyEq;
      this.valueEq = valueEq;
   }
","   public EquivalentHashMap(
         int initialCapacity, float loadFactor,
         Equivalence<K> keyEq, Equivalence<V> valueEq) {
      int capacity = 1;
      while (capacity < initialCapacity)
         capacity <<= 1;

      this.loadFactor = loadFactor;
      threshold = (int)(capacity * loadFactor);
      table = new Node[capacity];
      this.keyEq = keyEq;
      this.valueEq = valueEq;
   }
"
701,just throw the exception upwards..,"    private void mockSSHClient() {
        try {
            doNothing().when(sshclient).connect();
            doNothing().when(sshclient).authenticate();
        }
        catch(Exception e) {}
    }
","START     private void mockSSHClient() { END 
        try {
            doNothing().when(sshclient).connect();
            doNothing().when(sshclient).authenticate();
        }
        catch(Exception e) {}
    }
","    private void mockSSHClient() {
        try {
            doNothing().when(sshclient).connect();
            doNothing().when(sshclient).authenticate();
        }
        catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
"
702,![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the redundant '!unknownSymbol!' thrown exception declaration(s). [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck),"    public static String sanitizeKey(final Contentlet vanityUrl)
            throws DotDataException, DotRuntimeException, DotSecurityException {
        Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),
                        APILocator.systemUser(), false);
        return sanitizeKey(host.getIdentifier(),
                fixURI(vanityUrl.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)),
                vanityUrl.getLanguageId());
    }
","    public static String sanitizeKey(final Contentlet vanityUrl)
START             throws DotDataException, DotRuntimeException, DotSecurityException { END 
        Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),
                        APILocator.systemUser(), false);
        return sanitizeKey(host.getIdentifier(),
                fixURI(vanityUrl.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)),
                vanityUrl.getLanguageId());
    }
","    public static String sanitizeKey(final Contentlet vanityUrl)
            throws DotDataException, DotSecurityException {
        Host host = hostAPI.find(vanityUrl.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),
                APILocator.systemUser(), false);
        return sanitizeKey(host.getIdentifier(),
                fixURI(vanityUrl.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)),
                vanityUrl.getLanguageId());
    }
"
703,You can revert this change now.,"  protected void dataTemplateToJsonGenerator(Object data,
                                             DataSchema schema,
                                             JsonGenerator generator,
                                             boolean order) throws IOException
  {
    if (order)
    {
      JacksonTraverseCallback callback = new SchemaOrderTraverseCallback(schema, generator);
      Data.traverse(data, callback);
    }
    else
    {
      objectToJsonGenerator(data, generator, false);
    }
  }
","  protected void dataTemplateToJsonGenerator(Object data,
                                             DataSchema schema,
                                             JsonGenerator generator,
                                             boolean order) throws IOException
  {
    if (order)
    {
      JacksonTraverseCallback callback = new SchemaOrderTraverseCallback(schema, generator);
      Data.traverse(data, callback);
    }
    else
    {
START       objectToJsonGenerator(data, generator, false); END 
    }
  }
","  protected void dataTemplateToJsonGenerator(Object data,
                                             DataSchema schema,
                                             JsonGenerator generator,
                                             boolean order) throws IOException
  {
    if (order)
    {
      JacksonTraverseCallback callback = new SchemaOrderTraverseCallback(schema, generator);
      Data.traverse(data, callback);
    }
    else
    {
      objectToJsonGenerator(data, generator);
    }
  }
"
704,"these exceptions are unacceptable (intended pun miserably failed) we are listing clusters, no resource-, allocation-, or any change related exception should ever occur. at most a entity not found kind of thing.","    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException {
        ListResponse<KubernetesSupportedVersionResponse> response = kubernetesVersionService.listKubernetesSupportedVersions(this);
        response.setResponseName(getCommandName());
        setResponseObject(response);
    }
","START     public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException, ResourceAllocationException, NetworkRuleConflictException { END 
        ListResponse<KubernetesSupportedVersionResponse> response = kubernetesVersionService.listKubernetesSupportedVersions(this);
        response.setResponseName(getCommandName());
        setResponseObject(response);
    }
","    public void execute() throws ServerApiException, ConcurrentOperationException {
        ListResponse<KubernetesSupportedVersionResponse> response = kubernetesVersionService.listKubernetesSupportedVersions(this);
        response.setResponseName(getCommandName());
        setResponseObject(response);
    }
"
705,the turnOff is not really needed,"    public void loggedInUserPropertyFalseTest() throws Exception {
        context.turnOffAuthorisationSystem();
        configurationService.setProperty(""webui.user.assumelogin"", false);
        context.restoreAuthSystemState();

        String token = getAuthToken(admin.getEmail(), password);

        getClient(token).perform(get(""/api/authn/status"")
                                     .header(""X-On-Behalf-Of"", eperson.getID()))
                        .andExpect(status().isBadRequest());

        context.turnOffAuthorisationSystem();
        configurationService.setProperty(""webui.user.assumelogin"", true);
        context.restoreAuthSystemState();
    }
","    public void loggedInUserPropertyFalseTest() throws Exception {
START         context.turnOffAuthorisationSystem(); END 
        configurationService.setProperty(""webui.user.assumelogin"", false);
        context.restoreAuthSystemState();

        String token = getAuthToken(admin.getEmail(), password);

        getClient(token).perform(get(""/api/authn/status"")
                                     .header(""X-On-Behalf-Of"", eperson.getID()))
                        .andExpect(status().isBadRequest());

        context.turnOffAuthorisationSystem();
        configurationService.setProperty(""webui.user.assumelogin"", true);
        context.restoreAuthSystemState();
    }
","    public void loggedInUserPropertyFalseTest() throws Exception {
        configurationService.setProperty(""webui.user.assumelogin"", false);

        String token = getAuthToken(admin.getEmail(), password);

        getClient(token).perform(get(""/api/authn/status"")
                                     .header(""X-On-Behalf-Of"", eperson.getID()))
                        .andExpect(status().isBadRequest());
    }
"
706,Could use an entrySet.,"    protected void addExtraHeaders(Builder webResource) {
        if (additionalHeaders != null) {
            for (String key : additionalHeaders.keySet()) {
                webResource.header(key, additionalHeaders.get(key));
            }
        }
    }
","    protected void addExtraHeaders(Builder webResource) {
        if (additionalHeaders != null) {
START             for (String key : additionalHeaders.keySet()) { END 
                webResource.header(key, additionalHeaders.get(key));
            }
        }
    }
","    protected void addExtraHeaders(Builder webResource) {
        if (additionalHeaders != null) {
            for (Map.Entry<String, List<Object>> entry: additionalHeaders.entrySet()) {
                webResource.header(entry.getKey(), entry.getValue());
            }
        }
    }
"
707,"I think

return (newList.size() > currentList.size())

is sufficient","	private boolean hasNewFragment(EList<InteractionFragment> currentList, List<InteractionFragment> newList) {
		boolean newFragment = false;

		if (newList.size() > currentList.size()) {
			newFragment = true;
		}

		return newFragment;
	}
","	private boolean hasNewFragment(EList<InteractionFragment> currentList, List<InteractionFragment> newList) {
START 		boolean newFragment = false;

		if (newList.size() > currentList.size()) {
			newFragment = true;
		}

		return newFragment; END 
	}
","	private boolean hasNewFragment(EList<InteractionFragment> currentList, List<InteractionFragment> newList) {

		return (newList.size() > currentList.size());
	}
"
708,This is unnecessary as generatedKeysResultSet is added to activeResultSets when created,"  void closeResultSets() throws SQLException {
    closeResultSets(activeResultSets);

    if (generatedKeysResultSet != null && !generatedKeysResultSet.isClosed()) {
      generatedKeysResultSet.internalClose();
    }

    generatedKeysResultSet = null;
  }
","  void closeResultSets() throws SQLException {
    closeResultSets(activeResultSets);
START  END 
    if (generatedKeysResultSet != null && !generatedKeysResultSet.isClosed()) {
      generatedKeysResultSet.internalClose();
    }

    generatedKeysResultSet = null;
  }
","  void closeResultSets() throws SQLException {
    closeResultSets(activeResultSets);

    generatedKeysResultSet = null;
  }
"
709,The scope of this `try` block is broader than necessary. It only needs to contain this line.,"	public boolean isTemplateAvailable(String view, Environment environment,
			ClassLoader classLoader, ResourceLoader resourceLoader) {
		if (ClassUtils.isPresent(""org.apache.jasper.compiler.JspConfig"", classLoader)) {

			try {
				String resourceName = getResourceName(view, environment);
				if (resourceLoader.getResource(resourceName).exists()) {
					return true;
				}
				return new File(""src/main/webapp"", resourceName).exists();
			}
			catch (AccessControlException ex) {
				return false;
			}
		}
		return false;
	}
","	public boolean isTemplateAvailable(String view, Environment environment,
			ClassLoader classLoader, ResourceLoader resourceLoader) {
		if (ClassUtils.isPresent(""org.apache.jasper.compiler.JspConfig"", classLoader)) {

			try {
				String resourceName = getResourceName(view, environment);
				if (resourceLoader.getResource(resourceName).exists()) {
					return true;
				}
START 				return new File(""src/main/webapp"", resourceName).exists(); END 
			}
			catch (AccessControlException ex) {
				return false;
			}
		}
		return false;
	}
","	public boolean isTemplateAvailable(String view, Environment environment,
			ClassLoader classLoader, ResourceLoader resourceLoader) {
		if (ClassUtils.isPresent(""org.apache.jasper.compiler.JspConfig"", classLoader)) {

			String resourceName = getResourceName(view, environment);
			if (resourceLoader.getResource(resourceName).exists()) {
				return true;
			}

			try {
				return new File(""src/main/webapp"", resourceName).exists();
			}
			catch (AccessControlException ex) {
			}
		}
		return false;
	}
"
710,Why does this return Object instead of T ?,"    public Object visit(final AntlrBaseNode node) {
        return node.accept(this);
    }
","START     public Object visit(final AntlrBaseNode node) { END 
        return node.accept(this);
    }
","    public T visit(final AntlrBaseNode node) {
        return node.accept(this);
    }
"
711,please remove alias setting (should be encapsulated in addManagedDevice,"    public static void addDiskToVm(BaseDisk disk, Guid vmId) {
        DbFacade.getInstance().getBaseDiskDao().save(disk);
        VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId),
                VmDeviceType.DISK,
                VmDeviceType.DISK,
                null,
                true,
                false,
                """");
    }
","    public static void addDiskToVm(BaseDisk disk, Guid vmId) {
        DbFacade.getInstance().getBaseDiskDao().save(disk);
        VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId),
                VmDeviceType.DISK,
                VmDeviceType.DISK,
                null,
                true,
                false,
START                 """"); END 
    }
","    public static void addDiskToVm(BaseDisk disk, Guid vmId) {
        DbFacade.getInstance().getBaseDiskDao().save(disk);
        VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId),
                VmDeviceType.DISK,
                VmDeviceType.DISK,
                null,
                true,
                false);
    }
"
712,return here,"    private static Throwable getConfigFailureException(ITestContext context) {
        Throwable t = null;
        for (IInvokedMethod method : context.getSuite().getAllInvokedMethods()) {
            ITestNGMethod m = method.getTestMethod();
            if (m.isBeforeSuiteConfiguration() && (!method.getTestResult().isSuccess())) {
                t = method.getTestResult().getThrowable();
                break;
            }
        }
        return t;
    }
","    private static Throwable getConfigFailureException(ITestContext context) {
        Throwable t = null;
        for (IInvokedMethod method : context.getSuite().getAllInvokedMethods()) {
            ITestNGMethod m = method.getTestMethod();
            if (m.isBeforeSuiteConfiguration() && (!method.getTestResult().isSuccess())) {
START                 t = method.getTestResult().getThrowable(); END 
                break;
            }
        }
        return t;
    }
","    private static Throwable getConfigFailureException(ITestContext context) {
        for (IInvokedMethod method : context.getSuite().getAllInvokedMethods()) {
            ITestNGMethod m = method.getTestMethod();
            if (m.isBeforeSuiteConfiguration() && (!method.getTestResult().isSuccess())) {
                return method.getTestResult().getThrowable();
            }
        }
        return null;
    }
"
713,I recommend adding `{}` here,"    protected String toString(Operator operator) {
        if (Operator.STARTSWITH.equals(operator)) return LIKE;
        return operator.toString();
    }
","    protected String toString(Operator operator) {
START         if (Operator.STARTSWITH.equals(operator)) return LIKE; END 
        return operator.toString();
    }
","    protected String toString(Operator operator) {
        if (Operator.STARTSWITH.equals(operator)) {
            return LIKE;
        }
        return operator.toString();
    }
"
714,This looks like a leftover and it hasn't any usage. Can we remove it?,"	static UberDocument toUberDocument(final Object object) {

		if (object == null) {
			return null;
		}

		if (object instanceof UberDocument) {
			return (UberDocument) object;
		}

		if (object instanceof Iterable) {

		} else if (object instanceof Map) {

		}

		throw new IllegalArgumentException(""Don't know how to handle type : "" + object.getClass());
	}
","START 	static UberDocument toUberDocument(final Object object) { END 

		if (object == null) {
			return null;
		}

		if (object instanceof UberDocument) {
			return (UberDocument) object;
		}

		if (object instanceof Iterable) {

		} else if (object instanceof Map) {

		}

		throw new IllegalArgumentException(""Don't know how to handle type : "" + object.getClass());
	}
","	static UberDocument toUberDocument(final Object object) {

		if (object == null) {
			return null;
		}

		if (object instanceof UberDocument) {
			return (UberDocument) object;
		}

		throw new IllegalArgumentException(""Don't know how to handle type : "" + object.getClass());
	}
"
715,"There is no point exposing this constructor if there is not even a single public method. All methods are private (except for the static, which does not require a constructor to be used)","    public ArgumentSplitter(String arguments) {
        this.arguments = arguments;
    }
","START     public ArgumentSplitter(String arguments) { END 
        this.arguments = arguments;
    }
","    private ArgumentSplitter(String arguments) {
        this.arguments = arguments;
    }
"
716,"please improve error handling in accordance to: https://github.com/knowm/XChange/wiki/New-Implementation-Best-Practices#step-7

you should introduce and LgoException that implements HttpStatusExceptionSupport

try catch adapt should be done in methods that implement generic interfaces, *Raw methods should throw our the LgoException","  public LgoProducts getProducts() {
    LgoProducts products = null;
    try {
      products =
          this.proxy.getProducts(
              exchange.getNonceFactory().createValue(), exchange.getSignatureService());
    } catch (HttpStatusIOException e) {
      LgoErrorAdapter.adapt(e);
    }
    return products;
  }
","  public LgoProducts getProducts() {
    LgoProducts products = null;
    try {
      products =
          this.proxy.getProducts(
              exchange.getNonceFactory().createValue(), exchange.getSignatureService());
START     } catch (HttpStatusIOException e) { END 
      LgoErrorAdapter.adapt(e);
    }
    return products;
  }
","  public LgoProducts getProducts() throws IOException {
    return this.proxy.getProducts(
        exchange.getNonceFactory().createValue(), exchange.getSignatureService());
  }
"
717,"Do you still need to prepend the blank space, now that you're using MessageFormat.format()? If not, then you should be able to simplify this a little further.","    protected void addAttachmentToNote(T document, AccountingXmlDocumentBackupLink backupLink, Note note) {
        try {
            Attachment attachment = accountingXmlDocumentDownloadAttachmentService.createAttachmentFromBackupLink(document, backupLink);
            note.setAttachment(attachment);
        } catch (IOException e) {
            LOG.error(""addAttachmentToNote, unable to create attachment: "" + e.getMessage());
            String message = MessageFormat.format(
                    configurationService.getPropertyValueAsString(CuFPKeyConstants.ERROR_CREATE_ACCOUNTING_DOCUMENT_ATTACHMENT_DOWNLOAD), 
                    KFSConstants.BLANK_SPACE + backupLink.getLinkUrl());
            throw new ValidationException(message);
        }
    }
","    protected void addAttachmentToNote(T document, AccountingXmlDocumentBackupLink backupLink, Note note) {
        try {
            Attachment attachment = accountingXmlDocumentDownloadAttachmentService.createAttachmentFromBackupLink(document, backupLink);
            note.setAttachment(attachment);
        } catch (IOException e) {
            LOG.error(""addAttachmentToNote, unable to create attachment: "" + e.getMessage());
            String message = MessageFormat.format(
                    configurationService.getPropertyValueAsString(CuFPKeyConstants.ERROR_CREATE_ACCOUNTING_DOCUMENT_ATTACHMENT_DOWNLOAD), 
START                     KFSConstants.BLANK_SPACE + backupLink.getLinkUrl()); END 
            throw new ValidationException(message);
        }
    }
","    protected void addAttachmentToNote(T document, AccountingXmlDocumentBackupLink backupLink, Note note) {
        try {
            Attachment attachment = accountingXmlDocumentDownloadAttachmentService.createAttachmentFromBackupLink(document, backupLink);
            note.setAttachment(attachment);
        } catch (IOException e) {
            LOG.error(""addAttachmentToNote, unable to create attachment: "" + e.getMessage());
            String message = MessageFormat.format(
                    configurationService.getPropertyValueAsString(CuFPKeyConstants.ERROR_CREATE_ACCOUNTING_DOCUMENT_ATTACHMENT_DOWNLOAD), 
                    backupLink.getLinkUrl());
            throw new ValidationException(message);
        }
    }
"
718,"This is effectively final class, so just `throw new UnsupportedOperationException()`","        public Void getResult()
        {
            throw new UnsupportedOperationException(getClass().getName());
        }
","        public Void getResult()
        {
START             throw new UnsupportedOperationException(getClass().getName()); END 
        }
","        public Void getResult()
        {
            throw new UnsupportedOperationException();
        }
"
719,"Please add the actual type, just in case it ever fails","        public PlanWithProperties visitUnnest(UnnestNode node, PreferredProperties preferredProperties)
        {
            PreferredProperties translatedPreferred = preferredProperties.translate(variable -> {
                checkArgument(variable instanceof VariableReferenceExpression, ""Expect VariableReferenceExpression"");
                return node.getReplicateVariables().contains(variable) ? Optional.of(variable) : Optional.empty();
            });

            return rebaseAndDeriveProperties(node, planChild(node, translatedPreferred));
        }
","        public PlanWithProperties visitUnnest(UnnestNode node, PreferredProperties preferredProperties)
        {
            PreferredProperties translatedPreferred = preferredProperties.translate(variable -> {
START                 checkArgument(variable instanceof VariableReferenceExpression, ""Expect VariableReferenceExpression""); END 
                return node.getReplicateVariables().contains(variable) ? Optional.of(variable) : Optional.empty();
            });

            return rebaseAndDeriveProperties(node, planChild(node, translatedPreferred));
        }
","        public PlanWithProperties visitUnnest(UnnestNode node, PreferredProperties preferredProperties)
        {
            PreferredProperties translatedPreferred = preferredProperties.translate(variable -> node.getReplicateVariables().contains(variable) ? Optional.of(variable) : Optional.empty());

            return rebaseAndDeriveProperties(node, planChild(node, translatedPreferred));
        }
"
720,please put the correct status.,"    public ValidationResult isAnyDomainInProcess() {
        List<StoragePoolIsoMap> poolIsoMaps = getStoragePoolIsoMapDao().getAllForStoragePool(storagePool.getId());

        for (StoragePoolIsoMap domainIsoMap : poolIsoMaps) {
            if (domainIsoMap.getStatus() != null && domainIsoMap.getStatus().isStorageDomainInProcess()) {
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2,
                        String.format(""$status %1$s"", StorageDomainStatus.Locked));
            }
        }

        return ValidationResult.VALID;
    }
","    public ValidationResult isAnyDomainInProcess() {
        List<StoragePoolIsoMap> poolIsoMaps = getStoragePoolIsoMapDao().getAllForStoragePool(storagePool.getId());

        for (StoragePoolIsoMap domainIsoMap : poolIsoMaps) {
            if (domainIsoMap.getStatus() != null && domainIsoMap.getStatus().isStorageDomainInProcess()) {
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2,
START                         String.format(""$status %1$s"", StorageDomainStatus.Locked)); END 
            }
        }

        return ValidationResult.VALID;
    }
","    public ValidationResult isAnyDomainInProcess() {
        List<StoragePoolIsoMap> poolIsoMaps = getStoragePoolIsoMapDao().getAllForStoragePool(storagePool.getId());

        for (StoragePoolIsoMap domainIsoMap : poolIsoMaps) {
            if (domainIsoMap.getStatus() != null && domainIsoMap.getStatus().isStorageDomainInProcess()) {
                return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2,
                        String.format(""$status %1$s"", domainIsoMap.getStatus()));
            }
        }

        return ValidationResult.VALID;
    }
"
721,static,"    private boolean isFunctionNameMatch(RowExpression rowExpression, String expectedName)
    {
        if (castToExpression(rowExpression) instanceof FunctionCall) {
            return ((FunctionCall) castToExpression(rowExpression)).getName().toString().equalsIgnoreCase(expectedName);
        }
        return false;
    }
","START     private boolean isFunctionNameMatch(RowExpression rowExpression, String expectedName) END 
    {
        if (castToExpression(rowExpression) instanceof FunctionCall) {
            return ((FunctionCall) castToExpression(rowExpression)).getName().toString().equalsIgnoreCase(expectedName);
        }
        return false;
    }
","    private static boolean isFunctionNameMatch(RowExpression rowExpression, String expectedName)
    {
        if (castToExpression(rowExpression) instanceof FunctionCall) {
            return ((FunctionCall) castToExpression(rowExpression)).getName().toString().equalsIgnoreCase(expectedName);
        }
        return false;
    }
"
722,"We can slightly simplify:
```java
return result != null && Objects.equals(CommandResult.Type.ERROR, result.getType());
```","    public boolean hasError() {
        return result != null && result.getType() != null && CommandResult.Type.ERROR.equals(result.getType());
    }
","    public boolean hasError() {
START         return result != null && result.getType() != null && CommandResult.Type.ERROR.equals(result.getType()); END 
    }
","    public boolean hasError() {
        return result != null && CommandResult.Type.ERROR.equals(result.getType());
    }
"
723,Why did you have to change the order of the lines here?...,"    private void setupVdsNetworkInterfaceDao() {
        when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(vdsNetworkInterfaceDaoMock);
        List<VdsNetworkInterface> expectedVdsNetworkInterface = Collections.singletonList(vdsNetworkInterface);
        when(vdsNetworkInterfaceDaoMock.getVdsInterfacesByNetworkId(networkId)).thenReturn(
                expectedVdsNetworkInterface);
    }
","    private void setupVdsNetworkInterfaceDao() {
        when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(vdsNetworkInterfaceDaoMock);
        List<VdsNetworkInterface> expectedVdsNetworkInterface = Collections.singletonList(vdsNetworkInterface);
        when(vdsNetworkInterfaceDaoMock.getVdsInterfacesByNetworkId(networkId)).thenReturn(
START                 expectedVdsNetworkInterface); END 
    }
","    private void setupVdsNetworkInterfaceDao() {
        List<VdsNetworkInterface> expectedVdsNetworkInterface = Collections.singletonList(vdsNetworkInterface);
        when(vdsNetworkInterfaceDaoMock.getVdsInterfacesByNetworkId(networkId)).thenReturn(
                expectedVdsNetworkInterface);
        when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(vdsNetworkInterfaceDaoMock);
    }
"
724,Do we need this method public ? The place where it's used is in the same package so protected/default should work ?,"	public void setProject(IProject project) {
		this.project=project;
	}
","START 	public void setProject(IProject project) { END 
		this.project=project;
	}
","	protected void setProject(IProject project) {
		this.project=project;
	}
"
725,I think this should be `headers.get(name)`.,"	public List<String> values(String name) {
		return headers == null ? null : headers.get(""Request-Id"");
	}
","	public List<String> values(String name) {
START 		return headers == null ? null : headers.get(""Request-Id""); END 
	}
","	public List<String> values(String name) {
		return headers == null ? null : headers.get(name);
	}
"
726,dude,"    @Override protected Pair<Recipients, Boolean> doInBackground(Recipients... recipients) {
      Capability textCapability = DirectoryHelper.getUserCapabilities(context, recipients[0]).getTextCapability();
      return new Pair<>(recipients[0], textCapability == Capability.SUPPORTED);
    }
","START     @Override protected Pair<Recipients, Boolean> doInBackground(Recipients... recipients) { END 
      Capability textCapability = DirectoryHelper.getUserCapabilities(context, recipients[0]).getTextCapability();
      return new Pair<>(recipients[0], textCapability == Capability.SUPPORTED);
    }
","    protected Pair<Recipients, Boolean> doInBackground(Recipients... recipients) {
      Capability textCapability = DirectoryHelper.getUserCapabilities(context, recipients[0]).getTextCapability();
      return new Pair<>(recipients[0], textCapability == Capability.SUPPORTED);
    }
"
727,"Generally speaking, there's no need to null out the fields of an object if no one is going to hold the reference to the object afterwards. The GC is going to do its job, you don't need to help. :)","    public void cleanup() {
      myIdeFrame = null;
      myNavigationHelper.cleanup();
      myNavigationHelper = null;
      myStateComponent = null;
      myTaskContext = null;
    }
","    public void cleanup() {
      START  myIdeFrame = END  null;
      myNavigationHelper.cleanup();
      myNavigationHelper = null;
      myStateComponent = null;
      myTaskContext = null;
    }
","    public void cleanup() {
      myNavigationHelper.cleanup();
    }
"
728,Why is this public?,"    public static DateTime setBeginValidTime(DateTime beginValidTimeArg, DateTime issueInstant) {

        DateTime beginValidTime = beginValidTimeArg;
        final DateTime now = new DateTime();

        if (beginValidTime == null || beginValidTime.isAfter(now)) {
            beginValidTime = now;
        }
        // If provided time is after the given issue instant,
        // modify it to include the issue instant
        if (beginValidTime.isAfter(issueInstant)) {
            if (issueInstant.isAfter(now)) {
                beginValidTime = now;
            }
        } else {
            beginValidTime = issueInstant;
        }

        return beginValidTime;
    }
","START     public static DateTime setBeginValidTime(DateTime beginValidTimeArg, DateTime issueInstant) { END 

        DateTime beginValidTime = beginValidTimeArg;
        final DateTime now = new DateTime();

        if (beginValidTime == null || beginValidTime.isAfter(now)) {
            beginValidTime = now;
        }
        // If provided time is after the given issue instant,
        // modify it to include the issue instant
        if (beginValidTime.isAfter(issueInstant)) {
            if (issueInstant.isAfter(now)) {
                beginValidTime = now;
            }
        } else {
            beginValidTime = issueInstant;
        }

        return beginValidTime;
    }
","    private static DateTime setBeginValidTime(DateTime beginValidTimeArg, DateTime issueInstant) {

        DateTime beginValidTime = beginValidTimeArg;
        final DateTime now = new DateTime();

        if (beginValidTime == null || beginValidTime.isAfter(now)) {
            beginValidTime = now;
        }
        // If provided time is after the given issue instant,
        // modify it to include the issue instant
        if (beginValidTime.isAfter(issueInstant)) {
            if (issueInstant.isAfter(now)) {
                beginValidTime = now;
            }
        } else {
            beginValidTime = issueInstant;
        }

        return beginValidTime;
    }
"
729,"We do not have synchronized protection inside this function, If you would like to protect mUpdateLock from outside of this function, I think you may need to add a note to remind caller in the future to remember protect it.","    private void setupRestrictedNotification() {
        final Resources res = getResources(mContext, mActiveDataSubId);
        final String title = res.getString(R.string.disable_tether_notification_title);
        final String message = res.getString(R.string.disable_tether_notification_message);

        showNotification(R.drawable.stat_sys_tether_general, title, message, """");
    }
","    private void START  setupRestrictedNotification() END  {
        final Resources res = getResources(mContext, mActiveDataSubId);
        final String title = res.getString(R.string.disable_tether_notification_title);
        final String message = res.getString(R.string.disable_tether_notification_message);

        showNotification(R.drawable.stat_sys_tether_general, title, message, """");
    }
","    void setupRestrictedNotification() {
        final Resources res = getResources(mContext, mActiveDataSubId);
        final String title = res.getString(R.string.disable_tether_notification_title);
        final String message = res.getString(R.string.disable_tether_notification_message);

        showNotification(R.drawable.stat_sys_tether_general, title, message, """");
    }
"
730,Any specific reason to make this method no ``static`` anymore ?,"    private File getFeatureTypeDir(
            File featureTypesBaseDir, String namespacePrefix, String typeName) {
        return new File(featureTypesBaseDir, getDataStoreName(namespacePrefix, typeName));
    }
","START     private File getFeatureTypeDir( END 
            File featureTypesBaseDir, String namespacePrefix, String typeName) {
        return new File(featureTypesBaseDir, getDataStoreName(namespacePrefix, typeName));
    }
","    protected File getFeatureTypeDir(
            File featureTypesBaseDir, String namespacePrefix, String typeName) {
        return new File(featureTypesBaseDir, getDataStoreName(namespacePrefix, typeName));
    }
"
731,Just a note about consistency: does it make any sense to find free port and set system property if you're setting `org.uberfire.nio.git.daemon.enabled=false` on the lines below that?,"    public static void setupSystemProperties() {
        int freePort = TestUtilGit.findFreePort();
        System.setProperty(""org.uberfire.nio.git.daemon.port"", String.valueOf(freePort));
        logger.info(""Git port used:{}"", freePort);
        //These are not needed for the tests
        System.setProperty(""org.uberfire.nio.git.daemon.enabled"",
                           ""false"");
        System.setProperty(""org.uberfire.nio.git.ssh.enabled"",
                           ""false"");
        System.setProperty(""org.uberfire.sys.repo.monitor.disabled"",
                           ""true"");
    }
","    public static void setupSystemProperties() {
START         int freePort = TestUtilGit.findFreePort(); END 
        System.setProperty(""org.uberfire.nio.git.daemon.port"", String.valueOf(freePort));
        logger.info(""Git port used:{}"", freePort);
        //These are not needed for the tests
        System.setProperty(""org.uberfire.nio.git.daemon.enabled"",
                           ""false"");
        System.setProperty(""org.uberfire.nio.git.ssh.enabled"",
                           ""false"");
        System.setProperty(""org.uberfire.sys.repo.monitor.disabled"",
                           ""true"");
    }
","    public static void setupSystemProperties() {
        //These are not needed for the tests
        System.setProperty(""org.uberfire.nio.git.daemon.enabled"",
                           ""false"");
        System.setProperty(""org.uberfire.nio.git.ssh.enabled"",
                           ""false"");
        System.setProperty(""org.uberfire.sys.repo.monitor.disabled"",
                           ""true"");
    }
"
732,"""This method is not actually very useful and will likely be deprecated in the future.""","    public void setPreferredAgencies(String s) {
        if (s != null && !s.equals(""""))
            preferredAgencies = Sets.newHashSet(s.split("",""));
    }
","    public void setPreferredAgencies(String s) {
        if (s != null && !s.equals(""""))
START             preferredAgencies = Sets.newHashSet(s.split("","")); END 
    }
","    public void setPreferredAgencies(String s) {
        if (!s.isEmpty()) {
            preferredAgencies = new HashSet<>();
            Collections.addAll(preferredAgencies, s.split("",""));
        }
    }
"
733,"Thanks for the PR! I just noticed these two log messages are completely redundant; can we remove one of them, or combine into a single log?","    synchronized void updateSubscribedTopics(final Set<String> topics,
                                             final String logPrefix) {
        log.debug(""{}found {} topics possibly matching subscription"", logPrefix, topics.size());
        subscriptionUpdates.clear();
        subscriptionUpdates.addAll(topics);

        log.debug(""{}updating builder with {} topic(s) with possible matching regex subscription(s)"",
            logPrefix, subscriptionUpdates.size());
        setRegexMatchedTopicsToSourceNodes();
        setRegexMatchedTopicToStateStore();
    }
","    synchronized void updateSubscribedTopics(final Set<String> topics,
                                             final String logPrefix) {
START         log.debug(""{}found {} topics possibly matching subscription"", logPrefix, topics.size()); END 
        subscriptionUpdates.clear();
        subscriptionUpdates.addAll(topics);

        log.debug(""{}updating builder with {} topic(s) with possible matching regex subscription(s)"",
            logPrefix, subscriptionUpdates.size());
        setRegexMatchedTopicsToSourceNodes();
        setRegexMatchedTopicToStateStore();
    }
","    synchronized void updateSubscribedTopics(final Set<String> topics,
                                             final String logPrefix) {
        log.debug(""{}found {} topics possibly matching subscription"", logPrefix, topics.size());
        subscriptionUpdates.clear();
        subscriptionUpdates.addAll(topics);

        setRegexMatchedTopicsToSourceNodes();
        setRegexMatchedTopicToStateStore();
    }
"
734,why not put this with an `&&` in the previous `if`?,"  public void releaseCursor(Cursor cursor) {
    try {
      cursor.release();
      if (cursors.remove(cursor)) {
        if (provider.isClosed() && cursors.isEmpty()) {
          releaseResources();
        }
      }
    } catch (Exception e) {
      LOGGER.warn(""Exception was found trying to release cursor resources. Execution will continue"", e);
    } finally {
      statistics.decrementOpenCursors();
    }
  }
","  public void releaseCursor(Cursor cursor) {
    try {
      cursor.release();
      if (cursors.remove(cursor)) {
START         if (provider.isClosed() && cursors.isEmpty()) { END 
          releaseResources();
        }
      }
    } catch (Exception e) {
      LOGGER.warn(""Exception was found trying to release cursor resources. Execution will continue"", e);
    } finally {
      statistics.decrementOpenCursors();
    }
  }
","  public void releaseCursor(Cursor cursor) {
    try {
      cursor.release();
      if (cursors.remove(cursor) && provider.isClosed() && cursors.isEmpty()) {
        releaseResources();
      }
    } catch (Exception e) {
      LOGGER.warn(""Exception was found trying to release cursor resources. Execution will continue"", e);
    } finally {
      statistics.decrementOpenCursors();
    }
  }
"
735,Check for null missing?,"    protected void doStop() {
        autoEncryptionSupport.close();
        super.doStop();
        LDAPCache.clear();
    }
","    protected void doStop() {
START         autoEncryptionSupport.close(); END 
        super.doStop();
        LDAPCache.clear();
    }
","    protected void doStop() {
        if (autoEncryptionSupport != null) {
          autoEncryptionSupport.close();
        }
        super.doStop();
        LDAPCache.clear();
    }
"
736,make the constructor package private instead of private to avoid going through a generated synthetic constructor.,"    private Now(A a) {
      this.a = a;
    }
","START     private Now(A a) { END 
      this.a = a;
    }
","    Now(A a) {
      this.a = a;
    }
"
737,"I am not sure that toPortableString() is preferred here to just toString().
IPath.toString() makes only separator '/' for all platforms and it is what we need.
Docs say that if toPortableString() is used it has to be matched with fromPortableString() when converting back to Path.

toPortableString() doubles all ':' after the one that belongs to the device part (for Windows).
For example ""c:\one\two:x"" will be transformed into ""c://one/two::x"".
If segments have no ':' symbols, then there is no difference from toString().
However if a segment has ':' symbol, fromPortableString() is necessary to restore the original path, even for Linux.","	private String getWorkspaceRelativePath(String sourcePath) {
		if (org.apache.commons.lang.StringUtils.isBlank(sourcePath) || sourcePath.contains(""{"")) {
			return sourcePath;
		}
		IPath absolutePath = new Path(sourcePath);
		IContainer container = ResourcesPlugin.getWorkspace().getRoot().getContainerForLocation(absolutePath);
		if (container != null) {
			return container.getFullPath().toPortableString();
		}
		return null;
	}
","	private String getWorkspaceRelativePath(String sourcePath) {
		if (org.apache.commons.lang.StringUtils.isBlank(sourcePath) || sourcePath.contains(""{"")) {
			return sourcePath;
		}
		IPath absolutePath = new Path(sourcePath);
		IContainer container = ResourcesPlugin.getWorkspace().getRoot().getContainerForLocation(absolutePath);
		if (container != null) {
START 			return container.getFullPath().toPortableString(); END 
		}
		return null;
	}
","	private String getWorkspaceRelativePath(String sourcePath) {
		if (org.apache.commons.lang.StringUtils.isBlank(sourcePath) || sourcePath.contains(""{"")) {
			return sourcePath;
		}
		IPath absolutePath = new Path(sourcePath);
		IContainer container = ResourcesPlugin.getWorkspace().getRoot().getContainerForLocation(absolutePath);
		if (container != null) {
			return container.getFullPath().toString();
		}
		return null;
	}
"
738,style name wrong? should use the style.something()?,"    private void buildErrataDetailPanel() {
        errataDetailPanel.clear();
        errataDetailFormPanel = new GeneralFormPanel();
        errataTitle = new Span();
        errataTitle.setStyleName(style.errataTitleLabel());
        FlowPanel errataTitlePanel = new FlowPanel();
        errataTitlePanel.setStyleName(style.errataTitlePanel());
        errataTitlePanel.add(errataTitle);
        errataDetailPanel.add(errataTitlePanel);
        errataDetailPanel.setStyleName(""testtest""); //$NON-NLS-1$
        errataDetailPanel.add(errataDetailFormPanel);
    }
","    private void buildErrataDetailPanel() {
        errataDetailPanel.clear();
        errataDetailFormPanel = new GeneralFormPanel();
        errataTitle = new Span();
        errataTitle.setStyleName(style.errataTitleLabel());
        FlowPanel errataTitlePanel = new FlowPanel();
        errataTitlePanel.setStyleName(style.errataTitlePanel());
        errataTitlePanel.add(errataTitle);
        errataDetailPanel.add(errataTitlePanel);
START         errataDetailPanel.setStyleName(""testtest""); //$NON-NLS-1$ END 
        errataDetailPanel.add(errataDetailFormPanel);
    }
","    private void buildErrataDetailPanel() {
        errataDetailPanel.clear();
        errataDetailFormPanel = new GeneralFormPanel();
        errataTitle = new Span();
        errataTitle.setStyleName(style.errataTitleLabel());
        FlowPanel errataTitlePanel = new FlowPanel();
        errataTitlePanel.setStyleName(style.errataTitlePanel());
        errataTitlePanel.add(errataTitle);
        errataDetailPanel.add(errataTitlePanel);
        errataDetailPanel.add(errataDetailFormPanel);
    }
"
739,This subList should not be mutable to the caller.,"  public List<String> getMoreStable(String branch) {
    int i = order.indexOf(fullName(branch));
    if (0 <= i) {
      return order.subList(i + 1, order.size());
    } else {
      return Collections.emptyList();
    }
  }
","  public List<String> getMoreStable(String branch) {
    int i = order.indexOf(fullName(branch));
    if (0 <= i) {
START       return order.subList(i + 1, order.size()); END 
    } else {
      return Collections.emptyList();
    }
  }
","  public List<String> getMoreStable(String branch) {
    int i = order.indexOf(fullName(branch));
    if (0 <= i) {
      return order.subList(i + 1, order.size());
    } else {
      return ImmutableList.of();
    }
  }
"
740,why a check for the viewer here? shouldn't this be the dropdownTable? Now that we keep the table.,"    public void notifyListeners(int eventType, Event event) {
        if (this.dropdownTableViewer != null && !this.dropdownTable.isDisposed())
            this.dropdownTable.notifyListeners(eventType, event);
    }
","    public void notifyListeners(int eventType, Event event) {
        if START (this.dropdownTableViewer != END  null && !this.dropdownTable.isDisposed())
            this.dropdownTable.notifyListeners(eventType, event);
    }
","    public void notifyListeners(int eventType, Event event) {
        if (this.dropdownTable != null && !this.dropdownTable.isDisposed())
            this.dropdownTable.notifyListeners(eventType, event);
    }
"
741,Can't we move check to `BaseTestHiveImpersonation` and extend from some common Hive test class?,"  public static void setup() throws Exception {
    assumeTrue(""Skipping tests since Hive supports only JDK 8."", HiveTestUtilities.supportedJavaVersion());
    startMiniDfsCluster(TestSqlStdBasedAuthorization.class.getSimpleName());
    prepHiveConfAndData();
    setSqlStdBasedAuthorizationInHiveConf();
    startHiveMetaStore();
    startDrillCluster(true);
    addHiveStoragePlugin(getHivePluginConfig());
    addMiniDfsBasedStorage(new HashMap<>());
    generateTestData();
  }
","  public static void setup() throws Exception {
START     assumeTrue(""Skipping tests since Hive supports only JDK 8."", HiveTestUtilities.supportedJavaVersion()); END 
    startMiniDfsCluster(TestSqlStdBasedAuthorization.class.getSimpleName());
    prepHiveConfAndData();
    setSqlStdBasedAuthorizationInHiveConf();
    startHiveMetaStore();
    startDrillCluster(true);
    addHiveStoragePlugin(getHivePluginConfig());
    addMiniDfsBasedStorage(new HashMap<>());
    generateTestData();
  }
","  public static void setup() throws Exception {
    startMiniDfsCluster(TestSqlStdBasedAuthorization.class.getSimpleName());
    prepHiveConfAndData();
    setSqlStdBasedAuthorizationInHiveConf();
    startHiveMetaStore();
    startDrillCluster(true);
    addHiveStoragePlugin(getHivePluginConfig());
    addMiniDfsBasedStorage(new HashMap<>());
    generateTestData();
  }
"
742,these fields are already set by AOP in RetireSaveHandler and this needs to delegate to saveOrderType instead of calling the DAO just in case there is extra logic in the save method we don't want to by pass,"	public OrderType retireOrderType(OrderType orderType, String reason) {
		orderType.setRetired(true);
		orderType.setRetireReason(reason);
		return dao.saveOrderType(orderType);
	}
","	public OrderType retireOrderType(OrderType orderType, String reason) {
		orderType.setRetired(true);
START 		orderType.setRetireReason(reason); END 
		return dao.saveOrderType(orderType);
	}
","	public OrderType retireOrderType(OrderType orderType, String reason) {
		orderType.setRetired(true);
		orderType.setRetireReason(reason);
		return saveOrderType(orderType);
	}
"
743,rename 'child'?,"	private void updateFiltersCheckState() {
		Object[] children = filterContentProvider
				.getElements(getContentService());
		ICommonFilterDescriptor filterDescriptor;
		INavigatorFilterService filterService = getContentService()
				.getFilterService();
		for (Object element : children) {
			filterDescriptor = (ICommonFilterDescriptor) element;
			if(filterService.isActive(filterDescriptor.getId())) {
				getTableViewer().setChecked(element, true);
				getCheckedItems().add(element);
			} else {
				getTableViewer().setChecked(element, false);
			}
		}
	}
","	private void updateFiltersCheckState() {
		Object[] children = filterContentProvider
				.getElements(getContentService());
		ICommonFilterDescriptor filterDescriptor;
		INavigatorFilterService filterService = getContentService()
				.getFilterService();
		for (Object START  element : END  children) {
			filterDescriptor = (ICommonFilterDescriptor) element;
			if(filterService.isActive(filterDescriptor.getId())) {
				getTableViewer().setChecked(element, true);
				getCheckedItems().add(element);
			} else {
				getTableViewer().setChecked(element, false);
			}
		}
	}
","	private void updateFiltersCheckState() {
		ICommonFilterDescriptor filterDescriptor;
		INavigatorFilterService filterService = getContentService()
				.getFilterService();
		for (Object child : filterContentProvider.getElements(getContentService())) {
			filterDescriptor = (ICommonFilterDescriptor) child;
			if(filterService.isActive(filterDescriptor.getId())) {
				getTableViewer().setChecked(child, true);
				getCheckedItems().add(child);
			} else {
				getTableViewer().setChecked(child, false);
			}
		}
	}
"
744,This may return null if layer visibility = false,"    public FeatureTypeStyle transform(MBStyle styleContext, Double minScaleDenominator, Double maxScaleDenominator) {
        // Would prefer to accept zoom levels here (less concepts in our API)
        // If we accept zoom levels we may be able to reduce, and return a list of FeatureTypeStyles
        // (with the understanding that the list may be empty if the MBLayer does not contribute any content
        //  at a specific zoom level range)
        FeatureTypeStyle style = transform(styleContext);
        for (Rule rule : style.rules()) {
            if (minScaleDenominator != null) {
                rule.setMinScaleDenominator(minScaleDenominator);
            }
            if (maxScaleDenominator != null) {
                rule.setMaxScaleDenominator(maxScaleDenominator);
            }
        }
        return style;
    }
","    public FeatureTypeStyle transform(MBStyle styleContext, Double minScaleDenominator, Double maxScaleDenominator) {
        // Would prefer to accept zoom levels here (less concepts in our API)
        // If we accept zoom levels we may be able to reduce, and return a list of FeatureTypeStyles
        // (with the understanding that the list may be empty if the MBLayer does not contribute any content
        //  at a specific zoom level range)
START         FeatureTypeStyle style = transform(styleContext); END 
        for (Rule rule : style.rules()) {
            if (minScaleDenominator != null) {
                rule.setMinScaleDenominator(minScaleDenominator);
            }
            if (maxScaleDenominator != null) {
                rule.setMaxScaleDenominator(maxScaleDenominator);
            }
        }
        return style;
    }
","    public FeatureTypeStyle transform(MBStyle styleContext, Double minScaleDenominator, Double maxScaleDenominator) {
        // Would prefer to accept zoom levels here (less concepts in our API)
        // If we accept zoom levels we may be able to reduce, and return a list of FeatureTypeStyles
        // (with the understanding that the list may be empty if the MBLayer does not contribute any content
        //  at a specific zoom level range)
        FeatureTypeStyle style = transform(styleContext);
        if (style == null) {
            return null;
        }
        for (Rule rule : style.rules()) {
            if (minScaleDenominator != null) {
                rule.setMinScaleDenominator(minScaleDenominator);
            }
            if (maxScaleDenominator != null) {
                rule.setMaxScaleDenominator(maxScaleDenominator);
            }
        }
        return style;
    }
"
745,"The reason why ReachabilityChecker supports reusing an existing RevWalk (instead of maintaining our own), presumably, is so that we can save on object parsing. So I think it's less flexible if we set this here - the caller should be setting it if they know that they want it.","	public Optional<RevCommit> areAllReachable(Collection<RevCommit> targets,
			Collection<RevCommit> starters)
					throws MissingObjectException, IncorrectObjectTypeException,
					IOException {
		walk.reset();
		walk.setRetainBody(false);
		if (topoSort) {
			walk.sort(RevSort.TOPO);
		}

		for (RevCommit target: targets) {
			walk.markStart(target);
		}

		for (RevCommit starter : starters) {
			walk.markUninteresting(starter);
		}

		return Optional.ofNullable(walk.next());
	}
","	public Optional<RevCommit> areAllReachable(Collection<RevCommit> targets,
			Collection<RevCommit> starters)
					throws MissingObjectException, IncorrectObjectTypeException,
					IOException {
		walk.reset();
START 		walk.setRetainBody(false); END 
		if (topoSort) {
			walk.sort(RevSort.TOPO);
		}

		for (RevCommit target: targets) {
			walk.markStart(target);
		}

		for (RevCommit starter : starters) {
			walk.markUninteresting(starter);
		}

		return Optional.ofNullable(walk.next());
	}
","	public Optional<RevCommit> areAllReachable(Collection<RevCommit> targets,
			Collection<RevCommit> starters)
					throws MissingObjectException, IncorrectObjectTypeException,
					IOException {
		walk.reset();
		if (topoSort) {
			walk.sort(RevSort.TOPO);
		}

		for (RevCommit target: targets) {
			walk.markStart(target);
		}

		for (RevCommit starter : starters) {
			walk.markUninteresting(starter);
		}

		return Optional.ofNullable(walk.next());
	}
"
746,"shouldn't trackableSession be an Optional?

Either they are both or none are for me… actually, I don't think we really need to introduce Optional here, it is the caller that should be careful of not calling this with a null value!","    public Optional<SessionStore<J2EContext>> buildFromTrackableSession(final J2EContext context, final Object trackableSession) {
        return trackableSession == null ? Optional.empty() : Optional.of(new J2EProvidedSessionStore((HttpSession) trackableSession));
    }
","START     public Optional<SessionStore<J2EContext>> buildFromTrackableSession(final J2EContext context, final Object trackableSession) { END 
        return trackableSession == null ? Optional.empty() : Optional.of(new J2EProvidedSessionStore((HttpSession) trackableSession));
    }
","    public Optional<SessionStore<J2EContext>> buildFromTrackableSession(final J2EContext context, final Object trackableSession) {
        return trackableSession != null ? Optional.of(new J2EProvidedSessionStore((HttpSession) trackableSession)) : Optional.empty();
    }
"
747,I don't see any advantage of using `requireNonNull()`,"      public Response awaitResponse() throws Exception {
         return Objects.requireNonNull(remoteFuture).get();
      }
","      public Response awaitResponse() throws Exception {
START          return Objects.requireNonNull(remoteFuture).get(); END 
      }
","      public Response awaitResponse() throws Exception {
         return remoteFuture.get();
      }
"
748,"""<init>"".equals() is null safe and consistent to the last check in this method.","	static boolean isDefaultArgumentsConstructor(final MethodNode methodNode) {
		if (!methodNode.name.equals(""<init>"")) {
			return false;
		}
		final Type[] argumentTypes = Type.getMethodType(methodNode.desc)
				.getArgumentTypes();
		if (argumentTypes.length < 2) {
			return false;
		}
		return ""kotlin.jvm.internal.DefaultConstructorMarker""
				.equals(argumentTypes[argumentTypes.length - 1].getClassName());
	}
","	static boolean isDefaultArgumentsConstructor(final MethodNode methodNode) {
START 		if (!methodNode.name.equals(""<init>"")) { END 
			return false;
		}
		final Type[] argumentTypes = Type.getMethodType(methodNode.desc)
				.getArgumentTypes();
		if (argumentTypes.length < 2) {
			return false;
		}
		return ""kotlin.jvm.internal.DefaultConstructorMarker""
				.equals(argumentTypes[argumentTypes.length - 1].getClassName());
	}
","	static boolean isDefaultArgumentsConstructor(final MethodNode methodNode) {
		if (!""<init>"".equals(methodNode.name)) {
			return false;
		}
		final Type[] argumentTypes = Type.getMethodType(methodNode.desc)
				.getArgumentTypes();
		if (argumentTypes.length < 2) {
			return false;
		}
		return ""kotlin.jvm.internal.DefaultConstructorMarker""
				.equals(argumentTypes[argumentTypes.length - 1].getClassName());
	}
"
749,Where is currentSecond being updated?,"    public void increment(long amount) {
        long now = clock.now() / 1000L;
        if (now != currentSecond.get()) {
            currentCount.set(0);
        }
        long count = currentCount.addAndGet(amount);
        updatePeak(count);
    }
","    public void increment(long amount) {
        long now = clock.now() / 1000L;
START         if (now != currentSecond.get()) { END 
            currentCount.set(0);
        }
        long count = currentCount.addAndGet(amount);
        updatePeak(count);
    }
","    public void increment(long amount) {
        long now = clock.now() / 1000L;
        if (now != currentSecond.get()) {
            currentCount.set(0);
            currentSecond.set(now);
        }
        long count = currentCount.addAndGet(amount);
        updatePeak(count);
    }
"
750,Ack,"	public static void assertValidSubmodulePath(String path)
			throws SubmoduleValidationException {
		if (path.startsWith(""-"")) { //$NON-NLS-1$
			throw new SubmoduleValidationException(
					MessageFormat.format(
							JGitText.get().submodulePathInvalid, path),
					ObjectChecker.ErrorType.GITMODULES_PATH);
		}
	}
","	public static void assertValidSubmodulePath(String path)
			throws SubmoduleValidationException {
		if (path.startsWith(""-"")) { //$NON-NLS-1$
			throw new SubmoduleValidationException(
					MessageFormat.format(
							JGitText.get().submodulePathInvalid, path),
START 					ObjectChecker.ErrorType.GITMODULES_PATH); END 
		}
	}
","	public static void assertValidSubmodulePath(String path)
			throws SubmoduleValidationException {
		if (path.startsWith(""-"")) { //$NON-NLS-1$
			throw new SubmoduleValidationException(
					MessageFormat.format(
							JGitText.get().submodulePathInvalid, path),
					GITMODULES_PATH);
		}
	}
"
751,`ret` -> `message`,"    public String getMessage()
    {
        String ret = super.getMessage();
        if (pql.isPresent()) {
            ret += "" with pql \"""" + pql.get() + ""\"""";
        }
        return ret;
    }
","    public String getMessage()
    {
START         String ret = super.getMessage(); END 
        if (pql.isPresent()) {
            ret += "" with pql \"""" + pql.get() + ""\"""";
        }
        return ret;
    }
","    public String getMessage()
    {
        String message = super.getMessage();
        if (pql.isPresent()) {
            message += "" with pql \"""" + pql.get() + ""\"""";
        }
        return message;
    }
"
752,"Minor suggestion to change this exception to:
```
throw new IllegalArgumentException(""g may not be null."");
```","    protected AbstractGraphDecorator(Graph g) {
        if (g == null) {
            throw new NullPointerException(""g may not be null."");
        }
        this.inner = g;
    }
","    protected AbstractGraphDecorator(Graph g) {
        if (g == null) {
START             throw new NullPointerException(""g may not be null.""); END 
        }
        this.inner = g;
    }
","    protected AbstractGraphDecorator(Graph g) {
        if (g == null) {
            throw new IllegalArgumentException(""g may not be null."");
        }
        this.inner = g;
    }
"
753,"`return getCodecA() != null && (""dts"".contains(getCodecA()) || ""dca"".contains(getCodecA()));`","	public boolean isDTS() {
		return getCodecA() != null && (getCodecA().startsWith(""dts"") || ""dca"".equals(getCodecA()) || ""dca (dts)"".equals(getCodecA()));
	}
","	public boolean isDTS() {
START 		return getCodecA() != null && (getCodecA().startsWith(""dts"") || ""dca"".equals(getCodecA()) || ""dca (dts)"".equals(getCodecA())); END 
	}
","	public boolean isDTS() {
		return getCodecA() != null && (getCodecA().contains(""dts"") || getCodecA().contains(""dca""));
	}
"
754,This one shouldn't be public.,"   public CacheCollection<V> values(EnumSet<Flag> explicitFlags, ClassLoader explicitClassLoader) {
      return new ValueCacheCollection<>(this, cacheEntrySet(explicitFlags, explicitClassLoader));
   }
","START    public CacheCollection<V> values(EnumSet<Flag> explicitFlags, ClassLoader explicitClassLoader) { END 
      return new ValueCacheCollection<>(this, cacheEntrySet(explicitFlags, explicitClassLoader));
   }
","   CacheCollection<V> values(EnumSet<Flag> explicitFlags, ClassLoader explicitClassLoader) {
      return new ValueCacheCollection<>(this, cacheEntrySet(explicitFlags, explicitClassLoader));
   }
"
755,"Please, change as discussed.","	public synchronized void setBrightnessInUserInterfaceDimensionUnit(float percent) {
		if (percent < 0f) {
			percent = 0f;
		} else if (percent > 200f) {
			percent = 200f;
		}

		brightness = percent / 100f;
		changeShader = true;
		refreshTextures();
	}
","	public synchronized void setBrightnessInUserInterfaceDimensionUnit(float percent) {
		if (percent < 0f) {
			percent = 0f;
		} else if (percent > 200f) {
			percent = 200f;
		}

		brightness = percent / 100f;
START 		changeShader = true; END 
		refreshTextures();
	}
","	public synchronized void setBrightnessInUserInterfaceDimensionUnit(float percent) {
		if (percent < 0f) {
			percent = 0f;
		} else if (percent > 200f) {
			percent = 200f;
		}

		brightness = percent / 100f;
		refreshTextures(true);
	}
"
756,This is a backwards incompatible change and cannot be merged.,"    public Handles setForceEndTransactions(boolean forceEndTransactions) {
        this.forceEndTransactions = forceEndTransactions;
        return this;
    }
","START     public Handles setForceEndTransactions(boolean forceEndTransactions) { END 
        this.forceEndTransactions = forceEndTransactions;
        return this;
    }
","    public void setForceEndTransactions(boolean forceEndTransactions) {
        this.forceEndTransactions = forceEndTransactions;
    }
"
757,You should remove obsolete class casts,"    protected Cause createUpstreamCause(Run<?, ?> build) {
        if(Jenkins.getInstance().getPlugin(""promoted-builds"") != null) {
            // Test only when promoted-builds is installed.
            if(build instanceof Promotion) {
                Promotion promotion = (Promotion)build;
                
                // This cannot be done for PromotionCause#PromotionCause is in a package scope.
                // return new PromotionCause(build, promotion.getTarget());
                
                return new UpstreamCause((Run<?,?>)promotion.getTarget());
            }
        }
        return new UpstreamCause((Run) build);
    }
","    protected Cause createUpstreamCause(Run<?, ?> build) {
        if(Jenkins.getInstance().getPlugin(""promoted-builds"") != null) {
            // Test only when promoted-builds is installed.
            if(build instanceof Promotion) {
                Promotion promotion = (Promotion)build;
                
                // This cannot be done for PromotionCause#PromotionCause is in a package scope.
                // return new PromotionCause(build, promotion.getTarget());
                
                return new UpstreamCause((Run<?,?>)promotion.getTarget());
            }
        }
START         return new UpstreamCause((Run) build); END 
    }
","    protected Cause createUpstreamCause(Run<?, ?> build) {
        if(Jenkins.getInstance().getPlugin(""promoted-builds"") != null) {
            // Test only when promoted-builds is installed.
            if(build instanceof Promotion) {
                Promotion promotion = (Promotion)build;

                // This cannot be done for PromotionCause#PromotionCause is in a package scope.
                // return new PromotionCause(build, promotion.getTarget());

                return new UpstreamCause((Run<?,?>)promotion.getTarget());
            }
        }
        return new UpstreamCause(build);
    }
"
758,"Wouldn't it actually be better to check if instance of Date and then delegate to compare(Date, Date)?","	public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) {
		if (d1 == null) {
			return d2 == null;
		} else if (d2 == null) {
			return false;
		}
		return (d1 instanceof Timestamp || d2 instanceof Timestamp) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2);
	}
","	public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) {
		if (d1 == null) {
			return d2 == null;
		} else if (d2 == null) {
			return false;
		}
START 		return (d1 instanceof Timestamp || d2 instanceof Timestamp) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2); END 
	}
","	public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) {
		if (d1 == null) {
			return d2 == null;
		} else if (d2 == null) {
			return false;
		}
		return (d1 instanceof Date && d2 instanceof Date) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2);
	}
"
759,You don't need the `else` clause because the `if` clause does a `return`.,"        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( obj == null )
            {
                return false;
            }
            if ( getClass() != obj.getClass() )
            {
                return false;
            }
            final HeapObject other = (HeapObject) obj;
            if ( node == null )
            {
                return other.node == null;
            }
            else return node.equals(other.node);
        }
","        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( obj == null )
            {
                return false;
            }
            if ( getClass() != obj.getClass() )
            {
                return false;
            }
            final HeapObject other = (HeapObject) obj;
            if ( node == null )
            {
                return other.node == null;
            }
START             else return node.equals(other.node); END 
        }
","        public boolean equals( Object obj )
        {
            if ( this == obj )
            {
                return true;
            }
            if ( obj == null )
            {
                return false;
            }
            if ( getClass() != obj.getClass() )
            {
                return false;
            }
            final HeapObject other = (HeapObject) obj;
            if ( node == null )
            {
                return other.node == null;
            }
            return node.equals(other.node);
        }
"
760,I think in this class it is possible.,"    public void testSignalIntermediateThrow() throws Exception {
        KieBase kbase = createKnowledgeBase(""BPMN2-IntermediateThrowEventSignal.bpmn2"");
        ksession = createKnowledgeSession(kbase);
        Map<String, Object> params = new HashMap<String, Object>();
        params.put(""x"", ""MyValue"");
        ProcessInstance processInstance = ksession.startProcess(
                ""SignalIntermediateEvent"", params);
        Assertions.assertThat(processInstance.getState()).isEqualTo(ProcessInstance.STATE_COMPLETED);

    }
","    public void testSignalIntermediateThrow() throws Exception {
        KieBase kbase = createKnowledgeBase(""BPMN2-IntermediateThrowEventSignal.bpmn2"");
        ksession = createKnowledgeSession(kbase);
        Map<String, Object> params = new HashMap<String, Object>();
        params.put(""x"", ""MyValue"");
        ProcessInstance processInstance = ksession.startProcess(
                ""SignalIntermediateEvent"", params);
START         Assertions.assertThat(processInstance.getState()).isEqualTo(ProcessInstance.STATE_COMPLETED); END 

    }
","    public void testSignalIntermediateThrow() throws Exception {
        KieBase kbase = createKnowledgeBase(""BPMN2-IntermediateThrowEventSignal.bpmn2"");
        ksession = createKnowledgeSession(kbase);
        Map<String, Object> params = new HashMap<String, Object>();
        params.put(""x"", ""MyValue"");
        ProcessInstance processInstance = ksession.startProcess(
                ""SignalIntermediateEvent"", params);
        assertThat(processInstance.getState()).isEqualTo(ProcessInstance.STATE_COMPLETED);

    }
"
761,nit: how about `minhash.values().stream().forEach(this:: increaseTotalHllSize)`?,"    public KHyperLogLog(int maxSize, int hllBuckets, Long2ObjectSortedMap<HyperLogLog> minhash)
    {
        this.maxSize = maxSize;
        this.hllBuckets = hllBuckets;
        this.minhash = requireNonNull(minhash, ""minhash is null"");
        hllsTotalEstimatedInMemorySize = 0;
        hllsTotalEstimatedSerializedSize = 0;

        for (HyperLogLog hll : minhash.values()) {
            increaseTotalHllSize(hll);
        }
    }
","    public KHyperLogLog(int maxSize, int hllBuckets, Long2ObjectSortedMap<HyperLogLog> minhash)
    {
        this.maxSize = maxSize;
        this.hllBuckets = hllBuckets;
        this.minhash = requireNonNull(minhash, ""minhash is null"");
        hllsTotalEstimatedInMemorySize = 0;
        hllsTotalEstimatedSerializedSize = 0;

START         for (HyperLogLog hll : minhash.values()) { END 
            increaseTotalHllSize(hll);
        }
    }
","    public KHyperLogLog(int maxSize, int hllBuckets, Long2ObjectSortedMap<HyperLogLog> minhash)
    {
        this.maxSize = maxSize;
        this.hllBuckets = hllBuckets;
        this.minhash = requireNonNull(minhash, ""minhash is null"");

        minhash.values().forEach(this::increaseTotalHllSize);
    }
"
762,"This is dumb.  Add a Project.Id form to ProjectControl.GenericFactory and ProjectControl.Factory.  That way we only have to perform 1 cache lookup, not 2.","    public ChangeControl controlFor(Change change, CurrentUser user)
        throws NoSuchChangeException {
      final Project.NameKey projectKey = projectCache.get(change.getProject()).getProject().getNameKey();
      try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
      } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
      }
    }
","    public ChangeControl controlFor(Change change, CurrentUser user)
        throws NoSuchChangeException {
START       final Project.NameKey projectKey = projectCache.get(change.getProject()).getProject().getNameKey(); END 
      try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
      } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
      }
    }
","    public ChangeControl controlFor(Change change, CurrentUser user)
        throws NoSuchChangeException {
      try {
        return projectControl.controlFor(change.getProject(), user).controlFor(change);
      } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
      }
    }
"
763,"Should throw ```IllegalStateException``` , or similar.","    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (ShareFragmentListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString()
                    + "" must implement OnShareFragmentInteractionListener"");
        }
    }
","    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (ShareFragmentListener) activity;
        } catch (ClassCastException e) {
START             throw new ClassCastException(activity.toString() END 
                    + "" must implement OnShareFragmentInteractionListener"");
        }
    }
","    public void onAttach(Activity activity) {
        super.onAttach(activity);
        try {
            mListener = (ShareFragmentListener) activity;
        } catch (IllegalStateException e) {
            throw new IllegalStateException(activity.toString()
                    + "" must implement OnShareFragmentInteractionListener"");
        }
    }
"
764,"I wonder why we don't emit an event in this case.

Another thing is that I think in this case (using JMS) we will update autitTaskImpl in the database, but we currently don't update it in case we use normal JPA LifeCycleListener for tasks. Isn't this a little bit inconsistent?
https://github.com/kiegroup/jbpm/blob/25fabbca948df52f69475ca54a8cf85fe09e4074/jbpm-human-task/jbpm-human-task-audit/src/main/java/org/jbpm/services/task/audit/JPATaskLifeCycleEventListener.java#L743-L753
Here we just index and persist variables.","    public void afterTaskInputVariableChangedEvent(TaskEvent event, Map<String, Object> variables) {
        if (variables == null || variables.isEmpty()) {
            return;
        }
        Task task = event.getTask();               
        List<TaskVariableImpl> taskVariables = indexVariables(task, variables, VariableType.INPUT);
        
        AuditTaskImpl auditTaskImpl = createAuditTask(task, event.getEventDate());
        
        sendMessage(new AuditTaskData(auditTaskImpl, null, taskVariables, null), 2);
    }
","START     public void afterTaskInputVariableChangedEvent(TaskEvent event, Map<String, Object> variables) { END 
        if (variables == null || variables.isEmpty()) {
            return;
        }
        Task task = event.getTask();               
        List<TaskVariableImpl> taskVariables = indexVariables(task, variables, VariableType.INPUT);
        
        AuditTaskImpl auditTaskImpl = createAuditTask(task, event.getEventDate());
        
        sendMessage(new AuditTaskData(auditTaskImpl, null, taskVariables, null), 2);
    }
","    public void afterTaskInputVariableChangedEvent(TaskEvent event, Map<String, Object> variables) {
        if (variables == null || variables.isEmpty()) {
            return;
        }
        Task task = event.getTask();               
        List<TaskVariableImpl> taskVariables = indexVariables(task, variables, VariableType.INPUT);
        
        sendMessage(new AuditTaskData(null, null, taskVariables, null), 2);
    }
"
765,Remember to put {} around if/else/while/for etc.,"	public RubyGemParser(IFile file) throws IOException, CoreException {
		mSetupDefinitions = new HashMap<String, ArrayList<Object>>();
		mSetupDependencies = new HashMap<String, ArrayList<Object>>();
		if (file.getContents().available() <= 0)
			return;
		this.file = file;
		gemVariable = """";
		parse();
	}
","	public RubyGemParser(IFile file) throws IOException, CoreException {
		mSetupDefinitions = new HashMap<String, ArrayList<Object>>();
		mSetupDependencies = new HashMap<String, ArrayList<Object>>();
START 		if (file.getContents().available() <= 0) END 
			return;
		this.file = file;
		gemVariable = """";
		parse();
	}
","	public RubyGemParser(IFile file) throws IOException, CoreException {
		mSetupDefinitions = new HashMap<String, ArrayList<String>>();
		mSetupDependencies = new HashMap<String, ArrayList<String>>();
		if (file.getContents().available() <= 0) {
			return;
		}
		this.file = file;
		gemVariable = """";
		parse();
	}
"
766,I would turn this `&&` around. A simple deadlineName check is a lot cheaper than the full parameter assignment verification.,"        public boolean canHandle(Message<?> message) {
            return super.canHandle(message) && deadlineNameMatch((DeadlineMessage) message);
        }
","        public boolean canHandle(Message<?> message) {
START             return super.canHandle(message) && deadlineNameMatch((DeadlineMessage) message); END 
        }
","        public boolean canHandle(Message<?> message) {
            return message instanceof DeadlineMessage
                    && deadlineNameMatch((DeadlineMessage) message)
                    && super.canHandle(message);
        }
"
767,"This approach won't work if all the classes of a project are in a single root package:

```
package org;

import org.B;

class A {
  org.B b; // should be noncompliant
}
```

```
package org;

class B {
  ...
}
```

You probably should rather rely on the type of the symbol associated to the identifier of the parent member select, if the parent is a member select.

```
if (parent.is(Kind.MEMBER_SELECT)) {
  ExpressionTree expression = ((MemberSelectExpressionTree) parent).expression();
  if (expression.is(Kind.MEMBER_SELECT) && !((MemberSelectExpressionTree) expression).identifier().symbol().isTypeSymbol()) {
    return;
  }
  reportIssue(parent, String.format(MESSAGE, symbol.name()));
  hasIssue.add(parent);
}
```","  private void checkImportedSymbol(Symbol symbol) {
    for (IdentifierTree usageIdentifier : symbol.usages()) {
      Tree parent = usageIdentifier.parent();

      if (parent.is(Kind.MEMBER_SELECT) && ((MemberSelectExpressionTree) parent).expression().is(Kind.MEMBER_SELECT)) {
        reportIssue(parent, String.format(MESSAGE, symbol.name()));
        hasIssue.add(parent);
      }
    }
  }
","  private void checkImportedSymbol(Symbol symbol) {
    for (IdentifierTree usageIdentifier : symbol.usages()) {
      Tree parent = usageIdentifier.parent();

START       if (parent.is(Kind.MEMBER_SELECT) && ((MemberSelectExpressionTree) parent).expression().is(Kind.MEMBER_SELECT)) { END 
        reportIssue(parent, String.format(MESSAGE, symbol.name()));
        hasIssue.add(parent);
      }
    }
  }
","  private void checkImportedSymbol(Symbol symbol) {
    for (IdentifierTree usageIdentifier : symbol.usages()) {
      Tree parent = usageIdentifier.parent();

      if (parent.is(Kind.MEMBER_SELECT) && ((MemberSelectExpressionTree) parent).expression().is(Kind.MEMBER_SELECT)) {
        reportIssue(parent, String.format(MESSAGE, symbol.name()));
      }
    }
  }
"
768,"maybe, if @ Before doesn't work, create a method setUp for this? since the same code lines are in the beginning of each test of this class","    public void jmsPort_shouldBeExportedWithCorrectId() throws Exception {
        if (!featuresService.isInstalled(featuresService.getFeature(""openengsb-ports-ws""))) {
            featuresService.installFeature(""openengsb-ports-jms"");
        }

        OutgoingPort serviceWithId =
            OpenEngSBCoreServices.getServiceUtilsService().getServiceWithId(OutgoingPort.class, ""jms-json"", 60000);
        assertNotNull(serviceWithId);
    }
","    public void jmsPort_shouldBeExportedWithCorrectId() throws Exception {
START         if (!featuresService.isInstalled(featuresService.getFeature(""openengsb-ports-ws""))) { END 
            featuresService.installFeature(""openengsb-ports-jms"");
        }

        OutgoingPort serviceWithId =
            OpenEngSBCoreServices.getServiceUtilsService().getServiceWithId(OutgoingPort.class, ""jms-json"", 60000);
        assertNotNull(serviceWithId);
    }
","    public void jmsPort_shouldBeExportedWithCorrectId() throws Exception {
        OutgoingPort serviceWithId =
            OpenEngSBCoreServices.getServiceUtilsService().getServiceWithId(OutgoingPort.class, ""jms-json"", 60000);
        assertNotNull(serviceWithId);
    }
"
769,we have lambdas for this now.,"	private EventHandler createContextEventHandler() {
		if (contextEventHandler == null) {
			contextEventHandler = new EventHandler() {
				@Override
				public void handleEvent(Event event) {
					handleContextSet(event);
				}
			};
		}
		return contextEventHandler;
	}
","	private EventHandler createContextEventHandler() {
		if (contextEventHandler == null) {
			contextEventHandler = START  new EventHandler() { END 
				@Override
				public void handleEvent(Event event) {
					handleContextSet(event);
				}
			};
		}
		return contextEventHandler;
	}
","	private EventHandler createContextEventHandler() {
		if (contextEventHandler == null) {
			contextEventHandler = event -> handleContextSet(event);
		}
		return contextEventHandler;
	}
"
770,"Make the ""super"" dex field protected and remove this one? Or a protected getDexBuffer() method?","    public AnnotationValueReader(@Nonnull DexBuffer dex, @Nonnull ByteInput in) {
      super(dex, in);
      this.dex = dex;
    }
","    public AnnotationValueReader(@Nonnull DexBuffer dex, @Nonnull ByteInput in) {
      START  super(dex, in);
      this.dex = dex; END 
    }
","    public AnnotationValueReader(@Nonnull DexBuffer dex, @Nonnull ByteInput in) {
      super(dex, in);
    }
"
771,"You can pass `null` instead of `new HashMap<String, Serializable>()`.","    protected Blob convertBlobToMimeType(Blob blob, String destinationMimeType) {
        BlobHolder bh = new SimpleBlobHolder(blob);
        bh = convertToMimeType(destinationMimeType, bh, new HashMap<String, Serializable>());
        if (bh == null) {
            return null;
        }
        Blob result = bh.getBlob();
        return result;
    }
","    protected Blob convertBlobToMimeType(Blob blob, String destinationMimeType) {
        BlobHolder bh = new SimpleBlobHolder(blob);
START         bh = convertToMimeType(destinationMimeType, bh, new HashMap<String, Serializable>()); END 
        if (bh == null) {
            return null;
        }
        Blob result = bh.getBlob();
        return result;
    }
","    protected Blob convertBlobToMimeType(Blob blob, String destinationMimeType) {
        BlobHolder bh = new SimpleBlobHolder(blob);
        bh = convertToMimeType(destinationMimeType, bh, null);
        return bh == null ? null : bh.getBlob();
    }
"
772,i don't think redeclaring the type on the right side is needed.,"    private Set<SupportedAdditionalClusterFeature> getAdditionalClusterFeaturesAdded() {
        // Lets not modify the existing collection. Hence creating a new hashset.
        Set<SupportedAdditionalClusterFeature> featuresSupported =
                new HashSet<SupportedAdditionalClusterFeature>(getVdsGroup().getAddtionalFeaturesSupported());
        featuresSupported.removeAll(clusterFeatureDao.getSupportedFeaturesByClusterId(getVdsGroup().getId()));
        return featuresSupported;
    }
","    private Set<SupportedAdditionalClusterFeature> getAdditionalClusterFeaturesAdded() {
        // Lets not modify the existing collection. Hence creating a new hashset.
        Set<SupportedAdditionalClusterFeature> featuresSupported =
START                 new HashSet<SupportedAdditionalClusterFeature>(getVdsGroup().getAddtionalFeaturesSupported()); END 
        featuresSupported.removeAll(clusterFeatureDao.getSupportedFeaturesByClusterId(getVdsGroup().getId()));
        return featuresSupported;
    }
","    private Set<SupportedAdditionalClusterFeature> getAdditionalClusterFeaturesAdded() {
        // Lets not modify the existing collection. Hence creating a new hashset.
        Set<SupportedAdditionalClusterFeature> featuresSupported =
                new HashSet<>(getVdsGroup().getAddtionalFeaturesSupported());
        featuresSupported.removeAll(clusterFeatureDao.getSupportedFeaturesByClusterId(getVdsGroup().getId()));
        return featuresSupported;
    }
"
773,"Eeek, eatin away exceptions?","    static void runScript(String filename, Connection cx) throws SQLException {
        try {
            SqlUtil.runScript(new GeoPackage().getClass().getResourceAsStream(filename), cx);
        } catch (IOException e) {

        }
    }
","    static void runScript(String filename, Connection cx) throws SQLException {
        try {
            SqlUtil.runScript(new GeoPackage().getClass().getResourceAsStream(filename), cx);
        } catch (IOException e) {
START  END 
        }
    }
","    static void runScript(String filename, Connection cx) throws SQLException {
        try {
            SqlUtil.runScript(new GeoPackage().getClass().getResourceAsStream(filename), cx);
        } catch (IOException e) {
            throw new SQLException(e);
        }
    }
"
774,why stream? entrySet is iterable.,"    public void recycleAttributes(long ts) {
        fPoolAttributes.entrySet().stream().forEach(e -> {
            NonNullUtils.checkNotNull(e.getKey()).recycle(e.getValue(), ts);
        });
    }
","    public void recycleAttributes(long ts) {
        START fPoolAttributes.entrySet().stream().forEach(e END  -> {
            NonNullUtils.checkNotNull(e.getKey()).recycle(e.getValue(), ts);
        });
    }
","    public void recycleAttributes(long ts) {
        fPoolAttributes.entrySet().forEach(e -> {
            NonNullUtils.checkNotNull(e.getKey()).recycle(e.getValue(), ts);
        });
    }
"
775,please invert `if` condition,"        public boolean hasNext() {
            // If we do not have the next element pipelined, go ahead and fetch it.
            if (next == null) {
                // If the iterator is valid, this means that the next entry exists.
                checkInvariants();
                if (iterator.isValid()) {
                    // Go ahead and cache that entry.
                    next = new AbstractMap.SimpleEntry(
                            serializer.deserialize(Unpooled.wrappedBuffer(iterator.key()), corfuRuntime),
                            serializer.deserialize(Unpooled.wrappedBuffer(iterator.value()), corfuRuntime));
                    // Advance the underlying iterator.
                    iterator.next();
                } else {
                    // If there is no more elements to consume, we should release the resources.
                    iterator.close();
                }
            }

            return next != null;
        }
","        public boolean hasNext() {
            // If we do not have the next element pipelined, go ahead and fetch it.
START             if (next == null) { END 
                // If the iterator is valid, this means that the next entry exists.
                checkInvariants();
                if (iterator.isValid()) {
                    // Go ahead and cache that entry.
                    next = new AbstractMap.SimpleEntry(
                            serializer.deserialize(Unpooled.wrappedBuffer(iterator.key()), corfuRuntime),
                            serializer.deserialize(Unpooled.wrappedBuffer(iterator.value()), corfuRuntime));
                    // Advance the underlying iterator.
                    iterator.next();
                } else {
                    // If there is no more elements to consume, we should release the resources.
                    iterator.close();
                }
            }

            return next != null;
        }
","        public boolean hasNext() {
            // If we have the next element pipelined, go ahead and return true.
            if (next != null) {
                return true;
            }

            // If the iterator is valid, this means that the next entry exists.
            checkInvariants();
            if (iterator.isValid()) {
                // Go ahead and cache that entry.
                next = new AbstractMap.SimpleEntry(
                        serializer.deserialize(Unpooled.wrappedBuffer(iterator.key()), corfuRuntime),
                        serializer.deserialize(Unpooled.wrappedBuffer(iterator.value()), corfuRuntime));
                // Advance the underlying iterator.
                iterator.next();
            } else {
                // If there is no more elements to consume, we should release the resources.
                iterator.close();
            }

            return next != null;
        }
"
776,Missing braces,"	public int run() throws IOException {
		int b;
		if (in != null) {
			while ((b = in.read()) != -1)
				out.write(b);
			in.close();
		}
		out.close();
		return -1;
	}
","	public int run() throws IOException {
		int b;
		if (in != null) {
START 			while ((b = in.read()) != -1)
				out.write(b); END 
			in.close();
		}
		out.close();
		return -1;
	}
","	public int run() throws IOException {
		int b;
		if (in != null) {
			while ((b = in.read()) != -1) {
				out.write(b);
			}
			in.close();
		}
		out.close();
		return -1;
	}
"
777,"Do you have a voided field in this cohort_member table? In theory members don't get removed from the set.
You might need to update Cohort.removeMember() to set stop date instead of removing. Which means that getCohortsContainingPatientId() should return cohorts that contain the patient as of the current date i.e members that have no stop date or those where the startDate is before current date and end date is after current date","	public List<Cohort> getCohortsContainingPatientId(Integer patientId) throws DAOException {
		return (List<Cohort>) sessionFactory.getCurrentSession().createCriteria(Cohort.class)
                .add(Restrictions.eq(""voided"", false))
                .createAlias(""members"", ""m"")
                .createAlias(""m.patientId"", ""p"")
                .add(Restrictions.eq(""p.patientId"", patientId))
                .list();
	}
","	public List<Cohort> getCohortsContainingPatientId(Integer patientId) throws DAOException {
		return (List<Cohort>) sessionFactory.getCurrentSession().createCriteria(Cohort.class)
START                 .add(Restrictions.eq(""voided"", false)) END 
                .createAlias(""members"", ""m"")
                .createAlias(""m.patientId"", ""p"")
                .add(Restrictions.eq(""p.patientId"", patientId))
                .list();
	}
","	public List<Cohort> getCohortsContainingPatientId(Integer patientId) throws DAOException {
		return getCohortsContainingPatientId(patientId, false);
	}
"
778,How can this succeed if `tupleWriter.open()` isn't called (when `dataSink` is `null`)?,"  protected void init(final ImmutableMap<String, Object> execEnvVars) throws DbException {
    try {
      if (dataSink != null) {
        tupleWriter.open(dataSink.getOutputStream());
      }
      tupleWriter.writeColumnHeaders(getChild().getSchema().getColumnNames());
    } catch (IOException e) {
      throw new DbException(e);
    }
  }
","  protected void init(final ImmutableMap<String, Object> execEnvVars) throws DbException {
    try {
      if (dataSink != null) {
        tupleWriter.open(dataSink.getOutputStream());
      }
START       tupleWriter.writeColumnHeaders(getChild().getSchema().getColumnNames()); END 
    } catch (IOException e) {
      throw new DbException(e);
    }
  }
","  protected void init(final ImmutableMap<String, Object> execEnvVars) throws DbException {
    try {
      tupleWriter.open(dataSink.getOutputStream());
      tupleWriter.writeColumnHeaders(getChild().getSchema().getColumnNames());
    } catch (IOException e) {
      throw new DbException(e);
    }
  }
"
779,"use partitionData.length for consistency with getRetainedSizeInBytes

```
        public long getSizeInBytes()
        {
            long sizeInBytes = 0;
            for (int i = 0; i < partitionData.length; i++) {
                sizeInBytes += partitionData[i].getSizeInBytes();
            }
            return sizeInBytes;
        }
```","        public long getSizeInBytes()
        {
            long sizeInBytes = 0;
            int partitionCount = partitionFunction.getPartitionCount();
            for (int i = 0; i < partitionCount; i++) {
                sizeInBytes += partitionData[i].getSizeInBytes();
            }
            return sizeInBytes;
        }
","        public long getSizeInBytes()
        {
            long sizeInBytes = 0;
START             int partitionCount = partitionFunction.getPartitionCount(); END 
            for (int i = 0; i < partitionCount; i++) {
                sizeInBytes += partitionData[i].getSizeInBytes();
            }
            return sizeInBytes;
        }
","        public long getSizeInBytes()
        {
            long sizeInBytes = 0;
            for (int i = 0; i < partitionData.length; i++) {
                sizeInBytes += partitionData[i].getSizeInBytes();
            }

            return sizeInBytes;
        }
"
780,"Replace by `this(name, value, value, model);`","    public FixedRealVarImpl(String name, double value, Model model) {
        super(name, model);
        this.lb = value;
        this.ub = value;
    }
","    public FixedRealVarImpl(String name, double value, Model model) {
START         super(name, model);
        this.lb = value;
        this.ub = value; END 
    }
","    public FixedRealVarImpl(String name, double value, Model model) {
        this(name, value, value, model);
    }
"
781,"I'd expect this to be the other way around, when version is a WAN version.

I'm thinking about subclassing `Version`. That way we can create `ClusterVersion` and `WanVersion` that can
- compare/sort the versions properly,
- validate that once we set a cluster version, it can't be replaced by a WAN version (checking the sign bit) and vice-versa.

WDYT?","    public void isGreaterThan() {
        assertTrue(V3_0.isGreaterThan(of(2, 0)));
        assertFalse(V3_0.isGreaterThan(of(3, 0)));
        assertFalse(V3_0.isGreaterThan(of(4, 0)));
        assertTrue(V3_0.isGreaterThan(NEGATIVE_VERSION_1));
        assertTrue(NEGATIVE_VERSION_1.isGreaterThan(NEGATIVE_VERSION_2));
    }
","    public void isGreaterThan() {
        assertTrue(V3_0.isGreaterThan(of(2, 0)));
        assertFalse(V3_0.isGreaterThan(of(3, 0)));
        assertFalse(V3_0.isGreaterThan(of(4, 0)));
        assertTrue(V3_0.isGreaterThan(NEGATIVE_VERSION_1));
START         assertTrue(NEGATIVE_VERSION_1.isGreaterThan(NEGATIVE_VERSION_2)); END 
    }
","    public void isGreaterThan() throws Exception {
        assertTrue(V3_0.isGreaterThan(of(2, 0)));
        assertFalse(V3_0.isGreaterThan(of(3, 0)));
        assertFalse(V3_0.isGreaterThan(of(4, 0)));
    }
"
782,"I think that it is ok, although I am not sure how I feel about including the ""\n"".","    private String extractDefinitionLine(String typeDeclaration)
    {
        String typeLine = """";
        String[] lines = typeDeclaration.split(""\n"");
        for (String line : lines)
        {
            typeLine = typeLine + ""\n"" + line;
            if (line.contains(""{""))
            {
                break;
            }
        }
        return typeLine;
    }
","    private String extractDefinitionLine(String typeDeclaration)
    {
        String typeLine = """";
        String[] lines = typeDeclaration.split(""\n"");
        for (String line : lines)
        {
            typeLine = typeLine + ""\n"" + line;
            if (line.contains(""{""))
            {
                break;
            }
        }
        return typeLine;
START     } END 
","    private String extractDefinitionLine(String typeDeclaration)
    {
        String typeLine = """";
        String[] lines = typeDeclaration.split(""\n"");
        for (String line : lines)
        {
            typeLine = line;
            if (line.contains(""{""))
            {
                break;
            }
        }
        return typeLine;
    }
"
783,stackable armo(u)r?,"    public ItemAshenMask(ArmorMaterial material, int renderIndex, EntityEquipmentSlot slot, AshenMasks maskType) {
        super(material, renderIndex, slot);
        setHasSubtypes(true);
        this.maxStackSize = 64;
        this.maskType = maskType;
        ItemRegistry.maskMap.put(maskType, this);
    }
","    public ItemAshenMask(ArmorMaterial material, int renderIndex, EntityEquipmentSlot slot, AshenMasks maskType) {
        super(material, renderIndex, slot);
        setHasSubtypes(true);
START         this.maxStackSize = 64; END 
        this.maskType = maskType;
        ItemRegistry.maskMap.put(maskType, this);
    }
","    public ItemAshenMask(ArmorMaterial material, int renderIndex, EntityEquipmentSlot slot, AshenMasks maskType) {
        super(material, renderIndex, slot);
        this.maskType = maskType;
        ItemRegistry.maskMap.put(maskType, this);
    }
"
784,"I don't understand the `if` here. If the errorCount() was higher or equal to `config.storeIOErrorCountToTriggerShutdown`,  won't the store be shutting/shut down?","  private void onSuccess() {
    if (errorCount.getAndSet(0) >= config.storeIOErrorCountToTriggerShutdown) {
      logger.info(""Resetting the error count of BlobStore {} because restart or one operation succeeded"", storeId);
    }
  }
","  private void onSuccess() {
START     if (errorCount.getAndSet(0) >= config.storeIOErrorCountToTriggerShutdown) { END 
      logger.info(""Resetting the error count of BlobStore {} because restart or one operation succeeded"", storeId);
    }
  }
","  private void onSuccess() {
    errorCount.getAndSet(0);
  }
"
785,Perhaps the '104' could be a constant?,"      private ApplicationReportModel createAppDependencyGraphReport(GraphContext context)
      {
         ApplicationReportService applicationReportService = new ApplicationReportService(context);
         ApplicationReportModel report = applicationReportService.create();
         report.setReportPriority(104);
         report.setReportIconClass(""glyphicon glyphicon-tree-deciduous"");
         report.setTemplatePath(TEMPLATE);
         report.setTemplateType(TemplateType.FREEMARKER);
         report.setDisplayInApplicationReportIndex(Boolean.TRUE);
         report.setDescription(REPORT_DESCRIPTION);
         return report;
      }
","      private ApplicationReportModel createAppDependencyGraphReport(GraphContext context)
      {
START          ApplicationReportService applicationReportService = new ApplicationReportService(context); END 
         ApplicationReportModel report = applicationReportService.create();
         report.setReportPriority(104);
         report.setReportIconClass(""glyphicon glyphicon-tree-deciduous"");
         report.setTemplatePath(TEMPLATE);
         report.setTemplateType(TemplateType.FREEMARKER);
         report.setDisplayInApplicationReportIndex(Boolean.TRUE);
         report.setDescription(REPORT_DESCRIPTION);
         return report;
      }
","      private ApplicationReportModel createAppDependencyGraphReport(GraphContext context)
      {
         ApplicationReportService applicationReportService = new ApplicationReportService(context);
         ApplicationReportModel report = applicationReportService.create();
         report.setReportPriority(104);
         report.setReportIconClass(""glyphicon glyphicon-tree-deciduous"");
         report.setTemplatePath(TEMPLATE);
         report.setTemplateType(TemplateType.FREEMARKER);
         report.setDisplayInApplicationReportIndex(Boolean.TRUE);
         return report;
      }
"
786,Should this not be WARN or some exception thrown? Instead of logging that the ip is incorrect. And maybe this validation should be done in the doStart method so its validated earlier,"    private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException {
        if (client == null) {
            LOG.info(""Connecting to the ElasticSearch cluster: "" + configuration.getClusterName());
            if (configuration.getHostAddressesList() != null
                && !configuration.getHostAddressesList().isEmpty()) {
                client = createClient();
            } else {
                LOG.info(""Incorrect ip address and port parameters settings for ElasticSearch cluster"");
            }
        }
    }
","    private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException {
        if (client == null) {
            LOG.info(""Connecting to the ElasticSearch cluster: "" + configuration.getClusterName());
            if (configuration.getHostAddressesList() != null
                && !configuration.getHostAddressesList().isEmpty()) {
                client = createClient();
            } else {
START                 LOG.info(""Incorrect ip address and port parameters settings for ElasticSearch cluster""); END 
            }
        }
    }
","    private void startClient() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, UnknownHostException {
        if (client == null) {
            LOG.info(""Connecting to the ElasticSearch cluster: "" + configuration.getClusterName());
            if (configuration.getHostAddressesList() != null
                && !configuration.getHostAddressesList().isEmpty()) {
                client = createClient();
            } else {
                LOG.warn(""Incorrect ip address and port parameters settings for ElasticSearch cluster"");
            }
        }
    }
"
787,shouldn't the message get the 'size'?,"    protected String getRemoveQosMessage(int size) {
        return ConstantsManager.getInstance().getMessages().removeStorageQoSMessage();
    }
","    protected String getRemoveQosMessage(int size) {
START         return ConstantsManager.getInstance().getMessages().removeStorageQoSMessage(); END 
    }
","    protected String getRemoveQosMessage(int size) {
        return ConstantsManager.getInstance().getMessages().removeStorageQoSMessage(size);
    }
"
788,Just use images.forEach,"    public static Map<Guid, List<DiskImage>> getImagesLeaf(List<DiskImage> images) {
        Map<Guid, List<DiskImage>> retVal = new HashMap<>();
        images.stream().forEach(image -> MultiValueMapUtils.addToMap(image.getId(), image, retVal));
        retVal.values().forEach(ImagesHandler::sortImageList);
        return retVal;
    }
","    public static Map<Guid, List<DiskImage>> getImagesLeaf(List<DiskImage> images) {
        Map<Guid, List<DiskImage>> retVal = new HashMap<>();
        START  images.stream().forEach(image END  -> MultiValueMapUtils.addToMap(image.getId(), image, retVal));
        retVal.values().forEach(ImagesHandler::sortImageList);
        return retVal;
    }
","    public static Map<Guid, List<DiskImage>> getImagesLeaf(List<DiskImage> images) {
        Map<Guid, List<DiskImage>> retVal = new HashMap<>();
        images.forEach(image -> MultiValueMapUtils.addToMap(image.getId(), image, retVal));
        retVal.values().forEach(ImagesHandler::sortImageList);
        return retVal;
    }
"
789,"What is the contract for the return of this method? If we are already at the state that we are trying to move to, it could be said that the moveToState is successful (i.e. true).","    protected boolean moveToState(STATE to) {
        if (state.get() == to) {
            return false;
        }
        return moveToState(state.get(), to);
    }
","    protected boolean moveToState(STATE to) {
        if (state.get() == to) {
START             return false; END 
        }
        return moveToState(state.get(), to);
    }
","    protected void moveToState(STATE to) {
        if (state.get() != to) {
            moveToState(state.get(), to);
        }
    }
"
790,@NielsCharlier try-with-resources?,"    public void writeTo(Resource file) throws JDOMException, IOException {
        OutputStream out = path.out();
        try {
            IOUtils.write(body, out);
        } finally {
            out.close();
        }
    }
","    public void writeTo(Resource file) throws JDOMException, IOException {
        OutputStream out = path.out();
        try {
            IOUtils.write(body, out);
        } finally {
            out.close();
START         } END 
    }
","    public void writeTo(Resource file) throws JDOMException, IOException {
        try (OutputStream out = path.out()) {
            IOUtils.write(body, out);
        }
    }
"
791,The class is abstract. Constructor should be `protected`,"    public ApplicationFetchException(String apiKey, ErrorCode errorCode) {
        super();
        this.apiKey = apiKey;
        this.errorCode = errorCode;
    }
","START     public ApplicationFetchException(String apiKey, ErrorCode errorCode) { END 
        super();
        this.apiKey = apiKey;
        this.errorCode = errorCode;
    }
","    protected ApplicationFetchException(String apiKey, ErrorCode errorCode) {
        super();
        this.apiKey = apiKey;
        this.errorCode = errorCode;
    }
"
792,"using this approach only root collections will have validatorLocator, all sub-collections/resources will get NPE, when you'll try to use it,

you need to inject it in runtime to every resource.","    private void addResource(final BackendResource resource) {
        resource.setMessageBundle(messageBundle);
        resource.setBackend(backend);
        resource.setSessionHelper(sessionHelper);
        if (resource instanceof AbstractBackendResource) {
            ((AbstractBackendResource) resource).setMappingLocator(mappingLocator);
        }
        else if (resource instanceof CapabilitiesResource) {
            ((BackendCapabilitiesResource) resource).setMappingLocator(mappingLocator);
        }
        resource.setValidatorLocator(validatorLocator);
        singletons.add(resource);
    }
","    private void addResource(final BackendResource resource) {
        resource.setMessageBundle(messageBundle);
        resource.setBackend(backend);
        resource.setSessionHelper(sessionHelper);
        if (resource instanceof AbstractBackendResource) {
            ((AbstractBackendResource) resource).setMappingLocator(mappingLocator);
        }
        else if (resource instanceof CapabilitiesResource) {
            ((BackendCapabilitiesResource) resource).setMappingLocator(mappingLocator);
        }
START         resource.setValidatorLocator(validatorLocator); END 
        singletons.add(resource);
    }
","    private void addResource(final BackendResource resource) {
        resource.setMessageBundle(messageBundle);
        resource.setBackend(backend);
        resource.setSessionHelper(sessionHelper);
        if (resource instanceof AbstractBackendResource) {
            ((AbstractBackendResource) resource).setMappingLocator(mappingLocator);
        }
        else if (resource instanceof CapabilitiesResource) {
            ((BackendCapabilitiesResource) resource).setMappingLocator(mappingLocator);
        }
        singletons.add(resource);
    }
"
793,listeners is atomic,"   public boolean isEmpty()
   {
      synchronized (listeners)
      {
         return listeners.size() == 0;
      }
   }
","   public boolean isEmpty()
   {
START       synchronized (listeners) END 
      {
         return listeners.size() == 0;
      }
   }
","   public boolean isEmpty()
   {
      return listeners.isEmpty();
   }
"
794,"Here we need to take sequence number wrap around into account. Alternatively, what we could do is unconditionally set the `maxSeen`, and prevent the `maxSeen` from being set if the `end` has been set.

However, I don't like adding this kind of logic in the setters. Maybe it'd be better to have a getMaxOrEnd() method.","    void setEnd(int end)
    {
        this.end = end;
        if (this.end > this.maxSeen)
        {
            this.maxSeen = this.end;
        }
    }
","    void setEnd(int end)
    {
        this.end = end;
START         if (this.end > this.maxSeen) END 
        {
            this.maxSeen = this.end;
        }
    }
","    void setEnd(int end)
    {
        this.end = end;
    }
"
795,"> Use this.mHandler.removeCallbacksAndMessages(null) instead.

Done in Patch set 2","    public void dispose() {
        //Remove all messages from the queue
        this.mHandler.removeCallbacksAndMessages(null);

        this.mHandler = null;
        this.mPhone = null;
    }
","    public void dispose() {
        //Remove all messages from the queue
START         this.mHandler.removeCallbacksAndMessages(null); END 

        this.mHandler = null;
        this.mPhone = null;
    }
","    public void dispose() {
    }
"
796,"a couple of questions:
- can't you return true here?
- is it possible to configure multiple directory providers?","   public boolean indexShareable() {
      TypedProperties properties = properties();
      boolean hasRamDirectoryProvider = false;
      boolean hasOtherDirectoryProvider = false;
      for (Object objKey : properties.keySet()) {
         String key = (String) objKey;
         if (key.endsWith(DIRECTORY_PROVIDER_KEY)) {
            if (properties.get(key).equals(RAM_DIRECTORY_PROVIDER)) {
               hasRamDirectoryProvider = true;
            } else {
               hasOtherDirectoryProvider = true;
            }
         }
      }
      boolean ramOnly = hasRamDirectoryProvider && !hasOtherDirectoryProvider;
      return !ramOnly;
   }
","   public boolean indexShareable() {
      TypedProperties properties = properties();
      boolean hasRamDirectoryProvider = false;
      boolean hasOtherDirectoryProvider = false;
      for (Object objKey : properties.keySet()) {
         String key = (String) objKey;
         if (key.endsWith(DIRECTORY_PROVIDER_KEY)) {
            if (properties.get(key).equals(RAM_DIRECTORY_PROVIDER)) {
               hasRamDirectoryProvider = true;
            } else {
START                hasOtherDirectoryProvider = true; END 
            }
         }
      }
      boolean ramOnly = hasRamDirectoryProvider && !hasOtherDirectoryProvider;
      return !ramOnly;
   }
","   public boolean indexShareable() {
      TypedProperties properties = properties();
      boolean hasRamDirectoryProvider = false;
      for (Object objKey : properties.keySet()) {
         String key = (String) objKey;
         if (key.endsWith(DIRECTORY_PROVIDER_KEY)) {
            if (properties.get(key).equals(RAM_DIRECTORY_PROVIDER)) {
               hasRamDirectoryProvider = true;
            } else {
               return true;
            }
         }
      }
      return !hasRamDirectoryProvider;
   }
"
797,move this to the first line of this method for optimization.,"    public boolean delete( final ConcreteResource resource, final EventMetadata eventMetadata )
        throws TransferException
    {
        final Transfer item = getCacheReference( resource );
        if ( !resource.allowsDeletion() )
        {
            throw new TransferException( ""Deletion not allowed for: {}"", resource );
        }
        return doDelete( item, eventMetadata );
    }
","    public boolean delete( final ConcreteResource resource, final EventMetadata eventMetadata )
        throws TransferException
    {
        final Transfer item = getCacheReference( resource );
        if ( !resource.allowsDeletion() )
        {
            throw new TransferException( ""Deletion not allowed for: {}"", resource );
START         } END 
        return doDelete( item, eventMetadata );
    }
","    public boolean delete( final ConcreteResource resource, final EventMetadata eventMetadata )
        throws TransferException
    {
        if ( !resource.allowsDeletion() )
        {
            throw new TransferException( ""Deletion not allowed for: {}"", resource );
        }

        final Transfer item = getCacheReference( resource );
        return doDelete( item, eventMetadata );
    }
"
798,when will it be < 0? isnt it better to use Integer that can be null? (like other fields in vm dynamic),"    public String getActualCpuTopology() {
        if (actualCpuTopology < 0) {
            return ConstantsManager.getInstance().getConstants().notAvailableLabel();
        } else {
            return String.valueOf(actualCpuTopology);
        }
    }
","    public String getActualCpuTopology() {
START         if (actualCpuTopology < 0) { END 
            return ConstantsManager.getInstance().getConstants().notAvailableLabel();
        } else {
            return String.valueOf(actualCpuTopology);
        }
    }
","    public String getActualCpuTopology() {
        if (actualCpuTopology > 0) {
            return String.valueOf(actualCpuTopology);
        } else {
            return ConstantsManager.getInstance().getConstants().notAvailableLabel();
        }
    }
"
799,Oh I see now it does get slightly darker when you manually page. It was so subtle I didn't see it at first.,"    public void onPageScrolled(int i, float v, int i2) {
        if (pager.getCurrentItem() != 0) {
            speakerbox.stop();
        }

        if (pager.getCurrentItem() == pagerPositionWhenPaused) {
            resume.setVisibility(View.GONE);
            getView().findViewById(R.id.routes).setBackgroundColor(act.getBaseContext()
                    .getResources().getColor(R.color.transparent_white));
        }
    }
","    public void onPageScrolled(int i, float v, int i2) {
        if (pager.getCurrentItem() != 0) {
            speakerbox.stop();
        }

        if (pager.getCurrentItem() == pagerPositionWhenPaused) {
            resume.setVisibility(View.GONE);
START             getView().findViewById(R.id.routes).setBackgroundColor(act.getBaseContext() END 
                    .getResources().getColor(R.color.transparent_white));
        }
    }
","    public void onPageScrolled(int i, float v, int i2) {
        if (pager.getCurrentItem() != 0) {
            speakerbox.stop();
        }

        if (pager.getCurrentItem() == pagerPositionWhenPaused) {
            resume.setVisibility(View.GONE);
        }
    }
"
800,"If an exception can be thrown, then wrap wavTrack.close() in a try-finally block, to guarantee resources are properly closed.","    public void benchWavTrack() throws Exception {      
        WavTrack wavTrack = new WavTrack(url);
        boolean isEOMReached = false;
        while (!isEOMReached) {
            Frame process = wavTrack.process(0);
            isEOMReached = process.isEOM();
        }
        wavTrack.close();
    }
","    public void benchWavTrack() throws Exception {      
        WavTrack wavTrack = new WavTrack(url);
        boolean isEOMReached = false;
        while (!isEOMReached) {
            Frame process = wavTrack.process(0);
            isEOMReached = process.isEOM();
        }
START         wavTrack.close(); END 
    }
","    public void benchWavTrack() throws Exception {      
        try {
            wavTrack = new WavTrack(url);
            boolean isEOMReached = false;
            while (!isEOMReached) {
                Frame process = wavTrack.process(0);
                isEOMReached = process.isEOM();
            }
        }finally {
             wavTrack.close();
        }
    }
"
801,aren't these already set by logging.properties?,"    private static void setupLogger(Map<String, Object> args) throws IOException{
        String logfile = (String)args.get(""log-file"");
        Logger logger = Logger.getLogger("""");
        logger.setLevel((Level)args.get(""log-level""));
        logger.addHandler(new ConsoleHandler());
        if(logfile != null) {
            FileHandler fh = new FileHandler(logfile);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
        }
    }
","    private static void setupLogger(Map<String, Object> args) throws IOException{
        String logfile = (String)args.get(""log-file"");
        Logger logger = Logger.getLogger("""");
        logger.setLevel((Level)args.get(""log-level""));
        logger.addHandler(new ConsoleHandler());
        if(logfile != null) {
            FileHandler fh = new FileHandler(logfile);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
START         } END 
    }
","    private void setupLogger(Map<String, Object> args) throws IOException{
        Logger logger = Logger.getLogger("""");
        logger.setLevel((Level)args.get(""log-level""));

        String logfile = (String)args.get(""log-file"");
        if(logfile != null) {
            FileHandler fh = new FileHandler(logfile);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
        }
    }
"
802,I would use == instead of equals. XWikiAttachment don't implement equals and even if they were is might be super slow (they would have to compare sometime big files contents). Then no need for `put == null` anymore since the input cannot be null.,"    public XWikiAttachment set(XWikiAttachment attachment)
    {
        XWikiAttachment put = map.put(attachment.getFilename(), attachment);
        if (put == null || !put.equals(attachment)) {
            added(attachment);
            updatedMap();
        }
        return put;
    }
","    public XWikiAttachment set(XWikiAttachment attachment)
    {
        XWikiAttachment put = map.put(attachment.getFilename(), attachment);
START         if (put == null || !put.equals(attachment)) { END 
            added(attachment);
            updatedMap();
        }
        return put;
    }
","    public XWikiAttachment set(XWikiAttachment attachment)
    {
        XWikiAttachment put = map.put(attachment.getFilename(), attachment);
        if (put != attachment) {
            added(attachment);
            updatedMap();
        }
        return put;
    }
"
803,"final, here and elsewhere","  public boolean equals(Object obj) {
    if (obj instanceof MethodKey) {
      MethodKey toCompare = (MethodKey) obj;
      return toCompare.name.equals(name) && toCompare.parameterTypes.equals(parameterTypes);
    }
    return false;
  }
","START   public boolean equals(Object obj) { END 
    if (obj instanceof MethodKey) {
      MethodKey toCompare = (MethodKey) obj;
      return toCompare.name.equals(name) && toCompare.parameterTypes.equals(parameterTypes);
    }
    return false;
  }
","  public final boolean equals(Object obj) {
    if (obj instanceof MethodKey) {
      MethodKey toCompare = (MethodKey) obj;
      return toCompare.name.equals(name) && toCompare.parameterTypes.equals(parameterTypes);
    }
    return false;
  }
"
804,"Copy into a new set too, the user will still be able to modify the set through the builder.","  MongoDBTracing(Builder builder) {
    tracing = builder.tracing;
    maxAbbreviatedCommandLength = builder.maxAbbreviatedCommandLength;
    commandsWithCollectionName = Collections.unmodifiableSet(builder.commandsWithCollectionName);
  }
","  MongoDBTracing(Builder builder) {
    tracing = builder.tracing;
    maxAbbreviatedCommandLength = builder.maxAbbreviatedCommandLength;
START     commandsWithCollectionName = Collections.unmodifiableSet(builder.commandsWithCollectionName); END 
  }
","  MongoDBTracing(Builder builder) {
    tracing = builder.tracing;
  }
"
805,"this makes no sense. synchronizing on a new object is meaningless.
I do not know why partitions must be null, if we want synchronize on this object, we should make it final and never null, instead simply clear() them on dispose","	public void disconnect() {
		Object lock = partitions != null ? partitions : new Object();
		synchronized (lock) {
			document = null;
			partitions = null;
			try {
				inputStream.close();
			} catch (IOException e) {
			}
		}
	}
","	public void disconnect() {
START 		Object lock = partitions != null ? partitions : new Object(); END 
		synchronized (lock) {
			document = null;
			partitions = null;
			try {
				inputStream.close();
			} catch (IOException e) {
			}
		}
	}
","	public void disconnect() {
		Object lock = partitions != null ? partitions : new Object();
		synchronized (lock) {
			document = null;
			partitions.clear();
			try {
				inputStream.close();
			} catch (IOException e) {
			}
		}
	}
"
806,can use `inMemMessage.isEmpty()`,"  private void printInfo(String sizeMessage,
      String inAlluxioMessage, String inMemMessage, String path) {
    System.out.println(inMemMessage.equals("""")
        ? String.format(SHORT_INFO_FORMAT, sizeMessage, inAlluxioMessage, path)
        : String.format(LONG_INFO_FORMAT, sizeMessage, inAlluxioMessage, inMemMessage, path));
  }
","  private void printInfo(String sizeMessage,
      String inAlluxioMessage, String inMemMessage, String path) {
START     System.out.println(inMemMessage.equals("""") END 
        ? String.format(SHORT_INFO_FORMAT, sizeMessage, inAlluxioMessage, path)
        : String.format(LONG_INFO_FORMAT, sizeMessage, inAlluxioMessage, inMemMessage, path));
  }
","  private void printInfo(String sizeMessage,
      String inAlluxioMessage, String inMemMessage, String path) {
    System.out.println(inMemMessage.isEmpty()
        ? String.format(SHORT_INFO_FORMAT, sizeMessage, inAlluxioMessage, path)
        : String.format(LONG_INFO_FORMAT, sizeMessage, inAlluxioMessage, inMemMessage, path));
  }
"
807,"I think alternatively we can move out the construction of the service from the test cases into a factory method that sets a shutdown function object field that we can call in the tearDown. This may prevent some other unwanted potential side-effects. With this approach we construct two services, but shutdown only one. For example, the service submits a scheduled task. I think it is fine for now, but it would be safer with the function proposed.","    public void tearDown() {
        // Destroy JMX beans created during testing.
        MetricsService metricsService = new MetricsService(nodeEngineMock, () -> metricsRegistry);
        metricsService.init(nodeEngineMock, new Properties());
        metricsService.shutdown(true);

        JmxLeakHelper.checkJmxBeans();

        // Stop executor service.
        if (executionService != null) {
            executionService.shutdown();
        }
    }
","    public void tearDown() {
        // Destroy JMX beans created during testing.
START         MetricsService metricsService = new MetricsService(nodeEngineMock, () -> metricsRegistry); END 
        metricsService.init(nodeEngineMock, new Properties());
        metricsService.shutdown(true);

        JmxLeakHelper.checkJmxBeans();

        // Stop executor service.
        if (executionService != null) {
            executionService.shutdown();
        }
    }
","    public void tearDown() {
        // Destroy JMX beans created during testing.
        if (metricsService != null) {
            metricsService.shutdown(true);

            metricsService = null;
        }

        JmxLeakHelper.checkJmxBeans();

        // Stop executor service.
        if (executionService != null) {
            executionService.shutdown();
        }
    }
"
808,"swap the left and right for the equals to avoid NullPointerException
also, use equalsIgnoreCase instead

```
""MOBILE"".equalsIgnoreCase(src);
```","	public AdsBaseObject verifyAdImage(String slotName, String src, String imageUrl) {
		WebElement element = getWebElement(slotName);
		boolean isMobile = src.toUpperCase().equals(""MOBILE"");
		Assertion.assertTrue(new AdsComparison().compareImageWithScreenshot(imageUrl, element, driver, isMobile));
		PageObjectLogging.log(""verifyAdImage"", ""Ad looks good"", true, driver);
		return this;
	}
","	public AdsBaseObject verifyAdImage(String slotName, String src, String imageUrl) {
		WebElement element = getWebElement(slotName);
START 		boolean isMobile = src.toUpperCase().equals(""MOBILE""); END 
		Assertion.assertTrue(new AdsComparison().compareImageWithScreenshot(imageUrl, element, driver, isMobile));
		PageObjectLogging.log(""verifyAdImage"", ""Ad looks good"", true, driver);
		return this;
	}
","	public AdsBaseObject verifyAdImage(String slotName, String src, String imageUrl) {
		WebElement element = getWebElement(slotName);
		boolean isMobile = ""MOBILE"".equalsIgnoreCase(src);
		Assertion.assertTrue(new AdsComparison().compareImageWithScreenshot(imageUrl, element, driver, isMobile));
		PageObjectLogging.log(""verifyAdImage"", ""Ad looks good"", true, driver);
		return this;
	}
"
809,Missing synchronization?,"  public Set<String> getUnmatchedLabels() {
    return Collections.unmodifiableSet(unmatchedLabels);
  }
","START   public Set<String> getUnmatchedLabels() { END 
    return Collections.unmodifiableSet(unmatchedLabels);
  }
","  public synchronized Set<String> getUnmatchedLabels() {
    return Collections.unmodifiableSet(unmatchedLabels);
  }
"
810,"This shouldn't be necessary anymore.

RefDirectory.refresh() should trigger an event listener if one or more refs was detected to be modified, which means we can drop the getAllRefs() call here.","	public void scanForRepoChanges() throws IOException {
		refs.refresh();
		getAllRefs(); // This will look for changes to refs
		if (!isBare())
			getIndex(); // This will detect changes in the index
	}
","	public void scanForRepoChanges() throws IOException {
		refs.refresh();
START 		getAllRefs(); // This will look for changes to refs END 
		if (!isBare())
			getIndex(); // This will detect changes in the index
	}
","	public void scanForRepoChanges() throws IOException {
		getAllRefs(); // This will look for changes to refs
		if (!isBare())
			getIndex(); // This will detect changes in the index
	}
"
811,"In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean.","    public List<Server> getReachableServers() {
        return getServerList(true);
    }
","    public List<Server> getReachableServers() {
START         return getServerList(true); END 
    }
","    public List<Server> getReachableServers() {
        return null;

    }
"
812,Might throw an IndexOutOfBound if no the storage domain is not attached to any storage pool,"    protected Guid getStoragePoolId() {
        return getDbFacade().getStoragePoolDao().getAllForStorageDomain(getStorageDomainId()).get(0).getId();
    }
","    protected Guid getStoragePoolId() {
START         return getDbFacade().getStoragePoolDao().getAllForStorageDomain(getStorageDomainId()).get(0).getId(); END 
    }
","    protected Guid getStoragePoolId() {
        return getParameters().getStoragePoolId();
    }
"
813,Why returning Integer instead of plain int?,"    private Integer prerequirementImgResource(String group) {
        if (group.equalsIgnoreCase(AssignmentPrerequirement.RANK.toString())) {
            return R.drawable.rank_prerequirement;
        } else if (group.equalsIgnoreCase(AssignmentPrerequirement.MISSION.toString())) {
            return R.drawable.group_prerequirement;
        } else {
            return R.drawable.empty;
        }
    }
","START     private Integer prerequirementImgResource(String group) { END 
        if (group.equalsIgnoreCase(AssignmentPrerequirement.RANK.toString())) {
            return R.drawable.rank_prerequirement;
        } else if (group.equalsIgnoreCase(AssignmentPrerequirement.MISSION.toString())) {
            return R.drawable.group_prerequirement;
        } else {
            return R.drawable.empty;
        }
    }
","    private int prerequirementImgResource(String group) {
        if (group.equalsIgnoreCase(AssignmentPrerequirement.RANK.toString())) {
            return R.drawable.rank_prerequirement;
        } else if (group.equalsIgnoreCase(AssignmentPrerequirement.MISSION.toString())) {
            return R.drawable.group_prerequirement;
        } else {
            return R.drawable.empty;
        }
    }
"
814,"The TODO above the changed line indicates the reason for using a multi value list here... But of course, we could change this until we actually return multiple values.","    public Iterator<ImageTypeSpecifier> getImageTypes(int pImageIndex) throws IOException {
        checkBounds(pImageIndex);

        // TODO: Better implementation, include INT_RGB types for 3BYTE_BGR and 4BYTE_ABGR for INT_ARGB
        return Collections.singletonList(getRawImageType(pImageIndex)).iterator();
    }
","    public Iterator<ImageTypeSpecifier> getImageTypes(int pImageIndex) throws IOException {
        checkBounds(pImageIndex);

        // TODO: Better implementation, include INT_RGB types for 3BYTE_BGR and 4BYTE_ABGR for INT_ARGB
START         return Collections.singletonList(getRawImageType(pImageIndex)).iterator(); END 
    }
","    public Iterator<ImageTypeSpecifier> getImageTypes(int pImageIndex) throws IOException {
        checkBounds(pImageIndex);

        // TODO: Better implementation, include INT_RGB types for 3BYTE_BGR and 4BYTE_ABGR for INT_ARGB
        return Arrays.asList(getRawImageType(pImageIndex)).iterator();
    }
"
815,"For better readability i would sort the methods in the way they are used `resetPositions` -> `addPosition` -> `appendData` -> `flush`.

Please also order the private methods accordingly: Method that uses a private method - >  private method","        public void resetPositions(int positionCount)
        {
            positions = ensureCapacity(positions, positionCount);
            this.positionCount = 0;
        }
","START         public void resetPositions(int positionCount) END 
        {
            positions = ensureCapacity(positions, positionCount);
            this.positionCount = 0;
        }
","        private void resetPositions(int positionCount)
        {
            positions = ensureCapacity(positions, positionCount);
            this.positionCount = 0;
        }
"
816,"Why `selectorStr.substring(0, 1)`","    public static SelectorHandler getHandler(final String selectorStr)
    {
        if (!selectorStr.isEmpty())
            for (final Entry<String, SelectorHandler> handler : selectorHandlers.subMap(selectorStr, true, selectorStr.substring(0, 1), true).entrySet())
                if (selectorStr.startsWith(handler.getKey()))
                    return handler.getValue();

        return vanillaHandler;
    }
","    public static SelectorHandler getHandler(final String selectorStr)
    {
        if (!selectorStr.isEmpty())
START             for (final Entry<String, SelectorHandler> handler : selectorHandlers.subMap(selectorStr, true, selectorStr.substring(0, 1), true).entrySet()) END 
                if (selectorStr.startsWith(handler.getKey()))
                    return handler.getValue();

        return vanillaHandler;
    }
","    public static SelectorHandler getHandler(final String selectorStr)
    {
        if (!selectorStr.isEmpty())
        {
            for (final Entry<String, SelectorHandler> handler : selectorHandlers.subMap(selectorStr, true, selectorStr.substring(0, 1), true).entrySet())
            {
                if (selectorStr.startsWith(handler.getKey()))
                {
                    return handler.getValue();
                }
            }
        }

        return vanillaHandler;
    }
"
817,"This `if` is redundant.

Question for you, @nezihyigitbasi: Do you see IntelliJ ""warning""s for this? If not, you should turn those on.","    public synchronized void close()
    {
        if (closed) {
            return;
        }
        closed = true;
        if (parentMemoryContext != null) {
            parentMemoryContext.updateBytes(-usedBytes);
        }
        usedBytes = 0;
    }
","    public synchronized void close()
    {
        if (closed) {
            return;
        }
        closed = true;
START         if (parentMemoryContext != null) { END 
            parentMemoryContext.updateBytes(-usedBytes);
        }
        usedBytes = 0;
    }
","    public synchronized void close()
    {
        if (closed) {
            return;
        }
        closed = true;
        parentMemoryContext.updateBytes(-usedBytes);
        usedBytes = 0;
    }
"
818,Change seems unneeded.  And actually the unchecked can be removed as well.,"   public Map<K, V> getEntries() {
      return (Map<K, V>) entries;
   }
","START    public Map<K, V> getEntries() { END 
      return (Map<K, V>) entries;
   }
","   public Map<? extends K, ? extends V> getEntries() {
      return entries;
   }
"
819,"Why are you changing expectation, when no related production code changed? There should be really two events (`modification` and `modification 2`) Please note that this test is platform dependent. We are targetting to Linux and CI reports no issues or flakes with this test. Which OS are you running tests?
Last CI build is here: https://builds.apache.org/view/C/view/Apache%20Camel/job/Camel/job/master/1533/consoleFull","    public void testDefaultConfig() throws Exception {
        Files.write(springTestFile.toPath(), ""modification"".getBytes(), StandardOpenOption.SYNC);
        // Adding few millis to avoid fleaky tests
        // The file hasher could sometimes evaluate these two changes as duplicate, as the second modification of file could be done before hashing is done
        Thread.sleep(50);
        Files.write(springTestFile.toPath(), ""modification 2"".getBytes(), StandardOpenOption.SYNC);
        MockEndpoint mock = getMockEndpoint(""mock:springTest"");
        mock.setExpectedCount(1); // The same with testCustomHasher, that second MODIFY event is discarded
        mock.setResultWaitTime(1000);
        mock.assertIsSatisfied();

    }
","    public void testDefaultConfig() throws Exception {
        Files.write(springTestFile.toPath(), ""modification"".getBytes(), StandardOpenOption.SYNC);
        // Adding few millis to avoid fleaky tests
        // The file hasher could sometimes evaluate these two changes as duplicate, as the second modification of file could be done before hashing is done
        Thread.sleep(50);
        Files.write(springTestFile.toPath(), ""modification 2"".getBytes(), StandardOpenOption.SYNC);
        MockEndpoint mock = getMockEndpoint(""mock:springTest"");
START         mock.setExpectedCount(1); // The same with testCustomHasher, that second MODIFY event is discarded END 
        mock.setResultWaitTime(1000);
        mock.assertIsSatisfied();

    }
","    public void testDefaultConfig() throws Exception {
        Files.write(springTestFile.toPath(), ""modification"".getBytes(), StandardOpenOption.SYNC);
        // Adding few millis to avoid fleaky tests
        // The file hasher could sometimes evaluate these two changes as duplicate, as the second modification of file could be done before hashing is done
        Thread.sleep(50);
        Files.write(springTestFile.toPath(), ""modification 2"".getBytes(), StandardOpenOption.SYNC);
        MockEndpoint mock = getMockEndpoint(""mock:springTest"");
        mock.setExpectedCount(2); // two MODIFY events
        mock.setResultWaitTime(1000);
        mock.assertIsSatisfied();

    }
"
820,Isn't isNotBlank already checking for null?,"	private boolean startsOrEndsWithWhitespace(String value) {
		boolean startsOrEndsWithWhitespace = false;
		if (value != null && StringUtils.isNotBlank(value)) {
		    int lastIndex = value.length() - 1;
		    if (Character.isSpaceChar(value.charAt(0))) {
			    startsOrEndsWithWhitespace = true;
		    } else if (Character.isSpaceChar(value.charAt(lastIndex))) {
		    	
			    startsOrEndsWithWhitespace = true; 
		    }
		} else {
			startsOrEndsWithWhitespace = false;
		}
		return startsOrEndsWithWhitespace;		
	}
","	private boolean startsOrEndsWithWhitespace(String value) {
		boolean startsOrEndsWithWhitespace = false;
START 		if (value != null && StringUtils.isNotBlank(value)) { END 
		    int lastIndex = value.length() - 1;
		    if (Character.isSpaceChar(value.charAt(0))) {
			    startsOrEndsWithWhitespace = true;
		    } else if (Character.isSpaceChar(value.charAt(lastIndex))) {
		    	
			    startsOrEndsWithWhitespace = true; 
		    }
		} else {
			startsOrEndsWithWhitespace = false;
		}
		return startsOrEndsWithWhitespace;		
	}
","	private boolean startsOrEndsWithWhitespace(String value) {
		return (StringUtils.isNotBlank(value) && (Character.isSpaceChar(value.charAt(0)) || Character.isSpaceChar(value.charAt(value.length() -1))));		
	}
"
821,This Block can be shortened to `share.setIsFolder(mPath.endsWith(FileUtils.PATH_SEPARATOR))`,"    private void updateData(OCShare share) {
        // Update DB with the response
        share.setPath(mPath);
        if (mPath.endsWith(FileUtils.PATH_SEPARATOR)) {
            share.setIsFolder(true);
        } else {
            share.setIsFolder(false);
        }
        share.setPermissions(READ_ONLY);
        
        getStorageManager().saveShare(share);
        
        // Update OCFile with data from share: ShareByLink  and publicLink
        OCFile file = getStorageManager().getFileByPath(mPath);
        if (file!=null) {
            file.setShareWithSharee(true);    // TODO - this should be done by the FileContentProvider, as part of getStorageManager().saveShare(share)
            getStorageManager().saveFile(file);
        }
    }
","    private void updateData(OCShare share) {
        // Update DB with the response
        share.setPath(mPath);
START         if (mPath.endsWith(FileUtils.PATH_SEPARATOR)) { END 
            share.setIsFolder(true);
        } else {
            share.setIsFolder(false);
        }
        share.setPermissions(READ_ONLY);
        
        getStorageManager().saveShare(share);
        
        // Update OCFile with data from share: ShareByLink  and publicLink
        OCFile file = getStorageManager().getFileByPath(mPath);
        if (file!=null) {
            file.setShareWithSharee(true);    // TODO - this should be done by the FileContentProvider, as part of getStorageManager().saveShare(share)
            getStorageManager().saveFile(file);
        }
    }
","    private void updateData(OCShare share) {
        // Update DB with the response
        share.setPath(mPath);
        share.setIsFolder(mPath.endsWith(FileUtils.PATH_SEPARATOR));
        share.setPermissions(READ_ONLY);
        
        getStorageManager().saveShare(share);
        
        // Update OCFile with data from share: ShareByLink  and publicLink
        OCFile file = getStorageManager().getFileByPath(mPath);
        if (file!=null) {
            file.setShareWithSharee(true);    // TODO - this should be done by the FileContentProvider, as part of getStorageManager().saveShare(share)
            getStorageManager().saveFile(file);
        }
    }
"
822,does the propagated exception not get logged? This looks like it would result in logging the same thing twice,"  protected void startMasters(boolean isLeader) {
    try {
      connectToUFS();
      mRegistry.start(isLeader);
    } catch (IOException e) {
      LOG.error(""Failed to start master."", e);
      throw Throwables.propagate(e);
    }
  }
","  protected void startMasters(boolean isLeader) {
    try {
      connectToUFS();
      mRegistry.start(isLeader);
    } catch (IOException e) {
START       LOG.error(""Failed to start master."", e); END 
      throw Throwables.propagate(e);
    }
  }
","  protected void startMasters(boolean isLeader) {
    try {
      connectToUFS();
      mRegistry.start(isLeader);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }
"
823,"The default constructor should assign ""null"" to connector.","	public BugzillaRestRepositoryConnectorUi() {
		connector = BugzillaRestConnector.getDefault() == null
				? new BugzillaRestConnector()
		: BugzillaRestConnector.getDefault();
	}
","START 	public BugzillaRestRepositoryConnectorUi() { END 
		connector = BugzillaRestConnector.getDefault() == null
				? new BugzillaRestConnector()
		: BugzillaRestConnector.getDefault();
	}
","	public BugzillaRestRepositoryConnectorUi() {
		this.connector = BugzillaRestConnector.getDefault() == null
				? new BugzillaRestConnector()
		: BugzillaRestConnector.getDefault();
	}
"
824,helper for setting common options?,"  public static ListStatusPOptions getListStatusOptions() {
    FileSystemMasterCommonPOptions commonOptions =
        getCommonOptions().toBuilder().setTtl(Configuration.getMs(PropertyKey.USER_FILE_LOAD_TTL))
            .setTtlAction(GrpcUtils.toProto(
                Configuration.getEnum(PropertyKey.USER_FILE_LOAD_TTL_ACTION, TtlAction.class)))
            .build();

    return ListStatusPOptions.newBuilder().setCommonOptions(commonOptions)
        .setLoadMetadataType(GrpcUtils.toProto(Configuration
            .getEnum(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.class)))
        .build();
  }
","  public static ListStatusPOptions getListStatusOptions() {
START     FileSystemMasterCommonPOptions commonOptions = END 
        getCommonOptions().toBuilder().setTtl(Configuration.getMs(PropertyKey.USER_FILE_LOAD_TTL))
            .setTtlAction(GrpcUtils.toProto(
                Configuration.getEnum(PropertyKey.USER_FILE_LOAD_TTL_ACTION, TtlAction.class)))
            .build();

    return ListStatusPOptions.newBuilder().setCommonOptions(commonOptions)
        .setLoadMetadataType(GrpcUtils.toProto(Configuration
            .getEnum(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.class)))
        .build();
  }
","  public static ListStatusPOptions getListStatusOptions() {
    return ListStatusPOptions.newBuilder()
        .setCommonOptions(getCommonOptions().toBuilder()
            .setTtl(Configuration.getMs(PropertyKey.USER_FILE_LOAD_TTL))
            .setTtlAction(GrpcUtils.toProto(
                Configuration.getEnum(PropertyKey.USER_FILE_LOAD_TTL_ACTION, TtlAction.class))))
        .setLoadMetadataType(GrpcUtils.toProto(Configuration
            .getEnum(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.class)))
        .build();
  }
"
825,"small typo - I think `name` is supposed to be `dag`, right?","  Node(final String name, final NodeProcessor nodeProcessor, final Dag dag) {
    requireNonNull(nodeProcessor, ""The nodeProcessor parameter can't be null."");
    this.nodeProcessor = nodeProcessor;
    requireNonNull(name, ""The name of the node can't be null"");
    this.name = name;
    requireNonNull(name, ""The dag of the node can't be null"");
    this.dag = dag;
  }
","  Node(final String name, final NodeProcessor nodeProcessor, final Dag dag) {
    requireNonNull(nodeProcessor, ""The nodeProcessor parameter can't be null."");
    this.nodeProcessor = nodeProcessor;
    requireNonNull(name, ""The name of the node can't be null"");
    this.name = name;
START     requireNonNull(name, ""The dag of the node can't be null""); END 
    this.dag = dag;
  }
","  Node(final String name, final NodeProcessor nodeProcessor, final Dag dag) {
    requireNonNull(nodeProcessor, ""The nodeProcessor parameter can't be null."");
    this.nodeProcessor = nodeProcessor;
    requireNonNull(name, ""The name of the node can't be null"");
    this.name = name;
    requireNonNull(dag, ""The dag of the node can't be null"");
    this.dag = dag;
  }
"
826,"Here it's not the state of this class that's invalid, it's the given parameter.
The relevant exception in such a case is

    IllegalArgumentException","	public String getTooltip(MergeMode mode) {
		String tooltip;
		switch (mode) {
			case LEFT_TO_RIGHT:
				tooltip = EMFCompareDiagramEditMessages.getString(""merged.to.right.tooltip""); //$NON-NLS-1$
				break;
			case RIGHT_TO_LEFT:
				tooltip = EMFCompareDiagramEditMessages.getString(""merged.to.left.tooltip""); //$NON-NLS-1$
				break;
			case ACCEPT:
				tooltip = EMFCompareDiagramEditMessages.getString(""accept.change.tooltip""); //$NON-NLS-1$
				break;
			case REJECT:
				tooltip = EMFCompareDiagramEditMessages.getString(""reject.change.tooltip""); //$NON-NLS-1$
				break;
			default:
				throw new IllegalStateException();
		}
		return tooltip;
	}
","	public String getTooltip(MergeMode mode) {
		String tooltip;
		switch (mode) {
			case LEFT_TO_RIGHT:
				tooltip = EMFCompareDiagramEditMessages.getString(""merged.to.right.tooltip""); //$NON-NLS-1$
				break;
			case RIGHT_TO_LEFT:
				tooltip = EMFCompareDiagramEditMessages.getString(""merged.to.left.tooltip""); //$NON-NLS-1$
				break;
			case ACCEPT:
				tooltip = EMFCompareDiagramEditMessages.getString(""accept.change.tooltip""); //$NON-NLS-1$
				break;
			case REJECT:
				tooltip = EMFCompareDiagramEditMessages.getString(""reject.change.tooltip""); //$NON-NLS-1$
				break;
			default:
START 				throw new IllegalStateException(); END 
		}
		return tooltip;
	}
","	public String getTooltip(MergeMode mode) throws IllegalArgumentException {
		String tooltip;
		switch (mode) {
			case LEFT_TO_RIGHT:
				tooltip = EMFCompareDiagramEditMessages.getString(""merged.to.right.tooltip""); //$NON-NLS-1$
				break;
			case RIGHT_TO_LEFT:
				tooltip = EMFCompareDiagramEditMessages.getString(""merged.to.left.tooltip""); //$NON-NLS-1$
				break;
			case ACCEPT:
				tooltip = EMFCompareDiagramEditMessages.getString(""accept.change.tooltip""); //$NON-NLS-1$
				break;
			case REJECT:
				tooltip = EMFCompareDiagramEditMessages.getString(""reject.change.tooltip""); //$NON-NLS-1$
				break;
			default:
				throw new IllegalArgumentException();
		}
		return tooltip;
	}
"
827,Please add an overloaded constructor to keep comparibility (like `TriggerredBuildSelector(boolean)`).,"    public TriggeredBuildSelector(boolean fallbackToLastSuccessful, UpstreamFilterStrategy upstreamFilterStrategy, boolean allowUpstreamDependencies) {
        this.fallbackToLastSuccessful = fallbackToLastSuccessful ? Boolean.TRUE : null;
        this.upstreamFilterStrategy = upstreamFilterStrategy;
        this.allowUpstreamDependencies = allowUpstreamDependencies ? Boolean.TRUE : null;
    }
","START     public TriggeredBuildSelector(boolean fallbackToLastSuccessful, UpstreamFilterStrategy upstreamFilterStrategy, boolean allowUpstreamDependencies) { END 
        this.fallbackToLastSuccessful = fallbackToLastSuccessful ? Boolean.TRUE : null;
        this.upstreamFilterStrategy = upstreamFilterStrategy;
        this.allowUpstreamDependencies = allowUpstreamDependencies ? Boolean.TRUE : null;
    }
","    public TriggeredBuildSelector(boolean fallbackToLastSuccessful, UpstreamFilterStrategy upstreamFilterStrategy, boolean allowUpstreamDependencies) {
        this.fallbackToLastSuccessful = fallbackToLastSuccessful ? Boolean.TRUE : null;
        this.upstreamFilterStrategy = upstreamFilterStrategy;
        this.allowUpstreamDependencies = allowUpstreamDependencies;
    }
"
828,"사소한 거긴 하지만

if (not a) {
...
} not not a {
...
}

가 되지 않도록 if 순서를 변경해 주세요.","    public static Result deleteUser(Long userId) {
        if (User.findByLoginId(session().get(""loginId"")).isSiteManager()){
            if (!Project.isOnlyManager(userId)) {
                User.find.byId(userId).delete();                
            } else {
                flash(Constants.WARNING, ""site.userList.deleteAlert"");                
            }
        } else {
            flash(Constants.WARNING, ""auth.unauthorized.waringMessage"");
        }

        return redirect(routes.SiteApp.userList(0, null));
    }
","    public static Result deleteUser(Long userId) {
        if (User.findByLoginId(session().get(""loginId"")).isSiteManager()){
START             if (!Project.isOnlyManager(userId)) { END 
                User.find.byId(userId).delete();                
            } else {
                flash(Constants.WARNING, ""site.userList.deleteAlert"");                
            }
        } else {
            flash(Constants.WARNING, ""auth.unauthorized.waringMessage"");
        }

        return redirect(routes.SiteApp.userList(0, null));
    }
","    public static Result deleteUser(Long userId) {
        if (User.findByLoginId(session().get(""loginId"")).isSiteManager()){
            if (Project.isOnlyManager(userId)) {
                flash(Constants.WARNING, ""site.userList.deleteAlert"");                
            } else {
                User.find.byId(userId).delete();                
            }
        } else {
            flash(Constants.WARNING, ""auth.unauthorized.waringMessage"");
        }

        return redirect(routes.SiteApp.userList(0, null));
    }
"
829,"I know these are annotated nonnull, but since this is an assertion let's leave it in","    public Attachment(@NonNull Uri uri, @NonNull String contentType,
                      long date, @Nullable String fileName)
    {
      if (date < 0) {
        throw new AssertionError(""uri, content type, and date must all be specified"");
      }
      this.uri         = uri;
      this.fileName    = fileName;
      this.contentType = contentType;
      this.date        = date;
    }
","    public Attachment(@NonNull Uri uri, @NonNull String contentType,
                      long date, @Nullable String fileName)
    {
START       if (date < 0) { END 
        throw new AssertionError(""uri, content type, and date must all be specified"");
      }
      this.uri         = uri;
      this.fileName    = fileName;
      this.contentType = contentType;
      this.date        = date;
    }
","    public Attachment(@NonNull Uri uri, @NonNull String contentType,
                      long date, @Nullable String fileName)
    {
      if (uri == null || contentType == null || date < 0) {
        throw new AssertionError(""uri, content type, and date must all be specified"");
      }
      this.uri         = uri;
      this.fileName    = fileName;
      this.contentType = contentType;
      this.date        = date;
    }
"
830,"Just this will work too : services.add(new CoordinatorProxyService(config, storeClientConfigs));

You can save a line by not declaring a coordinator object.","    private List<VoldemortService> createServices() {
        List<VoldemortService> services = new ArrayList<VoldemortService>();
        CoordinatorProxyService coordinator = new CoordinatorProxyService(config,
                                                                          storeClientConfigs);
        services.add(coordinator);
        if(config.isAdminServiceEnabled()) {
            services.add(new CoordinatorAdminService(config, storeClientConfigs));
        }
        return ImmutableList.copyOf(services);
    }
","    private List<VoldemortService> createServices() {
        List<VoldemortService> services = new ArrayList<VoldemortService>();
        CoordinatorProxyService coordinator = new CoordinatorProxyService(config,
                                                                          storeClientConfigs);
START         services.add(coordinator); END 
        if(config.isAdminServiceEnabled()) {
            services.add(new CoordinatorAdminService(config, storeClientConfigs));
        }
        return ImmutableList.copyOf(services);
    }
","    private List<VoldemortService> createServices() {
        List<VoldemortService> services = new ArrayList<VoldemortService>();
        services.add(new CoordinatorProxyService(config, storeClientConfigs));
        if(config.isAdminServiceEnabled()) {
            services.add(new CoordinatorAdminService(config, storeClientConfigs));
        }
        return ImmutableList.copyOf(services);
    }
"
831,log.trace,"    public void afterBegin() throws EJBException, RemoteException {
        log.info(""afterBegin called"");
        checker.setSynchronizedBegin();
    }
","    public void afterBegin() throws EJBException, RemoteException {
START         log.info(""afterBegin called""); END 
        checker.setSynchronizedBegin();
    }
","    public void afterBegin() throws EJBException, RemoteException {
        log.trace(""afterBegin called"");
        checker.setSynchronizedBegin();
    }
"
832,This is a part of the java spec I'm not as familiar with. Is this doing `((descending ? 1 : 0) ^ value) < 0` or `descending ^ (value < 0)`?,"  private boolean checkPagingSpec(PagingSpec pagingSpec, boolean descending)
  {
    for (Integer value : pagingSpec.getPagingIdentifiers().values()) {
      if (descending ^ value < 0) {
        return false;
      }
    }
    return pagingSpec.getThreshold() >= 0;
  }
","  private boolean checkPagingSpec(PagingSpec pagingSpec, boolean descending)
  {
    for (Integer value : pagingSpec.getPagingIdentifiers().values()) {
START       if (descending ^ value < 0) { END 
        return false;
      }
    }
    return pagingSpec.getThreshold() >= 0;
  }
","  private boolean checkPagingSpec(PagingSpec pagingSpec, boolean descending)
  {
    for (Integer value : pagingSpec.getPagingIdentifiers().values()) {
      if (descending ^ (value < 0)) {
        return false;
      }
    }
    return pagingSpec.getThreshold() >= 0;
  }
"
833,Can we unroll this to use the new `Configurable` method instead?,"    private void init(Jdbi db) {
        db.registerArrayType(SqlArrayTypeFactory.of(UserId.class, ""int"", UserId::getId));
        db.registerColumnMapper(new UserIdColumnMapper());
    }
","    private void init(Jdbi db) {
START         db.registerArrayType(SqlArrayTypeFactory.of(UserId.class, ""int"", UserId::getId)); END 
        db.registerColumnMapper(new UserIdColumnMapper());
    }
","    private void init(Jdbi db) {
        db.registerArrayType(UserId.class, ""int"", UserId::getId);
        db.registerColumnMapper(new UserIdColumnMapper());
    }
"
834,"shouldn't it return false even if addCanDoActionMessage=false?
from the name of the parameter it sounds like only the message is not needed but still give the correct return value","    protected boolean updateBrickServerName(GlusterBrickEntity brick, boolean addCanDoActionMessage) {
        VdsStatic server = getVdsStaticDao().get(brick.getServerId());
        if ((server == null || !server.getvds_group_id().equals(getVdsGroupId())) && addCanDoActionMessage) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_SERVER_ID);
            return false;
        }
        brick.setServerName(server.gethost_name());
        return true;
    }
","    protected boolean updateBrickServerName(GlusterBrickEntity brick, boolean addCanDoActionMessage) {
        VdsStatic server = getVdsStaticDao().get(brick.getServerId());
START         if ((server == null || !server.getvds_group_id().equals(getVdsGroupId())) && addCanDoActionMessage) { END 
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_SERVER_ID);
            return false;
        }
        brick.setServerName(server.gethost_name());
        return true;
    }
","    protected boolean updateBrickServerName(GlusterBrickEntity brick, boolean addCanDoActionMessage) {
        VdsStatic server = getVdsStaticDao().get(brick.getServerId());
        if ((server == null || !server.getvds_group_id().equals(getVdsGroupId()))) {
            if (addCanDoActionMessage) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_SERVER_ID);
            }
            return false;
        }
        brick.setServerName(server.gethost_name());
        return true;
    }
"
835,private,"    public static @NonNull String getSpanName(String attributeName) {
        return attributeName.substring(0, attributeName.lastIndexOf('/'));
    }
","    START  public static END  @NonNull String getSpanName(String attributeName) {
        return attributeName.substring(0, attributeName.lastIndexOf('/'));
    }
","    private static @NonNull String getSpanName(String attributeName) {
        return attributeName.substring(0, attributeName.lastIndexOf('/'));
    }
"
836,Why do you need to type parameter ?,"	private static boolean containsAll(String text, final Collection<String> items) {
		final String _text = text.toLowerCase();
		return items.stream()
				.allMatch((String it) -> {
					return _text.contains(it);
				});
	}
","	private static boolean containsAll(String text, final Collection<String> items) {
		final String _text = text.toLowerCase();
		return items.stream()
START 				.allMatch((String it) -> { END 
					return _text.contains(it);
				});
	}
","	private static boolean containsAll(String text, final Collection<String> items) {
		final String _text = text.toLowerCase();
		return items.stream()
				.allMatch(it -> {
					return _text.contains(it);
				});
	}
"
837,"This doesn't really need to be in an else clause.

It might be more readable to invert the logic of this block, i.e.:

 if (e != null) {
   throw e;
 }
 Files.delete(dir);
 return FileVisitResult.CONTINUE;","  private void recursiveDelete(Path file) throws IOException {
    Files.walkFileTree(file, new SimpleFileVisitor<Path>() {
      @Override
      public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
          throws IOException {
        Files.delete(file);
        return FileVisitResult.CONTINUE;
      }

      @Override
      public FileVisitResult postVisitDirectory(Path dir, IOException e)
          throws IOException {
        if (e == null) {
          Files.delete(dir);
          return FileVisitResult.CONTINUE;
        } else {
          throw e;
        }
      }
    });
  }
","  private void recursiveDelete(Path file) throws IOException {
    Files.walkFileTree(file, new SimpleFileVisitor<Path>() {
      @Override
      public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
          throws IOException {
        Files.delete(file);
        return FileVisitResult.CONTINUE;
      }

      @Override
      public FileVisitResult postVisitDirectory(Path dir, IOException e)
          throws IOException {
        if (e == null) {
          Files.delete(dir);
          return FileVisitResult.CONTINUE;
        START } else {
          throw e;
        } END 
      }
    });
  }
","  private void recursiveDelete(Path file) throws IOException {
    Files.walkFileTree(file, new SimpleFileVisitor<Path>() {
      @Override
      public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
          throws IOException {
        Files.delete(file);
        return FileVisitResult.CONTINUE;
      }

      @Override
      public FileVisitResult postVisitDirectory(Path dir, IOException e)
          throws IOException {
        if (e != null) {
          throw e;
        }
        Files.delete(dir);
        return FileVisitResult.CONTINUE;
      }
    });
  }
"
838,"Does the `pageNumber` start at 1 or 0? If it starts at one, this conditional could be wrong: pageNumber=1, totalCount=7,pageSize=5 would return false, but there is still a next page.","   public Optional<Object> nextMarker() {
      if (totalCount < pageSize)
         return Optional.absent();
      if (pageNumber < (totalCount / pageSize)) {
         return Optional.of(toPaginationOptions(pageNumber + 1));
      }
      return Optional.absent();
   }
","   public Optional<Object> nextMarker() {
      if (totalCount < pageSize)
         return Optional.absent();
START       if (pageNumber < (totalCount / pageSize)) { END 
         return Optional.of(toPaginationOptions(pageNumber + 1));
      }
      return Optional.absent();
   }
","   public Optional<Object> nextMarker() {
      if (totalCount < pageSize)
         return Optional.absent();

      if ((float) pageNumber < ((float) totalCount / (float) pageSize)) {
         return Optional.of(toPaginationOptions(pageNumber + 1));
      }
      return Optional.absent();
   }
"
839,Is it really necessary to add this check here? Doesn't the AuthenticationProcessor prevent the login request from reaching this point?,"    public void testInvalidUser(AuthenticationFlowContext context, UserModel user) {
        if (user == null || user.getServiceAccountClientLink() != null) {
            dummyHash(context);
            context.getEvent().error(Errors.USER_NOT_FOUND);
            Response challengeResponse = challenge(context, getDefaultChallengeMessage(context));
            context.failureChallenge(AuthenticationFlowError.INVALID_USER, challengeResponse);
        }
    }
","    public void testInvalidUser(AuthenticationFlowContext context, UserModel user) {
START         if (user == null || user.getServiceAccountClientLink() != null) { END 
            dummyHash(context);
            context.getEvent().error(Errors.USER_NOT_FOUND);
            Response challengeResponse = challenge(context, getDefaultChallengeMessage(context));
            context.failureChallenge(AuthenticationFlowError.INVALID_USER, challengeResponse);
        }
    }
","    public void testInvalidUser(AuthenticationFlowContext context, UserModel user) {
        if (user == null) {
            dummyHash(context);
            context.getEvent().error(Errors.USER_NOT_FOUND);
            Response challengeResponse = challenge(context, getDefaultChallengeMessage(context));
            context.failureChallenge(AuthenticationFlowError.INVALID_USER, challengeResponse);
        }
    }
"
840,"missing second argument to view the actual exception message/stack trace:
`file: "" + downloadedFilePath, e)`","    public boolean validateChecksum() {
        if (StringUtils.isNotBlank(checksum)) {
            try {
                return DigestHelper.check(checksum, new FileInputStream(downloadedFilePath));
            } catch (IOException e) {
                throw new CloudRuntimeException(""could not check sum for file: "" + downloadedFilePath);
            } catch (NoSuchAlgorithmException e) {
                throw new CloudRuntimeException(""Unknown checksum algorithm: "" + checksum, e);
            }
        }
        return true;
    }
","    public boolean validateChecksum() {
        if (StringUtils.isNotBlank(checksum)) {
            try {
                return DigestHelper.check(checksum, new FileInputStream(downloadedFilePath));
            } catch (IOException e) {
START                 throw new CloudRuntimeException(""could not check sum for file: "" + downloadedFilePath); END 
            } catch (NoSuchAlgorithmException e) {
                throw new CloudRuntimeException(""Unknown checksum algorithm: "" + checksum, e);
            }
        }
        return true;
    }
","    public boolean validateChecksum() {
        if (StringUtils.isNotBlank(checksum)) {
            try {
                return DigestHelper.check(checksum, new FileInputStream(downloadedFilePath));
            } catch (IOException e) {
                throw new CloudRuntimeException(""could not check sum for file: "" + downloadedFilePath,e);
            } catch (NoSuchAlgorithmException e) {
                throw new CloudRuntimeException(""Unknown checksum algorithm: "" + checksum, e);
            }
        }
        return true;
    }
"
841,can we avoid using `unmodifiableList` and have the cluster manager trust the list will be not modified ?,"  public RegistrationUpdateEvent(String address, List<RegistrationInfo> registrations) {
    this.address = address;
    if (registrations == null || registrations.isEmpty()) {
      this.registrations = Collections.emptyList();
    } else {
      this.registrations = Collections.unmodifiableList(registrations);
    }
  }
","  public RegistrationUpdateEvent(String address, List<RegistrationInfo> registrations) {
    this.address = address;
    if (registrations == null || registrations.isEmpty()) {
      this.registrations = Collections.emptyList();
    } else {
START       this.registrations = Collections.unmodifiableList(registrations); END 
    }
  }
","  public RegistrationUpdateEvent(String address, List<RegistrationInfo> registrations) {
    this.address = address;
    this.registrations = registrations == null ? Collections.emptyList() : registrations;
  }
"
842,"I would remove the variables and do `return new SingleKeyNonTxInvocationContext(true, keyEq);`

the same thing can be applied to other methods","   public InvocationContext createInvocationContext(boolean isWrite, int keyCount) {
      if (keyCount == 1) {
         SingleKeyNonTxInvocationContext result =
               new SingleKeyNonTxInvocationContext(true, keyEq);
         return result;
      } else if (keyCount > 0) {
         NonTxInvocationContext ctx = new NonTxInvocationContext(keyCount, true, keyEq);
         return ctx;
      }
      return createInvocationContext(null);
   }
","   public InvocationContext createInvocationContext(boolean isWrite, int keyCount) {
      if (keyCount == 1) {
START          SingleKeyNonTxInvocationContext result = END 
               new SingleKeyNonTxInvocationContext(true, keyEq);
         return result;
      } else if (keyCount > 0) {
         NonTxInvocationContext ctx = new NonTxInvocationContext(keyCount, true, keyEq);
         return ctx;
      }
      return createInvocationContext(null);
   }
","   public InvocationContext createInvocationContext(boolean isWrite, int keyCount) {
      if (keyCount == 1) {
         return new SingleKeyNonTxInvocationContext(true, keyEq);
      } else if (keyCount > 0) {
         return new NonTxInvocationContext(keyCount, true, keyEq);
      }
      return createInvocationContext(null);
   }
"
843,Remove all of the unnecessary final modifier from the local variables from all of the modified classes.,"  private boolean isRealWorklog(final EveritWorklog worklog) {
    boolean isRealWorklog = true;
    if (issuesRegex != null) {
      for (final Pattern issuePattern : issuesRegex) {
        final boolean issueMatches = issuePattern.matcher(worklog.getIssue()).matches();
        // if match not count in summary
        if (issueMatches) {
          isRealWorklog = false;
          break;
        }
      }
    }
    return isRealWorklog;
  }
","  private boolean isRealWorklog(final EveritWorklog worklog) {
    boolean isRealWorklog = true;
    if (issuesRegex != null) {
START       for (final Pattern issuePattern : issuesRegex) { END 
        final boolean issueMatches = issuePattern.matcher(worklog.getIssue()).matches();
        // if match not count in summary
        if (issueMatches) {
          isRealWorklog = false;
          break;
        }
      }
    }
    return isRealWorklog;
  }
","  private boolean isRealWorklog(final EveritWorklog worklog) {
    boolean isRealWorklog = true;
    if (issuesRegex != null) {
      for (Pattern issuePattern : issuesRegex) {
        boolean issueMatches = issuePattern.matcher(worklog.getIssue()).matches();
        // if match not count in summary
        if (issueMatches) {
          isRealWorklog = false;
          break;
        }
      }
    }
    return isRealWorklog;
  }
"
844,remove instead?,"    public void removed(IExtension[] extensions) {
        for (IExtension extension : extensions) {
            CustomLayoutAlgorithmProvider layoutAlgorithmProvider = extensionToLayoutAlgorithmProvider.get(extension);

            if (layoutAlgorithmProvider != null) {
                List<CustomLayoutAlgorithm> customLayoutAlgorithms = layoutAlgorithmProvider.getCustomLayoutAlgorithms();
                for (CustomLayoutAlgorithm customLayoutAlgorithm : customLayoutAlgorithms) {
                    layoutProviderRegistry.remove(customLayoutAlgorithm.getId());
                }
            }
            extensionToLayoutAlgorithmProvider.put(extension, null);
        }

    }
","    public void removed(IExtension[] extensions) {
        for (IExtension extension : extensions) {
            CustomLayoutAlgorithmProvider layoutAlgorithmProvider = extensionToLayoutAlgorithmProvider.get(extension);

            if (layoutAlgorithmProvider != null) {
                List<CustomLayoutAlgorithm> customLayoutAlgorithms = layoutAlgorithmProvider.getCustomLayoutAlgorithms();
                for (CustomLayoutAlgorithm customLayoutAlgorithm : customLayoutAlgorithms) {
                    layoutProviderRegistry.remove(customLayoutAlgorithm.getId());
                }
            }
            START extensionToLayoutAlgorithmProvider.put(extension, END  null);
        }

    }
","    public void removed(IExtension[] extensions) {
        for (IExtension extension : extensions) {
            CustomLayoutAlgorithmProvider layoutAlgorithmProvider = extensionToLayoutAlgorithmProvider.get(extension);

            if (layoutAlgorithmProvider != null) {
                List<CustomLayoutAlgorithm> customLayoutAlgorithms = layoutAlgorithmProvider.getCustomLayoutAlgorithms();
                for (CustomLayoutAlgorithm customLayoutAlgorithm : customLayoutAlgorithms) {
                    layoutProviderRegistry.remove(customLayoutAlgorithm.getId());
                }
            }
            extensionToLayoutAlgorithmProvider.remove(extension);
        }

    }
"
845,"This needs to be `typeId + 1`, since the parameter here is the _length_, while `typeId` is elsewhere used as an _index_.","        public void increment( int typeId )
        {
            if ( typeId >= counts.length )
            {
                counts = Arrays.copyOf( counts, max( counts.length * 2, typeId ) );
            }
            counts[typeId]++;
            if ( typeId > highestTypeId )
            {
                highestTypeId = typeId;
            }
        }
","        public void increment( int typeId )
        {
            if ( typeId >= counts.length )
            {
START                 counts = Arrays.copyOf( counts, max( counts.length * 2, typeId ) ); END 
            }
            counts[typeId]++;
            if ( typeId > highestTypeId )
            {
                highestTypeId = typeId;
            }
        }
","        public void increment( int typeId )
        {
            if ( typeId >= counts.length )
            {
                counts = Arrays.copyOf( counts, max( counts.length * 2, typeId + 1 ) );
            }
            counts[typeId]++;
            if ( typeId > highestTypeId )
            {
                highestTypeId = typeId;
            }
        }
"
846,"s/n/name/
n is always an index","	private static void delete(List<ReceiveCommand> cmds,
			List<ReceiveCommand> createCmds) {
		for (ReceiveCommand c : createCmds) {
			ObjectId id = c.getNewId();
			String n = c.getRefName();
			cmds.add(new ReceiveCommand(id, ObjectId.zeroId(), n));
		}
	}
","	private static void delete(List<ReceiveCommand> cmds,
			List<ReceiveCommand> createCmds) {
		for (ReceiveCommand c : createCmds) {
			ObjectId id = c.getNewId();
			String START  n = END  c.getRefName();
			cmds.add(new ReceiveCommand(id, ObjectId.zeroId(), n));
		}
	}
","	private static void delete(List<ReceiveCommand> cmds,
			List<ReceiveCommand> createCmds) {
		for (ReceiveCommand cmd : createCmds) {
			ObjectId id = cmd.getNewId();
			String name = cmd.getRefName();
			cmds.add(new ReceiveCommand(id, ObjectId.zeroId(), name));
		}
	}
"
847,"Use the one-argument version of convert, since the second argument passed in here is never used.","	public RefreshLocalVisitor(IProgressMonitor monitor) {
		this.monitor = SubMonitor.convert(monitor, TOTAL_WORK);
		workspace = (Workspace) ResourcesPlugin.getWorkspace();
		resourceChanged = false;
		String msg = Messages.resources_errorMultiRefresh;
		errors = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.FAILED_READ_LOCAL, msg, null);
	}
","	public RefreshLocalVisitor(IProgressMonitor monitor) {
		this.monitor = START SubMonitor.convert(monitor, END  TOTAL_WORK);
		workspace = (Workspace) ResourcesPlugin.getWorkspace();
		resourceChanged = false;
		String msg = Messages.resources_errorMultiRefresh;
		errors = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.FAILED_READ_LOCAL, msg, null);
	}
","	public RefreshLocalVisitor(IProgressMonitor monitor) {
		this.monitor = SubMonitor.convert(monitor);
		workspace = (Workspace) ResourcesPlugin.getWorkspace();
		resourceChanged = false;
		String msg = Messages.resources_errorMultiRefresh;
		errors = new MultiStatus(ResourcesPlugin.PI_RESOURCES, IResourceStatus.FAILED_READ_LOCAL, msg, null);
	}
"
848,"Should we really use it by default?

I agree this would be nice (and we surely will do it as of BV 1.2) but for now the spec [describes](http://beanvalidation.org/1.1/spec/#constraintdeclarationvalidationprocess-methodlevelconstraints-definingparameterconstraints-namingparameters) ""arg0"", ""arg1"" etc. as the default names. I feel we should stick to this for now.","	private ConfigurationImpl() {
		this.validationBootstrapParameters = new ValidationBootstrapParameters();
		this.defaultResourceBundleLocator = new PlatformResourceBundleLocator( ResourceBundleMessageInterpolator.USER_VALIDATION_MESSAGES );
		this.defaultTraversableResolver = new DefaultTraversableResolver();
		this.defaultConstraintValidatorFactory = new ConstraintValidatorFactoryImpl();
		if ( Version.getJavaRelease() >= 8 ) {
			this.defaultParameterNameProvider = new Java8DefaultParameterNameProvider();
		}
		else {
			this.defaultParameterNameProvider = new DefaultParameterNameProvider();
		}
		this.defaultMessageInterpolator = new ResourceBundleMessageInterpolator( defaultResourceBundleLocator );
	}
","	private ConfigurationImpl() {
		this.validationBootstrapParameters = new ValidationBootstrapParameters();
		this.defaultResourceBundleLocator = new PlatformResourceBundleLocator( ResourceBundleMessageInterpolator.USER_VALIDATION_MESSAGES );
		this.defaultTraversableResolver = new DefaultTraversableResolver();
		this.defaultConstraintValidatorFactory = new ConstraintValidatorFactoryImpl();
		if ( Version.getJavaRelease() >= 8 ) {
START 			this.defaultParameterNameProvider = new Java8DefaultParameterNameProvider(); END 
		}
		else {
			this.defaultParameterNameProvider = new DefaultParameterNameProvider();
		}
		this.defaultMessageInterpolator = new ResourceBundleMessageInterpolator( defaultResourceBundleLocator );
	}
","	private ConfigurationImpl() {
		this.validationBootstrapParameters = new ValidationBootstrapParameters();
		this.defaultResourceBundleLocator = new PlatformResourceBundleLocator( ResourceBundleMessageInterpolator.USER_VALIDATION_MESSAGES );
		this.defaultTraversableResolver = new DefaultTraversableResolver();
		this.defaultConstraintValidatorFactory = new ConstraintValidatorFactoryImpl();
		this.defaultParameterNameProvider = new DefaultParameterNameProvider();
		this.defaultMessageInterpolator = new ResourceBundleMessageInterpolator( defaultResourceBundleLocator );
	}
"
849,Do we need to declare object and then assign to null? Just remove them,"	public void testNull_Event() {

		XDRResponseEventType eventA = new XDRResponseEventType();
		XDREventType eventB = new XDREventType();

		eventA = null;
		eventB = null;
		assertNull(xdrTransformHelper.transformXDRResponseToCheckPolicy(eventA));
		assertNull(xdrTransformHelper.transformXDRToCheckPolicy(eventB));

	}
","	public void testNull_Event() {

		XDRResponseEventType eventA = new XDRResponseEventType();
START 		XDREventType eventB = new XDREventType(); END 

		eventA = null;
		eventB = null;
		assertNull(xdrTransformHelper.transformXDRResponseToCheckPolicy(eventA));
		assertNull(xdrTransformHelper.transformXDRToCheckPolicy(eventB));

	}
","	public void testNull_Event() {

		assertNull(xdrTransformHelper.transformXDRResponseToCheckPolicy(null));
		assertNull(xdrTransformHelper.transformXDRToCheckPolicy(null));

	}
"
850,"Cruft, It doesn't matter, but this is an unused variable.","    public void testJNDIBindingsNoAppName() throws Exception {
        boolean passed = false;
        Context ctx = getInitialContext(HOST, PORT);
        Hello ejb = (Hello) ctx.lookup(""ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello"");
        Assert.assertNotNull(""Null object returned for local business interface lookup in the ejb namespace"", ejb);
        Assert.assertTrue(""Expected JNDI binding message not found"", LoggingUtil.hasLogMessage(managementClient, TEST_HANDLER_NAME,
                ""ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello""));
    }
","    public void testJNDIBindingsNoAppName() throws Exception {
START         boolean passed = false; END 
        Context ctx = getInitialContext(HOST, PORT);
        Hello ejb = (Hello) ctx.lookup(""ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello"");
        Assert.assertNotNull(""Null object returned for local business interface lookup in the ejb namespace"", ejb);
        Assert.assertTrue(""Expected JNDI binding message not found"", LoggingUtil.hasLogMessage(managementClient, TEST_HANDLER_NAME,
                ""ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello""));
    }
","    public void testJNDIBindingsNoAppName() throws Exception {
        Context ctx = getInitialContext(HOST, PORT);
        Hello ejb = (Hello) ctx.lookup(""ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello"");
        Assert.assertNotNull(""Null object returned for local business interface lookup in the ejb namespace"", ejb);
        Assert.assertTrue(""Expected JNDI binding message not found"", LoggingUtil.hasLogMessage(managementClient, TEST_HANDLER_NAME,
                ""ejb:/ejb-jndi/Hello!org.jboss.as.test.integration.ejb.jndi.logging.Hello""));
    }
"
851,remove,"	public CrossesListDescriptionSheetParser(final T importedList, final UserDataManager userDataManager) {
		this.importedList = importedList;
		this.doParseDetails = true;
		this.doParseConditions = true;
		this.doParseFactors = true;
		this.doParseVariates = true;
		this.userDataManager = userDataManager;
		this.descriptionSheetIndex = 0;
		;
	}
","	public CrossesListDescriptionSheetParser(final T importedList, final UserDataManager userDataManager) {
		this.importedList = importedList;
		this.doParseDetails = true;
		this.doParseConditions = true;
		this.doParseFactors = true;
		this.doParseVariates = true;
		this.userDataManager = userDataManager;
		this.descriptionSheetIndex = 0;
START 		; END 
	}
","	public CrossesListDescriptionSheetParser(final T importedList, final UserDataManager userDataManager) {
		this.importedList = importedList;
		this.doParseDetails = true;
		this.doParseConditions = true;
		this.doParseFactors = true;
		this.doParseVariates = true;
		this.userDataManager = userDataManager;
		this.descriptionSheetIndex = 0;
	}
"
852,please change to ternary,"    public VolumeClassification getVolumeClassification() {
        if (volumeClassification == null) {
            if (active) {
                return VolumeClassification.Volume;
            }
            return VolumeClassification.Snapshot;
        }
        return volumeClassification;
    }
","    public VolumeClassification getVolumeClassification() {
        if (volumeClassification == null) {
            if START  (active) END  {
                return VolumeClassification.Volume;
            }
            return VolumeClassification.Snapshot;
        }
        return volumeClassification;
    }
","    public VolumeClassification getVolumeClassification() {
        if (volumeClassification == null) {
            return (active ? VolumeClassification.Volume : VolumeClassification.Snapshot);
        }
        return volumeClassification;
    }
"
853,"no need for isNotNull nor isInstanceOf(String.class). They are both implicit with .isEqualTo(""1.0.0.0"")","  public void registerSonarQubeVersion_publishes_version_on_first_call() {
    ClusterProperties clusterProperties = new ClusterProperties(newClusterSettings());
    try (HazelcastCluster hzCluster = HazelcastCluster.builder(clusterProperties).build()) {
      hzCluster.registerSonarQubeVersion(""1.0.0.0"");

      HazelcastInstance hzInstance = createHazelcastClient(hzCluster);
      assertThat(hzInstance.getAtomicReference(SONARQUBE_VERSION).get())
        .isNotNull()
        .isInstanceOf(String.class)
        .isEqualTo(""1.0.0.0"");
    }
  }
","  public void registerSonarQubeVersion_publishes_version_on_first_call() {
    ClusterProperties clusterProperties = new ClusterProperties(newClusterSettings());
    try (HazelcastCluster hzCluster = HazelcastCluster.builder(clusterProperties).build()) {
      hzCluster.registerSonarQubeVersion(""1.0.0.0"");

      HazelcastInstance hzInstance = createHazelcastClient(hzCluster);
      assertThat(hzInstance.getAtomicReference(SONARQUBE_VERSION).get())
        .isNotNull()
        .isInstanceOf(String.class)
START         .isEqualTo(""1.0.0.0""); END 
    }
  }
","  public void registerSonarQubeVersion_publishes_version_on_first_call() {
    ClusterProperties clusterProperties = new ClusterProperties(newClusterSettings());
    try (HazelcastCluster hzCluster = HazelcastCluster.create(clusterProperties)) {
      hzCluster.registerSonarQubeVersion(""1.0.0.0"");

      HazelcastInstance hzInstance = createHazelcastClient(hzCluster);
      assertThat(hzInstance.getAtomicReference(SONARQUBE_VERSION).get()).isEqualTo(""1.0.0.0"");
    }
  }
"
854,Null pointer...,"        public String[] getColumnTexts(@NonNull ITimeGraphEntry entry) {
            String[] texts = new String[fColumns.length];
            for (int i = 0; i < fColumns.length; i++) {
                texts[i] = fLabelProvider.getColumnText(entry, i);
            }
            return texts;
        }
","        public String[] getColumnTexts(@NonNull ITimeGraphEntry entry) {
            String[] texts = new START String[fColumns.length]; END 
            for (int i = 0; i < fColumns.length; i++) {
                texts[i] = fLabelProvider.getColumnText(entry, i);
            }
            return texts;
        }
","        public String[] getColumnTexts(@NonNull ITimeGraphEntry entry) {
            String[] texts = null;
            if (fColumns != null) {
                texts = new String[fColumns.length];
                for (int i = 0; i < fColumns.length; i++) {
                    texts[i] = fLabelProvider.getColumnText(entry, i);
                }
            } else {
                texts = new String[1];
                texts[0] = entry.getName();
            }
            return texts;
        }
"
855,private,"    protected Pageview() {
    }
","    protected Pageview() {
START     } END 
","    private Pageview() {
    }
"
856,import the class Messages ?,"	public TreeFillingConfigurationDialog(final Shell parentShell, final TreeFillingConfiguration treefillingConfiguration, final List<ILabelProviderConfiguration> existingLabelProvidersConfiguration,
			final List<PasteEObjectConfiguration> existingPasteConfigurations) {
		super(parentShell);
		this.modifiedTreefillingConfiguration = EcoreUtil.copy(treefillingConfiguration);
		this.existingLabelProviderConfigurations = existingLabelProvidersConfiguration;
		this.existingPasteConfigurations = existingPasteConfigurations;
		setTitle(org.eclipse.papyrus.customization.nattableconfiguration.messages.Messages.TreeFillingConfigurationDialog_treeFillingConfigurationDialogName);
	}
","	public TreeFillingConfigurationDialog(final Shell parentShell, final TreeFillingConfiguration treefillingConfiguration, final List<ILabelProviderConfiguration> existingLabelProvidersConfiguration,
			final List<PasteEObjectConfiguration> existingPasteConfigurations) {
		super(parentShell);
		this.modifiedTreefillingConfiguration = EcoreUtil.copy(treefillingConfiguration);
		this.existingLabelProviderConfigurations = existingLabelProvidersConfiguration;
		this.existingPasteConfigurations = existingPasteConfigurations;
START 		setTitle(org.eclipse.papyrus.customization.nattableconfiguration.messages.Messages.TreeFillingConfigurationDialog_treeFillingConfigurationDialogName); END 
	}
","	public TreeFillingConfigurationDialog(final Shell parentShell, final TreeFillingConfiguration treefillingConfiguration, final List<ILabelProviderConfiguration> existingLabelProvidersConfiguration,
			final List<PasteEObjectConfiguration> existingPasteConfigurations) {
		super(parentShell);
		this.modifiedTreefillingConfiguration = EcoreUtil.copy(treefillingConfiguration);
		this.existingLabelProviderConfigurations = existingLabelProvidersConfiguration;
		this.existingPasteConfigurations = existingPasteConfigurations;
		setTitle(Messages.TreeFillingConfigurationDialog_treeFillingConfigurationDialogName);
	}
"
857,"`current` is redundant, just use `idx`","    public void execute(final Talks talks) throws IOException {
        int idx = this.index(talks);
        for (final Talk talk : talks.active()) {
            final int current = idx + 1;
            talk.modify(
                new Directives()
                    .xpath(""/talk/request"")
                    .attr(""index"", Integer.toString(current))
            );
            idx = current;
        }
    }
","    public void execute(final Talks talks) throws IOException {
        int idx = this.index(talks);
        for (final Talk talk : talks.active()) {
START             final int current = idx + 1; END 
            talk.modify(
                new Directives()
                    .xpath(""/talk/request"")
                    .attr(""index"", Integer.toString(current))
            );
            idx = current;
        }
    }
","    public void execute(final Talks talks) throws IOException {
        int idx = this.index(talks);
        for (final Talk talk : talks.active()) {
            idx += 1;
            talk.modify(
                new Directives()
                    .xpath(""/talk/request"")
                    .attr(""index"", Integer.toString(idx))
            );
        }
    }
"
858,"Looks good to me, but worth to protect `getFirstDrId()` and `getLastDrId()` too, they'll throw `NoSuchElementException` also if `m_map` is empty.","    public long getSafePointDrId() {
        // Acquire lock to avoid seeing bad data while another thread is in truncate()
        synchronized (m_map) {
            assert (!m_map.isEmpty());
            return end(m_map.asRanges().iterator().next());
        }
    }
","    public long getSafePointDrId() {
        // Acquire lock to avoid seeing bad data while another thread is in truncate()
START         synchronized (m_map) { END 
            assert (!m_map.isEmpty());
            return end(m_map.asRanges().iterator().next());
        }
    }
","    public long getSafePointDrId() {
        assert (!m_map.isEmpty());
        return end(m_map.asRanges().iterator().next());
    }
"
859,"is this necessary in the set up?
wouldnt it be sufficient if this would be done once in the layout test?","	public void setUp() throws Exception {
		createProjectWithNfcAndSetVariable(PROJECT_NAME);
		numDetectedTags.setValue(0);

		nfcBrickPosition = 0;
		setVariableIDPosition = 1;
		setVariableMessagePosition = 2;
		baseActivityTestRule.launchActivity(null);

		checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableIDPosition, READ_TAG_ID);
		checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableMessagePosition,
				READ_TAG_MESSAGE);
	}
","	public void setUp() throws Exception {
		createProjectWithNfcAndSetVariable(PROJECT_NAME);
		numDetectedTags.setValue(0);

		nfcBrickPosition = 0;
		setVariableIDPosition = 1;
		setVariableMessagePosition = 2;
		baseActivityTestRule.launchActivity(null);

START 		checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableIDPosition, READ_TAG_ID); END 
		checkIfSpinnerOnBrickAtPositionShowsString(R.id.set_variable_spinner, setVariableMessagePosition,
				READ_TAG_MESSAGE);
	}
","	public void setUp() throws Exception {
		createProjectWithNfcAndSetVariable();
		baseActivityTestRule.launchActivity(null);
	}
"
860,"I don't think ProjectsImpl.this is necessary, it would only be necessary if the method call were get(this) which conflicts with the method name in the anonymous class.","  public ListRequest list() {
    return new ListRequest() {
      @Override
      public List<ProjectInfo> get() throws RestApiException {
        return ProjectsImpl.this.list(this);
      }
    };
  }
","  public ListRequest list() {
    return new ListRequest() {
      @Override
      public List<ProjectInfo> get() throws RestApiException {
START         return ProjectsImpl.this.list(this); END 
      }
    };
  }
","  public ListRequest list() {
    return new ListRequest() {
      @Override
      public List<ProjectInfo> get() throws RestApiException {
        return list(this);
      }
    };
  }
"
861,"potential NPE, entity can be NULL","    public void validateEnums(WatchDog entity) {
        EnumValidator.validateEnum(WatchdogAction.class, entity.getAction(), true);
        EnumValidator.validateEnum(WatchdogModel.class, entity.getModel(), false);
    }
","START     public void validateEnums(WatchDog entity) { END 
        EnumValidator.validateEnum(WatchdogAction.class, entity.getAction(), true);
        EnumValidator.validateEnum(WatchdogModel.class, entity.getModel(), false);
    }
","    public void validateEnums(WatchDog entity) {
        if (entity != null) {
            EnumValidator.validateEnum(WatchdogAction.class, entity.getAction(), true);
            EnumValidator.validateEnum(WatchdogModel.class, entity.getModel(), true);
        }
    }
"
862,My preference would be to remove `e.printStackTrace()` altogether and let the 'error' filters determine if they want to log the error.,"    void error(ZuulException e) {
        RequestContext.getCurrentContext().setThrowable(e);
        zuulRunner.error();
        LOG.error(e.getMessage(), e);
    }
","    void error(ZuulException e) {
        RequestContext.getCurrentContext().setThrowable(e);
        zuulRunner.error();
START         LOG.error(e.getMessage(), e); END 
    }
","    void error(ZuulException e) {
        RequestContext.getCurrentContext().setThrowable(e);
        zuulRunner.error();
    }
"
863,rename to element,"	private List<String> defaultIncludedModuleNamesForUnnamedModule() {
		if (fJavaElements != null) {
			List<IPackageFragmentRoot> roots= new ArrayList<>();
			for (IJavaElement fJavaElement : fJavaElements) {
				if (fJavaElement instanceof IPackageFragmentRoot) {
					roots.add((IPackageFragmentRoot) fJavaElement);
				}
			}
			return JavaCore.defaultRootModules(roots);
		}
		return Collections.emptyList();
	}
","	private List<String> defaultIncludedModuleNamesForUnnamedModule() {
		if (fJavaElements != null) {
			List<IPackageFragmentRoot> roots= new ArrayList<>();
			for (IJavaElement START  fJavaElement : END  fJavaElements) {
				if (fJavaElement instanceof IPackageFragmentRoot) {
					roots.add((IPackageFragmentRoot) fJavaElement);
				}
			}
			return JavaCore.defaultRootModules(roots);
		}
		return Collections.emptyList();
	}
","	private List<String> defaultIncludedModuleNamesForUnnamedModule() {
		if (fJavaElements != null) {
			List<IPackageFragmentRoot> roots= new ArrayList<>();
			for (IJavaElement element : fJavaElements) {
				if (element instanceof IPackageFragmentRoot) {
					roots.add((IPackageFragmentRoot) element);
				}
			}
			return JavaCore.defaultRootModules(roots);
		}
		return Collections.emptyList();
	}
"
864,"`@ResponseStatus(HttpStatus.NO_RESPONSE)`, void return type

Same for `/enable`","  public ResponseEntity<?> disable(@RequestBody List<Long> printerIds) throws IOException {
    return setState(printerIds, false);
  }
","START   public ResponseEntity<?> disable(@RequestBody List<Long> printerIds) throws IOException { END 
    return setState(printerIds, false);
  }
","  public void disable(@RequestBody List<Long> printerIds) throws IOException {
    setState(printerIds, false);
  }
"
865,"Make the option validators above typed:
`public static final FloatValidator FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR ...`

and change this line to:
`return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR);`

Same for the other option.","  public double getFilterMinSelectivityEstimateFactor() {
    return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR.getOptionName()).float_val;
  }
","  public double getFilterMinSelectivityEstimateFactor() {
START     return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR.getOptionName()).float_val; END 
  }
","  public double getFilterMinSelectivityEstimateFactor() {
    return options.getOption(FILTER_MIN_SELECTIVITY_ESTIMATE_FACTOR);
  }
"
866,"why did you need to copy the env?
it is accessible via getFactory().getEnv().","	public JavaOutputProcessor(PrettyPrinter printer) {
		this.printer = printer;
		this.environment = printer.getEnvironment();
	}
","	public JavaOutputProcessor(PrettyPrinter printer) {
START 		this.printer = printer; END 
		this.environment = printer.getEnvironment();
	}
","	public JavaOutputProcessor(PrettyPrinter printer) {
		this.printer = printer;
	}
"
867,nit `IllegalArgumentException`,"    public BucketFunction getBucketFunction(
            ConnectorTransactionHandle transactionHandle,
            ConnectorSession session,
            ConnectorPartitioningHandle partitioningHandle,
            List<Type> partitionChannelTypes,
            int bucketCount)
    {
        HivePartitioningHandle handle = (HivePartitioningHandle) partitioningHandle;
        BucketFunctionType bucketFunctionType = handle.getBucketFunctionType();
        switch (bucketFunctionType) {
            case HIVE_COMPATIBLE:
                return createHiveCompatibleBucketFunction(bucketCount, handle.getHiveTypes().get());
            case PRESTO_NATIVE:
                return createPrestoNativeBucketFunction(bucketCount, handle.getTypes().get());
            default:
                throw new IllegalStateException(""Unsupported bucket function type "" + bucketFunctionType);
        }
    }
","    public BucketFunction getBucketFunction(
            ConnectorTransactionHandle transactionHandle,
            ConnectorSession session,
            ConnectorPartitioningHandle partitioningHandle,
            List<Type> partitionChannelTypes,
            int bucketCount)
    {
        HivePartitioningHandle handle = (HivePartitioningHandle) partitioningHandle;
        BucketFunctionType bucketFunctionType = handle.getBucketFunctionType();
        switch (bucketFunctionType) {
            case HIVE_COMPATIBLE:
                return createHiveCompatibleBucketFunction(bucketCount, handle.getHiveTypes().get());
            case PRESTO_NATIVE:
                return createPrestoNativeBucketFunction(bucketCount, handle.getTypes().get());
            default:
START                 throw new IllegalStateException(""Unsupported bucket function type "" + bucketFunctionType); END 
        }
    }
","    public BucketFunction getBucketFunction(
            ConnectorTransactionHandle transactionHandle,
            ConnectorSession session,
            ConnectorPartitioningHandle partitioningHandle,
            List<Type> partitionChannelTypes,
            int bucketCount)
    {
        HivePartitioningHandle handle = (HivePartitioningHandle) partitioningHandle;
        BucketFunctionType bucketFunctionType = handle.getBucketFunctionType();
        switch (bucketFunctionType) {
            case HIVE_COMPATIBLE:
                return createHiveCompatibleBucketFunction(bucketCount, handle.getHiveTypes().get());
            case PRESTO_NATIVE:
                return createPrestoNativeBucketFunction(bucketCount, handle.getTypes().get());
            default:
                throw new IllegalArgumentException(""Unsupported bucket function type "" + bucketFunctionType);
        }
    }
"
868,This is only required in things that render the FluidStack in a TESR.,"    public void writePacketData(RailcraftOutputStream data) throws IOException {
        super.writePacketData(data);
        tankManager.writePacketData(data);
        data.writeBoolean(boiler.isBurning());
    }
","    public void writePacketData(RailcraftOutputStream data) throws IOException {
        super.writePacketData(data);
START         tankManager.writePacketData(data); END 
        data.writeBoolean(boiler.isBurning());
    }
","    public void writePacketData(RailcraftOutputStream data) throws IOException {
        super.writePacketData(data);
//        tankManager.writePacketData(data);
        data.writeBoolean(boiler.isBurning());
    }
"
869,This _smells_ bad.. what was your reasoning to catch `UpdateException`?,"    protected void setValue(final int rowIndex,
                            final int columnIndex,
                            final Date value) {
        DTCellValue52 dtCellValue52 = table52.getData()
                .get(rowIndex)
                .get(columnIndex);
        dtCellValue52
                .setDateValue(value);
        try {
            updateManager.update(table52,
                                 getUpdates(rowIndex,
                                            columnIndex));
        } catch (UpdateException e) {
            e.printStackTrace();
        }
    }
","    protected void setValue(final int rowIndex,
                            final int columnIndex,
                            final Date value) {
        DTCellValue52 dtCellValue52 = table52.getData()
                .get(rowIndex)
                .get(columnIndex);
        dtCellValue52
                .setDateValue(value);
        try {
            updateManager.update(table52,
                                 getUpdates(rowIndex,
                                            columnIndex));
START         } catch (UpdateException e) { END 
            e.printStackTrace();
        }
    }
","    protected void setValue(final int rowIndex,
                            final int columnIndex,
                            final Date value) {
        DTCellValue52 dtCellValue52 = table52.getData()
                .get(rowIndex)
                .get(columnIndex);
        dtCellValue52
                .setDateValue(value);
        updateManager.update(table52,
                             getUpdates(rowIndex,
                                        columnIndex));
    }
"
870,"```suggestion
                        () -> new TreeMap<>(Comparator.comparing(Event::getWhenOccured).thenComparing(Event::getExternalId)), Collectors.toList()));
```","    private TreeMap<Event, List<EntryDTO>> buildEventEntryDTOMap(List<EntryDTO> entryDTOS) {
        return entryDTOS.stream().collect(Collectors.groupingBy(EntryDTO::getEvent,
                        () -> new TreeMap<>(Comparator.comparing(Event::getExternalId).thenComparing(Event::getWhenOccured)), Collectors.toList()));
    }
","    private TreeMap<Event, List<EntryDTO>> buildEventEntryDTOMap(List<EntryDTO> entryDTOS) {
        return entryDTOS.stream().collect(Collectors.groupingBy(EntryDTO::getEvent,
START                         () -> new TreeMap<>(Comparator.comparing(Event::getExternalId).thenComparing(Event::getWhenOccured)), Collectors.toList())); END 
    }
","    private TreeMap<Event, List<EntryDTO>> buildEventEntryDTOMap(List<EntryDTO> entryDTOS) {
        return entryDTOS.stream().collect(Collectors.groupingBy(EntryDTO::getEvent,
                        () -> new TreeMap<>(Comparator.comparing(Event::getWhenOccured).thenComparing(Event::getExternalId)), Collectors.toList()));
    }
"
871,"1. set this method to private,
2. create helpers for each property","	public void verifyTableProperty(String propertyName, int propertyValue) {
		waitForElementByElement(table);
		Assertion.assertEquals(table.getAttribute(propertyName), Integer.toString(propertyValue));
		PageObjectLogging.log(
			""verifyTableProperty"",
			""table has correct "" + propertyName + "" property"",
			true
		);
	}
","START 	public void verifyTableProperty(String propertyName, int propertyValue) { END 
		waitForElementByElement(table);
		Assertion.assertEquals(table.getAttribute(propertyName), Integer.toString(propertyValue));
		PageObjectLogging.log(
			""verifyTableProperty"",
			""table has correct "" + propertyName + "" property"",
			true
		);
	}
","	private void verifyTableProperty(String propertyName, int propertyValue) {
		waitForElementByElement(table);
		Assertion.assertEquals(table.getAttribute(propertyName), Integer.toString(propertyValue));
		PageObjectLogging.log(
			""verifyTableProperty"",
			""table has correct "" + propertyName + "" property"",
			true
		);
	}
"
872,Please post the examples of content for new metadata cache files to the Jira description,"    public ColumnMetadata_v4(String[] name, PrimitiveType.PrimitiveTypeName primitiveType, Object minValue, Object maxValue, Long nulls) {
      this.name = name;
      this.minValue = minValue;
      this.maxValue = maxValue;
      this.nulls = nulls;
      this.primitiveType = primitiveType;
    }
","    public ColumnMetadata_v4(String[] name, PrimitiveType.PrimitiveTypeName primitiveType, Object minValue, Object maxValue, Long nulls) {
START       this.name = name; END 
      this.minValue = minValue;
      this.maxValue = maxValue;
      this.nulls = nulls;
      this.primitiveType = primitiveType;
    }
","    public ColumnMetadata_v4(String[] name, PrimitiveType.PrimitiveTypeName primitiveType, Object minValue, Object maxValue, Long nulls) {
      super(name, primitiveType, minValue, maxValue, nulls);
    }
"
873,"The @Override should go on a line on its own, like in getReverseEntries() and the same below.","    @Override public ReflogEntry getReverseEntry(int number) throws IOException {
        lock.lock();
        try {
            LogCursor cursor = reftable.seekLog(refname);
            while (true) {
                if (!cursor.next() || number < 0) {
                    return null;
                }
                if (number == 0) {
                    return cursor.getReflogEntry();
                }
                number--;
            }
        } finally {
            lock.unlock();
        }
    }
","    START @Override public END  ReflogEntry getReverseEntry(int number) throws IOException {
        lock.lock();
        try {
            LogCursor cursor = reftable.seekLog(refname);
            while (true) {
                if (!cursor.next() || number < 0) {
                    return null;
                }
                if (number == 0) {
                    return cursor.getReflogEntry();
                }
                number--;
            }
        } finally {
            lock.unlock();
        }
    }
","	public ReflogEntry getReverseEntry(int number) throws IOException {
		lock.lock();
		try {
			LogCursor cursor = reftable.seekLog(refname);
			while (true) {
				if (!cursor.next() || number < 0) {
					return null;
				}
				if (number == 0) {
					return cursor.getReflogEntry();
				}
				number--;
			}
		} finally {
			lock.unlock();
		}
	}
"
874,the .bagit folder does not have to be hidden. .bagit is our incubating next version of the bagit spec; it solves a lot of problems from the originial spec.,"  public void testVersion0_98IsValid() throws Exception{
    rootDir = Paths.get(getClass().getClassLoader().getResource(""bags/v0_98/bag"").toURI());
    if (System.getProperty(""os.name"").contains(""Windows"")){
    	Path bagitDir = rootDir.resolve("".bagit"");
    	Files.setAttribute(bagitDir, ""dos:hidden"", Boolean.TRUE);
    }
    Bag bag = reader.read(rootDir);
    
    sut.isValid(bag, true);
  }
","  public void testVersion0_98IsValid() throws Exception{
    rootDir = Paths.get(getClass().getClassLoader().getResource(""bags/v0_98/bag"").toURI());
    if (System.getProperty(""os.name"").contains(""Windows"")){
START     	Path bagitDir = rootDir.resolve("".bagit""); END 
    	Files.setAttribute(bagitDir, ""dos:hidden"", Boolean.TRUE);
    }
    Bag bag = reader.read(rootDir);
    
    sut.isValid(bag, true);
  }
","  public void testVersion0_98IsValid() throws Exception{
    rootDir = Paths.get(getClass().getClassLoader().getResource(""bags/v0_98/bag"").toURI());
    Bag bag = reader.read(rootDir);
    
    sut.isValid(bag, true);
  }
"
875,remove `final` modifiers everywhere.,"  public ProgramState checkPreStatement(CheckerContext context, Tree syntaxNode) {
    final AbstractStatementVisitor visitor = new PreStatementVisitor(context);
    syntaxNode.accept(visitor);
    return visitor.programState;
  }
","  public ProgramState checkPreStatement(CheckerContext context, Tree syntaxNode) {
START     final AbstractStatementVisitor visitor = new PreStatementVisitor(context); END 
    syntaxNode.accept(visitor);
    return visitor.programState;
  }
","  public ProgramState checkPreStatement(CheckerContext context, Tree syntaxNode) {
    AbstractStatementVisitor visitor = new PreStatementVisitor(context);
    syntaxNode.accept(visitor);
    return visitor.programState;
  }
"
876,This breaks compatibility.,"    ParameterMap getQueryParams(MuleEvent event)
    {
        return resolveParams(event, HttpParamType.QUERY_PARAM);
    }
","START     ParameterMap getQueryParams(MuleEvent event) END 
    {
        return resolveParams(event, HttpParamType.QUERY_PARAM);
    }
","    public ParameterMap getQueryParams(MuleEvent event)
    {
        return resolveParams(event, HttpParamType.QUERY_PARAM);
    }
"
877,maybe make a copy constructor for this case?,"  public Mutation(Mutation m) {
    m.serialize();
    this.row = m.row;
    this.data = m.data;
    this.size = new MutationSize(m.size.entries, m.size.sizeInBytes);
    this.values = m.values;
    this.replicationSources = m.replicationSources;
  }
","  public Mutation(Mutation m) {
    m.serialize();
    this.row = m.row;
    this.data = m.data;
START     this.size = new MutationSize(m.size.entries, m.size.sizeInBytes); END 
    this.values = m.values;
    this.replicationSources = m.replicationSources;
  }
","  public Mutation(Mutation m) {
    m.serialize();
    this.row = m.row;
    this.data = m.data;
    this.entries = m.entries;
    this.values = m.values;
    this.replicationSources = m.replicationSources;
  }
"
878,"The last `null` is interpreted as a null `Flag`, not as a null `Flag[]`, and is causing some NPEs in the test suite: http://ci.infinispan.org/viewLog.html?buildId=6702&buildTypeId=bt9","   public DecoratedCache(AdvancedCache<K, V> delegate, ClassLoader classLoader) {
      this(delegate, classLoader, null, null);
   }
","   public DecoratedCache(AdvancedCache<K, V> delegate, ClassLoader classLoader) {
START       this(delegate, classLoader, null, null); END 
   }
","   public DecoratedCache(AdvancedCache<K, V> delegate, ClassLoader classLoader) {
      this(delegate, classLoader, null);
   }
"
879,Ternary ? true : false. ;),"		default Query getRemoveByQuery() {

			if (isVersionedEntity()) {
				return getQueryForVersion();
			}

			return getByIdQuery();
		}
","		default Query getRemoveByQuery() {

START 			if (isVersionedEntity()) { END 
				return getQueryForVersion();
			}

			return getByIdQuery();
		}
","		default Query getRemoveByQuery() {
			return isVersionedEntity() ? getQueryForVersion() : getByIdQuery();
		}
"
880,"There are still a lot of calls to this method, resulting in errors that will not reference any BPMN element. From a quick look, many of those do have an element id that we could reference.","  public void addError(String errorMessage, Element element) {
    errors.add(new ProblemImpl(errorMessage, name, element));
  }
","START   public void addError(String errorMessage, Element element) { END 
    errors.add(new ProblemImpl(errorMessage, name, element));
  }
","  public void addError(String errorMessage, Element element) {
    errors.add(new ProblemImpl(errorMessage, element));
  }
"
881,Suggestion: Use an else-if for these two and provide the missing braces. And instead of length() == 0 I'd use isEmpty().,"	private void validatePage() {
		String message = null;
		if (userText.getText().trim().length() == 0)
			message = Messages.CredentialsWizardPage_ErrorUser;

		if (message == null && passwordText.getText().trim().length() == 0)
			message = Messages.CredentialsWizardPage_ErrorPassword;

		setErrorMessage(message);
		setPageComplete(message == null);

	}
","	private void validatePage() {
		String message = null;
		if (userText.getText().trim().length() == 0)
			message = Messages.CredentialsWizardPage_ErrorUser;

START 		if (message == null && passwordText.getText().trim().length() == 0) END 
			message = Messages.CredentialsWizardPage_ErrorPassword;

		setErrorMessage(message);
		setPageComplete(message == null);

	}
","	private void validatePage() {
		String message = null;
		if (userText.getText().trim().isEmpty()) {
			message = Messages.CredentialsWizardPage_ErrorUser;
		} else if (passwordText.getText().trim().isEmpty()) {
			message = Messages.CredentialsWizardPage_ErrorPassword;
		}

		setErrorMessage(message);
		setPageComplete(message == null);

	}
"
882,"You probably don't want to pick this if `browserName` is also `chrome` or `chromium`, right? Otherwise this will match: `{""browserName"": ""chrome"", ""goog:chromeOptions"": {}}`, which isn't what you want.","  public boolean isSupporting(Capabilities capabilities) {
    return BrowserType.EDGE.equals(capabilities.getBrowserName()) ||
           capabilities.getCapability(""chromeOptions"") != null ||
           capabilities.getCapability(""goog:chromeOptions"") != null;
  }
","  public boolean isSupporting(Capabilities capabilities) {
    return BrowserType.EDGE.equals(capabilities.getBrowserName()) ||
           capabilities.getCapability(""chromeOptions"") != null ||
START            capabilities.getCapability(""goog:chromeOptions"") != null; END 
  }
","  public boolean isSupporting(Capabilities capabilities) {
    return BrowserType.EDGE.equals(capabilities.getBrowserName());
  }
"
883,"getSHT() can never actually be null, we should just annotate it.","    public HistoryTreeStub getHistoryTree() {
        return (HistoryTreeStub) NonNullUtils.checkNotNull(super.getSHT());
    }
","    public HistoryTreeStub getHistoryTree() {
START         return (HistoryTreeStub) NonNullUtils.checkNotNull(super.getSHT()); END 
    }
","    public HistoryTreeStub getHistoryTree() {
        return (HistoryTreeStub) super.getSHT();
    }
"
884,"why the newArrayList?

Iterables.filter already returns an iterable.","    public static Iterable<ITmfEventAspect<?>> getEventAspects(ITmfTrace trace, Class<? extends ITmfEventAspect<?>> aspectClass) {
         return Lists.newArrayList(Iterables.filter(Iterables.concat(trace.getEventAspects(), EXTRA_ASPECTS), aspect -> aspectClass.isAssignableFrom(aspect.getClass())));
    }
","    public static Iterable<ITmfEventAspect<?>> getEventAspects(ITmfTrace trace, Class<? extends ITmfEventAspect<?>> aspectClass) {
         return START  Lists.newArrayList(Iterables.filter(Iterables.concat(trace.getEventAspects(), END  EXTRA_ASPECTS), aspect -> aspectClass.isAssignableFrom(aspect.getClass())));
    }
","    public static Iterable<ITmfEventAspect<?>> getEventAspects(ITmfTrace trace, Class<? extends ITmfEventAspect<?>> aspectClass) {
         return Iterables.filter(Iterables.concat(trace.getEventAspects(), EXTRA_ASPECTS), aspect -> aspectClass.isAssignableFrom(aspect.getClass()));
    }
"
885,So `PrestoSparkRowBuffer#get` is a blocked call. Is there any reason for that -- I am asking this since the general convention in Presto seems to be using `ListenableFuture<PrestoSparkRow>` for such cases?,"    public PrestoSparkRow get()
            throws InterruptedException
    {
        PrestoSparkRow row;
        synchronized (monitor) {
            while (!finished && buffer.isEmpty()) {
                monitor.wait();
            }
            if (finished) {
                return null;
            }
            row = buffer.poll();
        }
        memoryManager.updateMemoryUsage(-row.getRetainedSize());
        return row;
    }
","    public PrestoSparkRow get()
            throws InterruptedException
    {
        PrestoSparkRow row;
        synchronized (monitor) {
            while (!finished && buffer.isEmpty()) {
START                 monitor.wait(); END 
            }
            if (finished) {
                return null;
            }
            row = buffer.poll();
        }
        memoryManager.updateMemoryUsage(-row.getRetainedSize());
        return row;
    }
","    public PrestoSparkRow get()
            throws InterruptedException
    {
        PrestoSparkRow row = null;
        synchronized (monitor) {
            while (buffer.isEmpty() && !finished) {
                monitor.wait();
            }
            if (!buffer.isEmpty()) {
                row = buffer.poll();
            }
        }
        if (row != null) {
            memoryManager.updateMemoryUsage(-row.getRetainedSize());
        }
        return row;
    }
"
886,This is useless since clear() below resets position to zero?,"    private ByteBuffer parsePacketIDBAndNRB(int blockLength) throws IOException {

        ByteBuffer pcapPacketData;

        pcapPacketData = ByteBuffer.allocate(blockLength - PcapFileValues.PCAPNG_PACKET_HEADER_SIZE);
        pcapPacketData.position(PcapFileValues.PCAPNG_PACKET_HEADER_SIZE);
        pcapPacketData.clear();
        SeekableByteChannel fFileChannel;
        try {
            fFileChannel = getFileChannel();
            fFileChannel.read(pcapPacketData);
        } catch (BadPcapFileException e1) {
            /* Just ignore */
        }

        pcapPacketData.flip();

        return pcapPacketData;
    }
","    private ByteBuffer parsePacketIDBAndNRB(int blockLength) throws IOException {

        ByteBuffer pcapPacketData;

        pcapPacketData = ByteBuffer.allocate(blockLength - PcapFileValues.PCAPNG_PACKET_HEADER_SIZE);
START         pcapPacketData.position(PcapFileValues.PCAPNG_PACKET_HEADER_SIZE); END 
        pcapPacketData.clear();
        SeekableByteChannel fFileChannel;
        try {
            fFileChannel = getFileChannel();
            fFileChannel.read(pcapPacketData);
        } catch (BadPcapFileException e1) {
            /* Just ignore */
        }

        pcapPacketData.flip();

        return pcapPacketData;
    }
","    private ByteBuffer parsePacketIDBAndNRB(int blockLength) throws IOException {

        ByteBuffer pcapPacketData;

        pcapPacketData = ByteBuffer.allocate(blockLength - PcapFileValues.PCAPNG_PACKET_HEADER_SIZE);
        pcapPacketData.clear();
        SeekableByteChannel fFileChannel;
        try {
            fFileChannel = getFileChannel();
            fFileChannel.read(pcapPacketData);
        } catch (BadPcapFileException e1) {
            /* Just ignore */
        }

        pcapPacketData.flip();

        return pcapPacketData;
    }
"
887,merge into one line,"  public MiniEditorComponentObject triggerEditCommentArea() {
    jsActions.scrollToElement(allCommentsArea);
    WebElement mostRecentComment = articleComments.get(0);
    PageObjectLogging.log(""First check"",mostRecentComment.getText(), true);
    JavascriptExecutor js = (JavascriptExecutor) driver;
    WebElement editButton = mostRecentComment.findElement(By.cssSelector(EDIT_BUTTON_SELECTOR));
    Actions actions =  new Actions(driver);
    actions.moveToElement(editButton).perform();
    js.executeScript(""arguments[0].querySelector(arguments[1]).click()"", mostRecentComment,
                     EDIT_BUTTON_SELECTOR);
    return new MiniEditorComponentObject(driver);
  }
","  public MiniEditorComponentObject triggerEditCommentArea() {
    jsActions.scrollToElement(allCommentsArea);
    WebElement mostRecentComment = articleComments.get(0);
    PageObjectLogging.log(""First check"",mostRecentComment.getText(), true);
    JavascriptExecutor js = (JavascriptExecutor) driver;
    WebElement editButton = mostRecentComment.findElement(By.cssSelector(EDIT_BUTTON_SELECTOR));
START     Actions actions =  new Actions(driver); END 
    actions.moveToElement(editButton).perform();
    js.executeScript(""arguments[0].querySelector(arguments[1]).click()"", mostRecentComment,
                     EDIT_BUTTON_SELECTOR);
    return new MiniEditorComponentObject(driver);
  }
","  public MiniEditorComponentObject triggerEditCommentArea() {
    jsActions.scrollToElement(allCommentsArea);
    WebElement mostRecentComment = articleComments.get(0);
    PageObjectLogging.log(""First check"",mostRecentComment.getText(), true);
    JavascriptExecutor js = (JavascriptExecutor) driver;
    WebElement editButton = mostRecentComment.findElement(By.cssSelector(EDIT_BUTTON_SELECTOR));
    new Actions(driver).moveToElement(editButton).perform();
    js.executeScript(""arguments[0].querySelector(arguments[1]).click()"", mostRecentComment,
                     EDIT_BUTTON_SELECTOR);
    return new MiniEditorComponentObject(driver);
  }
"
888,"@wottop Would this mean that the ""entitlement"" mode is always included? Even if a mode list has been set on the owner that did not include it? If so, that does not seem right as it is valid to set the list to not contain entitlements as an option, just that if the list is empty that means it should be set to entitlement.","    public String getContentAccessModeList() {
        String[] modeList = contentAccessModeList == null ? new String[0] : contentAccessModeList.split("","");
        String ammend = """";
        if (!ArrayUtils.contains(modeList, ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE)) {
            ammend = modeList.length > 0 ? "","" : """";
            ammend += ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE;
        }
        return modeList.length > 0 ? this.contentAccessModeList + ammend : ammend;
    }
","    public String getContentAccessModeList() {
        String[] modeList = contentAccessModeList == null ? new String[0] : contentAccessModeList.split("","");
        String ammend = """";
START         if (!ArrayUtils.contains(modeList, ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE)) { END 
            ammend = modeList.length > 0 ? "","" : """";
            ammend += ContentAccessCertServiceAdapter.DEFAULT_CONTENT_ACCESS_MODE;
        }
        return modeList.length > 0 ? this.contentAccessModeList + ammend : ammend;
    }
","    public String getContentAccessModeList() {
        return this.contentAccessModeList;
    }
"
889,"@timowest 
weird.
I remembered it was failed with testing on querydls-sql module.
but it's gone now.","    public void setUp() {
        System.setProperty(""user.timezone"", ""UTC"");
        TimeZone.setDefault(null);

        configuration = Configuration.DEFAULT;
    }
","    public void setUp() {
START         System.setProperty(""user.timezone"", ""UTC""); END 
        TimeZone.setDefault(null);

        configuration = Configuration.DEFAULT;
    }
","    public void setUp() {
        configuration = Configuration.DEFAULT;
    }
"
890,"mWebViewStateOnDestroyViewを追加せずに
mWebViewBridge.destroy();
のあとにmWebViewBridge =null;
で解決すると思います","    public void onDestroyView() {
        mWebViewStateOnDestroyView = new Bundle();
        try {
            storeWebView(mWebViewStateOnDestroyView);
            mWebViewBridge.destroy();
        } catch (Exception exp) {
            Log.w(TAG, exp.getMessage() + """", exp);
        }
        super.onDestroyView();
    }
","    public void onDestroyView() {
        mWebViewStateOnDestroyView = new Bundle();
        try {
            storeWebView(mWebViewStateOnDestroyView);
START             mWebViewBridge.destroy(); END 
        } catch (Exception exp) {
            Log.w(TAG, exp.getMessage() + """", exp);
        }
        super.onDestroyView();
    }
","    public void onDestroyView() {
        try {
            mWebViewBridge.destroy();
        } catch (Exception exp) {
            Log.w(TAG, exp.getMessage() + """", exp);
        }
        mWebViewBridge = null;
        super.onDestroyView();
    }
"
891,"Declare the logger at the top of the class:
```java
private static final Logger log = Logger.get(GlueHiveMetastore.class);
```
(you might see the inline `Logger.get()` pattern in some tests, but it's not the normal way)","    private static void deleteDir(HdfsContext context, HdfsEnvironment hdfsEnvironment, Path path, boolean recursive)
    {
        try {
            hdfsEnvironment.getFileSystem(context, path).delete(path, recursive);
        }
        catch (Exception e) {
            // don't fail if unable to delete path
            Logger.get(GlueHiveMetastore.class).warn(e, ""Failed to delete path: "" + path.toString());
        }
    }
","    private static void deleteDir(HdfsContext context, HdfsEnvironment hdfsEnvironment, Path path, boolean recursive)
    {
        try {
            hdfsEnvironment.getFileSystem(context, path).delete(path, recursive);
        }
        catch (Exception e) {
            // don't fail if unable to delete path
START             Logger.get(GlueHiveMetastore.class).warn(e, ""Failed to delete path: "" + path.toString()); END 
        }
    }
","    private static void deleteDir(HdfsContext context, HdfsEnvironment hdfsEnvironment, Path path, boolean recursive)
    {
        try {
            hdfsEnvironment.getFileSystem(context, path).delete(path, recursive);
        }
        catch (Exception e) {
            // don't fail if unable to delete path
            log.warn(e, ""Failed to delete path: "" + path.toString());
        }
    }
"
892,`private static`,"    private boolean isNakedTD1Key(String s)
    {
        return NAKED_TD1_KEY_PATTERN.matcher(s).matches();
    }
","START     private boolean isNakedTD1Key(String s) END 
    {
        return NAKED_TD1_KEY_PATTERN.matcher(s).matches();
    }
","    private static boolean isNakedTD1Key(String s)
    {
        return NAKED_TD1_KEY_PATTERN.matcher(s).matches();
    }
"
893,nit: for readability i prefer a method called  `isSequentialReadMode` to determine whether to seek or not,"  public long skip(long n) throws IOException {
    if (n <= 0) {
      return 0;
    }
    if (n > MOVEMENT_LIMIT) {
      mSequentialReadCount = 0;
    } else {
      ((Seekable) in).seek(mPos + n);
    }
    mPos += n;
    return n;
  }
","  public long skip(long n) throws IOException {
    if (n <= 0) {
      return 0;
    }
    if (n > MOVEMENT_LIMIT) {
      mSequentialReadCount = 0;
    } else {
START       ((Seekable) in).seek(mPos + n); END 
    }
    mPos += n;
    return n;
  }
","  public long skip(long n) throws IOException {
    if (n <= 0) {
      return 0;
    }
    if (n > MOVEMENT_LIMIT) {
      mSequentialReadCount = 0;
    }
    mPos += n;
    return n;
  }
"
894,Missing assertNotNull for executionSet here.,"    public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception {
        Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH);
        assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM);

        StartNoneEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, StartNoneEvent.class);
        assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE);

        assertStartEventSlaDueDate(emptySubprocess.getExecutionSet(), EMPTY_VALUE);
    }
","    public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception {
START         Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH); END 
        assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM);

        StartNoneEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, StartNoneEvent.class);
        assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE);

        assertStartEventSlaDueDate(emptySubprocess.getExecutionSet(), EMPTY_VALUE);
    }
","    public void testUnmarshallSubprocessLevelEventEmptyProperties() throws Exception {
        Diagram<Graph, Metadata> diagram = unmarshall(marshaller, BPMN_START_EVENT_FILE_PATH);
        assertDiagram(diagram, AMOUNT_OF_NODES_IN_DIAGRAM);

        StartNoneEvent emptySubprocess = getStartNodeById(diagram, EMPTY_SUBPROCESS_LEVEL_EVENT_ID, StartNoneEvent.class);
        assertGeneralSet(emptySubprocess.getGeneral(), EMPTY_VALUE, EMPTY_VALUE);

        assertNotNull(emptySubprocess.getExecutionSet());
        assertStartEventSlaDueDate(emptySubprocess.getExecutionSet(), EMPTY_VALUE);
    }
"
895,"Remove the reversal here, and let the JDK 8 implementation return it in reverse, and the JDK 9 implementation *not* reversed.","    private List<Window> fetchWindowsInQueue() {
        List<Window> windows = Lists.newArrayList(getWindows());
        return ImmutableList.copyOf(Lists.reverse(windows));
    }
","    private List<Window> fetchWindowsInQueue() {
        List<Window> windows = Lists.newArrayList(getWindows());
START         return ImmutableList.copyOf(Lists.reverse(windows)); END 
    }
","    private List<Window> fetchWindowsInQueue() {
        return ImmutableList.copyOf(getWindows());
    }
"
896,what is the point of catching the exception here?,"	protected void executeCommand(IDeviceManagementInteractor executor) throws DeploymentException {
		try {
			executor.startFB(resource, new FBDeploymentData("""", resFB)); //$NON-NLS-1$  //TODO correctly determine prefix
		} catch (DeploymentException e) {
			throw e;
		}
	}
","	protected void executeCommand(IDeviceManagementInteractor executor) throws DeploymentException {
START 		try {
			executor.startFB(resource, new FBDeploymentData("""", resFB)); //$NON-NLS-1$  //TODO correctly determine prefix
		} catch (DeploymentException e) {
			throw e;
		} END 
	}
","	protected void executeCommand(IDeviceManagementInteractor executor) throws DeploymentException {
		executor.startFB(resource, new FBDeploymentData("""", resFB)); //$NON-NLS-1$  //TODO correctly determine prefix
	}
"
897,Make this method private.,"    void setReaderBudget()
    {
        reader.setResultSizeBudget(ariaBatchRows <= MIN_BATCH_ROWS ? UNLIMITED_BUDGET : targetResultBytes);
    }
","START     void setReaderBudget() END 
    {
        reader.setResultSizeBudget(ariaBatchRows <= MIN_BATCH_ROWS ? UNLIMITED_BUDGET : targetResultBytes);
    }
","    private void setReaderBudget()
    {
        reader.setResultSizeBudget(ariaBatchRows <= MIN_BATCH_ROWS ? UNLIMITED_BUDGET : targetResultBytes);
    }
"
898,Same as with the imperative template: Shouldn't we just deprecate these methods and introduce `Flux<SearchHit<T>> search(…)`?,"	default <T> Flux<SearchHit<T>> find(Query query, Class<T> entityType) {
		return find(query, entityType, entityType);
	}
","START 	default <T> Flux<SearchHit<T>> find(Query query, Class<T> entityType) { END 
		return find(query, entityType, entityType);
	}
","	default <T> Flux<T> find(Query query, Class<T> entityType) {
		return find(query, entityType, entityType);
	}
"
899,"True, now.","	public Object execute(ExecutionEvent event) throws ExecutionException {
		RepositorySearchWizard wizard = new RepositorySearchWizard(
				util.getConfiguredRepositories(), false);
		WizardDialog dialog = new WizardDialog(getShell(event), wizard);
		if (dialog.open() == Window.OK) {
			for (String dir : wizard.getDirectories()) {
				File repositoryDir = FileUtils.canonicalize(new File(dir));
				addRepository(repositoryDir);
			}
		}
		return null;
	}
","	public Object execute(ExecutionEvent event) throws ExecutionException {
		RepositorySearchWizard wizard = new RepositorySearchWizard(
				util.getConfiguredRepositories(), START  false); END 
		WizardDialog dialog = new WizardDialog(getShell(event), wizard);
		if (dialog.open() == Window.OK) {
			for (String dir : wizard.getDirectories()) {
				File repositoryDir = FileUtils.canonicalize(new File(dir));
				addRepository(repositoryDir);
			}
		}
		return null;
	}
","	public Object execute(ExecutionEvent event) throws ExecutionException {
		RepositorySearchWizard wizard = new RepositorySearchWizard(
				util.getConfiguredRepositories(), true);
		WizardDialog dialog = new WizardDialog(getShell(event), wizard);
		if (dialog.open() == Window.OK) {
			for (String dir : wizard.getDirectories()) {
				File repositoryDir = FileUtils.canonicalize(new File(dir));
				addRepository(repositoryDir);
			}
		}
		return null;
	}
"
900,We normally check if this is `null` and only set if non-null... IDK if your code handles `null` differently?,"    public Map<String, String> load() {
        final Map<String, String> preferences = new HashMap<String, String>();
        final String property = System.getProperty( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED );

        log.info( ""Setting preference '"" + GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED + ""' to '"" + property + ""'."" );

        preferences.put( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED,
                         property );

        return preferences;
    }
","    public Map<String, String> load() {
        final Map<String, String> preferences = new HashMap<String, String>();
START         final String property = System.getProperty( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED ); END 

        log.info( ""Setting preference '"" + GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED + ""' to '"" + property + ""'."" );

        preferences.put( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED,
                         property );

        return preferences;
    }
","    public Map<String, String> load() {
        final Map<String, String> preferences = new HashMap<String, String>();

        final String property = getProperty();
        log.info( ""Setting preference '"" + GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED + ""' to '"" + property + ""'."" );
        preferences.put( GuidedDecisionTableEditorService.DTABLE_VERIFICATION_ENABLED,
                         property );

        return preferences;
    }
"
901,"I think you need to return `taskParallelism` here b/c if the value specified as the max degree != `DEFAULT_MAX_DEGREE_OF_PARALLELISM`, then we return `1`, not, say `40`","  protected int getParallelHostCount(UpgradeContext ctx, int defaultValue) {

    if (m_grouping.parallelScheduler != null) {
      int taskParallelism = m_grouping.parallelScheduler.maxDegreeOfParallelism;
      if (taskParallelism == ParallelScheduler.DEFAULT_MAX_DEGREE_OF_PARALLELISM) {
        taskParallelism = ctx.getDefaultMaxDegreeOfParallelism();
      }
    }

    return defaultValue;
  }
","  protected int getParallelHostCount(UpgradeContext ctx, int defaultValue) {

    if (m_grouping.parallelScheduler != null) {
      int taskParallelism = m_grouping.parallelScheduler.maxDegreeOfParallelism;
      if (taskParallelism == ParallelScheduler.DEFAULT_MAX_DEGREE_OF_PARALLELISM) {
START         taskParallelism = ctx.getDefaultMaxDegreeOfParallelism(); END 
      }
    }

    return defaultValue;
  }
","  protected int getParallelHostCount(UpgradeContext ctx, int defaultValue) {

    if (m_grouping.parallelScheduler != null) {
      int taskParallelism = m_grouping.parallelScheduler.maxDegreeOfParallelism;
      if (taskParallelism == ParallelScheduler.DEFAULT_MAX_DEGREE_OF_PARALLELISM) {
        taskParallelism = ctx.getDefaultMaxDegreeOfParallelism();
      }
      return taskParallelism;
    }

    return defaultValue;
  }
"
902,think this has to be synchronized,"  public static boolean stopIfIsPlaying(@Nullable AudioSlide slide) {
    if (playing.isPresent() && playing.get().getAudioSlide().equals(slide)) {
      playing.get().stop();
      return true;
    } else {
      return false;
    }
  }
","START   public static boolean stopIfIsPlaying(@Nullable AudioSlide slide) { END 
    if (playing.isPresent() && playing.get().getAudioSlide().equals(slide)) {
      playing.get().stop();
      return true;
    } else {
      return false;
    }
  }
","  public synchronized static boolean stopIfIsPlaying(@Nullable AudioSlide slide) {
    if (playing.isPresent() && playing.get().getAudioSlide().equals(slide)) {
      playing.get().stop();
      return true;
    } else {
      return false;
    }
  }
"
903,Line should be breaked after `)`,"  public List<AggregatorFactory> getRequiredColumns()
  {
    return fields.stream()
                 .map(
                     input -> new CardinalityAggregatorFactory(
                         input.getOutputName(),
                         null,
                         Collections.singletonList(input),
                         byRow,
                         round
                     )
                 ).collect(Collectors.toList());
  }
","  public List<AggregatorFactory> getRequiredColumns()
  {
    return fields.stream()
                 .map(
                     input -> new CardinalityAggregatorFactory(
                         input.getOutputName(),
                         null,
                         Collections.singletonList(input),
                         byRow,
                         round
                     )
START                  ).collect(Collectors.toList()); END 
  }
","  public List<AggregatorFactory> getRequiredColumns()
  {
    return fields.stream()
                 .map(
                     field ->
                         new CardinalityAggregatorFactory(
                             field.getOutputName(),
                             null,
                             Collections.singletonList(field),
                             byRow,
                             round
                         )
                 )
                 .collect(Collectors.toList());
  }
"
904,add the type parameter even if it's object,"    public Optional getRequestAttribute(final String name) {
        return Optional.ofNullable(this.request.getAttribute(name));
    }
","START     public Optional getRequestAttribute(final String name) { END 
        return Optional.ofNullable(this.request.getAttribute(name));
    }
","    public Optional<Object> getRequestAttribute(final String name) {
        return Optional.ofNullable(this.request.getAttribute(name));
    }
"
905,this method doesn't need to be public,"	public static String reflogComments(List<ReflogEntry> entries) {
		StringBuffer b = new StringBuffer();
		for (ReflogEntry e : entries) {
			b.append(e.getComment()).append("";"");
		}
		return b.toString();
	}
","START 	public static String reflogComments(List<ReflogEntry> entries) { END 
		StringBuffer b = new StringBuffer();
		for (ReflogEntry e : entries) {
			b.append(e.getComment()).append("";"");
		}
		return b.toString();
	}
","	private static String reflogComments(List<ReflogEntry> entries) {
		StringBuffer b = new StringBuffer();
		for (ReflogEntry e : entries) {
			b.append(e.getComment()).append("";"");
		}
		return b.toString();
	}
"
906,The return value is never used.,"    private static boolean validateName(String value) throws WSSecurityException {
        Name name;
        try {
            name = new LdapName(value);
        } catch (Exception e) {
            LOG.info(""Validation of X509 Subject Name failed: {}"", e.getLocalizedMessage(), e);
            throw new WSSecurityException(ErrorCode.FAILURE, ""Not a valid X509 Subject Name."");

        }
        return name != null;
    }
","    private static boolean validateName(String value) throws WSSecurityException {
        Name name;
        try {
            name = new LdapName(value);
        } catch (Exception e) {
            LOG.info(""Validation of X509 Subject Name failed: {}"", e.getLocalizedMessage(), e);
            throw new WSSecurityException(ErrorCode.FAILURE, ""Not a valid X509 Subject Name."");

        }
START         return name != null; END 
    }
","    private static void validateName(String value) throws WSSecurityException {
        Name name;
        try {
            name = new LdapName(value);
        } catch (Exception e) {
            LOG.info(""Validation of X509 Subject Name failed: {}"", e.getLocalizedMessage(), e);
            throw new WSSecurityException(ErrorCode.FAILURE, ""Not a valid X509 Subject Name."");
        }
    }
"
907,Move close() to a finally-block?,"    private static SimpleFeatureCollection parseGeoJSON(InputStream in,
            CoordinateReferenceSystem crs) throws IOException {
        Map<String, Object> geojson = OM.readValue(in, TYPE_REF);
        in.close();
        SimpleFeatureType schema = GeoJSONSchemaDetector.getSchema(geojson, crs);
        return GeoJSONReader2.toFeatureCollection(geojson, schema);
    }
","    private static SimpleFeatureCollection parseGeoJSON(InputStream in,
            CoordinateReferenceSystem crs) throws IOException {
        Map<String, Object> geojson = OM.readValue(in, TYPE_REF);
START         in.close(); END 
        SimpleFeatureType schema = GeoJSONSchemaDetector.getSchema(geojson, crs);
        return GeoJSONReader2.toFeatureCollection(geojson, schema);
    }
","    private static SimpleFeatureCollection parseGeoJSON(InputStream in,
            CoordinateReferenceSystem crs) throws IOException {
        Map<String, Object> geojson = OM.readValue(in, TYPE_REF);
        SimpleFeatureType schema = GeoJSONSchemaDetector.getSchema(geojson, crs);
        return GeoJSONReader2.toFeatureCollection(geojson, schema);
    }
"
908,"Worth checking if we really need this method at all, although probably not in THIS patch.

Regardless, why use Boolean.FALSE and not a primitive false?","    private void refreshHostStorage(Guid hostId) {
        getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId,
                StorageType.ISCSI,
                Boolean.FALSE));
    }
","    private void refreshHostStorage(Guid hostId) {
        getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId,
                StorageType.ISCSI,
                Boolean.FALSE));
START     } END 
","    private void refreshHostStorage(Guid hostId) {
        getBackendCollection(VdcQueryType.GetDeviceList, new GetDeviceListQueryParameters(hostId,
                StorageType.ISCSI,
                false, null));
    }
"
909,do not create new DefaultShell inside syncexec,"	public void openTestShells() {
		Display.syncExec(() -> {
			for (int i = 1; i <= TEST_SHELLS_COUNT; i++) {
				String shellTitle = ""shell"" + i;
				ShellTestUtils.createShell(shellTitle);
				shells.add(new DefaultShell(shellTitle));
			}
		});
	}
","	public void openTestShells() {
		Display.syncExec(() -> {
			for (int i = 1; i <= TEST_SHELLS_COUNT; i++) {
				String shellTitle = ""shell"" + i;
				ShellTestUtils.createShell(shellTitle);
START 				shells.add(new DefaultShell(shellTitle)); END 
			}
		});
	}
","	public void openTestShells() {
		for (int i = 1; i <= TEST_SHELLS_COUNT; i++) {
			String shellTitle = ""shell"" + i;
			Display.syncExec(() -> {
				ShellTestUtils.createShell(shellTitle);
			});
			shells.add(new DefaultShell(shellTitle));
		}
	}
"
910,I do not think it should be public. IMO it should only called from `Builder`.,"    public RangeColumnStatistics(
            Optional<Object> lowValue,
            Optional<Object> highValue,
            Estimate fraction,
            Estimate dataSize,
            Estimate distinctValuesCount)
    {
        this.lowValue = requireNonNull(lowValue, ""lowValue can not be null"");
        this.highValue = requireNonNull(highValue, ""highValue can not be null"");
        requireNonNull(fraction, ""fraction can not be null"");
        requireNonNull(dataSize, ""dataSize can not be null"");
        requireNonNull(distinctValuesCount, ""distinctValuesCount can not be null"");
        this.statistics = createStatisticsMap(dataSize, fraction, distinctValuesCount);
    }
","START     public RangeColumnStatistics( END 
            Optional<Object> lowValue,
            Optional<Object> highValue,
            Estimate fraction,
            Estimate dataSize,
            Estimate distinctValuesCount)
    {
        this.lowValue = requireNonNull(lowValue, ""lowValue can not be null"");
        this.highValue = requireNonNull(highValue, ""highValue can not be null"");
        requireNonNull(fraction, ""fraction can not be null"");
        requireNonNull(dataSize, ""dataSize can not be null"");
        requireNonNull(distinctValuesCount, ""distinctValuesCount can not be null"");
        this.statistics = createStatisticsMap(dataSize, fraction, distinctValuesCount);
    }
","    private RangeColumnStatistics(
            Optional<Object> lowValue,
            Optional<Object> highValue,
            Estimate fraction,
            Estimate dataSize,
            Estimate distinctValuesCount)
    {
        this.lowValue = requireNonNull(lowValue, ""lowValue can not be null"");
        this.highValue = requireNonNull(highValue, ""highValue can not be null"");
        this.fraction = requireNonNull(fraction, ""fraction can not be null"");
        this.dataSize = requireNonNull(dataSize, ""dataSize can not be null"");
        this.distinctValuesCount = requireNonNull(distinctValuesCount, ""distinctValuesCount can not be null"");
    }
"
911,Sounds reasonable to me,"    public void close() {
        log.debug(""Closing record collector"");

        if (eosEnabled) {
            streamsProducer.abortTransaction();
        }
        streamsProducer.flush();

        checkForException();
    }
","    public void close() {
        log.debug(""Closing record collector"");

        if (eosEnabled) {
            streamsProducer.abortTransaction();
        }
START         streamsProducer.flush(); END 

        checkForException();
    }
","    public void close() {
        log.debug(""Closing record collector"");

        if (eosEnabled) {
            streamsProducer.abortTransaction();
        }

        checkForException();
    }
"
912,set this in `initContext` instead?,"  public static FileSystemContext create(ClientContext clientContext) {
    FileSystemContext ctx = new FileSystemContext();
    ctx.init(clientContext, MasterInquireClient.Factory.create(clientContext.getClusterConf()));
    ctx.mUriValidationEnabled = clientContext.getUriValidationEnabled();
    return ctx;
  }
","  public static FileSystemContext create(ClientContext clientContext) {
    FileSystemContext ctx = new FileSystemContext();
    ctx.init(clientContext, MasterInquireClient.Factory.create(clientContext.getClusterConf()));
START     ctx.mUriValidationEnabled = clientContext.getUriValidationEnabled(); END 
    return ctx;
  }
","  public static FileSystemContext create(ClientContext clientContext) {
    FileSystemContext ctx = new FileSystemContext();
    ctx.init(clientContext, MasterInquireClient.Factory.create(clientContext.getClusterConf()));
    return ctx;
  }
"
913,"Replace scheme first since it's first in the URL. Let's also wrap this since it's getting long:
```java
return uriInfo.getBaseUriBuilder()
        .scheme(scheme)
        .replacePath(""/v1/statement"")
        .path(queryId.toString())
        .path(String.valueOf(resultId.incrementAndGet()))
        .replaceQuery("""")
        .build();","    private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo)
    {
        return uriInfo.getBaseUriBuilder().replacePath(""/v1/statement"").path(queryId.toString()).path(String.valueOf(resultId.incrementAndGet())).replaceQuery("""").scheme(scheme).build();
    }
","    private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo)
    {
START         return uriInfo.getBaseUriBuilder().replacePath(""/v1/statement"").path(queryId.toString()).path(String.valueOf(resultId.incrementAndGet())).replaceQuery("""").scheme(scheme).build(); END 
    }
","    private synchronized URI createNextResultsUri(String scheme, UriInfo uriInfo)
    {
        return uriInfo.getBaseUriBuilder()
                .scheme(scheme)
                .replacePath(""/v1/statement"")
                .path(queryId.toString())
                .path(String.valueOf(resultId.incrementAndGet()))
                .replaceQuery("""")
                .build();
    }
"
914,"``` java
assertEquals(expectedContent.length(), Files.size(af.toPath()));
```","    public void commitToFile() throws Exception {
        // Given
        afw.write(expectedContent, 0, expectedContent.length());

        // When
        afw.commit();

        // Then
        assertTrue(Files.size(af.toPath()) == expectedContent.length());
    }
","    public void commitToFile() throws Exception {
        // Given
        afw.write(expectedContent, 0, expectedContent.length());

        // When
        afw.commit();

        // Then
START         assertTrue(Files.size(af.toPath()) == expectedContent.length()); END 
    }
","    public void commitToFile() throws Exception {
        // Given
        afw.write(expectedContent, 0, expectedContent.length());

        // When
        afw.commit();

        // Then
        assertEquals(expectedContent.length(), Files.size(af.toPath()));
    }
"
915,add { and },"	public void setColumnWidthPercentageByPosition(int columnPosition, int width, boolean fireEvent) {
		this.columnWidthConfig.setPercentage(columnPosition, width);
		if (fireEvent)
			fireLayerEvent(new ColumnResizeEvent(this, columnPosition));
	}
","	public void setColumnWidthPercentageByPosition(int columnPosition, int width, boolean fireEvent) {
		this.columnWidthConfig.setPercentage(columnPosition, width);
		if START (fireEvent) END 
			fireLayerEvent(new ColumnResizeEvent(this, columnPosition));
	}
","	public void setColumnWidthPercentageByPosition(int columnPosition, int width, boolean fireEvent) {
		this.columnWidthConfig.setPercentage(columnPosition, width);
		if (fireEvent){
			fireLayerEvent(new ColumnResizeEvent(this, columnPosition));
		}
	}
"
916,Don't think any method is going to throw an `IOException`. We can get rid of this.,"    protected void connect() throws IOException
    {
        // note that we are not connecting via JMX for testing
        mbeanServerConn = null;
        jmxc = null;

        ssProxy = StorageService.instance;
        msProxy = MessagingService.instance();
        streamProxy = StreamManager.instance;
        compactionProxy = CompactionManager.instance;
        fdProxy = (FailureDetectorMBean) FailureDetector.instance;
        cacheService = CacheService.instance;
        spProxy = StorageProxy.instance;
        hhProxy = HintedHandOffManager.instance;
        gcProxy = new GCInspector();
        gossProxy = Gossiper.instance;
        memProxy = ManagementFactory.getMemoryMXBean();
        runtimeProxy = ManagementFactory.getRuntimeMXBean();
    }
","START     protected void connect() throws IOException END 
    {
        // note that we are not connecting via JMX for testing
        mbeanServerConn = null;
        jmxc = null;

        ssProxy = StorageService.instance;
        msProxy = MessagingService.instance();
        streamProxy = StreamManager.instance;
        compactionProxy = CompactionManager.instance;
        fdProxy = (FailureDetectorMBean) FailureDetector.instance;
        cacheService = CacheService.instance;
        spProxy = StorageProxy.instance;
        hhProxy = HintedHandOffManager.instance;
        gcProxy = new GCInspector();
        gossProxy = Gossiper.instance;
        memProxy = ManagementFactory.getMemoryMXBean();
        runtimeProxy = ManagementFactory.getRuntimeMXBean();
    }
","    protected void connect()
    {
        // note that we are not connecting via JMX for testing
        mbeanServerConn = null;
        jmxc = null;

        ssProxy = StorageService.instance;
        msProxy = MessagingService.instance();
        streamProxy = StreamManager.instance;
        compactionProxy = CompactionManager.instance;
        fdProxy = (FailureDetectorMBean) FailureDetector.instance;
        cacheService = CacheService.instance;
        spProxy = StorageProxy.instance;
        hhProxy = HintedHandOffManager.instance;
        gcProxy = new GCInspector();
        gossProxy = Gossiper.instance;
        memProxy = ManagementFactory.getMemoryMXBean();
        runtimeProxy = ManagementFactory.getRuntimeMXBean();
    }
"
917,"To clarify, this does not catch the `PrestoException` thrown from comparatorResult?

Do you wan to include the thrown `e` in the new `PrestoException` created here?","    private void sortPositions(int arrayLength, Comparator<Integer> comparator)
    {
        List<Integer> list = positions.subList(0, arrayLength);

        try {
            list.sort(comparator);
        }
        catch (IllegalArgumentException e) {
            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, ""Lambda comparator violates the comparator contract"");
        }
    }
","    private void sortPositions(int arrayLength, Comparator<Integer> comparator)
    {
        List<Integer> list = positions.subList(0, arrayLength);

        try {
            list.sort(comparator);
        }
        catch (IllegalArgumentException e) {
START             throw new PrestoException(INVALID_FUNCTION_ARGUMENT, ""Lambda comparator violates the comparator contract""); END 
        }
    }
","    private void sortPositions(int arrayLength, Comparator<Integer> comparator)
    {
        List<Integer> list = positions.subList(0, arrayLength);

        try {
            list.sort(comparator);
        }
        catch (IllegalArgumentException e) {
            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, ""Lambda comparator violates the comparator contract"", e);
        }
    }
"
918,debug,"    public void deactivate() {
        try {
            httpService.unregister(WEBAPP_ALIAS + SERVLET_NAME);
        } catch(IllegalArgumentException e) {
            logger.info(""LgTv Servlet '{}' was not registered. Nothing to deactivate."", WEBAPP_ALIAS + SERVLET_NAME);
        } finally {
            logger.info(""Stopped LgTv Servlet"");
        }
    }
","    public void deactivate() {
        try {
            httpService.unregister(WEBAPP_ALIAS + SERVLET_NAME);
        } catch(IllegalArgumentException e) {
START             logger.info(""LgTv Servlet '{}' was not registered. Nothing to deactivate."", WEBAPP_ALIAS + SERVLET_NAME); END 
        } finally {
            logger.info(""Stopped LgTv Servlet"");
        }
    }
","    public void deactivate() {
        try {
            httpService.unregister(WEBAPP_ALIAS + SERVLET_NAME);
        } catch(IllegalArgumentException e) {
            logger.debug(""LgTv Servlet '{}' was not registered. Nothing to deactivate."", WEBAPP_ALIAS + SERVLET_NAME);
        } finally {
            logger.info(""Stopped LgTv Servlet"");
        }
    }
"
919,times(1) is by default in verify,"    public void freeTicketWhenExists(TicketsInteractor mockedTicketsInteractor) throws RecordNotFoundException, UpdateTicketStateUnauthorizedException {
        long ticketId = 1;
        ObjectNode json = Json.newObject();
        ArrayNode node = json.putArray(ConstantsManager.TICKET_IDS_FIELD_NAME);
        node.add(ticketId);
        when(mockedBody.asJson()).thenReturn(json);

        Result result = ticketsController.free();

        assertEquals(Helpers.OK, Helpers.status(result));
        verify(mockedTicketsInteractor, times(1)).freeATicket(ticketId);
    }
","    public void freeTicketWhenExists(TicketsInteractor mockedTicketsInteractor) throws RecordNotFoundException, UpdateTicketStateUnauthorizedException {
        long ticketId = 1;
        ObjectNode json = Json.newObject();
        ArrayNode node = json.putArray(ConstantsManager.TICKET_IDS_FIELD_NAME);
        node.add(ticketId);
        when(mockedBody.asJson()).thenReturn(json);

        Result result = ticketsController.free();

        assertEquals(Helpers.OK, Helpers.status(result));
START         verify(mockedTicketsInteractor, times(1)).freeATicket(ticketId); END 
    }
","    public void freeTicketWhenExists(TicketsInteractor mockedTicketsInteractor) throws RecordNotFoundException, UpdateTicketStateUnauthorizedException {
        long ticketId = 1;
        ObjectNode json = Json.newObject();
        ArrayNode node = json.putArray(ConstantsManager.TICKET_IDS_FIELD_NAME);
        node.add(ticketId);
        when(mockedBody.asJson()).thenReturn(json);

        Result result = ticketsController.free();

        assertEquals(Helpers.OK, Helpers.status(result));
        verify(mockedTicketsInteractor).freeATicket(ticketId);
    }
"
920,"Should this be done in `OutputCommitter#setupTask` instead of here? This method could be called more than once, but we want to ensure we set up the environment config just one time per task. The `setupTask` methods seems like a good place, unless you have a reason to do it here?","  private static <E> View<E> load(JobContext jobContext) {
    Configuration conf = Hadoop.JobContext.getConfiguration.invoke(jobContext);
    Class<E> type = getType(jobContext);

    String outputUri = conf.get(KITE_OUTPUT_URI);
    DefaultConfiguration.set(conf);
    return Datasets.<E, View<E>>load(outputUri, type);
  }
","  private static <E> View<E> load(JobContext jobContext) {
    Configuration conf = Hadoop.JobContext.getConfiguration.invoke(jobContext);
    Class<E> type = getType(jobContext);

    String outputUri = conf.get(KITE_OUTPUT_URI);
START     DefaultConfiguration.set(conf); END 
    return Datasets.<E, View<E>>load(outputUri, type);
  }
","  private static <E> View<E> load(JobContext jobContext) {
    Configuration conf = Hadoop.JobContext.getConfiguration.invoke(jobContext);
    Class<E> type = getType(jobContext);

    String outputUri = conf.get(KITE_OUTPUT_URI);
    return Datasets.<E, View<E>>load(outputUri, type);
  }
"
921,"if the principal login test will already print the root cause, do we still need to print this here?","  public boolean validate(Map<String, String> optionsMap) {
    if (shouldSkip()) {
      return true;
    }
    if (!super.validate(optionsMap)) {
      return false;
    }
    if (!validatePrincipalLogin()) {
      System.err.format(""Principal login test failed.%n"");
      return false;
    }
    return true;
  }
","  public boolean validate(Map<String, String> optionsMap) {
    if (shouldSkip()) {
      return true;
    }
    if (!super.validate(optionsMap)) {
      return false;
    }
    if (!validatePrincipalLogin()) {
START       System.err.format(""Principal login test failed.%n""); END 
      return false;
    }
    return true;
  }
","  public boolean validate(Map<String, String> optionsMap) {
    if (!super.validate(optionsMap)) {
      return false;
    }
    if (!validatePrincipalLogin()) {
      return false;
    }
    return true;
  }
"
922,Done,"	public void createEdit() {
		Button button = createButton(buttonparent, buttonEdit_ID, buttonEdit_caption, true);

		buttonBar.pack();
	}
","START 	public void createEdit() { END 
		Button button = createButton(buttonparent, buttonEdit_ID, buttonEdit_caption, true);

		buttonBar.pack();
	}
","	private void createEdit() {
		Button button = createButton(buttonparent, buttonEdit_ID, buttonEdit_caption, true);

		buttonBar.pack();
	}
"
923,"This should probably just call `read(String line, E reuse)` and pass in `null` for `reuse` rather than duplicate the method.","  public E read(String line) {
    try {
      return builder.makeRecord(parser.parseLine(line), null);
    } catch (IOException e) {
      throw new DatasetIOException(""Cannot parse line: "" + line, e);
    }
  }
","START   public E read(String line) { END 
    try {
      return builder.makeRecord(parser.parseLine(line), null);
    } catch (IOException e) {
      throw new DatasetIOException(""Cannot parse line: "" + line, e);
    }
  }
","  public E read(String line) {
    return read(line, null);
  }
"
924,"Why would this not be a part of findMe method? instead of the a wrapper?

Like here where the call to getLocation happens:
https://github.com/mapzen/mapzen-android-demo/blob/peter/noMoToast/src/main/java/com/mapzen/fragment/MapFragment.java#L245","    public void centerOnCurrentLocation() {
        followMe = true;
        if (getMapController().getLocation() != null) {
            findMe();
        }
    }
","    public void centerOnCurrentLocation() {
        followMe = true;
START         if (getMapController().getLocation() != null) { END 
            findMe();
        }
    }
","    public void centerOnCurrentLocation() {
        followMe = true;
        findMe();
    }
"
925,JsonProcessingException is not necessary.,"  public void serialize(final DoublesSketch sketch, final JsonGenerator generator, final SerializerProvider provider)
      throws IOException, JsonProcessingException
  {
    generator.writeBinary(sketch.toByteArray(true));
  }
","  public void serialize(final DoublesSketch sketch, final JsonGenerator generator, final SerializerProvider provider)
START       throws IOException, JsonProcessingException END 
  {
    generator.writeBinary(sketch.toByteArray(true));
  }
","  public void serialize(final DoublesSketch sketch, final JsonGenerator generator, final SerializerProvider provider)
      throws IOException
  {
    generator.writeBinary(sketch.toByteArray(true));
  }
"
926,"please keep old ""for loop"" style to reduce GC.","    public String toString() {
        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
        for (MqttTopicSubscription subscription : topicSubscriptions) {
            builder.append(subscription).append("", "");
        }
        if (!topicSubscriptions.isEmpty()) {
            builder.setLength(builder.length() - 2);
        }
        return builder.append(']').toString();
    }
","    public String toString() {
        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
START         for (MqttTopicSubscription subscription : topicSubscriptions) { END 
            builder.append(subscription).append("", "");
        }
        if (!topicSubscriptions.isEmpty()) {
            builder.setLength(builder.length() - 2);
        }
        return builder.append(']').toString();
    }
","    public String toString() {
        StringBuilder builder = new StringBuilder(StringUtil.simpleClassName(this)).append('[');
        for (int i = 0; i < topicSubscriptions.size(); i++) {
            builder.append(topicSubscriptions.get(i)).append("", "");
        }
        if (!topicSubscriptions.isEmpty()) {
            builder.setLength(builder.length() - 2);
        }
        return builder.append(']').toString();
    }
"
927,if you change to while (currentClass != null) {} you can avoid the outer if clause,"	private Field[] getFields(Class<?> currentClass) {
		final List<Field> fields = new ArrayList<>();
		if (currentClass != null) {
			do {
				fields.addAll(Arrays.asList(currentClass.getDeclaredFields()));
				currentClass = currentClass.getSuperclass();
			} while (currentClass.getSuperclass() != null);
		}

		return fields.toArray(new Field[0]);
	}
","	private Field[] getFields(Class<?> currentClass) {
		final List<Field> fields = new ArrayList<>();
START 		if (currentClass != null) {
			do { END 
				fields.addAll(Arrays.asList(currentClass.getDeclaredFields()));
				currentClass = currentClass.getSuperclass();
			} while (currentClass.getSuperclass() != null);
		}

		return fields.toArray(new Field[0]);
	}
","	private Field[] getFields(Class<?> currentClass) {
		final List<Field> fields = new ArrayList<>();
		while (currentClass != null) {
			fields.addAll(Arrays.asList(currentClass.getDeclaredFields()));
			currentClass = currentClass.getSuperclass();
		}

		return fields.toArray(new Field[0]);
	}
"
928,nit: you can merge both lines above as `checkNotNull` will return the given argument,"    public void setDecoderResult(DecoderResult decoderResult) {
        ObjectUtil.checkNotNull(decoderResult, ""decoderResult"");
        this.decoderResult = decoderResult;
    }
","    public void setDecoderResult(DecoderResult decoderResult) {
        ObjectUtil.checkNotNull(decoderResult, ""decoderResult"");
START         this.decoderResult = decoderResult; END 
    }
","    public void setDecoderResult(DecoderResult decoderResult) {
        this.decoderResult = ObjectUtil.checkNotNull(decoderResult, ""decoderResult"");
    }
"
929,"```suggestion
    requestData = request;
```","  protected String contentFrom(FitNesseContext context, Request request, WikiPage requestedPage) {
    requestData= request;
    return prepareResponseDocument(context).html();
  }
","  protected String contentFrom(FitNesseContext context, Request request, WikiPage requestedPage) {
START     requestData= request; END 
    return prepareResponseDocument(context).html();
  }
","  protected String contentFrom(FitNesseContext context, Request request, WikiPage requestedPage) {
    return prepareResponseDocument(context).html(request);
  }
"
930,"Just wonder how high requests rate we are discussing, 1mln/s? The Coordinator balancing process will choke to halt from such amount long before the discussed queue will show a mere slight latency. 
I'm sure a single queue will manage the current request rate of Coordinator, besides threads don't need to call *drainTo()* as they can perfectly consume calling *queue.take()*.","  public void start()
  {
    for (int i = 0; i < numProcessingQueues; i++) {
      processingExecutor.scheduleAtFixedRate(
          new SegmentChangeProcessor(segmentProcessingQueues[i]),
          0,
          config.getCuratorCreateZkNodesRepeatDelay().getMillis(),
          TimeUnit.MILLISECONDS
      );
    }
  }
","  public void start()
  {
    for (int i = 0; i < numProcessingQueues; i++) {
      processingExecutor.scheduleAtFixedRate(
          new SegmentChangeProcessor(segmentProcessingQueues[i]),
          0,
START           config.getCuratorCreateZkNodesRepeatDelay().getMillis(), END 
          TimeUnit.MILLISECONDS
      );
    }
  }
","  public void start()
  { }
"
931,Indentation here looks crazy! I'm thinking this might be some mismatch (between your IDE and github) in the number of spaces a tab is worth.,"	protected void doc(Class c) throws IOException {
        open(""tr class='TableRowColor'"");
		open(""td"");
		around(""span class='modifiers'"",getModifiers(c));
		close(""td"");
        open(""td"");
        link(c.getType());
        tag(""br"");
        around(""span class='doc'"", getDoc(c));
        close(""td"");
		close(""tr"");
	}
","START 	protected void doc(Class c) throws IOException { END 
        open(""tr class='TableRowColor'"");
		open(""td"");
		around(""span class='modifiers'"",getModifiers(c));
		close(""td"");
        open(""td"");
        link(c.getType());
        tag(""br"");
        around(""span class='doc'"", getDoc(c));
        close(""td"");
		close(""tr"");
	}
","	private void doc(Class c) throws IOException {
		open(""tr class='TableRowColor'"");
		open(""td"");
		around(""span class='modifiers'"", getModifiers(c));
		close(""td"");
		open(""td"");
		link(c.getType());
		tag(""br"");
		around(""span class='doc'"", getDoc(c));
		close(""td"");
		close(""tr"");
	}
"
932,"internal cache, or just return null from this.","    public ArrayList<Pair<AbstractIngredient[], Float>> lookupShapedRecipes(Item i)
    {
        if (shapedReverseLookupTable.get(i) != null)
            return shapedReverseLookupTable.get(i);
        
        return new ArrayList<Pair<AbstractIngredient[], Float>>();
    }
","    public ArrayList<Pair<AbstractIngredient[], Float>> lookupShapedRecipes(Item i)
    {
        if (shapedReverseLookupTable.get(i) != null)
            return shapedReverseLookupTable.get(i);
        
START         return new ArrayList<Pair<AbstractIngredient[], Float>>(); END 
    }
","    public List<Pair<AbstractIngredient[], Float>> lookupShapedRecipes(Item i)
    {
        return shapedReverseLookupTable.get(i);
    }
"
933,"At some point we will probably need a variant of exists() that accepts an EventMetadata parameter, in case the existence decorator needs to know if a path has special properties within the scope of some package type.

Not critical now.","    public boolean exists()
    {
        OverriddenBooleanValue overriden = null;
        if ( decorator != null )
        {
            overriden = decorator.decorateExists( this, new EventMetadata(  ) );
        }

        if ( ( overriden != null ) && overriden.overrides() )
        {
            return overriden.getResult();
        }
        else
        {
            return provider.exists( resource );
        }
    }
","    public boolean exists()
    {
        OverriddenBooleanValue overriden = null;
        if ( decorator != null )
        {
START             overriden = decorator.decorateExists( this, new EventMetadata(  ) ); END 
        }

        if ( ( overriden != null ) && overriden.overrides() )
        {
            return overriden.getResult();
        }
        else
        {
            return provider.exists( resource );
        }
    }
","    public boolean exists()
    {
        return exists( new EventMetadata() );
    }
"
934,"I think there is a race in `IndexingService` between `createIndexes` and `shutdown` where population jobs can be added after `IndexPopulationJobController.stop` is called. Result will be that we can leak population jobs.

It might be that this is guarded for higher up in the stack. But I think this should be guarded for explicitly. Either here or in `IndexingService`.","    public void startIndexPopulation( IndexPopulationJob job )
    {
        populationJobs.add( job );
        scheduler.schedule( indexPopulation, new IndexPopulationJobWrapper( job, this ) );
    }
","    public void startIndexPopulation( IndexPopulationJob job )
    {
        populationJobs.add( job );
START         scheduler.schedule( indexPopulation, new IndexPopulationJobWrapper( job, this ) ); END 
    }
","    void startIndexPopulation( IndexPopulationJob job )
    {
        populationJobs.add( job );
        scheduler.schedule( indexPopulation, new IndexPopulationJobWrapper( job, this ) );
    }
"
935,`Integer.parseInt`,"    public static int getOptionAsInteger(Map<String, String> options, String option, int defaultValue) {
        String value = options.get(option);
        return value == null ? defaultValue : Integer.valueOf(value);
    }
","    public static int getOptionAsInteger(Map<String, String> options, String option, int defaultValue) {
        String value = options.get(option);
START         return value == null ? defaultValue : Integer.valueOf(value); END 
    }
","    public static int getOptionAsInteger(Map<String, String> options, String option, int defaultValue) {
        String value = options.get(option);
        return value == null ? defaultValue : Integer.parseInt(value);
    }
"
936,should this be thread safe ?,"    public void releaseBuffer() {
        if (serializedCache != null) {
            serializedCache.release();
            if (serializedCache.refCnt() == 0) {
                serializedCache = null;
            }
        }
    }
","    public void releaseBuffer() {
        if (serializedCache != null) {
            serializedCache.release();
START             if (serializedCache.refCnt() == 0) { END 
                serializedCache = null;
            }
        }
    }
","    public synchronized void releaseBuffer() {
        if (serializedCache != null) {
            serializedCache.release();
            if (serializedCache.refCnt() == 0) {
                serializedCache = null;
            }
        }
    }
"
937,"Good idea 👍 , but this checking should IMO be moved to `AppCredentials`. The `Os<X>` classes should generally just expose the Os interface and then we do the mapping on the ""upper"" layer, i.e. `AppCredentials`","    public Credentials.IdentityProvider getProvider() {
        String nativeProvider = nativeGetProvider(nativePtr);
        String id = identityProvider.getId();

        // Sanity check - ensure nothing changed in the OS
        if (nativeProvider.equals(id)) {
            return identityProvider;
        } else {
            throw new AssertionError(""The provider from the Object Store differs from the one in Realm."");
        }
    }
","    public Credentials.IdentityProvider getProvider() {
        String nativeProvider = nativeGetProvider(nativePtr);
        String id = identityProvider.getId();

        // Sanity check - ensure nothing changed in the OS
        if (nativeProvider.equals(id)) {
            return identityProvider;
        } else {
START             throw new AssertionError(""The provider from the Object Store differs from the one in Realm.""); END 
        }
    }
","    public String getProvider() {
        return nativeGetProvider(nativePtr);
    }
"
938,minor: rely on interface rather that full type.,"  private static Set<SymbolicValue> computedFrom(@Nullable SymbolicValue symbolicValue) {
    if (symbolicValue == null) {
      return Collections.emptySet();
    }
    HashSet<SymbolicValue> result = new HashSet<>();
    result.add(symbolicValue);
    symbolicValue.computedFrom().forEach(sv -> result.addAll(computedFrom(sv)));
    return result;
  }
","  private static Set<SymbolicValue> computedFrom(@Nullable SymbolicValue symbolicValue) {
    if (symbolicValue == null) {
      return Collections.emptySet();
    }
START     HashSet<SymbolicValue> result = new HashSet<>(); END 
    result.add(symbolicValue);
    symbolicValue.computedFrom().forEach(sv -> result.addAll(computedFrom(sv)));
    return result;
  }
","  private static Set<SymbolicValue> computedFrom(@Nullable SymbolicValue symbolicValue) {
    if (symbolicValue == null) {
      return Collections.emptySet();
    }
    Set<SymbolicValue> result = new HashSet<>();
    result.add(symbolicValue);
    symbolicValue.computedFrom().forEach(sv -> result.addAll(computedFrom(sv)));
    return result;
  }
"
939,"This method recursively calls itself, which will result in stackoverflow. Is that ok?","    public ClassLoader getClassLoader() {
        return this.getClassLoader();
    }
","    public ClassLoader getClassLoader() {
START         return this.getClassLoader(); END 
    }
","    public ClassLoader getClassLoader() {
        return this.getClass().getClassLoader();
    }
"
940,Shouldn't this throw an exception instead?,"	public Integer add(Stream<E> entities)
	{
		return delegate().add(entities.filter(entity ->
		{
			boolean permitted = isOperationPermitted(entity, Action.CREATE);
			if (permitted)
			{
				createAcl(entity);
			}
			return permitted;
		}));
	}
","	public Integer add(Stream<E> entities)
	{
		return delegate().add(entities.filter(entity ->
		{
START 			boolean permitted = isOperationPermitted(entity, Action.CREATE); END 
			if (permitted)
			{
				createAcl(entity);
			}
			return permitted;
		}));
	}
","	public Integer add(Stream<E> entities)
	{
		return delegate().add(entities.filter(entity ->
		{
			//throws exception if no permission on the containing package
			isOperationPermitted(entity, Action.CREATE);
			createAcl(entity);
			return true;
		}));
	}
"
941,"@lukasz-szewc I'd rather propose

``` java
delayedExecution.allAsyncCallsStarted();

verify(mock, timeout(50)).oneArg('1');

twentyMillisDelayedExecution.allAsyncCallsStarted();
verify(mock, timeout(50)).oneArg('2');
```

I agree with you however the name of this test is wrong...","    public void canIgnoreInvocationsWithJunit() throws InterruptedException {
        // given
        DelayedExecution delayedExecution = createZeroMillisDelayedExecution();
        DelayedExecution twentyMillisDelayedExecution = createTwentyMillisDelayedExecution();

        // when
        delayedExecution.allAsyncCallsStarted();
        twentyMillisDelayedExecution.allAsyncCallsStarted();

        // then
        verify(mock, timeout(50)).oneArg('1');
        verify(mock, timeout(50)).oneArg('2');
    }
","    public void canIgnoreInvocationsWithJunit() throws InterruptedException {
        // given
        DelayedExecution delayedExecution = createZeroMillisDelayedExecution();
        DelayedExecution twentyMillisDelayedExecution = createTwentyMillisDelayedExecution();

        // when
        delayedExecution.allAsyncCallsStarted();
START         twentyMillisDelayedExecution.allAsyncCallsStarted(); END 

        // then
        verify(mock, timeout(50)).oneArg('1');
        verify(mock, timeout(50)).oneArg('2');
    }
","    public void canIgnoreInvocationsWithJunit() throws InterruptedException {
        // given
        DelayedExecution delayedExecution = createZeroMillisDelayedExecution();
        DelayedExecution twentyMillisDelayedExecution = createTwentyMillisDelayedExecution();

        // when
        delayedExecution.allAsyncCallsStarted();

        // then
        verify(mock, timeout(50)).oneArg('1');

        // when
        twentyMillisDelayedExecution.allAsyncCallsStarted();

        // then
        verify(mock, timeout(50)).oneArg('2');
    }
"
942,"> else { [](start = 10, length = 6)

you don't need this else block.","    public final boolean isExtendedLifetimeValid() {
        //extended lifetime is only valid if it contains an access token
        if (mExtendedExpiresOn != null && !StringExtensions.IsNullOrBlank(mAccessToken)) {
            return !isTokenExpired(mExtendedExpiresOn);
        } else {
            return false;
        }
    }
","    public final boolean isExtendedLifetimeValid() {
        //extended lifetime is only valid if it contains an access token
        if (mExtendedExpiresOn != null && !StringExtensions.IsNullOrBlank(mAccessToken)) {
            return !isTokenExpired(mExtendedExpiresOn);
START         } else { END 
            return false;
        }
    }
","    public final boolean isExtendedLifetimeValid() {
        //extended lifetime is only valid if it contains an access token
        if (mExtendedExpiresOn != null && !StringExtensions.IsNullOrBlank(mAccessToken)) {
            return !isTokenExpired(mExtendedExpiresOn);
        }
        
        return false;
    }
"
943,Redundant String constructor.,"    public void sendDocumentFinalizedMessage(IWantDocument iWantDocument) {
        BodyMailMessage message = buildDocumentFinalizedMessage(iWantDocument);

        try {
            emailService.sendMessage(message, false);
        } catch (Exception e) {
            String errorMessage = new String(""sendDocumentFinalizedMessage, Email could not be sent for IWNT edoc# "" + iWantDocument.getDocumentNumber());
            LOG.error(errorMessage, e);
        }
    }
","    public void sendDocumentFinalizedMessage(IWantDocument iWantDocument) {
        BodyMailMessage message = buildDocumentFinalizedMessage(iWantDocument);

        try {
            emailService.sendMessage(message, false);
        } catch (Exception e) {
START             String errorMessage = new String(""sendDocumentFinalizedMessage, Email could not be sent for IWNT edoc# "" + iWantDocument.getDocumentNumber()); END 
            LOG.error(errorMessage, e);
        }
    }
","    public void sendDocumentFinalizedMessage(IWantDocument iWantDocument) {
        BodyMailMessage message = buildDocumentFinalizedMessage(iWantDocument);

        try {
            emailService.sendMessage(message, false);
        } catch (Exception e) {
            LOG.error((""sendDocumentFinalizedMessage, Email could not be sent for IWNT edoc# "" + iWantDocument.getDocumentNumber()), e);
        }
    }
"
944,minor: can be package private,"  public void addStore(PartitionId partitionId, ReplicationTest.StoreEventListener listener) {
    storesByPartition.computeIfAbsent(partitionId, partitionId1 -> new InMemoryStore(partitionId,
        infosByPartition.computeIfAbsent(partitionId1,
            (Function<PartitionId, List<MessageInfo>>) partitionId2 -> new ArrayList<>()),
        buffersByPartition.computeIfAbsent(partitionId1,
            (Function<PartitionId, List<ByteBuffer>>) partitionId22 -> new ArrayList<>()), listener));
  }
","START   public void addStore(PartitionId partitionId, ReplicationTest.StoreEventListener listener) { END 
    storesByPartition.computeIfAbsent(partitionId, partitionId1 -> new InMemoryStore(partitionId,
        infosByPartition.computeIfAbsent(partitionId1,
            (Function<PartitionId, List<MessageInfo>>) partitionId2 -> new ArrayList<>()),
        buffersByPartition.computeIfAbsent(partitionId1,
            (Function<PartitionId, List<ByteBuffer>>) partitionId22 -> new ArrayList<>()), listener));
  }
","  void addStore(PartitionId partitionId, ReplicationTest.StoreEventListener listener) {
    storesByPartition.computeIfAbsent(partitionId, partitionId1 -> new InMemoryStore(partitionId,
        infosByPartition.computeIfAbsent(partitionId1,
            (Function<PartitionId, List<MessageInfo>>) partitionId2 -> new ArrayList<>()),
        buffersByPartition.computeIfAbsent(partitionId1,
            (Function<PartitionId, List<ByteBuffer>>) partitionId22 -> new ArrayList<>()), listener));
  }
"
945,Add clarifying parenthesis. It's easy to forget the precedence rules for `^` and `&` so that will make the code easier to reason about.,"    private static long doubleToSortableLong(double value)
    {
        long bits = Double.doubleToLongBits(value);
        return bits ^ (bits >> 63) & Long.MAX_VALUE;
    }
","    private static long doubleToSortableLong(double value)
    {
        long bits = Double.doubleToLongBits(value);
START         return bits ^ (bits >> 63) & Long.MAX_VALUE; END 
    }
","    private static long doubleToSortableLong(double value)
    {
        long bits = Double.doubleToLongBits(value);
        return bits ^ ((bits >> 63) & Long.MAX_VALUE);
    }
"
946,"It's probably a bit low. I doubt GroupedJobInitializer use much memory so we could easily increase it a bit by default (like 100 maybe). Would need to check how many nodes are created after a few jobs are run in XWiki Standard. On extension side there is the root ""extension"" node and then 1 per namespace (so in practice 1 par wiki). It's potentially a lot more for the refactoring module since you have the root ""refactoring"" node and then one node for each element of each EntityReference which is manipulated.","    default int getGroupedJobInitializerCacheSize()
    {
        return 10;
    }
","    default int getGroupedJobInitializerCacheSize()
    {
START         return 10; END 
    }
","    default int getGroupedJobInitializerCacheSize()
    {
        return 100;
    }
"
947,minor: `this` qualifiers not required.,"  public DefaultCompactionPolicyTest() throws InterruptedException {
    Pair<MockBlobStore, StoreConfig> initState =
        CompactionPolicyTest.initializeBlobStore(properties, time, -1, -1, DEFAULT_MAX_BLOB_SIZE);
    this.config = initState.getSecond();
    this.blobStore = initState.getFirst();
    this.mockBlobStoreStats = blobStore.getBlobStoreStats();
    this.messageRetentionTimeInMs =
        config.storeDeletedMessageRetentionDays * Time.HoursPerDay * Time.SecsPerHour * Time.MsPerSec;
    this.compactionPolicy = new DefaultCompactionPolicy(config, time);
  }
","  public DefaultCompactionPolicyTest() throws InterruptedException {
    Pair<MockBlobStore, StoreConfig> initState =
        CompactionPolicyTest.initializeBlobStore(properties, time, -1, -1, DEFAULT_MAX_BLOB_SIZE);
START     this.config = initState.getSecond(); END 
    this.blobStore = initState.getFirst();
    this.mockBlobStoreStats = blobStore.getBlobStoreStats();
    this.messageRetentionTimeInMs =
        config.storeDeletedMessageRetentionDays * Time.HoursPerDay * Time.SecsPerHour * Time.MsPerSec;
    this.compactionPolicy = new DefaultCompactionPolicy(config, time);
  }
","  public DefaultCompactionPolicyTest() throws InterruptedException {
    Pair<MockBlobStore, StoreConfig> initState =
        CompactionPolicyTest.initializeBlobStore(properties, time, -1, -1, DEFAULT_MAX_BLOB_SIZE);
    config = initState.getSecond();
    blobStore = initState.getFirst();
    mockBlobStoreStats = blobStore.getBlobStoreStats();
    messageRetentionTimeInMs =
        config.storeDeletedMessageRetentionDays * Time.HoursPerDay * Time.SecsPerHour * Time.MsPerSec;
    compactionPolicy = new DefaultCompactionPolicy(config, time);
  }
"
948,Why not simply iterate over the array of chars and not check if `stringToValidate.contains(character)`.,"    private boolean containtsOnlyValidXMLChars(String stringToValidate) {
        String pattern = ""[^""
                + ""\u0009\r\n""
                + ""\u0020-\uD7FF""
                + ""\uE000-\uFFFD""
                + ""\ud800\udc00-\udbff\udfff""
                + ""]"";
        String resultString = stringToValidate.replaceAll(pattern, """");
        if (resultString.equals(stringToValidate)) {
            return true;
        }
        return false;
    }
","    private boolean containtsOnlyValidXMLChars(String stringToValidate) {
START         String pattern = ""[^"" END 
                + ""\u0009\r\n""
                + ""\u0020-\uD7FF""
                + ""\uE000-\uFFFD""
                + ""\ud800\udc00-\udbff\udfff""
                + ""]"";
        String resultString = stringToValidate.replaceAll(pattern, """");
        if (resultString.equals(stringToValidate)) {
            return true;
        }
        return false;
    }
","    private boolean containtsOnlyValidXMLChars(String stringToValidate) {
        String pattern = ""[^""
                + ""\u0009\r\n""
                + ""\u0020-\uD7FF""
                + ""\uE000-\uFFFD""
                + ""\ud800\udc00-\udbff\udfff""
                + ""]"";
        String resultString = stringToValidate.replaceAll(pattern, """");
        return resultString.equals(stringToValidate);
    }
"
949,"It's a pity we have to change the public API, but I guess it's reasonable in this case. Let's hope not so many folks wrote custom migrations commands.","    public CloseableLiquibase(String changeLogFile, ResourceAccessor resourceAccessor, Database database, ManagedDataSource dataSource) throws LiquibaseException, SQLException {
        super(changeLogFile, resourceAccessor, database);
        this.dataSource = dataSource;
    }
","START     public CloseableLiquibase(String changeLogFile, ResourceAccessor resourceAccessor, Database database, ManagedDataSource dataSource) throws LiquibaseException, SQLException { END 
        super(changeLogFile, resourceAccessor, database);
        this.dataSource = dataSource;
    }
","    CloseableLiquibase(
        String changeLogFile,
        ResourceAccessor resourceAccessor,
        Database database,
        ManagedDataSource dataSource
    ) throws LiquibaseException, SQLException {
        super(changeLogFile, resourceAccessor, database);
        this.dataSource = dataSource;
    }
"
950,"Might as well remove these fields if they are not used.
Perhaps just call the other constructor with:
this(iters.get(0).getCtfTmfTrace());","    public CtfTmfLightweightContext(ArrayList<CtfIterator> iters,
            ListIterator<CtfIterator> pos) {
        fIteratorPool = iters;
        fCurrentIterator = pos;
        fTrace = iters.get(0).getCtfTmfTrace();
        curLocation = new CtfLocation((Long)null);
        collisions = 0;
    }
","    public CtfTmfLightweightContext(ArrayList<CtfIterator> iters,
            ListIterator<CtfIterator> pos) {
        fIteratorPool = iters;
START         fCurrentIterator = pos; END 
        fTrace = iters.get(0).getCtfTmfTrace();
        curLocation = new CtfLocation((Long)null);
        collisions = 0;
    }
","    public CtfTmfLightweightContext(ArrayList<CtfIterator> iters,
            ListIterator<CtfIterator> pos) {
        fTrace = iters.get(0).getCtfTmfTrace();
        curLocation = new CtfLocation((Long) null);
    }
"
951,The Exception is never thrown.,"    public void testIsAdHocAutostart_true() throws Exception {
        String id = UUID.randomUUID().toString();

        AdHocSubProcess adHocSubProcess = bpmn2.createAdHocSubProcess();
        adHocSubProcess.setId(id);
        CustomElement.autoStart.of(adHocSubProcess).set(Boolean.TRUE);

        tested = new AdHocSubProcessPropertyReader(adHocSubProcess,
                                                   definitionResolverReal.getDiagram(),
                                                   definitionResolverReal);

        assertTrue(tested.isAdHocAutostart());
    }
","START     public void testIsAdHocAutostart_true() throws Exception { END 
        String id = UUID.randomUUID().toString();

        AdHocSubProcess adHocSubProcess = bpmn2.createAdHocSubProcess();
        adHocSubProcess.setId(id);
        CustomElement.autoStart.of(adHocSubProcess).set(Boolean.TRUE);

        tested = new AdHocSubProcessPropertyReader(adHocSubProcess,
                                                   definitionResolverReal.getDiagram(),
                                                   definitionResolverReal);

        assertTrue(tested.isAdHocAutostart());
    }
","    public void testIsAdHocAutostart_true() {
        String id = UUID.randomUUID().toString();

        AdHocSubProcess adHocSubProcess = bpmn2.createAdHocSubProcess();
        adHocSubProcess.setId(id);
        CustomElement.autoStart.of(adHocSubProcess).set(Boolean.TRUE);

        tested = new AdHocSubProcessPropertyReader(adHocSubProcess,
                                                   definitionResolverReal.getDiagram(),
                                                   definitionResolverReal);

        assertTrue(tested.isAdHocAutostart());
    }
"
952,"Remove the parameter completely, the other constructor will initiate the publisher as null.","    private BroadcastTrimmer broadcastTrimmer() {
        return new ScheduleResolverBroadcastTrimmer(
                null,
                scheduleResolver,
                contentResolver,
                contentWriter
        );
    }
","    private BroadcastTrimmer broadcastTrimmer() {
        return new ScheduleResolverBroadcastTrimmer(
START                 null, END 
                scheduleResolver,
                contentResolver,
                contentWriter
        );
    }
","    private BroadcastTrimmer broadcastTrimmer() {
        return new ScheduleResolverBroadcastTrimmer(
                scheduleResolver,
                contentResolver,
                contentWriter
        );
    }
"
953,clear the forwarders list after the loop?,"    public void disconnect()
            throws IOException {
        if (forwarders != null) {
            for (LocalPortForwarder forwarder : forwarders) {
                try {
                    forwarder.close();
                } catch (IOException e) {
                    log.warn(""Error closing forwarder"", e);
                }
            }
        }
        trans.disconnect();
        super.disconnect();
    }
","    public void disconnect()
            throws IOException {
        if (forwarders != null) {
            for (LocalPortForwarder forwarder : forwarders) {
                try {
                    forwarder.close();
                } catch (IOException e) {
                    log.warn(""Error closing forwarder"", e);
                }
START             } END 
        }
        trans.disconnect();
        super.disconnect();
    }
","    public void disconnect()
            throws IOException {
        for (LocalPortForwarder forwarder : forwarders) {
            try {
                forwarder.close();
            } catch (IOException e) {
                log.warn(""Error closing forwarder"", e);
            }
        }
        forwarders.clear();
        trans.disconnect();
        super.disconnect();
    }
"
954,NIT: is there just a plain `decrement()`?,"  public void close() {
    super.close();
    if (mRefCount != null) {
      mRefCount.decrementAndGet();
    }
  }
","  public void close() {
    super.close();
    if (mRefCount != null) {
START       mRefCount.decrementAndGet(); END 
    }
  }
","  public void close() {
    super.close();
    mRefCount.decrementAndGet();
  }
"
955,Use logger instead of `printStackTrace()` calls.,"    public static String getParameter(String key) {
        try {
            return getConfig().getString(key);
        } catch (NoSuchElementException e) {
            e.printStackTrace();
            throw new NoSuchElementException(""No configuration found in "" + CONFIG_FILE + "" for key "" + key + ""!"");
        }
    }
","    public static String getParameter(String key) {
        try {
            return getConfig().getString(key);
        } catch (NoSuchElementException e) {
START             e.printStackTrace(); END 
            throw new NoSuchElementException(""No configuration found in "" + CONFIG_FILE + "" for key "" + key + ""!"");
        }
    }
","    public static String getParameter(String key) {
        try {
            return getConfig().getString(key);
        } catch (NoSuchElementException e) {
            throw new NoSuchElementException(""No configuration found in "" + CONFIG_FILE + "" for key "" + key + ""!"");
        }
    }
"
956,This class should be immutable anyway so why not wrap the collection in the constructor once rather than every time it is returned to caller?,"   public List<Option> getOptions() {
      return unmodifiableList(options);
   }
","   public List<Option> getOptions() {
START       return unmodifiableList(options); END 
   }
","   public List<Option> getOptions() {
      return options;
   }
"
957,Do we need to set the input position to the initial offset?,"    public DataInputNavigableJsonAdapter(BufferObjectDataInput input, int initialOffset) {
        this.input = input;
        this.initialOffset = initialOffset;
    }
","    public DataInputNavigableJsonAdapter(BufferObjectDataInput input, int initialOffset) {
        this.input = input;
        this.initialOffset = initialOffset;
START     } END 
","    public DataInputNavigableJsonAdapter(BufferObjectDataInput input, int initialOffset) {
        this.input = input;
        this.input.position(initialOffset);
        this.initialOffset = initialOffset;
    }
"
958,"So it means that an argument with unknown type is considered as not serializable?
Should we consider making the unknown check inside `isNotSerializable` and provide the same behavior for all rules using it?

I'm saying this since the other rule (S2118) using `isNotSerializable` is also reporting an arguable issue with a similar message if we run it against an unknown type.

> Make the ""!Unknown!"" class ""Serializable"" or don't write it.","  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree argument = mit.arguments().get(1);
    Type type = argument.symbolType();
    if (type.isUnknown()) {
      return;
    }
    if (ExpressionsHelper.isNotSerializable(argument)) {
      String andParameters = JUtils.isParametrized(type) ? "" and its parameters"" : """";
      reportIssue(argument, ""Make \"""" + type + ""\"""" + andParameters + "" serializable or don't store it in the session."");
    }
  }
","  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree argument = mit.arguments().get(1);
    Type type = argument.symbolType();
START     if (type.isUnknown()) { END 
      return;
    }
    if (ExpressionsHelper.isNotSerializable(argument)) {
      String andParameters = JUtils.isParametrized(type) ? "" and its parameters"" : """";
      reportIssue(argument, ""Make \"""" + type + ""\"""" + andParameters + "" serializable or don't store it in the session."");
    }
  }
","  protected void onMethodInvocationFound(MethodInvocationTree mit) {
    ExpressionTree argument = mit.arguments().get(1);
    Type type = argument.symbolType();
    if (ExpressionsHelper.isNotSerializable(argument)) {
      String andParameters = JUtils.isParametrized(type) ? "" and its parameters"" : """";
      reportIssue(argument, ""Make \"""" + type.name() + ""\"""" + andParameters + "" serializable or don't store it in the session."");
    }
  }
"
959,Is this cast still necessary?,"    public Predicate createPredicateAndJoin(String filterString, Root<T> root) {
        LogicalOperatorRulesLexer lexer = new LogicalOperatorRulesLexer(new ANTLRInputStream(filterString));
        LogicalOperatorRulesParser parser = new LogicalOperatorRulesParser(new CommonTokenStream(lexer));
        parser.addErrorListener(new OsiamAntlrErrorListener());
        ParseTree tree = parser.parse();
        EvalVisitor<T> visitor = new EvalVisitor<>(this, root);

        return (Predicate) visitor.visit(tree);
    }
","    public Predicate createPredicateAndJoin(String filterString, Root<T> root) {
        LogicalOperatorRulesLexer lexer = new LogicalOperatorRulesLexer(new ANTLRInputStream(filterString));
        LogicalOperatorRulesParser parser = new LogicalOperatorRulesParser(new CommonTokenStream(lexer));
        parser.addErrorListener(new OsiamAntlrErrorListener());
        ParseTree tree = parser.parse();
        EvalVisitor<T> visitor = new EvalVisitor<>(this, root);

START         return (Predicate) visitor.visit(tree); END 
    }
","    public Predicate createPredicateAndJoin(String filterString, Root<T> root) {
        LogicalOperatorRulesLexer lexer = new LogicalOperatorRulesLexer(new ANTLRInputStream(filterString));
        LogicalOperatorRulesParser parser = new LogicalOperatorRulesParser(new CommonTokenStream(lexer));
        parser.addErrorListener(new OsiamAntlrErrorListener());
        ParseTree tree = parser.parse();
        EvalVisitor<T> visitor = new EvalVisitor<>(this, root);

        return visitor.visit(tree);
    }
"
960,"Remove the exceptions, since they're never thrown from the method.","    public Privilege[] getSupportedPrivileges(String path) throws PathNotFoundException, RepositoryException {
        return privileges.listOfSupported();
    }
","START     public Privilege[] getSupportedPrivileges(String path) throws PathNotFoundException, RepositoryException { END 
        return privileges.listOfSupported();
    }
","    public Privilege[] getSupportedPrivileges(String path) {
        return privileges.listOfSupported();
    }
"
961,I'd have thought preserving the use of ```Optional``` in the class's implementation would be nicer than just using ```Optional``` on the constructor and then reverting to ```null``` _inside_ the class.,"    protected AbstractSessionPresenter(final SessionManager sessionManager,
                                       final SessionPresenter.View view,
                                       final Optional<? extends ToolbarFactory<S>> toolbarFactory,
                                       final Optional<PaletteWidgetFactory<DefinitionSetPalette, ?>> paletteFactory,
                                       final NotificationsObserver notificationsObserver) {
        this.sessionManager = sessionManager;
        this.toolbarFactory = toolbarFactory.orElse(null);
        this.paletteFactory = paletteFactory.orElse(null);
        this.notificationsObserver = notificationsObserver;
        this.view = view;
        this.hasToolbar = true;
        this.hasPalette = true;
    }
","    protected AbstractSessionPresenter(final SessionManager sessionManager,
                                       final SessionPresenter.View view,
                                       final Optional<? extends ToolbarFactory<S>> toolbarFactory,
                                       final Optional<PaletteWidgetFactory<DefinitionSetPalette, ?>> paletteFactory,
                                       final NotificationsObserver notificationsObserver) {
        this.sessionManager = sessionManager;
START         this.toolbarFactory = toolbarFactory.orElse(null); END 
        this.paletteFactory = paletteFactory.orElse(null);
        this.notificationsObserver = notificationsObserver;
        this.view = view;
        this.hasToolbar = true;
        this.hasPalette = true;
    }
","    protected AbstractSessionPresenter(final SessionManager sessionManager,
                                       final SessionPresenter.View view,
                                       final Optional<? extends ToolbarFactory<S>> toolbarFactory,
                                       final Optional<PaletteWidgetFactory<DefinitionSetPalette, ?>> paletteFactory,
                                       final NotificationsObserver notificationsObserver) {
        this.sessionManager = sessionManager;
        this.toolbarFactory = (Optional<ToolbarFactory<S>>) toolbarFactory;
        this.paletteFactory = paletteFactory;
        this.notificationsObserver = notificationsObserver;
        this.view = view;
        this.hasToolbar = true;
        this.hasPalette = true;
    }
"
962,czy to musi byc publiczne?,"    public void prepareToNewMarker() {
        drawerLayout.closeDrawers();
        setLongClickListener(true);
        setToastMarkerInfo();
    }
","START     public void prepareToNewMarker() { END 
        drawerLayout.closeDrawers();
        setLongClickListener(true);
        setToastMarkerInfo();
    }
","    private void prepareToNewMarker() {
        drawerLayout.closeDrawers();
        setLongClickListener();
        setToastMarkerInfo();
    }
"
963,The skipRead parameter isn't used.,"   private MVCCEntry wrapMvccEntryForPut(InvocationContext ctx, Object key, CacheEntry cacheEntry, Metadata providedMetadata, boolean skipRead) {
      if (cacheEntry instanceof MVCCEntry) {
         MVCCEntry mvccEntry = (MVCCEntry) cacheEntry;
         updateMetadata(mvccEntry, providedMetadata);
         return mvccEntry;
      }
      return wrapInternalCacheEntryForPut(ctx, key, (InternalCacheEntry) cacheEntry, providedMetadata, true);
   }
","START    private MVCCEntry wrapMvccEntryForPut(InvocationContext ctx, Object key, CacheEntry cacheEntry, Metadata providedMetadata, boolean skipRead) { END 
      if (cacheEntry instanceof MVCCEntry) {
         MVCCEntry mvccEntry = (MVCCEntry) cacheEntry;
         updateMetadata(mvccEntry, providedMetadata);
         return mvccEntry;
      }
      return wrapInternalCacheEntryForPut(ctx, key, (InternalCacheEntry) cacheEntry, providedMetadata, true);
   }
","   private MVCCEntry wrapMvccEntryForPut(InvocationContext ctx, Object key, CacheEntry cacheEntry, Metadata providedMetadata, boolean skipRead) {
      if (cacheEntry instanceof MVCCEntry) {
         MVCCEntry mvccEntry = (MVCCEntry) cacheEntry;
         updateMetadata(mvccEntry, providedMetadata);
         return mvccEntry;
      }
      return wrapInternalCacheEntryForPut(ctx, key, (InternalCacheEntry) cacheEntry, providedMetadata, skipRead);
   }
"
964,You should make the `read()` call part of the `SERVICE_FAILURE_ACTIONS(Pointer)` constructor.,"	public SERVICE_FAILURE_ACTIONS getFailureActions() {
		Pointer buffer = queryServiceConfig2(Winsvc.SERVICE_CONFIG_FAILURE_ACTIONS);
		SERVICE_FAILURE_ACTIONS result = new SERVICE_FAILURE_ACTIONS(buffer);
		result.read();
		return result;
	}
","	public SERVICE_FAILURE_ACTIONS getFailureActions() {
		Pointer buffer = queryServiceConfig2(Winsvc.SERVICE_CONFIG_FAILURE_ACTIONS);
		SERVICE_FAILURE_ACTIONS result = new SERVICE_FAILURE_ACTIONS(buffer);
START 		result.read(); END 
		return result;
	}
","	public SERVICE_FAILURE_ACTIONS getFailureActions() {
		Pointer buffer = queryServiceConfig2(Winsvc.SERVICE_CONFIG_FAILURE_ACTIONS);
		SERVICE_FAILURE_ACTIONS result = new SERVICE_FAILURE_ACTIONS(buffer);
		return result;
	}
"
965,I would add the other createTempFile method to enforce the fact that we explicitly target this one only.,"  void fun(String strPath, String StrParent, String StrChild, String prefix, String suffix, java.net.URI uri) throws Exception {

    // Questionable: check what is done with this file
    new File(strPath); // Noncompliant
    new File(StrParent, StrChild); // Noncompliant {{Make sure this file handling is safe here.}}
    File parent = new File(uri); // Noncompliant
    new File(parent, StrChild); // compliant we rely on the fact that parent should be highlighted


    File.createTempFile(prefix, suffix); // Noncompliant
  }
","  void fun(String strPath, String StrParent, String StrChild, String prefix, String suffix, java.net.URI uri) throws Exception {

    // Questionable: check what is done with this file
    new File(strPath); // Noncompliant
    new File(StrParent, StrChild); // Noncompliant {{Make sure this file handling is safe here.}}
    File parent = new File(uri); // Noncompliant
    new File(parent, StrChild); // compliant we rely on the fact that parent should be highlighted


START     File.createTempFile(prefix, suffix); // Noncompliant END 
  }
","  void fun(String strPath, String StrParent, String StrChild, String prefix, String suffix, java.net.URI uri) throws Exception {

    // Questionable: check what is done with this file
    new File(strPath); // Noncompliant
    new File(StrParent, StrChild); // Noncompliant {{Make sure this file handling is safe here.}}
    File parent = new File(uri); // Noncompliant
    new File(parent, StrChild); // compliant we rely on the fact that parent should be highlighted


    File.createTempFile(prefix, suffix); // Noncompliant
    File.createTempFile(prefix, suffix, parent); // compliant
  }
"
966,I see that VmName in not included in the error message.. not sure if the right thing to do is to include it in the message or not to set it here,"    public ValidationResult vmNotHavingPciPassthroughDevices() {
        for (VM vm : vms) {
           if (getHostDeviceManager().checkVmNeedsPciDevices(vm.getId())) {
               return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES,
                       String.format(""$VmName %s"", vm.getName()));
           }
        }
        return ValidationResult.VALID;
    }
","    public ValidationResult vmNotHavingPciPassthroughDevices() {
        for (VM vm : vms) {
           if (getHostDeviceManager().checkVmNeedsPciDevices(vm.getId())) {
               return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES,
START                        String.format(""$VmName %s"", vm.getName())); END 
           }
        }
        return ValidationResult.VALID;
    }
","    public ValidationResult vmNotHavingPciPassthroughDevices() {
        for (VM vm : vms) {
           if (getHostDeviceManager().checkVmNeedsPciDevices(vm.getId())) {
               return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_ATTACHED_PCI_HOST_DEVICES);
           }
        }
        return ValidationResult.VALID;
    }
"
967,did you want to log this exception ?,"	public void onError(Throwable e) {
		e.printStackTrace();
		try {
			FileLfsServlet.sendError(response,
					HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());
			context.complete();
			in.close();
		} catch (IOException ex) {
			LOG.log(Level.SEVERE, ex.getMessage(), ex);
		}
	}
","	public void onError(Throwable e) {
START 		e.printStackTrace(); END 
		try {
			FileLfsServlet.sendError(response,
					HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());
			context.complete();
			in.close();
		} catch (IOException ex) {
			LOG.log(Level.SEVERE, ex.getMessage(), ex);
		}
	}
","	public void onError(Throwable e) {
		try {
			FileLfsServlet.sendError(response,
					HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());
			context.complete();
			in.close();
		} catch (IOException ex) {
			LOG.log(Level.SEVERE, ex.getMessage(), ex);
		}
	}
"
968,Return could be simplified: `return lines.remove(lines.lastKey());` :),"    public String pop() {
        String value = lines.remove(lines.lastKey());
        return value;
    }
","    public String pop() {
START         String value = lines.remove(lines.lastKey()); END 
        return value;
    }
","    public String pop() {
        return lines.remove(lines.lastKey());
    }
"
969,Shouldn't this be in onDestroy?,"    public void onDestroyView() {
        mapView.onDestroy();
        mapboxMap = null;
        unbinder.unbind();
        unbinder = null;
        WikipediaApp.getInstance().getRefWatcher().watch(this);
        super.onDestroyView();
    }
","    public void onDestroyView() {
        mapView.onDestroy();
        mapboxMap = null;
        unbinder.unbind();
        unbinder = null;
START         WikipediaApp.getInstance().getRefWatcher().watch(this); END 
        super.onDestroyView();
    }
","    public void onDestroyView() {
        mapView.onDestroy();
        mapboxMap = null;
        unbinder.unbind();
        unbinder = null;
        super.onDestroyView();
    }
"
970,"getClass comparison is required for Dtos because of the way their inheritance works (analyte is also a tissue and an identity for the purpose of including parent data), but instanceof should be used here (and typically for the non-dto models), and check vs. interfaces for flexibility. e.g. we could add another implementation of SampleCVSlide that this method should still work for, or we could subclass SampleCVSlideImpl (however unlikely)","  private static SampleTissueProcessingDto asTissueProcessingSampleDto(SampleTissueProcessing from) {
    SampleTissueProcessingDto dto = null;
    if (from.getClass() == SampleCVSlideImpl.class) {
      dto = asCVSlideSampleDto((SampleCVSlide) from);
    } else if (from.getClass() == SampleLCMTubeImpl.class) {
      dto = asLCMTubeSampleDto((SampleLCMTube) from);
    } else {
      dto = new SampleTissueProcessingDto();
    }
    return dto;
  }
","  private static SampleTissueProcessingDto asTissueProcessingSampleDto(SampleTissueProcessing from) {
    SampleTissueProcessingDto dto = null;
START     if (from.getClass() == SampleCVSlideImpl.class) { END 
      dto = asCVSlideSampleDto((SampleCVSlide) from);
    } else if (from.getClass() == SampleLCMTubeImpl.class) {
      dto = asLCMTubeSampleDto((SampleLCMTube) from);
    } else {
      dto = new SampleTissueProcessingDto();
    }
    return dto;
  }
","  private static SampleTissueProcessingDto asTissueProcessingSampleDto(SampleTissueProcessing from) {
    SampleTissueProcessingDto dto = null;
    if (from instanceof SampleCVSlideImpl) {
      dto = asCVSlideSampleDto((SampleCVSlide) from);
    } else if (from.getClass() == SampleLCMTubeImpl.class) {
      dto = asLCMTubeSampleDto((SampleLCMTube) from);
    } else {
      dto = new SampleTissueProcessingDto();
    }
    return dto;
  }
"
971,"Unnecessary new line here and below: why leave the first line blank? (unless there's a wrap in the signature, in which case it can help to differentiate between the signature and the body).","    public void testMakeTimeZone_NoOffsets() throws IOException {

        int[][] times = {};
        int[][] offsets = {};

        try {
            createZoneInfo(times, offsets);
            fail(""Did not detect no transitions"");
        } catch (IllegalStateException expected) {
            // Expected this to happen
        }
    }
","    public void testMakeTimeZone_NoOffsets() throws IOException {
START  END 
        int[][] times = {};
        int[][] offsets = {};

        try {
            createZoneInfo(times, offsets);
            fail(""Did not detect no transitions"");
        } catch (IllegalStateException expected) {
            // Expected this to happen
        }
    }
","  public void testMakeTimeZone_NoOffsets() throws Exception {
    int[][] times = {};
    int[][] offsets = {};
    try {
      createZoneInfo(times, offsets);
      fail(""Did not detect no transitions"");
    } catch (IllegalStateException expected) {
      // Expected this to happen
    }
  }
"
972,"Since the constructor is package private and only the Guice injector will be able to call it, you can remove all the null checks. The injector will already fail if any parameter is missing.","	DeploymentToNodeMetadata(@Memoized Supplier<Set<? extends Location>> locations,
										GroupNamingConvention.Factory namingConvention, OSImageToImage osImageToImage,
										RoleSizeToHardware roleSizeToHardware, Map<String, Credentials> credentialStore) {
		this.nodeNamingConvention = checkNotNull(namingConvention, ""namingConvention"").createWithoutPrefix();
		this.locations = checkNotNull(locations, ""locations"");
		this.osImageToImage = checkNotNull(osImageToImage, ""osImageToImage"");
		this.roleSizeToHardware = checkNotNull(roleSizeToHardware, ""roleSizeToHardware"");
		this.credentialStore = checkNotNull(credentialStore, ""credentialStore cannot be null"");
	}
","	DeploymentToNodeMetadata(@Memoized Supplier<Set<? extends Location>> locations,
										GroupNamingConvention.Factory namingConvention, OSImageToImage osImageToImage,
										RoleSizeToHardware roleSizeToHardware, Map<String, Credentials> credentialStore) {
		this.nodeNamingConvention = checkNotNull(namingConvention, ""namingConvention"").createWithoutPrefix();
		this.locations = checkNotNull(locations, ""locations"");
		this.osImageToImage = checkNotNull(osImageToImage, ""osImageToImage"");
		this.roleSizeToHardware = checkNotNull(roleSizeToHardware, ""roleSizeToHardware"");
START 		this.credentialStore = checkNotNull(credentialStore, ""credentialStore cannot be null""); END 
	}
","	DeploymentToNodeMetadata(@Memoized Supplier<Set<? extends Location>> locations,
										GroupNamingConvention.Factory namingConvention, OSImageToImage osImageToImage,
										RoleSizeToHardware roleSizeToHardware, Map<String, Credentials> credentialStore) {
		this.nodeNamingConvention = namingConvention.createWithoutPrefix();
		this.locations = locations;
		this.osImageToImage = osImageToImage;
		this.roleSizeToHardware = roleSizeToHardware;
		this.credentialStore = credentialStore;
	}
"
973,"I wonder if you shouldn't keep the old constructor here, and not use an extra boolean argument.","    public AsyncContext startAsync() throws IllegalStateException
    {
        if (_asyncNotSupportedSource != null)
            throw new IllegalStateException(""!asyncSupported: "" + _asyncNotSupportedSource);
        HttpChannelState state = getHttpChannelState();
        if (_async == null)
            _async = new AsyncContextState(state);
        AsyncContextEvent event = new AsyncContextEvent(_context, _async, state, this, this, getResponse(), false);
        state.startAsync(event);
        return _async;
    }
","    public AsyncContext startAsync() throws IllegalStateException
    {
        if (_asyncNotSupportedSource != null)
            throw new IllegalStateException(""!asyncSupported: "" + _asyncNotSupportedSource);
        HttpChannelState state = getHttpChannelState();
        if (_async == null)
            _async = new AsyncContextState(state);
START         AsyncContextEvent event = new AsyncContextEvent(_context, _async, state, this, this, getResponse(), false); END 
        state.startAsync(event);
        return _async;
    }
","    public AsyncContext startAsync() throws IllegalStateException
    {
        if (_asyncNotSupportedSource != null)
            throw new IllegalStateException(""!asyncSupported: "" + _asyncNotSupportedSource);
        HttpChannelState state = getHttpChannelState();
        if (_async == null)
            _async = new AsyncContextState(state);
        AsyncContextEvent event = new AsyncContextEvent(_context, _async, state, this, this, getResponse());
        state.startAsync(event);
        return _async;
    }
"
974,"After `throws Exception` is dropped from rollbackLocks, seems like this code should be : 

```java
  CompletableFuture<Void> getFailureOp(CommitData cd) {
      return rollbackLocks(cd);
    }
```","    CompletableFuture<Void> getFailureOp(CommitData cd) {
      return CompletableFuture.supplyAsync(() -> {
        try {
          rollbackLocks(cd);
        } catch (Exception e) {
          throw new CompletionException(e);
        }
        return null;
      }, env.getSharedResources().getSyncCommitExecutor());
    }
","    CompletableFuture<Void> getFailureOp(CommitData cd) {
START       return CompletableFuture.supplyAsync(() -> { END 
        try {
          rollbackLocks(cd);
        } catch (Exception e) {
          throw new CompletionException(e);
        }
        return null;
      }, env.getSharedResources().getSyncCommitExecutor());
    }
","    CompletableFuture<Void> getFailureOp(CommitData cd) {
      return rollbackLocks(cd);
    }
"
975,symbol.name() called 3 times? maybe worth a dedicated variable.,"    private boolean isGuavaPrecondition(Symbol.MethodSymbol symbol) {
      return symbol.owner().type().is(""com.google.common.base.Preconditions"")
        && (""checkNotNull"".equals(symbol.name()) || ""checkArgument"".equals(symbol.name()) || ""checkState"".equals(symbol.name()) );
    }
","    private boolean isGuavaPrecondition(Symbol.MethodSymbol symbol) {
      return symbol.owner().type().is(""com.google.common.base.Preconditions"")
START         && (""checkNotNull"".equals(symbol.name()) || ""checkArgument"".equals(symbol.name()) || ""checkState"".equals(symbol.name()) ); END 
    }
","    private boolean isGuavaPrecondition(Symbol.MethodSymbol symbol) {
      String name = symbol.name();
      return symbol.owner().type().is(""com.google.common.base.Preconditions"")
        && (""checkNotNull"".equals(name) || ""checkArgument"".equals(name) || ""checkState"".equals(name) );
    }
"
976,"We had that cancelUpdate() at the beginning of updateContent().

Now the UpdateThread doesn't get cancelled with TmfXYChartViewer.windowRangeUpdated() and TmfCommonXAxisChartViewer.setNbPoints().","    public void loadTrace(ITmfTrace trace) {
        cancelUpdate();
        super.loadTrace(trace);
        initializeDataProvider();
    }
","    public void loadTrace(ITmfTrace trace) {
START         cancelUpdate(); END 
        super.loadTrace(trace);
        initializeDataProvider();
    }
","    public void loadTrace(ITmfTrace trace) {
        super.loadTrace(trace);
        initializeDataProvider();
    }
"
977,"StringInputRowParser is used by parser options that aren't file-oriented (you can use it on streams etc) so this isn't a good place to put this. imo, this should replace `reset()` and be called in places that `reset()` is currently called (like FileIteratingFirehose). With one addition: it needs to be called before the very first file too.","  public StringInputRowParser(
      @JsonProperty(""parseSpec"") ParseSpec parseSpec,
      @JsonProperty(""encoding"") String encoding
  )
  {
    this.parseSpec = parseSpec;
    this.mapParser = new MapInputRowParser(parseSpec);
    this.parser = parseSpec.makeParser();
    parser.startFileFromBeginning();

    if (encoding != null) {
      this.charset = Charset.forName(encoding);
    } else {
      this.charset = DEFAULT_CHARSET;
    }
  }
","  public StringInputRowParser(
      @JsonProperty(""parseSpec"") ParseSpec parseSpec,
      @JsonProperty(""encoding"") String encoding
  )
  {
    this.parseSpec = parseSpec;
    this.mapParser = new MapInputRowParser(parseSpec);
    this.parser = parseSpec.makeParser();
START     parser.startFileFromBeginning(); END 

    if (encoding != null) {
      this.charset = Charset.forName(encoding);
    } else {
      this.charset = DEFAULT_CHARSET;
    }
  }
","  public StringInputRowParser(
      @JsonProperty(""parseSpec"") ParseSpec parseSpec,
      @JsonProperty(""encoding"") String encoding
  )
  {
    this.parseSpec = parseSpec;
    this.mapParser = new MapInputRowParser(parseSpec);
    this.parser = parseSpec.makeParser();

    if (encoding != null) {
      this.charset = Charset.forName(encoding);
    } else {
      this.charset = DEFAULT_CHARSET;
    }
  }
"
978,The superclass only repeats the assertComplete() call.  I don't think this PR adds any value.,"    public Object getNegotiatedProperty(String propName) {
        assertComplete();

        switch (propName) {
            case Sasl.QOP:
                return selectedQop.getName();
            case Sasl.MAX_BUFFER:
                return Integer.toString(actualMaxReceiveBuffer != 0 ? actualMaxReceiveBuffer : configuredMaxReceiveBuffer);
            case Sasl.RAW_SEND_SIZE:
                return Integer.toString(maxBuffer);
        }

        return super.getNegotiatedProperty(propName);
    }
","    public Object getNegotiatedProperty(String propName) {
        assertComplete();

        switch (propName) {
            case Sasl.QOP:
                return selectedQop.getName();
            case Sasl.MAX_BUFFER:
                return Integer.toString(actualMaxReceiveBuffer != 0 ? actualMaxReceiveBuffer : configuredMaxReceiveBuffer);
            case Sasl.RAW_SEND_SIZE:
                return Integer.toString(maxBuffer);
        }

START         return super.getNegotiatedProperty(propName); END 
    }
","    public Object getNegotiatedProperty(String propName) {
        assertComplete();

        switch (propName) {
            case Sasl.QOP:
                return selectedQop.getName();
            case Sasl.MAX_BUFFER:
                return Integer.toString(actualMaxReceiveBuffer != 0 ? actualMaxReceiveBuffer : configuredMaxReceiveBuffer);
            case Sasl.RAW_SEND_SIZE:
                return Integer.toString(maxBuffer);
        }

        return null;
    }
"
979,"this is inside Expressions, so maybe just `asBoolean(constant(value))`, the same with the others","    public static BooleanExpression asBoolean(boolean value) {
        return asBoolean(Expressions.constant(value));
    }
","    public static BooleanExpression asBoolean(boolean value) {
START         return asBoolean(Expressions.constant(value)); END 
    }
","    public static BooleanExpression asBoolean(boolean value) {
        return asBoolean(constant(value));
    }
"
980,You can do `this::deleteOldSegments` for the callable. It is more efficient lambda form,"        public void startPolicyEnforcement() throws IOException {
            if (m_pbd.getUsageSpecificLog().isDebugEnabled()) {
                m_pbd.getUsageSpecificLog().debug(""Starting time based retention policy enforcement with retainMillis="" + m_retainMillis +
                        "" for PBD "" + m_pbd.getNonce());
            }

            m_reader = m_pbd.openForRead(CURSOR_NAME);
            scheduleTaskFor(m_pbd.getNonce(), ()->deleteOldSegments(), 0);
        }
","        public void startPolicyEnforcement() throws IOException {
            if (m_pbd.getUsageSpecificLog().isDebugEnabled()) {
                m_pbd.getUsageSpecificLog().debug(""Starting time based retention policy enforcement with retainMillis="" + m_retainMillis +
                        "" for PBD "" + m_pbd.getNonce());
            }

            m_reader = m_pbd.openForRead(CURSOR_NAME);
START             scheduleTaskFor(m_pbd.getNonce(), ()->deleteOldSegments(), 0); END 
        }
","        public void startPolicyEnforcement() throws IOException {
            if (m_pbd.getUsageSpecificLog().isDebugEnabled()) {
                m_pbd.getUsageSpecificLog().debug(""Starting time based retention policy enforcement with retainMillis="" + m_retainMillis +
                        "" for PBD "" + m_pbd.getNonce());
            }

            m_reader = m_pbd.openForRead(CURSOR_NAME);
            scheduleTaskFor(m_pbd.getNonce(), this::deleteOldSegments, 0);
        }
"
981,Do you need to guard against `null` here as well?,"    public void afterRun() throws Exception {
        if (recordStore.isWanReplicationEnabled()) {
            CacheRecord record = recordStore.getRecord(key);
            if (record != null) {
                publishWanUpdate(key, record);
            } else {
                publishWanRemove(key);
            }
        }

        super.afterRun();
    }
","    public void afterRun() throws Exception {
        if (recordStore.isWanReplicationEnabled()) {
            CacheRecord record = recordStore.getRecord(key);
            if (record != null) {
                publishWanUpdate(key, record);
START             } else { END 
                publishWanRemove(key);
            }
        }

        super.afterRun();
    }
","    public void afterRun() throws Exception {
        if (recordStore == null) {
            return;
        }

        if (recordStore.isWanReplicationEnabled()) {
            CacheRecord record = recordStore.getRecord(key);
            if (record != null) {
                publishWanUpdate(key, record);
            } else {
                publishWanRemove(key);
            }
        }

        super.afterRun();
    }
"
982,`toLowerCase`,"    protected String getConfigRoot() {
        return ClientConfigSections.HAZELCAST_CLIENT.name.toLowerCase();
    }
","    protected String getConfigRoot() {
START         return ClientConfigSections.HAZELCAST_CLIENT.name.toLowerCase(); END 
    }
","    protected String getConfigRoot() {
        return ClientConfigSections.HAZELCAST_CLIENT.name;
    }
"
983,"Does this method have to be synchronized, considering that `capacity` is `final`?","    public synchronized int getCapacity() {
        return capacity;
    }
","START     public synchronized int getCapacity() { END 
        return capacity;
    }
","    public int getCapacity() {
        return capacity;
    }
"
984,why add 'null' to allArtTypes?,"   private Set<IArtifactType> getAllArtTypes() {
      Set<IArtifactType> allArtTypes = new HashSet<>();
      if (artifactTypes == null || !artifactTypes.isEmpty()) {
         allArtTypes.addAll(artifactTypes);
      } else {
         getArtifactTypesFromWorkItemTypes();
      }
      return allArtTypes;
   }
","   private Set<IArtifactType> getAllArtTypes() {
      Set<IArtifactType> allArtTypes = new HashSet<>();
      if (artifactTypes == null || !artifactTypes.isEmpty()) {
START          allArtTypes.addAll(artifactTypes); END 
      } else {
         getArtifactTypesFromWorkItemTypes();
      }
      return allArtTypes;
   }
","   private Set<IArtifactType> getAllArtTypes() {
      Set<IArtifactType> allArtTypes = new HashSet<>();
      if (artifactTypes != null || !artifactTypes.isEmpty()) {
         allArtTypes.addAll(artifactTypes);
      } else {
         allArtTypes = getArtifactTypesFromWorkItemTypes();
      }
      return allArtTypes;
   }
"
985,This should be moved outside the try block,"   public void testContextListenerIsSet() throws Exception
   {
      try (WizardCommandController tester = testHarness.createWizardController(MyFirstWizard.class))
      {
         tester.initialize();
         Assert.assertTrue(""Wizard is not on a valid state"", tester.isValid());
         Assert.assertTrue(""Listener is not set"", listener.isContextInitialized());
         tester.execute();
         Assert.assertFalse(""Listener is still set"", listener.isContextInitialized());
      }
   }
","   public void testContextListenerIsSet() throws Exception
   {
      try (WizardCommandController tester = testHarness.createWizardController(MyFirstWizard.class))
      {
         tester.initialize();
         Assert.assertTrue(""Wizard is not on a valid state"", tester.isValid());
         Assert.assertTrue(""Listener is not set"", listener.isContextInitialized());
         tester.execute();
START          Assert.assertFalse(""Listener is still set"", listener.isContextInitialized()); END 
      }
   }
","   public void testContextListenerIsSet() throws Exception
   {
      try (WizardCommandController tester = testHarness.createWizardController(MyFirstWizard.class))
      {
         tester.initialize();
         Assert.assertTrue(""Wizard is not on a valid state"", tester.isValid());
         Assert.assertTrue(""Listener is not set"", listener.isContextInitialized());
         tester.execute();
      }
      Assert.assertFalse(""Listener is still set"", listener.isContextInitialized());
   }
"
986,package private,"    private Later(F0<A> producer) {
      this.memo = P.hardMemo(producer);
    }
","START     private Later(F0<A> producer) { END 
      this.memo = P.hardMemo(producer);
    }
","    Later(F0<A> producer) {
      this.memo = P.hardMemo(producer);
    }
"
987,"Codacy flagged this method for ""Avoid using a branching statement as the last in a loop."" I think that is a reasonable call by Codacy and the code would be easier to read if runningFromCommandLine was set to true in the loop, followed by a break, and a single method return of runningFromCommandLine on what is currently line 136. Alternatively, one could also do away with runningFromCommandLine and have a return true statement in the loop, but I think the first alternative may be a little easier to read and will make Codacy content.","    private boolean isRunningFromCommandLine() {

        boolean runningFromCommandLine = false;
        // first look up all OptionProcessors and see if running from command line option is set
        Collection<? extends OptionProcessor> optionProcessors = Lookup.getDefault().lookupAll(OptionProcessor.class);
        Iterator<? extends OptionProcessor> optionsIterator = optionProcessors.iterator();
        while (optionsIterator.hasNext()) {
            // find CommandLineOptionProcessor
            OptionProcessor processor = optionsIterator.next();
            if (!(processor instanceof CommandLineOptionProcessor)) {
                continue;
            }

            // check if we are running from command line
            runningFromCommandLine = ((CommandLineOptionProcessor) processor).isRunFromCommandLine();
            return runningFromCommandLine;
        }
        return false;
    }
","    private boolean isRunningFromCommandLine() {

        boolean runningFromCommandLine = false;
        // first look up all OptionProcessors and see if running from command line option is set
        Collection<? extends OptionProcessor> optionProcessors = Lookup.getDefault().lookupAll(OptionProcessor.class);
        Iterator<? extends OptionProcessor> optionsIterator = optionProcessors.iterator();
        while (optionsIterator.hasNext()) {
            // find CommandLineOptionProcessor
            OptionProcessor processor = optionsIterator.next();
            if (!(processor instanceof CommandLineOptionProcessor)) {
                continue;
            }

            // check if we are running from command line
            runningFromCommandLine = ((CommandLineOptionProcessor) processor).isRunFromCommandLine();
            return runningFromCommandLine;
        }
        return false;
START     } END 
","    private boolean isRunningFromCommandLine() {

        // first look up all OptionProcessors and see if running from command line option is set
        Collection<? extends OptionProcessor> optionProcessors = Lookup.getDefault().lookupAll(OptionProcessor.class);
        Iterator<? extends OptionProcessor> optionsIterator = optionProcessors.iterator();
        while (optionsIterator.hasNext()) {
            // find CommandLineOptionProcessor
            OptionProcessor processor = optionsIterator.next();
            if ((processor instanceof CommandLineOptionProcessor)) {
                // check if we are running from command line            
                return ((CommandLineOptionProcessor) processor).isRunFromCommandLine();
            }
        }
        return false;
    }
"
988,"Unless you want this to be tri-state, then ""Boolean"" should be ""boolean"". I don't see the need for tristate, so go with ""boolean""","    public Boolean onReceivedHttpAuthRequest(CordovaWebView view, ICordovaHttpAuthHandler handler, String host, String realm) {
        for (CordovaPlugin plugin : this.pluginMap.values()) {
            if (plugin != null && plugin.onReceivedHttpAuthRequest(view, handler, host, realm)) {
                return true;
            }
        }
        return false;
    }
","START     public Boolean onReceivedHttpAuthRequest(CordovaWebView view, ICordovaHttpAuthHandler handler, String host, String realm) { END 
        for (CordovaPlugin plugin : this.pluginMap.values()) {
            if (plugin != null && plugin.onReceivedHttpAuthRequest(view, handler, host, realm)) {
                return true;
            }
        }
        return false;
    }
","    public boolean onReceivedHttpAuthRequest(CordovaWebView view, ICordovaHttpAuthHandler handler, String host, String realm) {
        for (CordovaPlugin plugin : this.pluginMap.values()) {
            if (plugin != null && plugin.onReceivedHttpAuthRequest(view, handler, host, realm)) {
                return true;
            }
        }
        return false;
    }
"
989,lockPath is already String,"    private String createAndGetLockPath() throws InterruptedException, KeeperException {
        // Create locks if it does not exist
        if (zk.exists(lockPath.toString(), false) == null) {
            try {
                Util.mkdir(zk, lockPath.toString(), ZooDefs.Ids.OPEN_ACL_UNSAFE);
            } catch (CloudnameException e) {
                log.log(
                    java.util.logging.Level.INFO,
                    ""CloudnameException while trying to get lock path "" + absoluteLockPath,
                    e);
            }
        }

        return lockPath + ""/"" + lockName;
    }
","    private String createAndGetLockPath() throws InterruptedException, KeeperException {
        // Create locks if it does not exist
START         if (zk.exists(lockPath.toString(), false) == null) { END 
            try {
                Util.mkdir(zk, lockPath.toString(), ZooDefs.Ids.OPEN_ACL_UNSAFE);
            } catch (CloudnameException e) {
                log.log(
                    java.util.logging.Level.INFO,
                    ""CloudnameException while trying to get lock path "" + absoluteLockPath,
                    e);
            }
        }

        return lockPath + ""/"" + lockName;
    }
","    private String createAndGetLockPath() throws InterruptedException, KeeperException {
        // Create locks if it does not exist
        if (zk.exists(lockPath, false) == null) {
            try {
                Util.mkdir(zk, lockPath, ZooDefs.Ids.OPEN_ACL_UNSAFE);
            } catch (CloudnameException e) {
                log.log(
                    java.util.logging.Level.INFO,
                    ""CloudnameException while trying to get lock path "" + absoluteLockPath,
                    e);
            }
        }

        return lockPath + ""/"" + lockName;
    }
"
990,"What I mean is, your dialect does not implement `BatchableGridDialect`, so items will never be put in to the operations queue.","	public Tuple getTuple(EntityKey key, TupleContext tupleContext) {

		Entity entity = getEntity( key, tupleContext.getOptionsContext() );
		if ( entity != null ) {
			return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) );
		}
		else if ( isInTheQueue( key, tupleContext ) ) {
			// The key has not been inserted in the db but it is in the queue
			return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) );
		}
		else {
			return null;
		}
	}
","	public Tuple getTuple(EntityKey key, TupleContext tupleContext) {

		Entity entity = getEntity( key, tupleContext.getOptionsContext() );
		if ( entity != null ) {
			return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) );
		}
START 		else if ( isInTheQueue( key, tupleContext ) ) { END 
			// The key has not been inserted in the db but it is in the queue
			return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) );
		}
		else {
			return null;
		}
	}
","	public Tuple getTuple(EntityKey key, TupleContext tupleContext) {
		Entity entity = getEntity( key );
		if ( entity != null ) {
			return new Tuple( new RedisTupleSnapshot( entity.getProperties() ) );
		}
		else {
			return null;
		}
	}
"
991,Isn't it enough to throw the logging exception instead of also logging locally ?,"      public void invoke(ClientEvent event) {
         try {
            method.invoke(listener, event);
         } catch (InvocationTargetException e) {
            log.errorInvokingListener(method, listener, e.getTargetException());
            throw log.exceptionInvokingListener(
               e.getClass().getName(), method, listener, e.getTargetException());
         } catch (Exception e) {
            throw log.exceptionInvokingListener(
                  e.getClass().getName(), method, listener, e);
         }
      }
","      public void invoke(ClientEvent event) {
         try {
            method.invoke(listener, event);
         } catch (InvocationTargetException e) {
            log.errorInvokingListener(method, listener, e.getTargetException());
            throw log.exceptionInvokingListener(
               e.getClass().getName(), method, listener, e.getTargetException());
         } catch (Exception e) {
            throw log.exceptionInvokingListener(
START                   e.getClass().getName(), method, listener, e); END 
         }
      }
","      public void invoke(ClientEvent event) {
         try {
            method.invoke(listener, event);
         } catch (InvocationTargetException e) {
            throw log.exceptionInvokingListener(
               e.getClass().getName(), method, listener, e.getTargetException());
         } catch (Exception e) {
            throw log.exceptionInvokingListener(
                  e.getClass().getName(), method, listener, e);
         }
      }
"
992,can you make loadProperties() take configFile location as an argument and remove the global variable configFile . It seems it is not really needed and reducing global state is good in general.,"  ConfigFileConfigProvider(@JsonProperty(""configFile"") String configFile){
    this.configFile = configFile;
    loadProperties();
  }
","  ConfigFileConfigProvider(@JsonProperty(""configFile"") String configFile){
    this.configFile = configFile;
START     loadProperties(); END 
  }
","  ConfigFileConfigProvider(@JsonProperty(""configFile"") String configFile){
    loadProperties(configFile);
  }
"
993,"No println's, please.","    public void addDataSource(long dataSourceObjectId) throws IngestStreamClosedException {
        // Do nothing
        System.out.println(""### DefaultAddImageTaskIngestStream - addDataSource "" + dataSourceObjectId);
    }
","    public void addDataSource(long dataSourceObjectId) throws IngestStreamClosedException {
        // Do nothing
START         System.out.println(""### DefaultAddImageTaskIngestStream - addDataSource "" + dataSourceObjectId); END 
    }
","    public void addDataSource(long dataSourceObjectId) throws IngestStreamClosedException {
        // Do nothing
    }
"
994,I don't know if they should be put inside this method or not. Should temp table be considered as staging directories?,"        private void deleteEmptyStagingDirectories(List<DeclaredIntentionToWrite> declaredIntentionsToWrite)
        {
            for (DeclaredIntentionToWrite declaredIntentionToWrite : declaredIntentionsToWrite) {
                Path path = declaredIntentionToWrite.getRootPath();
                if (declaredIntentionToWrite.isTemporaryTable()) {
                    // for temporary table simply delete the entire directory
                    deleteRecursivelyIfExists(declaredIntentionToWrite.getContext(), hdfsEnvironment, path);
                    continue;
                }
                if (declaredIntentionToWrite.getMode() != WriteMode.STAGE_AND_MOVE_TO_TARGET_DIRECTORY) {
                    continue;
                }
                recursiveDeleteFilesAndLog(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, ""staging directory cleanup"");
            }
        }
","        private void deleteEmptyStagingDirectories(List<DeclaredIntentionToWrite> declaredIntentionsToWrite)
        {
            for (DeclaredIntentionToWrite declaredIntentionToWrite : declaredIntentionsToWrite) {
START                 Path path = declaredIntentionToWrite.getRootPath(); END 
                if (declaredIntentionToWrite.isTemporaryTable()) {
                    // for temporary table simply delete the entire directory
                    deleteRecursivelyIfExists(declaredIntentionToWrite.getContext(), hdfsEnvironment, path);
                    continue;
                }
                if (declaredIntentionToWrite.getMode() != WriteMode.STAGE_AND_MOVE_TO_TARGET_DIRECTORY) {
                    continue;
                }
                recursiveDeleteFilesAndLog(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, ""staging directory cleanup"");
            }
        }
","        private void deleteEmptyStagingDirectories(List<DeclaredIntentionToWrite> declaredIntentionsToWrite)
        {
            for (DeclaredIntentionToWrite declaredIntentionToWrite : declaredIntentionsToWrite) {
                if (declaredIntentionToWrite.getMode() != WriteMode.STAGE_AND_MOVE_TO_TARGET_DIRECTORY) {
                    continue;
                }
                Path path = declaredIntentionToWrite.getRootPath();
                recursiveDeleteFilesAndLog(declaredIntentionToWrite.getContext(), path, ImmutableList.of(), true, ""staging directory cleanup"");
            }
        }
"
995,format,"    public void edit() {
        if (getWindow() != null) {
            return;
        }

        EditDiskProfileModel model =
                new EditDiskProfileModel(this,
                        getCompatibilityVersion(),
                        (DiskProfile) getSelectedItem(),
                        getEntity().getStoragePoolId());
        setWindow(model);

        initProfileStorageDomains(model);
    }
","    public void edit() {
        if (getWindow() != null) {
            return;
        }

START         EditDiskProfileModel model = END 
                new EditDiskProfileModel(this,
                        getCompatibilityVersion(),
                        (DiskProfile) getSelectedItem(),
                        getEntity().getStoragePoolId());
        setWindow(model);

        initProfileStorageDomains(model);
    }
","    public void edit() {
        if (getWindow() != null) {
            return;
        }

        EditDiskProfileModel model =
                new EditDiskProfileModel(this, (DiskProfile) getSelectedItem(), getEntity().getStoragePoolId());
        setWindow(model);

        initProfileStorageDomains(model);
    }
"
996,Please remove that line. It changes the tests.,"	public void setUp() throws Exception {
		super.setUp();
		gitDir = new File(project.getProject()
				.getLocationURI().getPath(), Constants.DOT_GIT);
		testRepository = new TestRepository(gitDir);
		testRepository.connect(project.getProject());
		testRepository.commit(""initial commit"");
	}
","	public void setUp() throws Exception {
		super.setUp();
		gitDir = new File(project.getProject()
				.getLocationURI().getPath(), Constants.DOT_GIT);
		testRepository = new TestRepository(gitDir);
		testRepository.connect(project.getProject());
START 		testRepository.commit(""initial commit""); END 
	}
","	public void setUp() throws Exception {
		super.setUp();
		gitDir = new File(project.getProject()
				.getLocationURI().getPath(), Constants.DOT_GIT);
		testRepository = new TestRepository(gitDir);
		testRepository.connect(project.getProject());
	}
"
997,"should look like this but without the declaration above - they should be on one line

```suggestion
        long deckID = getCol().getDecks().selected();
```","    protected long getParentDid() {
        long deckID;
        deckID = getCol().getDecks().selected();
        return deckID;
    }
","    protected long getParentDid() {
        long deckID;
START         deckID = getCol().getDecks().selected(); END 
        return deckID;
    }
","    protected long getParentDid() {
        long deckID = getCol().getDecks().selected();
        return deckID;
    }
"
998,"Actually this part does not throw any Exception. Just remove `throws Exception` and we should be good.
Beware of spaces vs tabs. Prefer using spaces for indentation please.","    public static String getFileExtension(File file) throws Exception {
 	return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase();
    }
","    public static String getFileExtension(File file) throws Exception {
START  	return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase(); END 
    }
","    public static String getFileExtension(File file) {
        return FilenameUtils.getExtension(file.getAbsolutePath()).toLowerCase();
    }
"
999,You do not need to call Integer.parseInt(getUuid()) more than once in a method.,"	public void shouldPurgeAnAutoGenerationOption() throws Exception {
		assertNotNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())));
		MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + ""/"" + getUuid());
		req.addParameter(""purge"", """");
		handle(req);
		assertNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())));
	}
","	public void shouldPurgeAnAutoGenerationOption() throws Exception {
START 		assertNotNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid()))); END 
		MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + ""/"" + getUuid());
		req.addParameter(""purge"", """");
		handle(req);
		assertNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())));
	}
","	public void shouldPurgeAnAutoGenerationOption() throws Exception {
		assertNotNull(identifierSourceService.getAutoGenerationOption(getId()));
		MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + ""/"" + getUuid());
		req.addParameter(""purge"", """");
		handle(req);
		assertNull(identifierSourceService.getAutoGenerationOption(getId()));
	}
"
1000,"Any chance we could make this test `@Parameterized`? To test 35 different perspectives from within one test case seems evil.

Alternatively (as I'm sniffing potential problems with the annotation and Arquillian.), can we at least make the looped code its own function and put some logging around it, so that we know when was it that the test actually failed?

Of course, we could also have a different method for each of the perspectives - which would be the ""cleanest"" solution in this situation. But I sort of see how that would be overkill.","    private void loadPerspectiveAndCheckLoadingTime(String perspectiveID, boolean headerIncluded) {
        //long loadingStart = System.currentTimeMillis();

        String standalonePerspectiveURL = getStandalonePerspectiveURL(perspectiveID, headerIncluded);
        driver.get(standalonePerspectiveURL);

        BusyPopup.waitForDisappearance();
        ApplicationLoadingPopup.waitForDisappearance(PERSPECTIVE_LOADING_TIMEOUT);

        //double perspectiveLoadingTime = (System.currentTimeMillis() - loadingStart) / (double) 1000;

        //TODO: What is the acceptable loading time? Do we want to test this?
        //assertThat(perspectiveLoadingTime)
        //        .as(""It should take less than ""+PERSPECTIVE_LOADING_TIMEOUT+"" seconds to load the perspective "" + perspectiveID + ""."")
        //        .isLessThan(PERSPECTIVE_LOADING_TIMEOUT);
    }
","START     private void loadPerspectiveAndCheckLoadingTime(String perspectiveID, boolean headerIncluded) { END 
        //long loadingStart = System.currentTimeMillis();

        String standalonePerspectiveURL = getStandalonePerspectiveURL(perspectiveID, headerIncluded);
        driver.get(standalonePerspectiveURL);

        BusyPopup.waitForDisappearance();
        ApplicationLoadingPopup.waitForDisappearance(PERSPECTIVE_LOADING_TIMEOUT);

        //double perspectiveLoadingTime = (System.currentTimeMillis() - loadingStart) / (double) 1000;

        //TODO: What is the acceptable loading time? Do we want to test this?
        //assertThat(perspectiveLoadingTime)
        //        .as(""It should take less than ""+PERSPECTIVE_LOADING_TIMEOUT+"" seconds to load the perspective "" + perspectiveID + ""."")
        //        .isLessThan(PERSPECTIVE_LOADING_TIMEOUT);
    }
","    private void loadPerspectiveAndCheckLoadingTime(String perspectiveID, boolean headerIncluded) {
        //long loadingStart = System.currentTimeMillis();

        String standalonePerspectiveURL = getStandalonePerspectiveURL(perspectiveID, headerIncluded);
        driver.get(standalonePerspectiveURL);

        ApplicationLoadingPopup.waitForDisappearance(PERSPECTIVE_LOADING_TIMEOUT);
        BusyPopup.waitForDisappearance();

        //double perspectiveLoadingTime = (System.currentTimeMillis() - loadingStart) / (double) 1000;

        //TODO: What is the acceptable loading time? Do we want to test this?
        //assertThat(perspectiveLoadingTime)
        //        .as(""It should take less than "" + PERSPECTIVE_LOADING_TIMEOUT + "" seconds to load the perspective "" + perspectiveID + ""."")
        //        .isLessThan(PERSPECTIVE_LOADING_TIMEOUT);
    }
"
1001,THis should return empty array,"	public default IVariableBinding[] getSyntheticOuterLocals() {
		return null;
	}
","	public default IVariableBinding[] getSyntheticOuterLocals() {
		return START  null; END 
	}
","	public default IVariableBinding[] getSyntheticOuterLocals() {
		return new IVariableBinding[0];
	}
"
1002,Both should be initialized even for failures,"    protected void executeCommand() {
        AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId());
        if (profile == null) {
            setSucceeded(false);
        } else {
            sessionId = getParameters().getSessionId();
            sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId());
            sessionDataContainer.setSessionValid(getParameters().getSessionId(), false);
            setSucceeded(true);
        }
    }
","    protected void executeCommand() {
        AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId());
        if (profile == null) {
            setSucceeded(false);
        } else {
            sessionId = getParameters().getSessionId();
START             sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId()); END 
            sessionDataContainer.setSessionValid(getParameters().getSessionId(), false);
            setSucceeded(true);
        }
    }
","    protected void executeCommand() {
        AuthenticationProfile profile = sessionDataContainer.getProfile(getParameters().getSessionId());
        sessionId = getParameters().getSessionId();
        sourceIp = sessionDataContainer.getSourceIp(getParameters().getSessionId());
        if (profile == null) {
            setSucceeded(false);
        } else {
            sessionDataContainer.setSessionValid(getParameters().getSessionId(), false);
            setSucceeded(true);
        }
    }
"
1003,"Sure you shouldn't do this if the thread is visible? This way, the notification will not disappear when the thread is visible for some reason.","  public static void updateNotification(Context context, MasterSecret masterSecret, long threadId) {
    if (TextSecurePreferences.isNotificationsEnabled(context)) {
      if (visibleThread == threadId) {
        DatabaseFactory.getThreadDatabase(context).setRead(threadId);
        sendInThreadNotification(context);
      } else {
        updateNotification(context, masterSecret, true);
      }
    }

    updateBadge(context);
  }
","  public static void updateNotification(Context context, MasterSecret masterSecret, long threadId) {
    if (TextSecurePreferences.isNotificationsEnabled(context)) {
      if (visibleThread == threadId) {
        DatabaseFactory.getThreadDatabase(context).setRead(threadId);
        sendInThreadNotification(context);
      } else {
START         updateNotification(context, masterSecret, true); END 
      }
    }

    updateBadge(context);
  }
","  public static void updateNotification(Context context, MasterSecret masterSecret, long threadId) {
    if (!TextSecurePreferences.isNotificationsEnabled(context)) {
      return;
    }

    if (visibleThread == threadId) {
      DatabaseFactory.getThreadDatabase(context).setRead(threadId);
      sendInThreadNotification(context);
    } else {
      updateNotification(context, masterSecret, true);
    }
  }
"
1004,"not sure if makes sense, but instead of putting the `toString()` as values, I probably would use the Enum's `name() `method, as the `toString()` is usually been overridden...","    protected void fillOptions(Map<Enum, String> options) {
        options.put(EnumModel.VAL1,
                    EnumModel.VAL1.toString());
        options.put(EnumModel.VAL2,
                    EnumModel.VAL2.toString());
        options.put(EnumModel.VAL3,
                    EnumModel.VAL3.toString());
        options.put(EnumModel.VAL4,
                    EnumModel.VAL4.toString());
    }
","    protected void fillOptions(Map<Enum, String> options) {
        options.put(EnumModel.VAL1,
START                     EnumModel.VAL1.toString()); END 
        options.put(EnumModel.VAL2,
                    EnumModel.VAL2.toString());
        options.put(EnumModel.VAL3,
                    EnumModel.VAL3.toString());
        options.put(EnumModel.VAL4,
                    EnumModel.VAL4.toString());
    }
","    protected void fillOptions(Map<Enum, String> options) {
        options.put(EnumModel.VAL1,
                    EnumModel.VAL1.name());
        options.put(EnumModel.VAL2,
                    EnumModel.VAL2.name());
        options.put(EnumModel.VAL3,
                    EnumModel.VAL3.name());
        options.put(EnumModel.VAL4,
                    EnumModel.VAL4.name());
    }
"
1005,The same `Arrays.stream()` can be applied here as well.,"	public boolean removeQueues(Queue... queues) {
		removeQueues(Arrays.asList(queues)
				.stream()
				.map(Queue::getName));
		return super.removeQueues(queues);
	}
","	public boolean removeQueues(Queue... queues) {
START 		removeQueues(Arrays.asList(queues) END 
				.stream()
				.map(Queue::getName));
		return super.removeQueues(queues);
	}
","	public boolean removeQueues(Queue... queues) {
		removeQueues(Arrays.stream(queues)
				.map(Queue::getName));
		return super.removeQueues(queues);
	}
"
1006,String.valueOf(),"    private static Object castIntegerToObect(int value, Type type)
    {
        if (type == INTEGER || type == TINYINT || type == BIGINT) {
            return (long) value;
        }
        if (type == VARCHAR) {
            return value + """";
        }
        if (type == DOUBLE) {
            return (double) value;
        }
        throw new UnsupportedOperationException();
    }
","    private static Object castIntegerToObect(int value, Type type)
    {
        if (type == INTEGER || type == TINYINT || type == BIGINT) {
            return (long) value;
        }
        if (type == VARCHAR) {
START             return value + """"; END 
        }
        if (type == DOUBLE) {
            return (double) value;
        }
        throw new UnsupportedOperationException();
    }
","    private static Object castIntegerToObect(int value, Type type)
    {
        if (type == INTEGER || type == TINYINT || type == BIGINT) {
            return (long) value;
        }
        if (type == VARCHAR) {
            return String.valueOf(value);
        }
        if (type == DOUBLE) {
            return (double) value;
        }
        throw new UnsupportedOperationException();
    }
"
1007,"`stop()` should be in a finally block, or you could use `TestingUtil.withCacheManager()`.","   public void testXmlConfig() throws IOException {
      EmbeddedCacheManager cm = new DefaultCacheManager(""jpa-config.xml"");
      Cache<String, KeyValueEntity> specificCache = cm.getCache(""specificCache"");
      validateConfig(specificCache);
      KeyValueEntity entity = new KeyValueEntity(""k"", ""v"");
      specificCache.put(entity.getK(), entity);
      cm.stop();
   }
","   public void testXmlConfig() throws IOException {
      EmbeddedCacheManager cm = new DefaultCacheManager(""jpa-config.xml"");
      Cache<String, KeyValueEntity> specificCache = cm.getCache(""specificCache"");
      validateConfig(specificCache);
      KeyValueEntity entity = new KeyValueEntity(""k"", ""v"");
      specificCache.put(entity.getK(), entity);
START       cm.stop(); END 
   }
","   public void testXmlConfig() throws IOException {
      EmbeddedCacheManager cm = null;
      try {
         cm = new DefaultCacheManager(""jpa-config.xml"");
         Cache<String, KeyValueEntity> specificCache = cm.getCache(""specificCache"");
         validateConfig(specificCache);
         KeyValueEntity entity = new KeyValueEntity(""k"", ""v"");
         specificCache.put(entity.getK(), entity);
      } finally {
         if (cm != null)
            cm.stop();
      }
   }
"
1008,"Shouldn't this be SessionEditorInput? Here equals() can return true for instances of different subclasses of URIEditorInput which point to the same URI. I have not checked, but maybe  it happen could if have my aird opened at the same time inside a non-Sirius editor.","    public boolean equals(Object o) {
        boolean equals = this == o || o instanceof URIEditorInput && getURI().equals(((URIEditorInput) o).getURI());
        if (equals && o instanceof SessionEditorInput) {
            EObject input = getInput(false);
            if (input != null) {
                SessionEditorInput otherSessionEditorInput = (SessionEditorInput) o;
                return input.equals(otherSessionEditorInput.getInput(false));
            }
        }
        return equals;
    }
","    public boolean equals(Object o) {
        boolean equals = this == o || o instanceof START  URIEditorInput && END  getURI().equals(((URIEditorInput) o).getURI());
        if (equals && o instanceof SessionEditorInput) {
            EObject input = getInput(false);
            if (input != null) {
                SessionEditorInput otherSessionEditorInput = (SessionEditorInput) o;
                return input.equals(otherSessionEditorInput.getInput(false));
            }
        }
        return equals;
    }
","    public boolean equals(Object o) {
        boolean equals = this == o || o instanceof SessionEditorInput && getURI().equals(((SessionEditorInput) o).getURI());
        if (equals && o instanceof SessionEditorInput) {
            EObject input = getInput(false);
            if (input != null) {
                SessionEditorInput otherSessionEditorInput = (SessionEditorInput) o;
                return input.equals(otherSessionEditorInput.getInput(false));
            }
        }
        return equals;
    }
"
1009,This will cause creator to change on every update,"  private void loadChildEntities(LibraryDilution dilution) throws IOException {
    if (dilution.getLibrary() != null) {
      dilution.setLibrary(libraryDao.get(dilution.getLibrary().getId()));
    }
    if (dilution.getTargetedSequencing() != null) {
      dilution.setTargetedSequencing(targetedSequencingDao.get(dilution.getTargetedSequencing().getId()));
    }
    dilution.setDilutionCreator(authorizationManager.getCurrentUsername());
  }
","  private void loadChildEntities(LibraryDilution dilution) throws IOException {
    if (dilution.getLibrary() != null) {
      dilution.setLibrary(libraryDao.get(dilution.getLibrary().getId()));
    }
    if (dilution.getTargetedSequencing() != null) {
      dilution.setTargetedSequencing(targetedSequencingDao.get(dilution.getTargetedSequencing().getId()));
    }
START     dilution.setDilutionCreator(authorizationManager.getCurrentUsername()); END 
  }
","  private void loadChildEntities(LibraryDilution dilution) throws IOException {
    if (dilution.getLibrary() != null) {
      dilution.setLibrary(libraryDao.get(dilution.getLibrary().getId()));
    }
    if (dilution.getTargetedSequencing() != null) {
      dilution.setTargetedSequencing(targetedSequencingDao.get(dilution.getTargetedSequencing().getId()));
    }
  }
"
1010,No need to have the styleState variable at all.,"GdkColor getContextColor () {
	long /*int*/ fontHandle = fontHandle ();
	long /*int*/ context = OS.gtk_widget_get_style_context (fontHandle);
	GdkRGBA rgba = new GdkRGBA ();
	if (OS.GTK_VERSION < OS.VERSION(3, 18, 0)) {
		rgba = display.styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba);
	} else {
		int styleState = OS.gtk_widget_get_state_flags(handle);
		rgba = display.styleContextGetColor (context, styleState, rgba);
	}
	return display.toGdkColor (rgba);
}
","GdkColor getContextColor () {
	long /*int*/ fontHandle = fontHandle ();
	long /*int*/ context = OS.gtk_widget_get_style_context (fontHandle);
	GdkRGBA rgba = new GdkRGBA ();
	if (OS.GTK_VERSION < OS.VERSION(3, 18, 0)) {
		rgba = display.styleContextGetColor (context, OS.GTK_STATE_FLAG_NORMAL, rgba);
	} else {
START 		int styleState = OS.gtk_widget_get_state_flags(handle); END 
		rgba = display.styleContextGetColor (context, styleState, rgba);
	}
	return display.toGdkColor (rgba);
}
","GdkColor getContextColor () {
	long /*int*/ fontHandle = fontHandle ();
	long /*int*/ context = OS.gtk_widget_get_style_context (fontHandle);
	int styleState = OS.gtk_widget_get_state_flags(handle);
	GdkRGBA rgba = new GdkRGBA ();
	rgba = display.styleContextGetColor (context, styleState, rgba);
	return display.toGdkColor (rgba);
}
"
1011,These 2 can be called just once.,"        public Subquery parameter(String listId, Object... values) {
            if (values == null || values.length == 0 || values[0] == null) {
                return this;
            }
            where.setToNormal();
            where.setToIntersection();
            where.addParameter(listId, values);
            return this;
        }
","        public Subquery parameter(String listId, Object... values) {
            if (values == null || values.length == 0 || values[0] == null) {
                return this;
            }
            where.setToNormal();
            where.setToIntersection();
            where.addParameter(listId, values);
START             return this; END 
        }
","        public Subquery parameter(String listId, Object... values) {
            if (values == null || values.length == 0 || values[0] == null) {
                return this;
            }
            where.setToIntersection();
            where.addParameter(listId, values);
            return this;
        }
"
1012,Minor : parentheses are not needed,"    public int hashCode() {
        int result = (key ? 1 : 0);

        result = 31 * result + (path != null ? path.hashCode() : 0);

        return result;
    }
","    public int hashCode() {
START         int result = (key ? 1 : 0); END 

        result = 31 * result + (path != null ? path.hashCode() : 0);

        return result;
    }
","    public int hashCode() {
        int result = key ? 1 : 0;

        result = 31 * result + (path != null ? path.hashCode() : 0);

        return result;
    }
"
1013,Is this only used for logging?,"    public boolean doSynchronousPing() {
        MerlinLog.d(""Pinging : "" + hostAddress);
        try {
            int responseCode = responseCodeFetcher.from(hostAddress);
            MerlinLog.d(""Got response : "" + responseCode);
        } catch (RequestException e) {
            if (e.causedByIO()) {
                return false;
            }

            throw e;
        }
        return true;
    }
","    public boolean doSynchronousPing() {
        MerlinLog.d(""Pinging : "" + hostAddress);
        try {
START             int responseCode = responseCodeFetcher.from(hostAddress); END 
            MerlinLog.d(""Got response : "" + responseCode);
        } catch (RequestException e) {
            if (e.causedByIO()) {
                return false;
            }

            throw e;
        }
        return true;
    }
","    public boolean doSynchronousPing() {
        MerlinLog.d(""Pinging : "" + hostAddress);
        try {
            responseCodeFetcher.from(hostAddress);
        } catch (RequestException e) {
            if (e.causedByIO()) {
                return false;
            }

            throw e;
        }
        return true;
    }
"
1014,"Is that bug reported?  If not, it should be so we can track that it's getting fixed.  Also, ensure that the bug fix should be done in a separate commit from the new feature work for elemMatch (I didn't check).","    public T hasThisElement(final Object val) {
        Assert.parametersNotNull(""val"", val);
        return addCriteria(FilterOperator.ELEMENT_MATCH, val, not);
    }
","    public T hasThisElement(final Object val) {
        Assert.parametersNotNull(""val"", val);
START         return addCriteria(FilterOperator.ELEMENT_MATCH, val, not); END 
    }
","    public T hasThisElement(final Object val) {
        Assert.parametersNotNull(""val"", val);
        return addCriteria(FilterOperator.ELEMENT_MATCH, val, false);
    }
"
1015,"Since this class overrides the ```equals``` method, it also needs to override the ```hashCode``` method. Let me know if you have any questions on this.","        public Builder setSSHDirectory(final File sshDirectory) {
            this.sshDirectory = sshDirectory;
            return this;
        }
","        public Builder setSSHDirectory(final File sshDirectory) {
            this.sshDirectory = sshDirectory;
START             return this; END 
        }
","        public Builder setSSHDirectory(final File sshDirectory) {
            Assert.assertNotNull(sshDirectory);
            this.sshDirectory = sshDirectory;
            return this;
        }
"
1016,"I believe you want to add result into the ``attributes`` list. Also, what if required attributes of passed services overlap? We probably should gather them into the set before returning as list.","	public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Facility facility, Resource resource, User user, Member member) throws InternalErrorException, MemberResourceMismatchException {
		List<Attribute> attributes = new ArrayList<>();
		for (Service service : services) {
			getRequiredAttributes(sess, service, facility, resource, user, member);
		}
		return attributes;
	}
","	public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Facility facility, Resource resource, User user, Member member) throws InternalErrorException, MemberResourceMismatchException {
		List<Attribute> attributes = new ArrayList<>();
		for (Service service : services) {
START 			getRequiredAttributes(sess, service, facility, resource, user, member); END 
		}
		return attributes;
	}
","	public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Facility facility, Resource resource, User user, Member member) throws MemberResourceMismatchException {
		Set<Attribute> attributes = new HashSet<>();
		for (Service service : services) {
			attributes.addAll(getRequiredAttributes(sess, service, facility, resource, user, member));
		}
		return new ArrayList<>(attributes);
	}
"
1017,"parameter sequence swapped: max, min is correct.","  public void zrevrangeByScoreWithScores(final byte[] key, final double max, final double min,
      final int offset, final int count) {

    sendCommand(ZREVRANGEBYSCORE, key, toByteArray(min), toByteArray(max), LIMIT.raw, toByteArray(offset),
      toByteArray(count), WITHSCORES.raw);
  }
","  public void zrevrangeByScoreWithScores(final byte[] key, final double max, final double min,
      final int offset, final int count) {

START     sendCommand(ZREVRANGEBYSCORE, key, toByteArray(min), toByteArray(max), LIMIT.raw, toByteArray(offset), END 
      toByteArray(count), WITHSCORES.raw);
  }
","  public void zrevrangeByScoreWithScores(final byte[] key, final double max, final double min,
      final int offset, final int count) {

    sendCommand(ZREVRANGEBYSCORE, key, toByteArray(max), toByteArray(min), LIMIT.raw, toByteArray(offset),
      toByteArray(count), WITHSCORES.raw);
  }
"
1018,`write(mSingleCharWrite)`?,"  public void write(int b) throws IOException {
    mSingleCharWrite[0] = (byte) b;
    write(mSingleCharWrite, 0, 1);
  }
","  public void write(int b) throws IOException {
    mSingleCharWrite[0] = (byte) b;
START     write(mSingleCharWrite, 0, 1); END 
  }
","  public void write(int b) throws IOException {
    mSingleCharWrite[0] = (byte) b;
    write(mSingleCharWrite);
  }
"
1019,"this method expects flowId, netId as parameters. Be careful with the order!","	public void deallocateFlow(String flowId) throws FlowNotFoundException,
			ProvisionerException {

		try {

			String netId = getNetworkSelector().findNetworkForFlowId(flowId);
			getNclController().deallocateFlow(netId, flowId);

		} catch (Exception e) {
			throw new ProvisionerException(e);
		}
	}
","	public void deallocateFlow(String flowId) throws FlowNotFoundException,
			ProvisionerException {

		try {

			String netId = getNetworkSelector().findNetworkForFlowId(flowId);
START 			getNclController().deallocateFlow(netId, flowId); END 

		} catch (Exception e) {
			throw new ProvisionerException(e);
		}
	}
","	public void deallocateFlow(String flowId) throws FlowNotFoundException,
			ProvisionerException {

		try {

			String netId = getNetworkSelector().findNetworkForFlowId(flowId);
			getNclController().deallocateFlow(flowId, netId);

		} catch (Exception e) {
			throw new ProvisionerException(e);
		}
	}
"
1020,Perhaps in this case the best is to just rethrow the exception as a RuntimeException,"   private String _encode(String strVal) {
      try {
         return URLEncoder.encode(strVal, StandardCharsets.UTF_8.toString());
      } catch (UnsupportedEncodingException e) {
         return e.getMessage();
      }
   }
","   private String _encode(String strVal) {
      try {
         return URLEncoder.encode(strVal, StandardCharsets.UTF_8.toString());
      } catch (UnsupportedEncodingException e) {
START          return e.getMessage(); END 
      }
   }
","   private String _encode(String strVal) {
      try {
         return URLEncoder.encode(strVal, StandardCharsets.UTF_8.name());
      } catch (UnsupportedEncodingException e) {
         throw new RuntimeException(e);
      }
   }
"
1021,"if o is null, should no we just return false ?","      public boolean contains(Object o) {
         boolean contains = super.contains(o);
         if (!contains && o != null) {
            MarshalledEntry<K, V> me = persistenceManager.loadFromAllStores(o, true);
            contains = me != null;
         }
         return contains;
      }
","      public boolean contains(Object o) {
START          boolean contains = super.contains(o); END 
         if (!contains && o != null) {
            MarshalledEntry<K, V> me = persistenceManager.loadFromAllStores(o, true);
            contains = me != null;
         }
         return contains;
      }
","      public boolean contains(Object o) {
         boolean contains = false;
         if (o != null) {
            contains = super.contains(o);
            if (!contains) {
               MarshalledEntry<K, V> me = persistenceManager.loadFromAllStores(o, true);
               contains = me != null;
            }
         }
         return contains;
      }
"
1022,The cast should not be removed to avoid compilation errors on Eclipse versions which do not have the generified getAdapter.,"    public boolean provides(IOperation operation) {
        if (!(operation instanceof CreateDecoratorsOperation)) {
            return false;
        }
        IDecoratorTarget decoratorTarget = ((CreateDecoratorsOperation) operation).getDecoratorTarget();
        View view = decoratorTarget.getAdapter(View.class);
        return view != null && DDiagramEditPart.MODEL_ID.equals(SiriusVisualIDRegistry.getModelID(view));
    }
","    public boolean provides(IOperation operation) {
        if (!(operation instanceof CreateDecoratorsOperation)) {
            return false;
        }
        IDecoratorTarget decoratorTarget = ((CreateDecoratorsOperation) operation).getDecoratorTarget();
START         View view = decoratorTarget.getAdapter(View.class); END 
        return view != null && DDiagramEditPart.MODEL_ID.equals(SiriusVisualIDRegistry.getModelID(view));
    }
","    public boolean provides(IOperation operation) {
        if (!(operation instanceof CreateDecoratorsOperation)) {
            return false;
        }
        IDecoratorTarget decoratorTarget = ((CreateDecoratorsOperation) operation).getDecoratorTarget();
        View view = (View) decoratorTarget.getAdapter(View.class);
        return view != null && DDiagramEditPart.MODEL_ID.equals(SiriusVisualIDRegistry.getModelID(view));
    }
"
1023,remove extra line,"  public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert() {
    CuratedContentPageObject ccp = new CuratedContentPageObject(driver);
    wikiURL = urlBuilder.getUrlForWiki(MercuryWikis.MERCURY_CC);
    ccp.openMercuryArticleByNameWithNoCacheBuster(wikiURL, MercurySubpages.CC_MAIN_PAGE);

    MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject(
        driver, Mercury.AlertMessage.NOT_EXISTING_CATEGORY);


    String oldUrl = driver.getCurrentUrl();
    ccp.clickOnCuratedContentElementByIndex(2);
    Assertion.assertTrue(mercuryAlert.isAlertMessageVisible());
    ccp.waitForLoadingSpinnerToFinish();
    Assertion.assertUrlEqualToCurrentUrl(driver, oldUrl);
  }
","  public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert() {
    CuratedContentPageObject ccp = new CuratedContentPageObject(driver);
    wikiURL = urlBuilder.getUrlForWiki(MercuryWikis.MERCURY_CC);
    ccp.openMercuryArticleByNameWithNoCacheBuster(wikiURL, MercurySubpages.CC_MAIN_PAGE);

    MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject(
        driver, Mercury.AlertMessage.NOT_EXISTING_CATEGORY);

START  END 
    String oldUrl = driver.getCurrentUrl();
    ccp.clickOnCuratedContentElementByIndex(2);
    Assertion.assertTrue(mercuryAlert.isAlertMessageVisible());
    ccp.waitForLoadingSpinnerToFinish();
    Assertion.assertUrlEqualToCurrentUrl(driver, oldUrl);
  }
","  public void MercuryCuratedMainPageTest_006_CheckWrongCategoryAlert() {
    CuratedContentPageObject ccp = new CuratedContentPageObject(driver);
    wikiURL = urlBuilder.getUrlForWiki(MercuryWikis.MERCURY_CC);
    ccp.openMercuryArticleByNameWithNoCacheBuster(wikiURL, MercurySubpages.CC_MAIN_PAGE);

    MercuryAlertComponentObject mercuryAlert = new MercuryAlertComponentObject(
        driver, MercuryAlertComponentObject.AlertMessage.NOT_EXISTING_CATEGORY);

    String oldUrl = driver.getCurrentUrl();
    ccp.clickOnCuratedContentElementByIndex(2);
    Assertion.assertTrue(mercuryAlert.isAlertMessageVisible());

    ccp.waitForLoadingSpinnerToFinish();
    Assertion.assertUrlEqualToCurrentUrl(driver, oldUrl);
  }
"
1024,"I would use a couple of assert equals since they give better output in case of failure.

(Remember that the expected value should be the first one)","    private void testUpdateInterface(Guid interface_id) {
        VdsNetworkInterface iface = dao.get(interface_id);

        iface.setName(iface.getName().toUpperCase());
        iface.setQos(newQos);

        dao.updateInterfaceForVds(iface);

        VdsNetworkInterface ifaced = dao.get(interface_id);
        assertTrue(ifaced.getName().equals(iface.getName()) && ifaced.getQos().equals(iface.getQos()));
    }
","    private void testUpdateInterface(Guid interface_id) {
        VdsNetworkInterface iface = dao.get(interface_id);

        iface.setName(iface.getName().toUpperCase());
        iface.setQos(newQos);

        dao.updateInterfaceForVds(iface);

        VdsNetworkInterface ifaced = dao.get(interface_id);
START         assertTrue(ifaced.getName().equals(iface.getName()) && ifaced.getQos().equals(iface.getQos())); END 
    }
","    private void testUpdateInterface(Guid interface_id) {
        VdsNetworkInterface iface = dao.get(interface_id);

        iface.setName(iface.getName().toUpperCase());
        iface.setQos(newQos);

        dao.updateInterfaceForVds(iface);

        VdsNetworkInterface ifaced = dao.get(interface_id);
        assertEquals(iface.getName(), ifaced.getName());
        assertEquals(iface.getQos(), ifaced.getQos());
    }
"
1025,"Shouldn't this be done before the patientProgram is saved, instead of after?","	public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException {
		
                if (patientProgram.getPatientProgramId() == null) {
			sessionFactory.getCurrentSession().save(patientProgram);
		} else {
			sessionFactory.getCurrentSession().merge(patientProgram);
		}
                
                CustomDatatypeUtil.saveAttributesIfNecessary(patientProgram);
		return patientProgram;
	}
","	public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException {
		
                if (patientProgram.getPatientProgramId() == null) {
			sessionFactory.getCurrentSession().save(patientProgram);
		} else {
			sessionFactory.getCurrentSession().merge(patientProgram);
		}
                
START                 CustomDatatypeUtil.saveAttributesIfNecessary(patientProgram); END 
		return patientProgram;
	}
","	public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException {
                CustomDatatypeUtil.saveAttributesIfNecessary(patientProgram);

                if (patientProgram.getPatientProgramId() == null) {
			sessionFactory.getCurrentSession().save(patientProgram);
		} else {
			sessionFactory.getCurrentSession().merge(patientProgram);
		}
                
		return patientProgram;
	}
"
1026,"Does `unwrapApi` not work for some reason? Just curious...it would make a nice example of the new call, that's why I ask...","   public UploadDirectoryToCDN(String username, String apiKey) {
      Iterable<Module> modules = ImmutableSet.<Module> of(new SLF4JLoggingModule());
      
      BlobStoreContext context = ContextBuilder.newBuilder(PROVIDER)
            .credentials(username, apiKey)
            .modules(modules)
            .buildView(BlobStoreContext.class);
      storage = context.getBlobStore();
      rackspace = context.unwrap(CloudFilesApiMetadata.CONTEXT_TOKEN).getApi();
   }
","   public UploadDirectoryToCDN(String username, String apiKey) {
      Iterable<Module> modules = ImmutableSet.<Module> of(new SLF4JLoggingModule());
      
      BlobStoreContext context = ContextBuilder.newBuilder(PROVIDER)
            .credentials(username, apiKey)
            .modules(modules)
            .buildView(BlobStoreContext.class);
      storage = context.getBlobStore();
START       rackspace = context.unwrap(CloudFilesApiMetadata.CONTEXT_TOKEN).getApi(); END 
   }
","   public UploadDirectoryToCDN(String username, String apiKey) {
      BlobStoreContext context = ContextBuilder.newBuilder(PROVIDER)
            .credentials(username, apiKey)
            .buildView(BlobStoreContext.class);
      storage = context.getBlobStore();
      rackspace = context.unwrap(CloudFilesApiMetadata.CONTEXT_TOKEN).getApi(); // can use unwrapApi() in jclouds 1.7.0
   }
"
1027,"The `forServer == false` flow looks wrong. If `null` is passed, then `KeyManagerFactoryWrapper` will throw (and we probably want the `keyManagerFactory` to be `null` in that case).","    public SslContextBuilder keyManager(KeyManager keyManager) {
        if (forServer) {
            checkNotNull(keyManager, ""keyManager required for servers"");
        }
        this.keyManagerFactory = new KeyManagerFactoryWrapper(keyManager);
        keyCertChain = null;
        key = null;
        keyPassword = null;
        return this;
    }
","    public SslContextBuilder keyManager(KeyManager keyManager) {
START         if (forServer) { END 
            checkNotNull(keyManager, ""keyManager required for servers"");
        }
        this.keyManagerFactory = new KeyManagerFactoryWrapper(keyManager);
        keyCertChain = null;
        key = null;
        keyPassword = null;
        return this;
    }
","    public SslContextBuilder keyManager(KeyManager keyManager) {
        if (forServer) {
            checkNotNull(keyManager, ""keyManager required for servers"");
        }
        if (keyManager != null) {
            this.keyManagerFactory = new KeyManagerFactoryWrapper(keyManager);
        } else {
            this.keyManagerFactory = null;
        }
        keyCertChain = null;
        key = null;
        keyPassword = null;
        return this;
    }
"
1028,"Should this be protected, or do we really want to allow to call it outside this class?","		public boolean isTypeSupported(Class<T> clazz) {
			// TODO: Add other types? Float, etc
			if (String.class.isAssignableFrom(clazz) || 
					Integer.class.isAssignableFrom(clazz) || 
					Boolean.class.isAssignableFrom(clazz)) 
			{
				return true;
			}
			return false;
		}
","START 		public boolean isTypeSupported(Class<T> clazz) { END 
			// TODO: Add other types? Float, etc
			if (String.class.isAssignableFrom(clazz) || 
					Integer.class.isAssignableFrom(clazz) || 
					Boolean.class.isAssignableFrom(clazz)) 
			{
				return true;
			}
			return false;
		}
","		protected boolean isTypeSupported(Class<T> clazz) {
			// TODO: Add other types? Float, etc
			if (String.class.isAssignableFrom(clazz) || 
					Integer.class.isAssignableFrom(clazz) || 
					Boolean.class.isAssignableFrom(clazz)) 
			{
				return true;
			}
			return false;
		}
"
1029,Replace Boris?,"	private List<Person>  createModel() {
		List<Person> elements = new ArrayList<Person>(4);
		elements.add(new Person(""Tom"", ""Schindl"",
				""tom.schindl@bestsolution.at""));
		elements.add(new Person(""Boris"", ""Bokowski"",
				""Boris_Bokowski@ca.ibm.com""));
		elements.add(new Person(""Tod"", ""Creasey"", ""Tod_Creasey@ca.ibm.com""));
		elements.add(new Person(""Wayne"", ""Beaton"", ""wayne@eclipse.org""));

		return elements;

	}
","	private List<Person>  createModel() {
		List<Person> elements = new ArrayList<Person>(4);
		elements.add(new Person(""Tom"", ""Schindl"",
				""tom.schindl@bestsolution.at""));
		elements.add(new Person(""Boris"", ""Bokowski"",
START 				""Boris_Bokowski@ca.ibm.com"")); END 
		elements.add(new Person(""Tod"", ""Creasey"", ""Tod_Creasey@ca.ibm.com""));
		elements.add(new Person(""Wayne"", ""Beaton"", ""wayne@eclipse.org""));

		return elements;

	}
","	private List<Person>  createModel() {
		List<Person> elements = new ArrayList<Person>(4);
		elements.add(new Person(""Tom"", ""Schindl"",
				""tom.schindl@bestsolution.at""));
		elements.add(new Person(""Tod"", ""Creasey"", ""Tod_Creasey@ca.ibm.com""));
		elements.add(new Person(""Wayne"", ""Beaton"", ""wayne@eclipse.org""));

		return elements;

	}
"
1030,maybe better to separate the incerement and then check,"    protected void updateIteration() {
        refreshIteration =  refreshIteration++ % NUMBER_VMS_REFRESHES_BEFORE_SAVE;
    }
","    protected void updateIteration() {
START         refreshIteration =  refreshIteration++ % NUMBER_VMS_REFRESHES_BEFORE_SAVE; END 
    }
","    protected void updateIteration() {
        refreshIteration =  (++refreshIteration) % NUMBER_VMS_REFRESHES_BEFORE_SAVE;
    }
"
1031,you can do fListeners.forEach() directly on Collections,"    public void add(E newInterval) {
        super.add(newInterval);
        fListeners.stream().forEach(l -> l.elementAdded(this, newInterval));
    }
","    public void add(E newInterval) {
        super.add(newInterval);
START         fListeners.stream().forEach(l -> l.elementAdded(this, newInterval)); END 
    }
","    public void add(E newInterval) {
        super.add(newInterval);
    }
"
1032,`new ArrayList<String>();` -> `new ArrayList<>();`,"    public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) {
        this.docsToCheckAndEvents = docsToCheckAndEvents;
        List<String> docs = new ArrayList<String>();
        docs.addAll(docsToCheckAndEvents.keySet());
        setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs);
    }
","    public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) {
        this.docsToCheckAndEvents = docsToCheckAndEvents;
START         List<String> docs = new ArrayList<String>(); END 
        docs.addAll(docsToCheckAndEvents.keySet());
        setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs);
    }
","    public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) {
        this.docsToCheckAndEvents = docsToCheckAndEvents;
        List<String> docs = new ArrayList<>();
        docs.addAll(docsToCheckAndEvents.keySet());
        setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs);
    }
"
1033,alias variable is redundant,"  private static String getTestingAlias(GoImportSpec testingImportSpec) {
    String alias = GoConstants.TESTING_PATH;
    if (testingImportSpec != null) {
      alias = !testingImportSpec.isDot() ? StringUtil.notNullize(testingImportSpec.getAlias(), GoConstants.TESTING_PATH) : """";
    }
    return alias;
  }
","  private static String getTestingAlias(GoImportSpec testingImportSpec) {
    String alias = GoConstants.TESTING_PATH;
START     if (testingImportSpec != null) { END 
      alias = !testingImportSpec.isDot() ? StringUtil.notNullize(testingImportSpec.getAlias(), GoConstants.TESTING_PATH) : """";
    }
    return alias;
  }
","  private static String getTestingAlias(GoImportSpec testingImportSpec) {
    return testingImportSpec == null ? GoConstants.TESTING_PATH :
           !testingImportSpec.isDot() ? StringUtil.notNullize(testingImportSpec.getAlias(), GoConstants.TESTING_PATH) : """";
  }
"
1034,"This should be using `super(source);` instead of the populate method (I know it was like this in `ComplianceStatusDTO`, and it is wrong there too).","    public SystemPurposeComplianceStatusDTO(SystemPurposeComplianceStatusDTO source) {
        this.populate(source);
    }
","    public SystemPurposeComplianceStatusDTO(SystemPurposeComplianceStatusDTO source) {
START         this.populate(source); END 
    }
","    public SystemPurposeComplianceStatusDTO(SystemPurposeComplianceStatusDTO source) {
        super(source);
    }
"
1035,"We create a new map-operation for every call, so moving `evictions` here doesn't make any difference.","    public MapOperation() {
        final ILogger logger = this.logger();
        final int forcedEvictionRetryCount = getRetryCount();

        evictions = new Eviction[]{
            new RecordStoreForcedEviction(forcedEvictionRetryCount, logger, this),
            new PartitionRecordStoreForcedEviction(forcedEvictionRetryCount, logger, this),
            new AllEntriesEviction(logger, this),
            new PartitionAllEntriesEviction(logger, this)
        };
    }
","    public MapOperation() {
        final ILogger logger = this.logger();
        final int forcedEvictionRetryCount = getRetryCount();

        evictions = new Eviction[]{
            new RecordStoreForcedEviction(forcedEvictionRetryCount, logger, this),
            new PartitionRecordStoreForcedEviction(forcedEvictionRetryCount, logger, this),
            new AllEntriesEviction(logger, this),
START             new PartitionAllEntriesEviction(logger, this) END 
        };
    }
","    public MapOperation() {
    }
"
1036,"We do not use single line if-statements throughout the project. Yes it's a nitty point, but I'd prefer you change it to curly braces.","        private static Instant retrieveDeadlineTimestamp(JobDataMap jobDataMap) {
            Object timestamp = jobDataMap.get(MESSAGE_TIMESTAMP);
            if (timestamp instanceof String) return Instant.parse(timestamp.toString());
            return Instant.ofEpochMilli((long) timestamp);
        }
","        private static Instant retrieveDeadlineTimestamp(JobDataMap jobDataMap) {
            Object timestamp = jobDataMap.get(MESSAGE_TIMESTAMP);
START             if (timestamp instanceof String) return Instant.parse(timestamp.toString()); END 
            return Instant.ofEpochMilli((long) timestamp);
        }
","        private static Instant retrieveDeadlineTimestamp(JobDataMap jobDataMap) {
            Object timestamp = jobDataMap.get(MESSAGE_TIMESTAMP);
            if (timestamp instanceof String) {
                return Instant.parse(timestamp.toString());
            }
            return Instant.ofEpochMilli((long) timestamp);
        }
"
1037,"Do all of these getters need to be public ? I think except `getBytesInMemory()`, others can be default package access.","  public AggregatorFactory[] getMetrics()
  {
    return metrics;
  }
","START   public AggregatorFactory[] getMetrics() END 
  {
    return metrics;
  }
","  AggregatorFactory[] getMetrics()
  {
    return metrics;
  }
"
1038,"```suggestion
```

Please don't add tables that are not used. Wastes CPU cycles.","    public void prepare() throws IOException {
        e = SQLExecutor.builder(clusterService)
            .enableDefaultTables()
            .addTable(""create table t ("" +
                      ""     id integer primary key,"" +
                      ""     qty integer constraint check_qty_gt_zero check (qty > 0),"" +
                      ""     constraint check_id_ge_zero check (id >= 0)"" +
                      "")"")
            .build();
        plannerContext = e.getPlannerContext(clusterService.state());
    }
","    public void prepare() throws IOException {
        e = SQLExecutor.builder(clusterService)
START             .enableDefaultTables() END 
            .addTable(""create table t ("" +
                      ""     id integer primary key,"" +
                      ""     qty integer constraint check_qty_gt_zero check (qty > 0),"" +
                      ""     constraint check_id_ge_zero check (id >= 0)"" +
                      "")"")
            .build();
        plannerContext = e.getPlannerContext(clusterService.state());
    }
","    public void prepare() throws IOException {
        e = SQLExecutor.builder(clusterService)
            .addTable(""create table t ("" +
                      ""     id integer primary key,"" +
                      ""     qty integer constraint check_qty_gt_zero check (qty > 0),"" +
                      ""     constraint check_id_ge_zero check (id >= 0)"" +
                      "")"")
            .build();
        plannerContext = e.getPlannerContext(clusterService.state());
    }
"
1039,"In JUnit4-style tests, you can assign variables where they are defined (and make them final if you want :-). JUnit4 won't create an instance of the class until just before it is run, and it will make it eligible for garbage collection right after it is run.","    public void setUp() {
        jUnitCore = new JUnitCore();
        testListener = new TestListener();

        jUnitCore.addListener(testListener);
    }
","    public void setUp() {
START         jUnitCore = new JUnitCore(); END 
        testListener = new TestListener();

        jUnitCore.addListener(testListener);
    }
","    public void setUp() {
        jUnitCore.addListener(testListener);
    }
"
1040,"I tend to agree. I mean the validator should not be used in other places, as its name indicates, but several times we extended the use of validators in the past so it may be the better approach to simplify its instantiation","    protected boolean validate() {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }

        if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), ""clusterId"", getVm().getStatus())) {
            addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }

        ChangeVmClusterValidator validator = Injector.injectMembers(new ChangeVmClusterValidator(this,
                getParameters().getClusterId(),
                getParameters().getVmCustomCompatibilityVersion(),
                getVmDeviceUtils()));
        return validator.validate();
    }
","    protected boolean validate() {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }

        if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), ""clusterId"", getVm().getStatus())) {
            addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }

START         ChangeVmClusterValidator validator = Injector.injectMembers(new ChangeVmClusterValidator(this, END 
                getParameters().getClusterId(),
                getParameters().getVmCustomCompatibilityVersion(),
                getVmDeviceUtils()));
        return validator.validate();
    }
","    protected boolean validate() {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }

        if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), ""clusterId"", getVm().getStatus())) {
            addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }

        ChangeVmClusterValidator validator = ChangeVmClusterValidator.create(this,
                getParameters().getClusterId(),
                getParameters().getVmCustomCompatibilityVersion());
        return validator.validate();
    }
"
1041,"I would prefer this code to be done in the `KeyStoreHelper` constructor and keep a `Map<String, TrustManagerFactory >` so can be detected at this moment and this is also like how we do for the SNI key manager mapping.","  public TrustManagerFactory getTrustMgr(String serverName)  {
    try {
      KeyStore trustStore = trustMgrMap.get(serverName);
      if (trustStore != null) {
        TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        fact.init(trustStore);
        return fact;
      }
      return null;
    } catch (NoSuchAlgorithmException | KeyStoreException e) {
      throw new RuntimeException(e);
    }
  }
","  public TrustManagerFactory getTrustMgr(String serverName)  {
    try {
START       KeyStore trustStore = trustMgrMap.get(serverName); END 
      if (trustStore != null) {
        TrustManagerFactory fact = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        fact.init(trustStore);
        return fact;
      }
      return null;
    } catch (NoSuchAlgorithmException | KeyStoreException e) {
      throw new RuntimeException(e);
    }
  }
","  public TrustManagerFactory getTrustMgr(String serverName) {
    return trustMgrMap.get(serverName);
  }
"
1042,I suggest putting this into a finally block.,"	public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) {
		boolean tmp = this.isInModuleInfo;
		this.isInModuleInfo = true;
		TextEdit edit = format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator);
		this.isInModuleInfo = tmp;
		return edit;
	}
","	public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) {
		boolean tmp = this.isInModuleInfo;
		this.isInModuleInfo = true;
		TextEdit edit = format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator);
START 		this.isInModuleInfo = tmp; END 
		return edit;
	}
","	public TextEdit formatModuleInfoFile(int kind, String source, int offset, int length, int indentationLevel, String lineSeparator) {
		boolean tmp = this.isInModuleInfo;
		try {
			this.isInModuleInfo = true;
			return format(kind, source, new IRegion[] { new Region(offset, length) }, indentationLevel, lineSeparator);
		} finally {
			this.isInModuleInfo = tmp;
		}
	}
"
1043,Should this become a property?,"	public <K, V> RemoteCache<K, V> getCache(String cacheName) {
		RemoteCache<K,V> cache = hotrodClient.getCache( cacheName, TransactionMode.NONE );
		if ( cache == null ) {
			throw log.expectedCachesNotDefined( Collections.singleton( cacheName ) );
		}
		return cache;
	}
","	public <K, V> RemoteCache<K, V> getCache(String cacheName) {
START 		RemoteCache<K,V> cache = hotrodClient.getCache( cacheName, TransactionMode.NONE ); END 
		if ( cache == null ) {
			throw log.expectedCachesNotDefined( Collections.singleton( cacheName ) );
		}
		return cache;
	}
","	public <K, V> RemoteCache<K, V> getCache(String cacheName) {
		RemoteCache<K,V> cache = hotrodClient.getCache( cacheName );
		if ( cache == null ) {
			throw log.expectedCachesNotDefined( Collections.singleton( cacheName ) );
		}
		return cache;
	}
"
1044,"do we allow `type == null`?
It doesn't make sense to me to take a value without type info.
probably add a precondition check to forbid that.","    public static Object valueForStringWithType(String value, VoltType type) {
        if (type == null || type == VoltType.NULL) {
            return null;
        }

        // leverage existing (rather heavyweight) code to convert param types
        Object retval = ParameterConverter.tryToMakeCompatible(type.classFromType(), value);
        // check the result type in an assert
        assert(ParameterConverter.verifyParameterConversion(retval, type.classFromType()));
        return retval;
    }
","    public static Object valueForStringWithType(String value, VoltType type) {
START         if (type == null || type == VoltType.NULL) { END 
            return null;
        }

        // leverage existing (rather heavyweight) code to convert param types
        Object retval = ParameterConverter.tryToMakeCompatible(type.classFromType(), value);
        // check the result type in an assert
        assert(ParameterConverter.verifyParameterConversion(retval, type.classFromType()));
        return retval;
    }
","    public static Object valueForStringWithType(String value, VoltType type) {
        if (type == VoltType.NULL) {
            return null;
        }

        // leverage existing (rather heavyweight) code to convert param types
        Object retval = ParameterConverter.tryToMakeCompatible(type.classFromType(), value);
        // check the result type in an assert
        assert(ParameterConverter.verifyParameterConversion(retval, type.classFromType()));
        return retval;
    }
"
1045,doppelt?,"    public void testContructor() throws IOException
    {
        String code = ""S2020-04-04"";
        ReportingPeriod period = ReportingPeriod.from(code);

        assertEquals(period.getClass(), SinceX.class);
        assertEquals(period.getClass(), SinceX.class);
    }
","    public void testContructor() throws IOException
    {
        String code = ""S2020-04-04"";
        ReportingPeriod period = ReportingPeriod.from(code);

        assertEquals(period.getClass(), SinceX.class);
START         assertEquals(period.getClass(), SinceX.class); END 
    }
","    public void testContructor() throws IOException
    {
        String code = ""S2020-04-04"";
        ReportingPeriod period = ReportingPeriod.from(code);

        assertEquals(period.getClass(), SinceX.class);
    }
"
1046,please user assertEquals,"    public void testGetConnectableFileStorageConnectionsByStorageType() {
        List<StorageServerConnections> conns =
                dao.getConnectableStorageConnectionsByStorageType(FixturesTool.STORAGE_POOL_NFS_2, StorageType.NFS);

        assertNotNull(conns);
        assertEquals(1, conns.size());

        for (StorageServerConnections conn : conns) {
            assertTrue(conn.getstorage_type() == StorageType.NFS);
        }
    }
","    public void testGetConnectableFileStorageConnectionsByStorageType() {
        List<StorageServerConnections> conns =
                dao.getConnectableStorageConnectionsByStorageType(FixturesTool.STORAGE_POOL_NFS_2, StorageType.NFS);

        assertNotNull(conns);
        assertEquals(1, conns.size());

        for (StorageServerConnections conn : conns) {
START             assertTrue(conn.getstorage_type() == StorageType.NFS); END 
        }
    }
","    public void testGetConnectableFileStorageConnectionsByStorageType() {
        List<StorageServerConnections> conns =
                dao.getConnectableStorageConnectionsByStorageType(FixturesTool.STORAGE_POOL_NFS_2, StorageType.NFS);

        assertNotNull(conns);
        assertEquals(1, conns.size());

        for (StorageServerConnections conn : conns) {
            assertEquals(StorageType.NFS, conn.getstorage_type());
        }
    }
"
1047,path,"    public static void setOverrideFileName(String... path) {
        fOverridePath = (path == null) ? null : path;
        fOverride = true;
    }
","    public static void setOverrideFileName(String... path) {
        fOverridePath = START  (path == null) ? null : path; END 
        fOverride = true;
    }
","    public static void setOverrideFileName(String... path) {
        fOverridePath = path;
        fOverride = true;
    }
"
1048,Small style nit: We don't use braces around simple statements.,"	void addChanges(Collection<String> filesToUpdate,
			Collection<IResource> resourcesToUpdate) {
		synchronized (lock) {
			files.addAll(filesToUpdate);
			resources.addAll(resourcesToUpdate);
		}
		if (!filesToUpdate.isEmpty()) {
			schedule(defaultDelay);
		}
	}
","	void addChanges(Collection<String> filesToUpdate,
			Collection<IResource> resourcesToUpdate) {
		synchronized (lock) {
			files.addAll(filesToUpdate);
			resources.addAll(resourcesToUpdate);
		}
START 		if (!filesToUpdate.isEmpty()) { END 
			schedule(defaultDelay);
		}
	}
","	void addChanges(Collection<String> filesToUpdate,
			Collection<IResource> resourcesToUpdate) {
		synchronized (lock) {
			files.addAll(filesToUpdate);
			resources.addAll(resourcesToUpdate);
		}
		if (!filesToUpdate.isEmpty())
			schedule(defaultDelay);
	}
"
1049,Why not use name as the key in CACHED_ENCRYPTION_KEYS?,"    public static synchronized String getEncryptionKey(String name) {
        final String keyString = getUniqueId(name);
        if (CACHED_ENCRYPTION_KEYS.get(keyString) == null) {
            generateEncryptionKey(keyString);
        }
        return CACHED_ENCRYPTION_KEYS.get(keyString);
    }
","    public static synchronized String getEncryptionKey(String name) {
START         final String keyString = getUniqueId(name); END 
        if (CACHED_ENCRYPTION_KEYS.get(keyString) == null) {
            generateEncryptionKey(keyString);
        }
        return CACHED_ENCRYPTION_KEYS.get(keyString);
    }
","    public static synchronized String getEncryptionKey(String name) {
        if (CACHED_ENCRYPTION_KEYS.get(name) == null) {
            generateEncryptionKey(name);
        }
        return CACHED_ENCRYPTION_KEYS.get(name);
    }
"
1050,That would case the page loading to fail. The exception should be removed from GerritUtil.toReview() instead.,"	public void init(IEditorSite site, IEditorInput input) {
		super.init(site, input);
		TaskData taskData = getModel().getTaskData();
		if (taskData != null) {
			GerritChange change = GerritUtil.getChange(taskData);
			final ChangeDetailX detail = change.getChangeDetail();
			try {
				review = GerritUtil.toReview(detail);
			} catch (GerritException e) {
				throw new RuntimeException(e);
			}
		}
	}
","	public void init(IEditorSite site, IEditorInput input) {
		super.init(site, input);
		TaskData taskData = getModel().getTaskData();
		if (taskData != null) {
			GerritChange change = GerritUtil.getChange(taskData);
			final ChangeDetailX detail = change.getChangeDetail();
			try {
				review = GerritUtil.toReview(detail);
			} catch (GerritException e) {
START 				throw new RuntimeException(e); END 
			}
		}
	}
","	public void init(IEditorSite site, IEditorInput input) {
		super.init(site, input);
		TaskData taskData = getModel().getTaskData();
		if (taskData != null) {
			GerritChange change = GerritUtil.getChange(taskData);
			final ChangeDetailX detail = change.getChangeDetail();
			review = GerritUtil.toReview(detail);
		}
	}
"
1051,This will create a new object every time the method is called. Is this wanted? If not it'd be better to store the object once and always return it (static field).,"    public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException {
        return new SnapshotInfo(EMPTY_STRING);
    }
","    public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException {
START         return new SnapshotInfo(EMPTY_STRING); END 
    }
","    public ISnapshotInfo getSnapshotInfo(String sessionName, IProgressMonitor monitor) throws ExecutionException {
        return null;
    }
"
1052,"headSet(Object,boolean) is a Java 6 API.  We need to define cutOff as super.getEntryLastModified() - 1 instead.","	public long getEntryLastModified() {
		if (modTimes == null)
			return 0;
		Long cutOff = Long.valueOf(super.getEntryLastModified());
		SortedSet<Long> head = modTimes.headSet(cutOff, true);
		return head.isEmpty() ? 0 : head.last().longValue();
	}
","	public long getEntryLastModified() {
		if (modTimes == null)
			return 0;
		Long cutOff = Long.valueOf(super.getEntryLastModified());
START 		SortedSet<Long> head = modTimes.headSet(cutOff, true); END 
		return head.isEmpty() ? 0 : head.last().longValue();
	}
","	public long getEntryLastModified() {
		if (modTimes == null)
			return 0;
		Long cutOff = Long.valueOf(super.getEntryLastModified() + 1);
		SortedSet<Long> head = modTimes.headSet(cutOff);
		return head.isEmpty() ? 0 : head.last().longValue();
	}
"
1053,"Initialization of the list should use generics. For this case, you can specify an empty generic-type placeholder and the compiler should be able to auto-detect what type should be used.","        public ParameterizedSqlFactory(String initialSql) {
            sqlStringBuilder = new StringBuilder(initialSql);
            parameters = new ArrayList();
        }
","        public ParameterizedSqlFactory(String initialSql) {
            sqlStringBuilder = new StringBuilder(initialSql);
START             parameters = new ArrayList(); END 
        }
","        public ParameterizedSqlFactory(String initialSql) {
            sqlStringBuilder = new StringBuilder(initialSql);
            parameters = new ArrayList<>();
        }
"
1054,Is this needed? What throws NumberFormatException?,"  public long getReadyTimestamp(Constraints viewConstraints) {
    String normalizedConstraints = getNormalizedConstraints(viewConstraints);

    Path signalPath = new Path(signalDirectory, normalizedConstraints);
    // check if the signal exists
    try {
      try {
        FileStatus signalStatus = rootFileSystem.getFileStatus(signalPath);
        return signalStatus.getModificationTime();
      } catch (final FileNotFoundException ex) {
        // empty, will be thrown when the signal path doesn't exist
      }
      return -1;
    } catch (NumberFormatException e) {
      throw new DatasetException(""Signal contents were modified to not be a number: ""
                                   + signalPath, e);
    } catch (IOException e) {
      throw new DatasetIOException(""Could not access signal path: "" + signalPath, e);
    }
  }
","  public long getReadyTimestamp(Constraints viewConstraints) {
    String normalizedConstraints = getNormalizedConstraints(viewConstraints);

    Path signalPath = new Path(signalDirectory, normalizedConstraints);
    // check if the signal exists
    try {
      try {
        FileStatus signalStatus = rootFileSystem.getFileStatus(signalPath);
        return signalStatus.getModificationTime();
      } catch (final FileNotFoundException ex) {
        // empty, will be thrown when the signal path doesn't exist
      }
      return -1;
START     } catch (NumberFormatException e) { END 
      throw new DatasetException(""Signal contents were modified to not be a number: ""
                                   + signalPath, e);
    } catch (IOException e) {
      throw new DatasetIOException(""Could not access signal path: "" + signalPath, e);
    }
  }
","  public long getReadyTimestamp(Constraints viewConstraints) {
    String normalizedConstraints = getNormalizedConstraints(viewConstraints);

    Path signalPath = new Path(signalDirectory, normalizedConstraints);
    // check if the signal exists
    try {
      try {
        FileStatus signalStatus = rootFileSystem.getFileStatus(signalPath);
        return signalStatus.getModificationTime();
      } catch (final FileNotFoundException ex) {
        // empty, will be thrown when the signal path doesn't exist
      }
      return -1;
    } catch (IOException e) {
      throw new DatasetIOException(""Could not access signal path: "" + signalPath, e);
    }
  }
"
1055,"Use equals instead of '==' as follows (And do the same for the 2 other conditions):
ArchitectureType.ppc64.equals(archType);","    private boolean hostHasPpcArchitecture() {
        Cluster cluster = getModel().getSelectedCluster();

        if (cluster == null) {
            return false;
        }

        ArchitectureType archType = cluster.getArchitecture();
        return (archType == ArchitectureType.ppc64) || (archType == ArchitectureType.ppc64le) || (archType == ArchitectureType.ppcle);

    }
","    private boolean hostHasPpcArchitecture() {
        Cluster cluster = getModel().getSelectedCluster();

        if (cluster == null) {
            return false;
        }

        ArchitectureType archType = cluster.getArchitecture();
        return START (archType == ArchitectureType.ppc64) || END  (archType == ArchitectureType.ppc64le) || (archType == ArchitectureType.ppcle);

    }
","    private boolean hostHasPpcArchitecture() {
        Cluster cluster = getModel().getSelectedCluster();

        if (cluster == null) {
            return false;
        }

        ArchitectureType archType = cluster.getArchitecture();
        return ArchitectureType.ppc64.equals(archType) || ArchitectureType.ppc64le.equals(archType) || ArchitectureType.ppcle.equals(archType);
    }
"
1056,name.substring(ext) is equivalent and shorter to write.,"  private static String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext, name.length()) : """";
  }
","  private static String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? START  name.substring(ext, name.length()) : END  """";
  }
","  private static String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext) : """";
  }
"
1057,more consistent to make this a no-op like other methods,"  public void checkpoint() {
    throw new UnsupportedOperationException(""Checkpoint is not supported in NoopJournalSystem"");
  }
","  public void checkpoint() {
START     throw new UnsupportedOperationException(""Checkpoint is not supported in NoopJournalSystem""); END 
  }
","  public void checkpoint() {}
"
1058,macToLong returns 'long',"    private void recalculateMacsCount() {
        if (!validate()) {
            setAvailableMacsCount(-1);
            return;
        }

        if (macRange.getMacPoolId() == null) {
            String from = getLeftBound().getEntity();
            String to = getRightBound().getEntity();
            Long count = MacRangeValidation.macToLong(to) - MacRangeValidation.macToLong(from) + 1;
            setAvailableMacsCount(count.intValue());
        }
    }
","    private void recalculateMacsCount() {
        if (!validate()) {
            setAvailableMacsCount(-1);
            return;
        }

        if (macRange.getMacPoolId() == null) {
            String from = getLeftBound().getEntity();
            String to = getRightBound().getEntity();
            START  Long count END  = MacRangeValidation.macToLong(to) - MacRangeValidation.macToLong(from) + 1;
            setAvailableMacsCount(count.intValue());
        }
    }
","    private void recalculateMacsCount() {
        if (!validate()) {
            setAvailableMacsCount(-1);
            return;
        }

        if (macRange.getMacPoolId() == null) {
            String from = getLeftBound().getEntity();
            String to = getRightBound().getEntity();
            long count = MacRangeValidation.macToLong(to) - MacRangeValidation.macToLong(from) + 1;
            setAvailableMacsCount((int) count);
        }
    }
"
1059,Is this cast necessary?,"    public void setup() {
        buffer = (DiskBuffer) new DiskBuffer(BUFFER_DIR, maxEvents);
    }
","    public void setup() {
START         buffer = (DiskBuffer) new DiskBuffer(BUFFER_DIR, maxEvents); END 
    }
","    public void setup() {
        buffer = new DiskBuffer(BUFFER_DIR, maxEvents);
    }
"
1060,It would make sense to check minimum values as well.,"    private boolean filterInvalid(Position position) {
        return filterInvalid && !position.getValid() || position.getLatitude() > 90 || position.getLongitude() > 180;
    }
","    private boolean filterInvalid(Position position) {
START         return filterInvalid && !position.getValid() || position.getLatitude() > 90 || position.getLongitude() > 180; END 
    }
","    private boolean filterInvalid(Position position) {
        if (filterInvalid == true) {
           return !position.getValid() || position.getLatitude() > 90
           || position.getLongitude() > 180 || position.getLatitude() < -90
           || position.getLongitude() < -180;
        }
        return false;
    }
"
1061,"Understood.  

IntelliJ does however suggest this small change:

        return new HashSet<Location>(
                asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE, Location.TYPE));","    public Set<Location> getAllowedLocations() {
        Set<Location> allowedLocations = new HashSet<Location>();
        allowedLocations.addAll(Arrays.asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE,
                Location.TYPE));
        return allowedLocations;
    }
","    public Set<Location> getAllowedLocations() {
        Set<Location> allowedLocations = new HashSet<Location>();
        allowedLocations.addAll(Arrays.asList(Location.CONSTRUCTOR, Location.METHOD, Location.FIELD, Location.OVERVIEW, Location.PACKAGE,
                Location.TYPE));
START         return allowedLocations; END 
    }
","    public Set<Location> getAllowedLocations() {
        return new HashSet<Location>(asList(CONSTRUCTOR, METHOD, FIELD, OVERVIEW, PACKAGE, TYPE));
    }
"
1062,getTaskJsonString() 是否可以改成 static method,"	public String getTasksJsonString(long taskId) throws JSONException {
		TaskObject task = TaskObject.get(taskId);
		return new ConvertSprintBacklog().getTaskJsonString(task);
	}
","	public String getTasksJsonString(long taskId) throws JSONException {
		TaskObject task = TaskObject.get(taskId);
START 		return new ConvertSprintBacklog().getTaskJsonString(task); END 
	}
","	public String getTasksJsonString(long taskId) throws JSONException {
		TaskObject task = TaskObject.get(taskId);
		return ConvertSprintBacklog.getTaskJsonString(task);
	}
"
1063,"no need explicitly open transaction, only one save to DB, transaction will be open automaticly","    private void addVolumeToDb(final GlusterVolumeEntity createdVolume) {
        TransactionSupport.executeInNewTransaction(
                new TransactionMethod<Void>() {
                    @Override
                    public Void runInTransaction() {
                        // volume fetched from VDSM doesn't contain cluster id GlusterFS
                        // is not aware of multiple clusters
                        createdVolume.setClusterId(getVdsGroupId());
                        DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume);
                        return null;
                    }
                });
    }
","START     private void addVolumeToDb(final GlusterVolumeEntity createdVolume) { END 
        TransactionSupport.executeInNewTransaction(
                new TransactionMethod<Void>() {
                    @Override
                    public Void runInTransaction() {
                        // volume fetched from VDSM doesn't contain cluster id GlusterFS
                        // is not aware of multiple clusters
                        createdVolume.setClusterId(getVdsGroupId());
                        DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume);
                        return null;
                    }
                });
    }
","    private void addVolumeToDb(final GlusterVolumeEntity createdVolume) {
        // volume fetched from VDSM doesn't contain cluster id GlusterFS
        // is not aware of multiple clusters
        createdVolume.setClusterId(getVdsGroupId());
        DbFacade.getInstance().getGlusterVolumeDao().save(createdVolume);
    }
"
1064,"It seems this have added a new import: org.jfree.util.Log, why not use the same log object as line 204? log.error(""Workbook creation exception"", e); ? Is there a reason behind using 2 different ways of logging errors?","    public Sheet getDataSheet(File file) {
        stream = new PushbackInputStream(new FileInputStream(file));
        Workbook wb = null;
        try {
            wb = WorkbookFactory.create(stream);
        } catch (Exception e) {
            Log.error(""Workbook creation exception:"" + e);
        }
        return wb.getSheetAt(0);
    }
","    public Sheet getDataSheet(File file) {
        stream = new PushbackInputStream(new FileInputStream(file));
        Workbook wb = null;
        try {
            wb = WorkbookFactory.create(stream);
        } catch (Exception e) {
START             Log.error(""Workbook creation exception:"" + e); END 
        }
        return wb.getSheetAt(0);
    }
","    public Sheet getDataSheet(File file) {
        Workbook wb = null;
        try {
            stream = new PushbackInputStream(new FileInputStream(file));
            wb = WorkbookFactory.create(stream);
        } catch (Exception e) {
            log.error(""Workbook creation exception:"" + e);
        }
        return wb.getSheetAt(0);
    }
"
1065,"That's not much different than the current `getProcess(int processID)` except with an optional rather than null.  (And the API for that is fixed so we can't change it.)  

That's not the problem I'm discussing... the problem is that someone writing `new OSProcess(1234)` will definitely get a Process object unless we throw an exception.  We could throw an `InstantiationError`, for example, and require them to handle it.  Or a `MissingResourceException`. Or return a class with the pid and essentially zero data.  Perhaps I should have thought about this dilemma before suggesting the feature!","    public void updateAttributes() {
        OperatingSystem operatingSystem = getCurrentOperatingSystem();
        if (operatingSystem != null) {
            OSProcess process = operatingSystem.getProcess(this.processID);
            if (process != null) {
                copyValuesToThisProcess(process);
            } else {
                LOG.error(""No process found: {}"", this.processID);
            }
        } else {
            LOG.error(""Unsupported platform. No update performed."");
        }
    }
","    public void updateAttributes() {
        OperatingSystem operatingSystem = getCurrentOperatingSystem();
        if (operatingSystem != null) {
            OSProcess process = operatingSystem.getProcess(this.processID);
            if (process != null) {
                copyValuesToThisProcess(process);
            } else {
START                 LOG.error(""No process found: {}"", this.processID); END 
            }
        } else {
            LOG.error(""Unsupported platform. No update performed."");
        }
    }
","    public boolean updateAttributes() {
        OSProcess process = operatingSystem.getProcess(this.processID);
        if (process == null) {
            LOG.debug(""No process found: {}"", this.processID);
            return false;
        }
        copyValuesToThisProcess(process);
        return true;
    }
"
1066,avoid using this in these cases.,"    public boolean isMissingHookConflict() {
        return (this.conflictStatus & MISSING_HOOK.getValue()) == MISSING_HOOK.getValue();
    }
","    public boolean isMissingHookConflict() {
START         return (this.conflictStatus & MISSING_HOOK.getValue()) == MISSING_HOOK.getValue(); END 
    }
","    public boolean isMissingHookConflict() {
        return (conflictStatus & MISSING_HOOK.getValue()) == MISSING_HOOK.getValue();
    }
"
1067,"Nit: My pref would be to eliminate the unneeded elses (117,120) since there are returns.","  public Map<AccountGroup.UUID, GroupMembersList> getUnresolvedGroups(
      final boolean recursive) {
    if (!recursive) {
      if (isResolved()) {
        return Collections.emptyMap();
      } else {
        return Collections.singletonMap(getGroup().getGroupUUID(), this);
      }
    } else {
      return getAllUnresolvedGroups(new HashSet<AccountGroup.Id>());
    }
  }
","  public Map<AccountGroup.UUID, GroupMembersList> getUnresolvedGroups(
      final boolean recursive) {
    if (!recursive) {
      if (isResolved()) {
        return Collections.emptyMap();
START       } else { END 
        return Collections.singletonMap(getGroup().getGroupUUID(), this);
      }
    } else {
      return getAllUnresolvedGroups(new HashSet<AccountGroup.Id>());
    }
  }
","  public Map<AccountGroup.UUID, GroupMembersList> getUnresolvedGroups(
      final boolean recursive) {
    if (!recursive) {
      if (isResolved()) {
        return Collections.emptyMap();
      }
      return Collections.singletonMap(getGroup().getGroupUUID(), this);
    }
    return getAllUnresolvedGroups(new HashSet<AccountGroup.Id>());
  }
"
1068,Can you use `parser.getCurrentToken()` to detect JSON type ?,"  public boolean nextBoolean() throws IOException {
    requirePeek();
    boolean value;
    try {
      value = parser.getBooleanValue();
    } catch (JsonParseException e) {
      value = Boolean.parseBoolean(parser.getValueAsString());
    }
    clearPeek();
    return value;
  }
","  public boolean nextBoolean() throws IOException {
    requirePeek();
    boolean value;
    try {
START       value = parser.getBooleanValue(); END 
    } catch (JsonParseException e) {
      value = Boolean.parseBoolean(parser.getValueAsString());
    }
    clearPeek();
    return value;
  }
","  public boolean nextBoolean() throws IOException {
    requirePeek();
    boolean value = parser.getBooleanValue();
    clearPeek();
    return value;
  }
"
1069,why are all methods public except this one ?,"    boolean closeOnProtocolViolation() {
        return closeOnProtocolViolation;
    }
","START     boolean closeOnProtocolViolation() { END 
        return closeOnProtocolViolation;
    }
","    public boolean closeOnProtocolViolation() {
        return closeOnProtocolViolation;
    }
"
1070,"This should be done using the EnumTranslator. For example, see VmGeneralModel - > updateProperties(). In addition, add the appropriate values to LocalizedEnums.java an LocalizedEnums.properties.","    public String getSelinuxEnforceMode() {
        if (selinuxEnforceMode == null) {
            // Nothing
        } else if (selinuxEnforceMode.equals(SELinuxMode.DISABLED)) {
            return constants.disabled();
        } else if (selinuxEnforceMode.equals(SELinuxMode.PERMISSIVE)) {
            return constants.permissive();
        } else if (selinuxEnforceMode .equals(SELinuxMode.ENFORCING)) {
            return constants.enforcing();
        }
        return constants.notAvailableLabel();
    }
","START     public String getSelinuxEnforceMode() { END 
        if (selinuxEnforceMode == null) {
            // Nothing
        } else if (selinuxEnforceMode.equals(SELinuxMode.DISABLED)) {
            return constants.disabled();
        } else if (selinuxEnforceMode.equals(SELinuxMode.PERMISSIVE)) {
            return constants.permissive();
        } else if (selinuxEnforceMode .equals(SELinuxMode.ENFORCING)) {
            return constants.enforcing();
        }
        return constants.notAvailableLabel();
    }
","    public String getSelinuxEnforceMode() {
        return selinuxEnforceMode;
    }
"
1071,Sounds like you forgot to remove this one,"    public void startThreads()
    {
        if (!this.threadStarted) {
            synchronized (this) {
                if (!this.threadStarted) {
                    int nbThreads = this.configuration.getProperty(""mentions.poolSize"", 1);
                    for (int i = 0; i < nbThreads; i++) {
                        startConsumer();
                    }
                    this.threadStarted = true;
                }
            }
        }
    }
","    public void startThreads()
    {
START         if (!this.threadStarted) { END 
            synchronized (this) {
                if (!this.threadStarted) {
                    int nbThreads = this.configuration.getProperty(""mentions.poolSize"", 1);
                    for (int i = 0; i < nbThreads; i++) {
                        startConsumer();
                    }
                    this.threadStarted = true;
                }
            }
        }
    }
","    public void startThreads()
    {
        synchronized (this) {
            if (!this.threadStarted) {
                int nbThreads = this.configuration.getProperty(""mentions.poolSize"", 1);
                for (int i = 0; i < nbThreads; i++) {
                    startConsumer();
                }
                this.threadStarted = true;
            }
        }
    }
"
1072,"Why do you perform this test on FeaturesProvider's class?
This really looks strange and I do not see how this relates to the goal of this commit...","	public void init(EObject original, EditingDomain editingDomain) {
		List<EStructuralFeature> features = featuresProvider
				.getFeatures(original);

		initControlFactory(editingDomain, original);

		for (final EStructuralFeature feature : features) {
			if(!featuresProvider.getClass().equals(FeaturesProvider.class) || isToBeRendered(feature) ){
				createControlForFeature(feature);
			}
		}

		// toolkit.paintBordersFor(main);

		this.layout();
	}
","	public void init(EObject original, EditingDomain editingDomain) {
		List<EStructuralFeature> features = featuresProvider
				.getFeatures(original);

		initControlFactory(editingDomain, original);

		for (final EStructuralFeature feature : features) {
START 			if(!featuresProvider.getClass().equals(FeaturesProvider.class) || isToBeRendered(feature) ){ END 
				createControlForFeature(feature);
			}
		}

		// toolkit.paintBordersFor(main);

		this.layout();
	}
","	public void init(EObject original, EditingDomain editingDomain) {
		List<EStructuralFeature> features = featuresProvider
				.getFeatures(original);

		initControlFactory(editingDomain, original);

		for (final EStructuralFeature feature : features) {
			createControlForFeature(feature);
		}

		// toolkit.paintBordersFor(main);

		this.layout();
	}
"
1073,"I think you can return Arrays.asList(...) directly, no need to create wrap that in ArrayList.","    public List<Annotation> getQualifiers() {
        return new ArrayList<Annotation>(
                Arrays.asList(new org.jboss.arquillian.warp.servlet.AfterServlet() {
                        @Override
                        public Class<? extends Annotation> annotationType () {
                            return org.jboss.arquillian.warp.servlet.AfterServlet.class;
                        }
                    }
                )
        );

    }
","    public List<Annotation> getQualifiers() {
        return new ArrayList<Annotation>(
START                 Arrays.asList(new org.jboss.arquillian.warp.servlet.AfterServlet() { END 
                        @Override
                        public Class<? extends Annotation> annotationType () {
                            return org.jboss.arquillian.warp.servlet.AfterServlet.class;
                        }
                    }
                )
        );

    }
","    public List<Annotation> getQualifiers() {
        return Arrays.asList((Annotation) new org.jboss.arquillian.warp.servlet.AfterServlet() {
                        @Override
                        public Class<? extends Annotation> annotationType () {
                            return org.jboss.arquillian.warp.servlet.AfterServlet.class;
                        }
                    }
        );

    }
"
1074,"It should not be necessary to crate the RemoteCacheManager in a PrivligedAction. Only the GSSAPI mech requires a Subject to initialize the SASL client, and that should be passed in by the configuration","   protected void initialize(Subject subj) throws PrivilegedActionException {
      final Configuration config = getRemoteCacheManagerConfig(subj);
      Subject.doAs(subj, new PrivilegedExceptionAction<Void>() {
         public Void run() throws Exception {
            remoteCacheManager = new RemoteCacheManager(config, true);
            return null;
         }
      });
      remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME);
   }
","   protected void initialize(Subject subj) throws PrivilegedActionException {
      final Configuration config = getRemoteCacheManagerConfig(subj);
START       Subject.doAs(subj, new PrivilegedExceptionAction<Void>() { END 
         public Void run() throws Exception {
            remoteCacheManager = new RemoteCacheManager(config, true);
            return null;
         }
      });
      remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME);
   }
","   protected void initialize(Subject subj) throws PrivilegedActionException {
      final Configuration config = getRemoteCacheManagerConfig(subj);
      remoteCacheManager = new RemoteCacheManager(config, true);
      remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME);
   }
"
1075,"Shouldn't this copy in `baseSelectors`? I know it it currently empty, but the code implies you want to add another selector to the base selectors.","	LauncherDiscoveryRequest buildRequest(Bundle bundle) {
		List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1);
		selectors.add(BundleSelector.selectBundle(bundle));
		return LauncherDiscoveryRequestBuilder.request()
			.configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved)
			.selectors(selectors)
			.build();
	}
","START 	LauncherDiscoveryRequest buildRequest(Bundle bundle) { END 
		List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1);
		selectors.add(BundleSelector.selectBundle(bundle));
		return LauncherDiscoveryRequestBuilder.request()
			.configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved)
			.selectors(selectors)
			.build();
	}
","	LauncherDiscoveryRequest buildRequest(Bundle bundle) {
		List<DiscoverySelector> selectors = new ArrayList<>(baseSelectors.size() + 1);
		selectors.addAll(baseSelectors);
		selectors.add(BundleSelector.selectBundle(bundle));
		return LauncherDiscoveryRequestBuilder.request()
			.configurationParameter(BundleEngine.CHECK_UNRESOLVED, unresolved)
			.selectors(selectors)
			.build();
	}
"
1076,"there are some concerns in this file. I can see you are doing some defensive code, but possibly there are ways to do this in less code. for example, if your before and after blocks did the defense, the delegation methods would not need to.","    protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) {

        super.statementExecuteUpdateBefore(statement,sql);

        try {
            Before(statement,sql);
        }catch (Exception e){

        }


    }
","    protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) {

        super.statementExecuteUpdateBefore(statement,sql);

START         try { END 
            Before(statement,sql);
        }catch (Exception e){

        }


    }
","    protected void statementExecuteUpdateBefore(StatementProxy statement, String sql) {

        super.statementExecuteUpdateBefore(statement,sql);

        Before(statement,sql);

    }
"
1077,nit: merge lines,"    public static DecoderResult failure(Throwable cause) {
        ObjectUtil.checkNotNull(cause, ""cause"");
        return new DecoderResult(cause);
    }
","    public static DecoderResult failure(Throwable cause) {
        ObjectUtil.checkNotNull(cause, ""cause"");
START         return new DecoderResult(cause); END 
    }
","    public static DecoderResult failure(Throwable cause) {
        return new DecoderResult(ObjectUtil.checkNotNull(cause, ""cause""));
    }
"
1078,Why 5? Just use the default unless there's a good reason not to.,"  private void writeObject(Schema schema, GenericRecord datum) throws Exception {
    BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(5), null);
    GenericDatumWriter<GenericData.Record> writter = new GenericDatumWriter<GenericData.Record>(schema);
    writter.write(schema, datum, encoder);
  }
","  private void writeObject(Schema schema, GenericRecord datum) throws Exception {
START     BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(5), null); END 
    GenericDatumWriter<GenericData.Record> writter = new GenericDatumWriter<GenericData.Record>(schema);
    writter.write(schema, datum, encoder);
  }
","  private void writeObject(Schema schema, GenericRecord datum) throws Exception {
    BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(), null);
    GenericDatumWriter<GenericData.Record> writer = new GenericDatumWriter<GenericData.Record>(schema);
    writer.write(schema, datum, encoder);
  }
"
1079,"Sorry--what I meant before was to just build and return the collection on _every_ invocation, rather than storing it in a field.

There's only one place calling this method now, so the caching doesn't buy us anything.","    public Collection<String> getNames() {
        if (names == null) {
            names = new HashSet<>(named.keySet());
            namedArgumentFinder.forEach(args -> names.addAll(args.getNames()));
        }
        return Collections.unmodifiableSet(names);
    }
","    public Collection<String> getNames() {
        if (names == null) {
START             names = new HashSet<>(named.keySet()); END 
            namedArgumentFinder.forEach(args -> names.addAll(args.getNames()));
        }
        return Collections.unmodifiableSet(names);
    }
","    public Collection<String> getNames() {
        final Set<String> names = new HashSet<>(named.keySet());
        namedArgumentFinder.forEach(args -> names.addAll(args.getNames()));
        return Collections.unmodifiableSet(names);
    }
"
1080,"Hmmm. I'm thinking we might want to turn this into a logger.warning instead. I'd use the error only if the program cannot proceed, while in this case the consumer code is responsible for reacting to a null return: this particular piece of code can cope perfectly well with it.","    public FBOConfig getFboConfig(ResourceUrn fboName) {
        FBOConfig fboConfig = fboConfigs.get(fboName);

        if (fboConfig == null) {
            logger.error(""Failed to retrieve FBOConfig '"" + fboName + ""'!"");
        }

        return fboConfig;
    }
","    public FBOConfig getFboConfig(ResourceUrn fboName) {
        FBOConfig fboConfig = fboConfigs.get(fboName);

        if (fboConfig == null) {
START             logger.error(""Failed to retrieve FBOConfig '"" + fboName + ""'!""); END 
        }

        return fboConfig;
    }
","    public FBOConfig getFboConfig(ResourceUrn fboName) {
        FBOConfig fboConfig = fboConfigs.get(fboName);

        if (fboConfig == null) {
            logger.warn(""Failed to retrieve FBOConfig '"" + fboName + ""'!"");
        }

        return fboConfig;
    }
"
1081,"This is technically an API violation, although I can't find any usages. Probably an IDE recommendation? I don't think it is needed so we could swap it back to remain in compliance

(to clarify see the surrounding diff since this preview gets confused)","    void setKey(Input newInput, char newKeyChar) {
        this.input = newInput;
        this.keyChar = newKeyChar;
    }
","START     void setKey(Input newInput, char newKeyChar) { END 
        this.input = newInput;
        this.keyChar = newKeyChar;
    }
","    protected void setKey(Input newInput, char newKeyChar) {
        this.input = newInput;
        this.keyChar = newKeyChar;
    }
"
1082,"This doesn't seem right, the call to org.infinispan.configuration.cache.EvictionConfigurationBuilder#strategy(org.infinispan.eviction.EvictionStrategy) is missing completely, thus the default strategy will always be NONE.","    public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException {
        EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class);
        if (strategy.isEnabled()) {
            this.builder.type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong());
        }
        return this;
    }
","    public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException {
        EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class);
        if (strategy.isEnabled()) {
            this.builder.type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong());
START         } END 
        return this;
    }
","    public Builder<EvictionConfiguration> configure(OperationContext context, ModelNode model) throws OperationFailedException {
        EvictionStrategy strategy = ModelNodes.asEnum(STRATEGY.getDefinition().resolveModelAttribute(context, model), EvictionStrategy.class);
        this.builder.strategy(strategy);
        if (strategy.isEnabled()) {
            this.builder.type(EvictionType.COUNT).size(MAX_ENTRIES.getDefinition().resolveModelAttribute(context, model).asLong());
        }
        return this;
    }
"
1083,`CompletableFuture<Boolean>` to avoid raw types,"    public void closed( BoltConnection connection )
    {
        String id = connection.id();

        try
        {
            CompletableFuture currentFuture = activeWorkItems.remove( id );
            if ( currentFuture != null )
            {
                currentFuture.cancel( true );
            }
        }
        finally
        {
            activeConnections.remove( id );
        }
    }
","    public void closed( BoltConnection connection )
    {
        String id = connection.id();

        try
        {
START             CompletableFuture currentFuture = activeWorkItems.remove( id ); END 
            if ( currentFuture != null )
            {
                currentFuture.cancel( true );
            }
        }
        finally
        {
            activeConnections.remove( id );
        }
    }
","    public void closed( BoltConnection connection )
    {
        String id = connection.id();

        try
        {
            CompletableFuture<Boolean> currentFuture = activeWorkItems.remove( id );
            if ( currentFuture != null )
            {
                currentFuture.cancel( true );
            }
        }
        finally
        {
            activeConnections.remove( id );
        }
    }
"
1084,"https://i0.wp.com/100happybirthdaymemes.com/wp-content/uploads/2016/06/grumpy-cat-no-4.jpg

In other words: throw the exception upwards and fail the test if parsing the XML fails.","    public void testIsExternalVM() throws IOException {
        try {
            XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
            assertFalse(""VM should not be external VM"", OvfUtils.isExternalVM(xmlDocument));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
","    public void testIsExternalVM() throws IOException {
        try {
            XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
            assertFalse(""VM should not be external VM"", OvfUtils.isExternalVM(xmlDocument));
        START  } catch (Exception e) {
            e.printStackTrace();
        } END 
    }
","    public void testIsExternalVM() throws Exception {
        XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
        assertFalse(""VM should not be external VM"", OvfUtils.isExternalVM(xmlDocument));
    }
"
1085,Fix formatting. Run formatter phase in maven. fileList==null doesnt do anything here since folder.isDirectory is checked above and listFiles returns null only if the File is not a directory. It will return empty if the directory doesn't contain any files,"	public static boolean folderContains(File folder, String filename) {
		if (folder == null) {
			return false;
		}
		if (!folder.isDirectory()) {
			return false;
		}
		
        File[] fileList = folder.listFiles();
        if (fileList == null) {
            return false;
        }
		for (File f : fileList) {
			if (f.getName().equals(filename)) {
				return true;
			}
		}
		return false;
	}
","	public static boolean folderContains(File folder, String filename) {
		if (folder == null) {
			return false;
		}
		if (!folder.isDirectory()) {
			return false;
		}
		
START         File[] fileList = folder.listFiles(); END 
        if (fileList == null) {
            return false;
        }
		for (File f : fileList) {
			if (f.getName().equals(filename)) {
				return true;
			}
		}
		return false;
	}
","	public static boolean folderContains(File folder, String filename) {
		if (folder == null) {
			return false;
		}
		
        	File[] fileList = folder.listFiles();
        	if (fileList == null) {
            		return false;
        	}
		for (File f : fileList) {
			if (f.getName().equals(filename)) {
				return true;
			}
		}
		return false;
	}
"
1086,"`Collections.addAll(whiteListPatterns, patterns)` can be used here.","	public void addWhiteListPatterns(String... patterns) {
		this.whiteListPatterns.addAll(Arrays.asList(patterns));
	}
","	public void addWhiteListPatterns(String... patterns) {
START 		this.whiteListPatterns.addAll(Arrays.asList(patterns)); END 
	}
","	public void addWhiteListPatterns(String... patterns) {
		Collections.addAll(this.whiteListPatterns, patterns);
	}
"
1087,I think that this check can be avoided as we already check if auth != null below,"    private Long getRegistrationMillis(String playerName) {
        if (!isRegistered(playerName.toLowerCase())) {
            return null;
        }
        PlayerAuth auth = playerCache.getAuth(playerName);
        if (auth == null) {
            auth = dataSource.getAuth(playerName);
        }
        if (auth != null) {
            return auth.getRegistrationDate();
        }
        return null;
    }
","    private Long getRegistrationMillis(String playerName) {
START         if (!isRegistered(playerName.toLowerCase())) { END 
            return null;
        }
        PlayerAuth auth = playerCache.getAuth(playerName);
        if (auth == null) {
            auth = dataSource.getAuth(playerName);
        }
        if (auth != null) {
            return auth.getRegistrationDate();
        }
        return null;
    }
","    private Long getRegistrationMillis(String playerName) {
        PlayerAuth auth = playerCache.getAuth(playerName);
        if (auth == null) {
            auth = dataSource.getAuth(playerName);
        }
        if (auth != null) {
            return auth.getRegistrationDate();
        }
        return null;
    }
"
1088,typo: capacityFactor instead of numSegments,"   public HashConfigurationBuilder capacityFactor(float capacityFactor) {
      if (numSegments < 0) throw new IllegalArgumentException(""capacityFactor must be positive"");
      this.capacityFactor = capacityFactor;
      return this;
   }
","   public HashConfigurationBuilder capacityFactor(float capacityFactor) {
START       if (numSegments < 0) throw new IllegalArgumentException(""capacityFactor must be positive""); END 
      this.capacityFactor = capacityFactor;
      return this;
   }
","   public HashConfigurationBuilder capacityFactor(float capacityFactor) {
      if (capacityFactor < 0) throw new IllegalArgumentException(""capacityFactor must be positive"");
      this.capacityFactor = capacityFactor;
      return this;
   }
"
1089,This is not needed here,"        public synchronized void onHeaders(Response response)
        {
            long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString());
            if (length > maxLength) {
                response.abort(new ResponseTooLargeException());
            }
            allocateCurrentArray();
        }
","        public synchronized void onHeaders(Response response)
        {
            long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString());
            if (length > maxLength) {
                response.abort(new ResponseTooLargeException());
            }
START             allocateCurrentArray(); END 
        }
","        public synchronized void onHeaders(Response response)
        {
            long length = response.getHeaders().getLongField(HttpHeader.CONTENT_LENGTH.asString());
            if (length > maxLength) {
                response.abort(new ResponseTooLargeException());
            }
        }
"
1090,The return statement can never throw an exception here. So please remove the try-catch block.,"    public WorkspaceItem build() {
        try {
            return workspaceItem;
        } catch (Exception e) {
            return handleException(e);
        }
    }
","    public WorkspaceItem build() {
        try {
            return workspaceItem;
START         } catch (Exception e) { END 
            return handleException(e);
        }
    }
","    public WorkspaceItem build() {
            return workspaceItem;
    }
"
1091,Why sorted map? TreeMap is sorted already?!,"    public static SortedMap<String, Charset> requiredCharsets() {
        return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS);
    }
","START     public static SortedMap<String, Charset> requiredCharsets() { END 
        return Collections.unmodifiableSortedMap(REQUIRED_CHARSETS);
    }
","    public static SortedMap<String, Charset> requiredCharsets() {
        return REQUIRED_CHARSETS;
    }
"
1092,[minor] Split into two asserts or add a message showing what the offending value actually is?,"   protected void checkProject(Project project) {
      assertNotNull(project.getId());
      assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString());
      assertTrue(project.getState() != null && project.getState() != Project.State.UNRECOGNIZED);
   }
","   protected void checkProject(Project project) {
      assertNotNull(project.getId());
      assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString());
START       assertTrue(project.getState() != null && project.getState() != Project.State.UNRECOGNIZED); END 
   }
","   protected void checkProject(Project project) {
      assertNotNull(project.getId());
      assertEquals(project.toString(), client.getProjectApi().getProject(project.getId()).toString());
      assertTrue(project.getState() != null);
      assertTrue(project.getState() != Project.State.UNRECOGNIZED);
   }
"
1093,Please call ArtifactToken constructors without guid.,"   public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) {
      super(id, GUID.create(), name, CoreBranches.COMMON, artifactType);
   }
","   public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) {
START       super(id, GUID.create(), name, CoreBranches.COMMON, artifactType); END 
   }
","   public AtsProgramArtifactToken(Long id, String name, ArtifactTypeToken artifactType) {
      super(id, name, CoreBranches.COMMON, artifactType);
   }
"
1094,I think the deprecate is sufficient.  Why also log a warning?,"    public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) {
        LOG.warning(""Setting useBulkWriteOperations has no value functionally or performance-wise."");
    }
","    public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) {
START         LOG.warning(""Setting useBulkWriteOperations has no value functionally or performance-wise.""); END 
    }
","    public void setUseBulkWriteOperations(final boolean useBulkWriteOperations) {
    }
"
1095,When will this be false?,"    public void setActionConfirmationMessage(String message) {
        boolean isNonEmptyMessage = message != null;
        if (isNonEmptyMessage) {
            actionConfirmationMessage.setText(message);
        }
        actionConfirmationMessage.setVisible(isNonEmptyMessage);
    }
","    public void setActionConfirmationMessage(String message) {
        boolean isNonEmptyMessage = message != null;
        if START (isNonEmptyMessage) { END 
            actionConfirmationMessage.setText(message);
        }
        actionConfirmationMessage.setVisible(isNonEmptyMessage);
    }
","    public void setActionConfirmationMessage(String message) {
        boolean isNonEmptyMessage = message != null;
        if (isNonEmptyMessage) {
            actionConfirmationMessage.setText(message);
        }
    }
"
1096,the second parameter can be removed,"  public void close() throws InterruptedException {
    close(false, false);
  }
","  public void close() throws InterruptedException {
START     close(false, false); END 
  }
","  public void close() throws InterruptedException {
    close(false);
  }
"
1097,This class has a member variable called `indent` which will incur a data race in `recursivelyPrint`.  This is easily fixable though by just making `indent` a parameter to `recursivelyPrint`.  I realize it's debug-only code.,"    protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb)
    {
        for (int i = 0; i < indent; i++) {
            sb.append(""\t"");
        }
        sb.append(node.toJSONString() + ""\n"");
        indent++;
        if (node.getChildCount() > 0) {
            recursivelyPrint(node.getChild(0), sb);
        }
    }
","    protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb)
    {
        for (int i = 0; i < indent; i++) {
            sb.append(""\t"");
        }
        sb.append(node.toJSONString() + ""\n"");
        indent++;
        if (node.getChildCount() > 0) {
            recursivelyPrint(node.getChild(0), sb);
        }
START     } END 
","    protected void recursivelyPrint(AbstractPlanNode node, StringBuilder sb) {
        recursivelyPrint(node, sb, 0);
    }
"
1098,if condition not needed.,"    public void update(int inputIndex) {
      status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition()));
      if (logger.isDebugEnabled()) {
        logger.debug(""BATCH_STATS, incoming {}: {}"", inputIndex == 0 ? ""left"" : ""right"", getRecordBatchSizer(inputIndex));
      }
    }
","    public void update(int inputIndex) {
      status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition()));
START       if (logger.isDebugEnabled()) { END 
        logger.debug(""BATCH_STATS, incoming {}: {}"", inputIndex == 0 ? ""left"" : ""right"", getRecordBatchSizer(inputIndex));
      }
    }
","    public void update(int inputIndex) {
      status.setTargetOutputRowCount(super.update(inputIndex, status.getOutPosition()));
      logger.debug(""BATCH_STATS, incoming {}: {}"", inputIndex == 0 ? ""left"" : ""right"", getRecordBatchSizer(inputIndex));
    }
"
1099,Better: nextMemberPosition < 0,"	private int getNextPosition() throws CoreException {
		if (nextMemberPosition == -1) {
			nextMemberPosition = 0;
			while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) {
				nextMemberPosition++;
			}
		}
		return nextMemberPosition;
	}
","	private int getNextPosition() throws CoreException {
START 		if (nextMemberPosition == -1) { END 
			nextMemberPosition = 0;
			while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) {
				nextMemberPosition++;
			}
		}
		return nextMemberPosition;
	}
","	private int getNextPosition() throws CoreException {
		if (nextMemberPosition < 0) {
			nextMemberPosition = 0;
			while (nextMemberPosition < MAX_MEMBER_COUNT && getMemberRecord(nextMemberPosition) != 0) {
				nextMemberPosition++;
			}
		}
		return nextMemberPosition;
	}
"
1100,"nit: make `bulkRequest.numberOfActions()` a Supplier so it is only called if trace logging is enabled. 
```suggestion
            logger.trace(""[{}] ES API CALL: bulk request with {} actions"",  () -> jobId, () -> bulkRequest.numberOfActions());
```","        public BulkResponse executeRequest() {
            if (bulkRequest.numberOfActions() == 0) {
                return null;
            }
            logger.trace(""[{}] ES API CALL: bulk request with {} actions"", jobId, bulkRequest.numberOfActions());
            BulkResponse bulkResponse =
                resultsPersisterService.bulkIndexWithRetry(
                    bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, ""Bulk indexing of annotations failed "" + msg));
            bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME);
            return bulkResponse;
        }
","        public BulkResponse executeRequest() {
            if (bulkRequest.numberOfActions() == 0) {
                return null;
            }
START             logger.trace(""[{}] ES API CALL: bulk request with {} actions"", jobId, bulkRequest.numberOfActions()); END 
            BulkResponse bulkResponse =
                resultsPersisterService.bulkIndexWithRetry(
                    bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, ""Bulk indexing of annotations failed "" + msg));
            bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME);
            return bulkResponse;
        }
","        public BulkResponse executeRequest() {
            if (bulkRequest.numberOfActions() == 0) {
                return null;
            }
            logger.trace(""[{}] ES API CALL: bulk request with {} actions"", () -> jobId, () -> bulkRequest.numberOfActions());
            BulkResponse bulkResponse =
                resultsPersisterService.bulkIndexWithRetry(
                    bulkRequest, jobId, shouldRetry, msg -> auditor.warning(jobId, ""Bulk indexing of annotations failed "" + msg));
            bulkRequest = new BulkRequest(AnnotationIndex.WRITE_ALIAS_NAME);
            return bulkResponse;
        }
"
1101,isn't the iterator() excluding the expired and Tombstones?,"   public int size() {
      int size = 0;
      // We have to loop through to make sure to remove expired entries
      for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) {
         if (iter.next().getValue() == null) continue;
         if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE;
      }
      return size;
   }
","   public int size() {
      int size = 0;
      // We have to loop through to make sure to remove expired entries
      for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) {
START          if (iter.next().getValue() == null) continue; END 
         if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE;
      }
      return size;
   }
","   public int size() {
      int size = 0;
      // We have to loop through to make sure to remove expired entries
      for (Iterator<InternalCacheEntry<K, V>> iter = iterator(); iter.hasNext(); ) {
         iter.next();
         if (++size == Integer.MAX_VALUE) return Integer.MAX_VALUE;
      }
      return size;
   }
"
1102,I'd prefer the old order so when Environment.getExternalStorageState() return null we don't get an NPE.,"    public static File getDiskCacheDir(Context context, String uniqueName) {
        // Check if media is mounted or storage is built-in, if so, try and use external cache dir
        // otherwise use internal cache dir.
        final String cachePath;
        if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)
            && context.getExternalCacheDir() != null) {
            cachePath = context.getExternalCacheDir().getPath();
        } else {
            cachePath = context.getCacheDir().getPath();
        }
        return new File(cachePath + File.separator + uniqueName);
    }
","    public static File getDiskCacheDir(Context context, String uniqueName) {
        // Check if media is mounted or storage is built-in, if so, try and use external cache dir
        // otherwise use internal cache dir.
        final String cachePath;
START         if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) END 
            && context.getExternalCacheDir() != null) {
            cachePath = context.getExternalCacheDir().getPath();
        } else {
            cachePath = context.getCacheDir().getPath();
        }
        return new File(cachePath + File.separator + uniqueName);
    }
","    public static File getDiskCacheDir(Context context, String uniqueName) {
        // Check if media is mounted or storage is built-in, if so, try and use external cache dir
        // otherwise use internal cache dir.
        final String cachePath;
        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())
            && context.getExternalCacheDir() != null) {
            cachePath = context.getExternalCacheDir().getPath();
        } else {
            cachePath = context.getCacheDir().getPath();
        }
        return new File(cachePath + File.separator + uniqueName);
    }
"
1103,mark this method private as this is only used in this class.,"    String getBucketName(URI uri)
    {
        if (uri.getHost() != null) {
            return uri.getHost();
        }
        else if (uri.getUserInfo() == null) {
            return uri.getAuthority();
        }

        throw new IllegalArgumentException(""Unable to determine S3 bucket from URI."");
    }
","START     String getBucketName(URI uri) END 
    {
        if (uri.getHost() != null) {
            return uri.getHost();
        }
        else if (uri.getUserInfo() == null) {
            return uri.getAuthority();
        }

        throw new IllegalArgumentException(""Unable to determine S3 bucket from URI."");
    }
","    public static String getBucketName(URI uri)
    {
        if (uri.getHost() != null) {
            return uri.getHost();
        }

        if (uri.getUserInfo() == null) {
            return uri.getAuthority();
        }

        throw new IllegalArgumentException(""Unable to determine S3 bucket from URI."");
    }
"
1104,"I think we could make this initialization more terse if we initialize `MustacheResolver` with the ternary operator and pass it to `DefaultMustacheFactory`.
```java
new DefaultMustacheFactory(fileRoot.isPresent() ? new FileSystemResolver(fileRoot.get()) :
            new PerClassMustacheResolver(key))
```","    private MustacheFactory createNewMustacheFactory(Class<? extends View> key) {
        return (fileRoot != null) ? new DefaultMustacheFactory(new FileSystemResolver(fileRoot))
                : new DefaultMustacheFactory(new PerClassMustacheResolver(key));
    }
","    private MustacheFactory createNewMustacheFactory(Class<? extends View> key) {
START         return (fileRoot != null) ? new DefaultMustacheFactory(new FileSystemResolver(fileRoot)) END 
                : new DefaultMustacheFactory(new PerClassMustacheResolver(key));
    }
","    private MustacheFactory createNewMustacheFactory(Class<? extends View> key) {
        return new DefaultMustacheFactory(
                fileRoot.isPresent() ? new FileSystemResolver(fileRoot.get()) : new PerClassMustacheResolver(key));
    }
"
1105,"If we're all agreed on letting users choose system protocols in the browser, then I suppose we should not have this condition.","	public boolean isValidValue(final Object element) {
		boolean result = super.isValidValue(element);

		if (result) {
			EObject eObject = EMFHelper.getEObject(element);
			result = (ProtocolUtils.isProtocol(eObject) &&
					!SystemElementsUtils.isSystemProtocol((Collaboration) eObject) &&
					!SystemElementsUtils.isBaseProtocol((Collaboration) eObject));
		}

		return result;
	}
","	public boolean isValidValue(final Object element) {
		boolean result = super.isValidValue(element);

		if (result) {
			EObject eObject = EMFHelper.getEObject(element);
			result = (ProtocolUtils.isProtocol(eObject) &&
START 					!SystemElementsUtils.isSystemProtocol((Collaboration) eObject) && END 
					!SystemElementsUtils.isBaseProtocol((Collaboration) eObject));
		}

		return result;
	}
","	public boolean isValidValue(final Object element) {
		boolean result = super.isValidValue(element);

		if (result) {
			EObject eObject = EMFHelper.getEObject(element);
			result = (ProtocolUtils.isProtocol(eObject) &&
					!SystemElementsUtils.isBaseProtocol((Collaboration) eObject));
		}

		return result;
	}
"
1106,"Very minor: consider another helper method for runOnMainSync() so we can focus on the interesting bit (loginTestTask.execute()). As a side note, executing from the main thread doesn't seem to be a requirement of ""SaneAsyncTask"" for whatever reason. However, it seems more proper to call execute on the main thread[0] since we think of it as a normal AsyncTask so I think we should keep it.

[0] http://developer.android.com/reference/android/os/AsyncTask.html#execute(Params...)","    public void testLogin() throws Throwable {
        InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() {
            @Override
            public void run() {
                loginTestTask.execute();
            }
        });
        assertThat(completionLatch.await(), is(true));
    }
","    public void testLogin() throws Throwable {
START         InstrumentationRegistry.getInstrumentation().runOnMainSync(new Runnable() { END 
            @Override
            public void run() {
                loginTestTask.execute();
            }
        });
        assertThat(completionLatch.await(), is(true));
    }
","    public void testLogin() throws Throwable {
        runOnMainSync(new Runnable() {
            @Override
            public void run() {
                loginTestTask.execute();
            }
        });
        completionLatch.await();
    }
"
1107,We don't need to call `toString()`,"    public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) {
        String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG);
        if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString()))
            log.warn(""Configuration '{}' with value '{}' is deprecated and will be removed in "" +
                ""future version. Please use '{}' or another non-deprecated value."",
                CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT.toString(),
                ClientDnsLookup.USE_ALL_DNS_IPS);
    }
","    public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) {
        String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG);
        if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString()))
            log.warn(""Configuration '{}' with value '{}' is deprecated and will be removed in "" +
                ""future version. Please use '{}' or another non-deprecated value."",
START                 CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT.toString(), END 
                ClientDnsLookup.USE_ALL_DNS_IPS);
    }
","    public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) {
        String clientDnsLookupValue = config.getString(CLIENT_DNS_LOOKUP_CONFIG);
        if (clientDnsLookupValue.equals(ClientDnsLookup.DEFAULT.toString()))
            log.warn(""Configuration '{}' with value '{}' is deprecated and will be removed in "" +
                ""future version. Please use '{}' or another non-deprecated value."",
                CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT,
                ClientDnsLookup.USE_ALL_DNS_IPS);
    }
"
1108,I would like to remove the method getStats and would like to make the aggStats static.,"    public HdfsCopyStats(String source,
                         File destination,
                         boolean enableStatsFile,
                         int maxVersionsStatsFile,
                         boolean isFileCopy,
                         HdfsPathInfo pathInfo) {
        this.sourceFile = source;
        this.totalBytesTransferred = 0L;
        this.bytesTransferredSinceLastReport = 0L;
        this.pathInfo = pathInfo;
        this.lastReportNs = System.nanoTime();
        this.startTimeMS = System.currentTimeMillis();
        initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy);

        aggStats = HdfsFetcherAggStats.getStats();
    }
","    public HdfsCopyStats(String source,
                         File destination,
                         boolean enableStatsFile,
                         int maxVersionsStatsFile,
                         boolean isFileCopy,
                         HdfsPathInfo pathInfo) {
        this.sourceFile = source;
        this.totalBytesTransferred = 0L;
        this.bytesTransferredSinceLastReport = 0L;
        this.pathInfo = pathInfo;
        this.lastReportNs = System.nanoTime();
        this.startTimeMS = System.currentTimeMillis();
        initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy);

START         aggStats = HdfsFetcherAggStats.getStats(); END 
    }
","    public HdfsCopyStats(String source,
                         File destination,
                         boolean enableStatsFile,
                         int maxVersionsStatsFile,
                         boolean isFileCopy,
                         HdfsPathInfo pathInfo) {
        this.sourceFile = source;
        this.totalBytesTransferred = 0L;
        this.bytesTransferredSinceLastReport = 0L;
        this.pathInfo = pathInfo;
        this.lastReportNs = System.nanoTime();
        this.startTimeMS = System.currentTimeMillis();
        initializeStatsFile(destination, enableStatsFile, maxVersionsStatsFile, isFileCopy);
    }
"
1109,"toString() is not needed here, AFAIK.","    private void writeAlias(VmDevice device) {
        writer.writeStartElement(""alias"");
        writer.writeAttributeString(""name"", String.format(""ua-%s"", device.getId().getDeviceId().toString()));
        writer.writeEndElement();
    }
","    private void writeAlias(VmDevice device) {
        writer.writeStartElement(""alias"");
        writer.writeAttributeString(""name"", String.format(""ua-%s"", START device.getId().getDeviceId().toString())); END 
        writer.writeEndElement();
    }
","    private void writeAlias(VmDevice device) {
        writer.writeStartElement(""alias"");
        writer.writeAttributeString(""name"", String.format(""ua-%s"", device.getId().getDeviceId()));
        writer.writeEndElement();
    }
"
1110,You shouldn't need the checkNotNull,"    public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) {
        fProvider = provider;
        fSeries = checkNotNull(ImmutableList.copyOf(series));
    }
","    public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) {
        fProvider = provider;
START         fSeries = checkNotNull(ImmutableList.copyOf(series)); END 
    }
","    public ChartData(IDataChartProvider<?> provider, List<ChartSeries> series) {
        fProvider = provider;
        fSeries = ImmutableList.copyOf(series);
    }
"
1111,can this case be given? I mean having an entry for the given `uuid` but with no registrations?,"    protected boolean isRegistered(final String uuid) {
        return handlers.containsKey(uuid) && !handlers.get(uuid).isEmpty();
    }
","    protected boolean isRegistered(final String uuid) {
START         return handlers.containsKey(uuid) && !handlers.get(uuid).isEmpty(); END 
    }
","    protected boolean isRegistered(final String uuid) {
        return handlers.containsKey(uuid);
    }
"
1112,@manstis can this synchronized be removed? this method is only calling the defineClass overload which is already sync'ed.,"    public synchronized Class<?> defineClass(String name, byte[] bytecode) {
        return defineClass(name, convertClassToResourcePath(name), bytecode);
    }
","START     public synchronized Class<?> defineClass(String name, byte[] bytecode) { END 
        return defineClass(name, convertClassToResourcePath(name), bytecode);
    }
","    public Class<?> defineClass(String name, byte[] bytecode) {
        return defineClass(name, convertClassToResourcePath(name), bytecode);
    }
"
1113,Could we get brackets around this if {},"    public boolean onOptionsItemSelected(MenuItem item) {
        // home references the app icon
        if (item.getItemId() == android.R.id.home) {
            toggle(); // toggles the state of the sliding menu
            if(getSlidingMenu().isMenuShowing() && menu.isAdded())
                setTitle(((ITitleable)menu).getTitle());
            return true;
        }
        return false;
    }
","    public boolean onOptionsItemSelected(MenuItem item) {
        // home references the app icon
        if (item.getItemId() == android.R.id.home) {
            toggle(); // toggles the state of the sliding menu
START             if(getSlidingMenu().isMenuShowing() && menu.isAdded()) END 
                setTitle(((ITitleable)menu).getTitle());
            return true;
        }
        return false;
    }
","    public boolean onOptionsItemSelected(MenuItem item) {
        // home references the app icon
        if (item.getItemId() == android.R.id.home) {
            toggle(); // toggles the state of the sliding menu
            if(getSlidingMenu().isMenuShowing() && menu.isAdded()){
                setTitle(((ITitleable)menu).getTitle());
            }
            return true;
        }
        return false;
    }
"
1114,"super nit (okay to ignore): Here and below: For consistency, consider ""e"" rather than ""ex"". Typically we only use ""ex"" for nested catch blocks where the name ""e"" is already being used by the enclosing block.","    public static ParcelFileDescriptor fromSocket(Socket socket) {
        FileDescriptor fd = socket.getFileDescriptor$();
        try {
            return fd != null ? ParcelFileDescriptor.dup(fd) : null;
        } catch (IOException ex) {
            throw new UncheckedIOException(ex);
        }
    }
","    public static ParcelFileDescriptor fromSocket(Socket socket) {
        FileDescriptor fd = socket.getFileDescriptor$();
        try {
            return fd != null ? ParcelFileDescriptor.dup(fd) : null;
        } catch (IOException START  ex) { END 
            throw new UncheckedIOException(ex);
        }
    }
","    public static ParcelFileDescriptor fromSocket(Socket socket) {
        FileDescriptor fd = socket.getFileDescriptor$();
        try {
            return fd != null ? ParcelFileDescriptor.dup(fd) : null;
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }
"
1115,"Is the check for trailing Path.SEPARATOR necessary ? We just got the IntroTheme.ATT_ID property which is not supposed to have a trailing Path.SEPARATOR, no ?","	private String getThemePrefixedPath(String path) {
		String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null;
		prefix = prefix == null ? """" : prefix.trim(); //$NON-NLS-1$
		if (prefix.length() == 0) {
			return null;
		}
		return prefix.charAt(prefix.length() - 1) == Path.SEPARATOR ? prefix + path : prefix + Path.SEPARATOR + path;
	}
","	private String getThemePrefixedPath(String path) {
		String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null;
		prefix = prefix == null ? """" : prefix.trim(); //$NON-NLS-1$
		if (prefix.length() == 0) {
			return null;
		}
START 		return prefix.charAt(prefix.length() - 1) == Path.SEPARATOR ? prefix + path : prefix + Path.SEPARATOR + path; END 
	}
","	private String getThemePrefixedPath(String path) {
		String prefix = themeProperties != null ? themeProperties.get(IntroTheme.ATT_ID) : null;
		prefix = prefix == null ? """" : prefix.trim(); //$NON-NLS-1$
		if (prefix.length() == 0) {
			return null;
		}
		return prefix + Path.SEPARATOR + path;
	}
"
1116,what about the null case?,"    protected void writeString(int majorType, byte[] bytes) throws IOException {
        int len = (bytes == null) ? 0 : bytes.length;
        writeType(majorType, len);
        m_os.write(bytes);
    }
","    protected void writeString(int majorType, byte[] bytes) throws IOException {
        int len = (bytes == null) ? 0 : bytes.length;
        writeType(majorType, len);
START         m_os.write(bytes); END 
    }
","    protected void writeString(int majorType, byte[] bytes) throws IOException {
        int len = (bytes == null) ? 0 : bytes.length;
        writeType(majorType, len);
        if (len > 0){
            m_os.write(bytes);
        }
    }
"
1117,"extra `else` statement, please remove","    private void checkLogData(long address, ILogData logData) {
        if (logData == null || logData.getType() == DataType.EMPTY) {
            throw new RuntimeException(""Unexpected return of empty data at address ""
                    + address + "" on read"");
        } else if (logData.isTrimmed()) {
            throw new TrimmedException();
        }
    }
","    private void checkLogData(long address, ILogData logData) {
        if (logData == null || logData.getType() == DataType.EMPTY) {
            throw new RuntimeException(""Unexpected return of empty data at address ""
                    + address + "" on read"");
        } else if (logData.isTrimmed()) {
            throw new TrimmedException();
        }
START     } END 
","    private void checkLogData(long address, ILogData logData) {
        if (logData == null || logData.getType() == DataType.EMPTY) {
            throw new RuntimeException(""Unexpected return of empty data at address ""
                    + address + "" on read"");
        }

        if (logData.isTrimmed()) {
            throw new TrimmedException();
        }
    }
"
1118,"- space after comma
- you need to pass the source duration as well","    private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) {
        long sourceDuration = source.getDuration();
        long sourceSelfTime = source.getSelfTime();
        destination.addToDuration(sourceDuration);
        destination.addToSelfTime(sourceSelfTime);
        destination.fStatistics.update(source.fStatistics.getMaxSegment(),source.fStatistics.getMinSegment(), sourceSelfTime);
        // merge the children callees.
        mergeChildren(destination, source);
    }
","    private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) {
        long sourceDuration = source.getDuration();
        long sourceSelfTime = source.getSelfTime();
        destination.addToDuration(sourceDuration);
        destination.addToSelfTime(sourceSelfTime);
        START destination.fStatistics.update(source.fStatistics.getMaxSegment(),source.fStatistics.getMinSegment(), END  sourceSelfTime);
        // merge the children callees.
        mergeChildren(destination, source);
    }
","    private static void merge(AggregatedCalledFunction destination, AggregatedCalledFunction source) {
        long sourceDuration = source.getDuration();
        long sourceSelfTime = source.getSelfTime();
        destination.addToDuration(sourceDuration);
        destination.addToSelfTime(sourceSelfTime);
        destination.fStatistics.update(source.fStatistics.getMaxSegment(), source.fStatistics.getMinSegment(), sourceDuration, sourceSelfTime);
        // merge the children callees.
        mergeChildren(destination, source);
    }
"
1119,"Think this needs to go right below line 91. `parseResponse` can return `null` (line 133), which will cause this future to never complete.","  @Override protected void doEnqueue(Callback<V> callback) {
    sendRequest().handle((response, t) -> {
      if (t != null) {
        callback.onError(t);
      } else {
        V value = null;
        try {
          value = parseResponse(response, bodyConverter);
        } catch (Throwable t1) {
          propagateIfFatal(t1);
          callback.onError(t1);
        }
        if (value != null) callback.onSuccess(value);
      }
      return null;
    });
  }
","  @Override protected void doEnqueue(Callback<V> callback) {
    sendRequest().handle((response, t) -> {
      if (t != null) {
        callback.onError(t);
      } else {
        V value = null;
        try {
          value = parseResponse(response, bodyConverter);
        } catch (Throwable t1) {
          propagateIfFatal(t1);
          callback.onError(t1);
        }
START         if (value != null) callback.onSuccess(value); END 
      }
      return null;
    });
  }
","  @Override protected void doEnqueue(Callback<V> callback) {
    sendRequest().handle((response, t) -> {
      if (t != null) {
        callback.onError(t);
      } else {
        try {
          V value = parseResponse(response, bodyConverter);
          callback.onSuccess(value);
        } catch (Throwable t1) {
          propagateIfFatal(t1);
          callback.onError(t1);
        }
      }
      return null;
    });
  }
"
1120,if (!isExplicit) {  // ... around the try,"  public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) {
    SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel);
    try {
      transactionScopeManager.set(t);
    } catch (PersistenceException existingTransactionError) {
      t.end();
      throw existingTransactionError;
    }
    return t;
  }
","  public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) {
    SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel);
START     try { END 
      transactionScopeManager.set(t);
    } catch (PersistenceException existingTransactionError) {
      t.end();
      throw existingTransactionError;
    }
    return t;
  }
","  public SpiTransaction createServerTransaction(boolean isExplicit, int isolationLevel) {
    SpiTransaction t = transactionManager.createTransaction(isExplicit, isolationLevel);
    if (isExplicit) {
      try {
        transactionScopeManager.set(t);
      } catch (PersistenceException existingTransactionError) {
        t.end();
        throw existingTransactionError;
      }
    }
    return t;
  }
"
1121,"What about thread safety here?

I might be mistaken, but by just looking at this code snippet it looks like more than one thread could check the condition, receive `false` from the `contains()` method and execute the above code block. That might be the reason the blocking `putIfAbsent` method is used here?","    C baseApply() {
      final TreeMap<String, String> t = new TreeMap<String, String>(validate());
      if(!children.contains(t)) {
        C child = newChild();
        children.put(t, child);
        return child;
      } else
        return children.get(t);
    }
","    C baseApply() {
      final TreeMap<String, String> t = new TreeMap<String, String>(validate());
      if(!children.contains(t)) {
        C child = newChild();
        children.put(t, child);
START         return child; END 
      } else
        return children.get(t);
    }
","    C baseApply() {
      final TreeMap<String, String> t = new TreeMap<String, String>(validate());
      C child = children.get(t);
      if(child == null) { 
    	  child = newChild();
    	  children.put(t, child);
      }
      return child;
    }
"
1122,"i'd maybe just ""forward"" the `onConnect` to the presenter instead","    public void onConnect(String message) {
        debugView.showPermanently(getString(R.string.connected));
        switchableView.setDisplayedChild(1);
        presenter.startListeningForDirection();
    }
","    public void onConnect(String message) {
        debugView.showPermanently(getString(R.string.connected));
        switchableView.setDisplayedChild(1);
START         presenter.startListeningForDirection(); END 
    }
","    public void onConnect(String message) {
        debugView.showPermanently(getString(R.string.connected));
        switchableView.setDisplayedChild(1);
    }
"
1123,"yup, this is incorrect, seems I failed somewhere, this logic has to be in `public ByteBuffer[] nioBuffers()`, gonna change it","    public ByteBuffer[] nioBuffers(int index, int length) {
        if (b1.nioBufferCount() == 1 && b2.nioBufferCount() == 1) {
            return new ByteBuffer[] { b1.nioBuffer(), b2.nioBuffer() };
        }
        return ObjectArrays.concat(b1.nioBuffers(), b2.nioBuffers(), ByteBuffer.class);
    }
","    public ByteBuffer[] nioBuffers(int index, int length) {
        if (b1.nioBufferCount() == 1 && b2.nioBufferCount() == 1) {
            return new ByteBuffer[] { b1.nioBuffer(), b2.nioBuffer() };
        }
START         return ObjectArrays.concat(b1.nioBuffers(), b2.nioBuffers(), ByteBuffer.class); END 
    }
","    public ByteBuffer[] nioBuffers(int index, int length) {
        return new ByteBuffer[] { nioBuffer(index, length) };
    }
"
1124,"why the instance-level lock suggestion, vs. what's been implemented here. seems like overkill","    public void setDisabledAdministrativeMonitors(Set<String> disabledAdministrativeMonitors) {
        this.disabledAdministrativeMonitors = new CopyOnWriteArraySet<>(disabledAdministrativeMonitors);
    }
","START     public void setDisabledAdministrativeMonitors(Set<String> disabledAdministrativeMonitors) { END 
        this.disabledAdministrativeMonitors = new CopyOnWriteArraySet<>(disabledAdministrativeMonitors);
    }
","    public void setDisabledAdministrativeMonitors(Set<String> disabledAdministrativeMonitors) {
        synchronized (this.disabledAdministrativeMonitors) {
            this.disabledAdministrativeMonitors.clear();
            this.disabledAdministrativeMonitors.addAll(disabledAdministrativeMonitors);
        }
    }
"
1125,Is this method going to be overridden in a subclass to provide a different behavior? This method can be protected if is not supposed to be overridden outside the package.,"  public boolean waitUntilReadyToProcess(Properties jobProps) {
    return true;
  }
","START   public boolean waitUntilReadyToProcess(Properties jobProps) { END 
    return true;
  }
","  protected boolean waitUntilReadyToProcess(Properties jobProps) {
    return true;
  }
"
1126,Casting to `ArrayList` is brittle. Could we return `List<>` from here instead?,"  private ArrayList<Comment> fetchAllComments(ArticleTable article) {
    return (ArrayList<Comment>) hibernateTemplate.find(""FROM Comment WHERE articleId = ?"", article.getArticleId());
  }
","  private ArrayList<Comment> fetchAllComments(ArticleTable article) {
START     return (ArrayList<Comment>) hibernateTemplate.find(""FROM Comment WHERE articleId = ?"", article.getArticleId()); END 
  }
","  private List<Comment> fetchAllComments(ArticleTable article) {
    return (ArrayList<Comment>) hibernateTemplate.find(""FROM Comment WHERE articleId = ?"", article.getArticleId());
  }
"
1127,"Missed this one in the previous review, needs updating as well!","	public String getPreview() {
		StringBuilder bld= new StringBuilder();
		bld.append(""\n"");

		if (isEnabled(CleanUpConstants.NUMBER_SUFFIX)) {
			bld.append(""long number1 = 10L;\n"");
			bld.append(""float number2 = 10F;\n"");
			bld.append(""double number3 = 10D;\n"");
		} else {
			bld.append(""long number1 = 10l;\n"");
			bld.append(""float number2 = 10f;\n"");
			bld.append(""double number3 = 10d;\n"");
		}

		return bld.toString();
	}
","START 	public String getPreview() { END 
		StringBuilder bld= new StringBuilder();
		bld.append(""\n"");

		if (isEnabled(CleanUpConstants.NUMBER_SUFFIX)) {
			bld.append(""long number1 = 10L;\n"");
			bld.append(""float number2 = 10F;\n"");
			bld.append(""double number3 = 10D;\n"");
		} else {
			bld.append(""long number1 = 10l;\n"");
			bld.append(""float number2 = 10f;\n"");
			bld.append(""double number3 = 10d;\n"");
		}

		return bld.toString();
	}
","	public String getPreview() {
		StringBuilder bld= new StringBuilder();
		bld.append(""\n"");

		if (isEnabled(CleanUpConstants.NUMBER_SUFFIX)) {
			bld.append(""long number1 = 10L;\n"");
		} else {
			bld.append(""long number1 = 10l;\n"");
		}

		return bld.toString();
	}
"
1128,"Is this a race or corruption happens all the time?  Change looks fine, but I did not understand the actual issue with the current code on why corruption happening.","    private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) {
        int size = msg.getSerializedSize();
        ByteBuf buf = allocator.heapBuffer(size, size);

        try {
            msg.writeTo(new ByteBufOutputStream(buf));
        } catch (IOException e) {
            // This is in-memory serialization, should not fail
            throw new RuntimeException(e);
        }

        // Advance writer idx
        buf.writerIndex(buf.capacity());
        return buf;
    }
","    private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) {
        int size = msg.getSerializedSize();
        ByteBuf buf = allocator.heapBuffer(size, size);

        try {
START             msg.writeTo(new ByteBufOutputStream(buf)); END 
        } catch (IOException e) {
            // This is in-memory serialization, should not fail
            throw new RuntimeException(e);
        }

        // Advance writer idx
        buf.writerIndex(buf.capacity());
        return buf;
    }
","    private static ByteBuf serializeProtobuf(MessageLite msg, ByteBufAllocator allocator) {
        int size = msg.getSerializedSize();
        ByteBuf buf = allocator.heapBuffer(size, size);

        try {
            msg.writeTo(new ByteBufOutputStream(buf));
        } catch (IOException e) {
            // This is in-memory serialization, should not fail
            throw new RuntimeException(e);
        }

        return buf;
    }
"
1129,Is this the value we use for all other protocols?,"    public void testEncodeOutputControl() {

        Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder();

        Command command = new Command();
        command.setDeviceId(1);
        command.setType(Command.TYPE_OUTPUT_CONTROL);
        command.set(Command.KEY_INDEX, 0);
        command.set(Command.KEY_DATA, ""1"");

        assertEquals(""(123456789012345AV001)"", encoder.encodeCommand(command));

    }
","    public void testEncodeOutputControl() {

        Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder();

        Command command = new Command();
        command.setDeviceId(1);
        command.setType(Command.TYPE_OUTPUT_CONTROL);
        command.set(Command.KEY_INDEX, 0);
START         command.set(Command.KEY_DATA, ""1""); END 

        assertEquals(""(123456789012345AV001)"", encoder.encodeCommand(command));

    }
","    public void testEncodeOutputControl() {

        Tk103ProtocolEncoder encoder = new Tk103ProtocolEncoder();

        Command command = new Command();
        command.setDeviceId(1);
        command.setType(Command.TYPE_OUTPUT_CONTROL);
        command.set(Command.KEY_DATA, ""1"");

        assertEquals(""(123456789012345AV001)"", encoder.encodeCommand(command));

    }
"
1130,"No `if` check needed, just always set the reference to `null`.","  void cancel() {
    super.cancel();
    if (callback != null) {
      callback = null;
    }
  }
","  void cancel() {
    super.cancel();
START     if (callback != null) { END 
      callback = null;
    }
  }
","  @Override void cancel() {
    super.cancel();
    callback = null;
  }
"
1131,`new Error` -> `new RuntimeException`,"    public void cancel() {
        try {
            Field field = FileWatchdog.class.getDeclaredField(""interrupted"");
            field.setAccessible(true);
            field.set(this, true);
        } catch (ReflectiveOperationException cause) {
            throw new Error(""Cannot cancel log4j watchdog"", cause);
        }
    }
","    public void cancel() {
        try {
            Field field = FileWatchdog.class.getDeclaredField(""interrupted"");
            field.setAccessible(true);
            field.set(this, true);
        } catch (ReflectiveOperationException cause) {
START             throw new Error(""Cannot cancel log4j watchdog"", cause); END 
        }
    }
","    public void cancel() {
        try {
            Field field = FileWatchdog.class.getDeclaredField(""interrupted"");
            field.setAccessible(true);
            field.set(this, true);
        } catch (ReflectiveOperationException cause) {
            throw new RuntimeException(""Cannot cancel log4j watchdog"", cause);
        }
    }
"
1132,Very minor: it's probably cleaner just to initialized ENABLED_LANGUAGES using Arrays.asList,"    public static boolean isEditAllowed(@NonNull PageTitle title) {
        return Arrays.asList(ENABLED_LANGUAGES).contains(title.getWikiSite().languageCode());
    }
","    public static boolean isEditAllowed(@NonNull PageTitle title) {
        return START  Arrays.asList(ENABLED_LANGUAGES).contains(title.getWikiSite().languageCode()); END 
    }
","    public static boolean isEditAllowed(@NonNull PageTitle title) {
        return ENABLED_LANGUAGES.contains(title.getWikiSite().languageCode());
    }
"
1133,Why is this hardcoded? and why is it 1 not 0?,"    private InputStream simulateSendAndReceive(ByteArrayOutputStream baos) throws IOException {
        byte[] bytes = baos.toByteArray();
        baos.reset();
        int testMessageNo = 1;
        PacketFormat format = new PacketFormat(testMessageNo, bytes);
        format.serialize(baos);
        return new ByteArrayInputStream(baos.toByteArray());
    }
","    private InputStream simulateSendAndReceive(ByteArrayOutputStream baos) throws IOException {
        byte[] bytes = baos.toByteArray();
        baos.reset();
START         int testMessageNo = 1; END 
        PacketFormat format = new PacketFormat(testMessageNo, bytes);
        format.serialize(baos);
        return new ByteArrayInputStream(baos.toByteArray());
    }
","    private InputStream simulateSendAndReceive(ByteArrayOutputStream baos) throws IOException {
        return new ByteArrayInputStream(baos.toByteArray());
    }
"
1134,"This wasn't necessary, I was using the constructor I added that defaults to battlefield because most activated abilities are on the battlefield anyway. It doesn't really matter, I just figured I'd mention it.","    public ShovingMatch(UUID ownerId, CardSetInfo setInfo) {
        super(ownerId, setInfo, new CardType[]{CardType.INSTANT}, ""{2}{U}"");

        // Until end of turn, all creatures gain ""{tap}: Tap target creature.""
        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost());
        ability.addTarget(new TargetCreaturePermanent());
        this.getSpellAbility().addEffect(
                new GainAbilityAllEffect(ability, Duration.EndOfTurn, new FilterCreaturePermanent())
                        .setText(""Until end of turn, all creatures gain \""{T}: Tap target creature.\"""")
        );
    }
","    public ShovingMatch(UUID ownerId, CardSetInfo setInfo) {
        super(ownerId, setInfo, new CardType[]{CardType.INSTANT}, ""{2}{U}"");

        // Until end of turn, all creatures gain ""{tap}: Tap target creature.""
START         Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new TapTargetEffect(), new TapSourceCost()); END 
        ability.addTarget(new TargetCreaturePermanent());
        this.getSpellAbility().addEffect(
                new GainAbilityAllEffect(ability, Duration.EndOfTurn, new FilterCreaturePermanent())
                        .setText(""Until end of turn, all creatures gain \""{T}: Tap target creature.\"""")
        );
    }
","    public ShovingMatch(UUID ownerId, CardSetInfo setInfo) {
        super(ownerId, setInfo, new CardType[]{CardType.INSTANT}, ""{2}{U}"");

        // Until end of turn, all creatures gain ""{tap}: Tap target creature.""
        Ability ability = new SimpleActivatedAbility(new TapTargetEffect(), new TapSourceCost());
        ability.addTarget(new TargetCreaturePermanent());
        this.getSpellAbility().addEffect(
                new GainAbilityAllEffect(ability, Duration.EndOfTurn, new FilterCreaturePermanent())
                        .setText(""Until end of turn, all creatures gain \""{T}: Tap target creature.\"""")
        );
    }
"
1135,Use `assertEquals`,"    public void testCompareRanges()
    {
        assertTrue(compareRanges(""abcdefghij"".getBytes(), 0, 10, ""abcdefghij"".getBytes(), 0, 10) == 0);
        assertTrue(compareRanges(""123abcdefghij"".getBytes(), 3, 10, ""abcdefghij"".getBytes(), 0, 10) == 0);
    }
","    public void testCompareRanges()
    {
START         assertTrue(compareRanges(""abcdefghij"".getBytes(), 0, 10, ""abcdefghij"".getBytes(), 0, 10) == 0); END 
        assertTrue(compareRanges(""123abcdefghij"".getBytes(), 3, 10, ""abcdefghij"".getBytes(), 0, 10) == 0);
    }
","    public void testCompareRanges()
    {
        assertEquals(compareRanges(""abcdefghij"".getBytes(), 0, 10, ""abcdefghij"".getBytes(), 0, 10), 0);
        assertEquals(compareRanges(""123abcdefghij"".getBytes(), 3, 10, ""abcdefghij"".getBytes(), 0, 10), 0);
    }
"
1136,Verificar necessidade desse else,"    public void setRequiredParametersForCreation(DateTime paymentDate, Timeframe timeframe, Integer requestedAmount, Boolean build){
        this.paymentDate = paymentDate;
        this.timeframe = timeframe;
        this.requestedAmount = requestedAmount;
        //???
        if(build){
            this.build = build;
        }else{
            this.building = build;
        }
        
    }
","    public void setRequiredParametersForCreation(DateTime paymentDate, Timeframe timeframe, Integer requestedAmount, Boolean build){
        this.paymentDate = paymentDate;
        this.timeframe = timeframe;
        this.requestedAmount = requestedAmount;
        //???
        if(build){
            this.build = build;
        }else{
START             this.building = build; END 
        }
        
    }
","    public void setRequiredParametersForCreation(DateTime paymentDate, Timeframe timeframe, Integer requestedAmount, Boolean build){
        this.paymentDate = paymentDate;
        this.timeframe = timeframe;
        this.requestedAmount = requestedAmount;
        if(build){
            this.build = build;
        }
    }
"
1137,unnecessary `throws` (same for the constructor above).,"    public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode)
            throws Exception
    {
        super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables()));
        this.embeddedElasticsearchNode = embeddedElasticsearchNode;
    }
","    public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode)
START             throws Exception END 
    {
        super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables()));
        this.embeddedElasticsearchNode = embeddedElasticsearchNode;
    }
","    public TestElasticsearchIntegrationSmokeTest(EmbeddedElasticsearchNode embeddedElasticsearchNode)
    {
        super(() -> createElasticsearchQueryRunner(embeddedElasticsearchNode, TpchTable.getTables()));
        this.embeddedElasticsearchNode = embeddedElasticsearchNode;
    }
"
1138,"print help all the time?
the command `> server` alone isn't valid.","   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {
      if (help) {
         commandInvocation.println(commandInvocation.getHelpInfo());
      }
      return CommandResult.SUCCESS;
   }
","   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {
START       if (help) { END 
         commandInvocation.println(commandInvocation.getHelpInfo());
      }
      return CommandResult.SUCCESS;
   }
","   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {
      commandInvocation.println(commandInvocation.getHelpInfo());
      return CommandResult.SUCCESS;
   }
"
1139,.value() returns .name().toLowerCase(),"        for (OsType type : OsType.values()) {
            osTypeValues.add(type.value().toLowerCase());
        }
","        for (OsType type : OsType.values()) {
START             osTypeValues.add(type.value().toLowerCase()); END 
        }
","        for (OsType type : OsType.values()) {
            osTypeValues.add(type.value());
        }
"
1140,Why don't you change getAction() to return a Collection<ContributionItem>?,"	private Menu fillMenu(Menu m) {
		for (IAction action : getActions()) {
			IContributionItem item;
			String actionText = action.getText();
			if (actionText == null || actionText.isEmpty()) {
				item = new Separator();
			} else {
				item = new ActionContributionItem(action);
			}
			item.fill(m, -1);
		}
		return m;
	}
","	private Menu fillMenu(Menu m) {
		for (IAction action : getActions()) {
			IContributionItem item;
			String actionText = action.getText();
			if (actionText == null || actionText.isEmpty()) {
				item = new Separator();
			} else {
				item = new ActionContributionItem(action);
START 			} END 
			item.fill(m, -1);
		}
		return m;
	}
","	private Menu fillMenu(Menu m) {
		for (IContributionItem item : getActions()) {
			item.fill(m, -1);
		}
		return m;
	}
"
1141,"In all `assert` method, the first argument is the ""expected"" value while the second one is the ""actual"" value. Can you swap them in this file to match that definition?","    public void testThreadNameWithoutNumberNoDemon() {
        Assert.assertEquals(ThreadUtils.createThreadFactory(THREAD_NAME, false).
                newThread(EMPTY_RUNNABLE).getName(), THREAD_NAME);
    }
","    public void testThreadNameWithoutNumberNoDemon() {
START         Assert.assertEquals(ThreadUtils.createThreadFactory(THREAD_NAME, false). END 
                newThread(EMPTY_RUNNABLE).getName(), THREAD_NAME);
    }
","    public void testThreadNameWithoutNumberNoDemon() {
        assertEquals(THREAD_NAME, ThreadUtils.createThreadFactory(THREAD_NAME, false).
                newThread(EMPTY_RUNNABLE).getName());
    }
"
1142,"```suggestion
        return (ModelAdaptor<? super T>) adaptors.get(attributeType);
```","    public <T> ModelAdaptor<? super T> getModelAdaptor(Class<T> attributeType) {
        //noinspection unchecked
        return (ModelAdaptor<T>) adaptors.get(attributeType);
    }
","    public <T> ModelAdaptor<? super T> getModelAdaptor(Class<T> attributeType) {
        //noinspection unchecked
START         return (ModelAdaptor<T>) adaptors.get(attributeType); END 
    }
","    public <T> ModelAdaptor<? super T> getModelAdaptor(Class<T> attributeType) {
        //noinspection unchecked
        return (ModelAdaptor<? super T>) adaptors.get(attributeType);
    }
"
1143,"If you override accountId then the parentKey is automatically a member, and this needs to only include the patchKey.","    public com.google.gwtorm.client.Key<?>[] members() {
      return new com.google.gwtorm.client.Key<?>[] {accountId, patchKey};
    }
","    public com.google.gwtorm.client.Key<?>[] members() {
START       return new com.google.gwtorm.client.Key<?>[] {accountId, patchKey}; END 
    }
","    public com.google.gwtorm.client.Key<?>[] members() {
      return new com.google.gwtorm.client.Key<?>[] {patchKey};
    }
"
1144,If it is then do what exactly? If we don't want to do anything do we need this ```if(..)``` block at all?,"    public void init(final RuleModellerPage page) {
        this.page = page;
        if (page.plugin() instanceof BRLActionColumnPlugin) {

        }
    }
","    public void init(final RuleModellerPage page) {
        this.page = page;
        if (page.plugin() instanceof BRLActionColumnPlugin) {
START  END 
        }
    }
","    public void init(final RuleModellerPage page) {
        this.page = page;
    }
"
1145,nit: Could you have `Override` in its own line.,"    @Override public TaskResult syncShards() {
        return periodicShardSyncManager.start();
    }
","START     @Override public TaskResult syncShards() { END 
        return periodicShardSyncManager.start();
    }
","    public TaskResult syncShards() {
        return periodicShardSyncManager.start();
    }
"
1146,Drop this `ImmutableList.copyOf` wrapper. It reduces clarity and we do expect random-access lists here anyway.,"    static <T> List<T> without(List<T> list, Collection<Integer> indexes)
    {
        Set<Integer> indexesSet = ImmutableSet.copyOf(indexes);

        return IntStream.range(0, list.size())
                .filter(index -> !indexesSet.contains(index))
                .mapToObj(ImmutableList.copyOf(list)::get)
                .collect(toImmutableList());
    }
","    static <T> List<T> without(List<T> list, Collection<Integer> indexes)
    {
        Set<Integer> indexesSet = ImmutableSet.copyOf(indexes);

        return IntStream.range(0, list.size())
                .filter(index -> !indexesSet.contains(index))
START                 .mapToObj(ImmutableList.copyOf(list)::get) END 
                .collect(toImmutableList());
    }
","    static <T> List<T> without(List<T> list, Collection<Integer> indexes)
    {
        Set<Integer> indexesSet = ImmutableSet.copyOf(indexes);

        return IntStream.range(0, list.size())
                .filter(index -> !indexesSet.contains(index))
                .mapToObj(list::get)
                .collect(toImmutableList());
    }
"
1147,"CacheException instanceOf RuntimeException, I guess you can simplify here.","   private Throwable getRealException(Throwable re) {
      if (re.getCause() == null) return re;
      Throwable cause = re.getCause();
      if (cause instanceof CacheException || cause instanceof RuntimeException || cause instanceof Error)
         return getRealException(cause);
      else
         return re;
   }
","   private Throwable getRealException(Throwable re) {
      if (re.getCause() == null) return re;
      Throwable cause = re.getCause();
START       if (cause instanceof CacheException || cause instanceof RuntimeException || cause instanceof Error) END 
         return getRealException(cause);
      else
         return re;
   }
","   private Throwable getRealException(Throwable re) {
      if (re.getCause() == null) return re;
      Throwable cause = re.getCause();
      if (cause instanceof RuntimeException || cause instanceof Error)
         return getRealException(cause);
      else
         return re;
   }
"
1148,What does this change do?,"    public void layoutIfNecessary() {
        if (dirtySize != null && control != null && control instanceof Composite) {
            if (control.getSize().equals(dirtySize)) {
				((Composite) control).layout();
	            flushChildren = false;
            }
        }
        dirtySize = null;
    }
","    public void layoutIfNecessary() {
        if (dirtySize != null && control != null && control instanceof Composite) {
            if (control.getSize().equals(dirtySize)) {
START 				((Composite) control).layout(); END 
	            flushChildren = false;
            }
        }
        dirtySize = null;
    }
","    public void layoutIfNecessary() {
        if (dirtySize != null && control != null && control instanceof Composite) {
            if (control.getSize().equals(dirtySize)) {
	            ((Composite)control).layout(flushChildren);
	            flushChildren = false;
            }
        }
        dirtySize = null;
    }
"
1149,"We ususally don't put the logic in the entity class. Will be confusing that this setter has side effects:
`addAttribute(""blah"").setNillable(true).setLabelAttribute(true)`","	public Attribute setLabelAttribute(Boolean isLabelAttr)
	{
		set(IS_LABEL_ATTRIBUTE, isLabelAttr);
		if (isLabelAttr != null && isLabelAttr)
		{
			setNillable(false);
		}
		return this;
	}
","	public Attribute setLabelAttribute(Boolean isLabelAttr)
	{
		set(IS_LABEL_ATTRIBUTE, isLabelAttr);
START 		if (isLabelAttr != null && isLabelAttr) END 
		{
			setNillable(false);
		}
		return this;
	}
","	public Attribute setLabelAttribute(Boolean isLabelAttr)
	{
		set(IS_LABEL_ATTRIBUTE, isLabelAttr);
		return this;
	}
"
1150,"So, maybe just remove this code for now? And keep in mind it. However I remember this one: https://github.com/SpringSource/spring-integration/pull/827#issuecomment-20274110
I mean to rely just only on 'system-wide conversion service', not from endpoint.","	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof IntegrationEvaluationContextAware) {
			StandardEvaluationContext evaluationContext = IntegrationContextUtils.getEvaluationContext(beanFactory);
			if (bean instanceof IntegrationObjectSupport) {
				ConversionService conversionService = ((IntegrationObjectSupport) bean).getConversionService();
				if (conversionService != null) {
					evaluationContext.setTypeConverter(new StandardTypeConverter(conversionService));
				}
			}
			((IntegrationEvaluationContextAware) bean).setIntegrationEvaluationContext(evaluationContext);
		}
		return bean;
	}
","	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof IntegrationEvaluationContextAware) {
			StandardEvaluationContext evaluationContext = IntegrationContextUtils.getEvaluationContext(beanFactory);
			if (bean instanceof IntegrationObjectSupport) {
				ConversionService conversionService = ((IntegrationObjectSupport) bean).getConversionService();
START 				if (conversionService != null) { END 
					evaluationContext.setTypeConverter(new StandardTypeConverter(conversionService));
				}
			}
			((IntegrationEvaluationContextAware) bean).setIntegrationEvaluationContext(evaluationContext);
		}
		return bean;
	}
","	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof IntegrationEvaluationContextAware) {
			StandardEvaluationContext evaluationContext = IntegrationContextUtils.getEvaluationContext(this.beanFactory);
			((IntegrationEvaluationContextAware) bean).setIntegrationEvaluationContext(evaluationContext);
		}
		return bean;
	}
"
1151,I believe we shouldn't close the handle here. It will be closed in the `afterCompletion` method. I think also it will probably be ignored because the handle is still binded to the active transaction.,"    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {
        Handle h = JdbiUtil.getHandle(jdbi);
        R result = callback.withHandle(h);
        // close if not in transaction
        JdbiUtil.closeIfNeeded(h);
        return result;
    }
","    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {
        Handle h = JdbiUtil.getHandle(jdbi);
        R result = callback.withHandle(h);
        // close if not in transaction
START         JdbiUtil.closeIfNeeded(h); END 
        return result;
    }
","    public <R, X extends Exception> R withHandle(HandleCallback<R, X> callback) throws X {
        Handle h = JdbiUtil.getHandle(jdbi);
        try {
            return callback.withHandle(h);
        } finally {
            JdbiUtil.closeIfNeeded(h);
        }
    }
"
1152,"In this case, shouldn't we getrid of the project parameter here (if we know the project, we shouldn't specify an extra initial path, or we should explicitly use the initial path.","	public LanguageServerWrapper(@Nullable IProject project, @NonNull LanguageServerDefinition serverDefinition,
			@Nullable IPath initialPath) {
		this.initialProject = project;
		this.initialPath = initialPath;
		this.allWatchedProjects = new HashSet<>();
		this.serverDefinition = serverDefinition;
		this.connectedDocuments = new HashMap<>();
	}
","START 	public LanguageServerWrapper(@Nullable IProject project, @NonNull LanguageServerDefinition serverDefinition, END 
			@Nullable IPath initialPath) {
		this.initialProject = project;
		this.initialPath = initialPath;
		this.allWatchedProjects = new HashSet<>();
		this.serverDefinition = serverDefinition;
		this.connectedDocuments = new HashMap<>();
	}
","	private LanguageServerWrapper(@Nullable IProject project, @NonNull LanguageServerDefinition serverDefinition,
			@Nullable IPath initialPath) {
		this.initialProject = project;
		this.initialPath = initialPath;
		this.allWatchedProjects = new HashSet<>();
		this.serverDefinition = serverDefinition;
		this.connectedDocuments = new HashMap<>();
	}
"
1153,minor: would prefer that `Cloud_Replica_Keyword` comes before mount path since that would order the path from least to most granular,"  public String getReplicaPath() {
    // GetRequest.Cloud_Replica_Keyword is added to avoid error on its peers.
    return getMountPath() + File.separator + GetRequest.Cloud_Replica_Keyword + File.separator
        + partitionId.toPathString();
  }
","  public String getReplicaPath() {
    // GetRequest.Cloud_Replica_Keyword is added to avoid error on its peers.
START     return getMountPath() + File.separator + GetRequest.Cloud_Replica_Keyword + File.separator END 
        + partitionId.toPathString();
  }
","  public String getReplicaPath() {
    // GetRequest.Cloud_Replica_Keyword is added to avoid error on its peers.
    return GetRequest.Cloud_Replica_Keyword + File.separator + getMountPath() + File.separator
        + partitionId.toPathString();
  }
"
1154,Why can't we add this parent->children listing cache even if the parent status is not in the other map?,"  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {
    UfsStatus status = mStatuses.get(path);
    // If this path doesn't yet exist, we can't keep track of the parent-child relationship
    // We can still add statuses to the cache regardless
    if (status != null) {
      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);
    }
    children.forEach(child -> {
      AlluxioURI childPath = path.joinUnsafe(child.getName());
      addStatus(childPath, child);
    });
  }
","  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {
    UfsStatus status = mStatuses.get(path);
    // If this path doesn't yet exist, we can't keep track of the parent-child relationship
    // We can still add statuses to the cache regardless
START     if (status != null) { END 
      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);
    }
    children.forEach(child -> {
      AlluxioURI childPath = path.joinUnsafe(child.getName());
      addStatus(childPath, child);
    });
  }
","  public Collection<UfsStatus> addChildren(AlluxioURI path, Collection<UfsStatus> children) {
    ConcurrentHashSet<UfsStatus> set = new ConcurrentHashSet<>();
    children.forEach(child -> {
      AlluxioURI childPath = path.joinUnsafe(child.getName());
      addStatus(childPath, child);
      set.add(child);
    });
    return mChildren.put(path, set);
  }
"
1155,"Pointless two level submission. `executeCallbacks()` submits each callback to itself another one time (this means that it's valuable to annotate each method in this class in which executor it's supposed to be run. Given that there are two different executors, plus ""external"", client code execution context (which we kind of shouldn't know where runs)","  private void actionCompleted(SegmentHolder segmentHolder)
  {
    switch (segmentHolder.getType()) {
      case LOAD:
        segmentsToLoad.remove(segmentHolder.getSegment());
        queuedSize.addAndGet(-segmentHolder.getSegmentSize());
        break;
      case DROP:
        segmentsToDrop.remove(segmentHolder.getSegment());
        break;
      default:
        throw new UnsupportedOperationException();
    }

    callBackExecutor.execute(
        () -> executeCallbacks(segmentHolder)
    );
  }
","  private void actionCompleted(SegmentHolder segmentHolder)
  {
    switch (segmentHolder.getType()) {
      case LOAD:
        segmentsToLoad.remove(segmentHolder.getSegment());
        queuedSize.addAndGet(-segmentHolder.getSegmentSize());
        break;
      case DROP:
        segmentsToDrop.remove(segmentHolder.getSegment());
        break;
      default:
        throw new UnsupportedOperationException();
    }

    callBackExecutor.execute(
START         () -> executeCallbacks(segmentHolder) END 
    );
  }
","  private void actionCompleted(SegmentHolder segmentHolder)
  {
    switch (segmentHolder.getType()) {
      case LOAD:
        segmentsToLoad.remove(segmentHolder.getSegment());
        queuedSize.addAndGet(-segmentHolder.getSegmentSize());
        break;
      case DROP:
        segmentsToDrop.remove(segmentHolder.getSegment());
        break;
      default:
        throw new UnsupportedOperationException();
    }
    executeCallbacks(segmentHolder);
  }
"
1156,"Is `this` needed here? If not, consider dropping it.","    public ScheduledReporter build(MetricRegistry registry) {
        GraphiteReporter.Builder builder = builder(registry);

        if (""udp"".equalsIgnoreCase(this.transport)) {
            return builder.build(new GraphiteUDP(host, port));
        } else {
            return builder.build(new Graphite(host, port));
        }
    }
","    public ScheduledReporter build(MetricRegistry registry) {
        GraphiteReporter.Builder builder = builder(registry);

START         if (""udp"".equalsIgnoreCase(this.transport)) { END 
            return builder.build(new GraphiteUDP(host, port));
        } else {
            return builder.build(new Graphite(host, port));
        }
    }
","    public ScheduledReporter build(MetricRegistry registry) {
        GraphiteReporter.Builder builder = builder(registry);

        if (""udp"".equalsIgnoreCase(transport)) {
            return builder.build(new GraphiteUDP(host, port));
        } else {
            return builder.build(new Graphite(host, port));
        }
    }
"
1157,"опять копипаст)
у тебя ж сверху в onConnectionClosedForUser точно такой код,
И вообще если мы удаляем в onConnectionClosedForUser  , то зачем еще здесь? 
onConnectionClosedForUser в любом случае срабатывает когда с юзером связь остаточно закрылась,","    public void onReceiveHangUpFromUser(QBRTCSession session, Integer userId) {
        setStatusForOpponent(userId, getString(R.string.text_status_hang_up));
        Log.d(TAG, ""onReceiveHangUpFromUser userId= "" + userId);
        if (!isPeerToPeerCall) {
            if (userId == userIDFullScreen) {
                Log.d(TAG, ""setAnotherUserToFullScreen call userId= "" + userId);
                setAnotherUserToFullScreen();
            }
            if (videoTrackMap != null && videoTrackMap.containsKey(userId)) {
                Log.d(TAG, ""onReceiveHangUpFromUser videoTrackMap.remove(userId)= "" + userId);
                videoTrackMap.remove(userId);
            }
        }
    }
","    public void onReceiveHangUpFromUser(QBRTCSession session, Integer userId) {
        setStatusForOpponent(userId, getString(R.string.text_status_hang_up));
        Log.d(TAG, ""onReceiveHangUpFromUser userId= "" + userId);
        if (!isPeerToPeerCall) {
            if (userId == userIDFullScreen) {
                Log.d(TAG, ""setAnotherUserToFullScreen call userId= "" + userId);
                setAnotherUserToFullScreen();
            }
START             if (videoTrackMap != null && videoTrackMap.containsKey(userId)) { END 
                Log.d(TAG, ""onReceiveHangUpFromUser videoTrackMap.remove(userId)= "" + userId);
                videoTrackMap.remove(userId);
            }
        }
    }
","    public void onReceiveHangUpFromUser(QBRTCSession session, Integer userId) {
        setStatusForOpponent(userId, getString(R.string.text_status_hang_up));
        Log.d(TAG, ""onReceiveHangUpFromUser userId= "" + userId);
        if (!isPeerToPeerCall) {
            if (userId == userIDFullScreen) {
                Log.d(TAG, ""setAnotherUserToFullScreen call userId= "" + userId);
                setAnotherUserToFullScreen();
            }
        }
    }
"
1158,useless parentheses,"    private boolean isThis(ExpressionTree expression) {
      ExpressionTree expressionNoParenthesis = (ExpressionUtils.skipParentheses(expression));
      if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) {
        String targetName = ((IdentifierTree) expressionNoParenthesis).name();
        return ""this"".equals(targetName);
      }
      return false;
    }
","    private boolean isThis(ExpressionTree expression) {
START       ExpressionTree expressionNoParenthesis = (ExpressionUtils.skipParentheses(expression)); END 
      if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) {
        String targetName = ((IdentifierTree) expressionNoParenthesis).name();
        return ""this"".equals(targetName);
      }
      return false;
    }
","    private boolean isThis(ExpressionTree expression) {
      ExpressionTree expressionNoParenthesis = ExpressionUtils.skipParentheses(expression);
      if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) {
        String targetName = ((IdentifierTree) expressionNoParenthesis).name();
        return ""this"".equals(targetName);
      }
      return false;
    }
"
1159,`Queue::getActualName` ?,"	protected Map<String, Queue> getQueueNamesToQueues() {
		return this.queues.stream()
				.collect(Collectors.toMap(q -> q.getActualName(), q -> q));
	}
","	protected Map<String, Queue> getQueueNamesToQueues() {
		return this.queues.stream()
START 				.collect(Collectors.toMap(q -> q.getActualName(), q -> q)); END 
	}
","	protected Map<String, Queue> getQueueNamesToQueues() {
		return this.queues.stream()
				.collect(Collectors.toMap(Queue::getActualName, q -> q));
	}
"
1160,Using String.valueOf(myBundle.getBundleId()) would make more sense than .valueOf.toString,"	public String toString() {
		Bundle myBundle = getBundle();
		if (myBundle == null)
			return """"; //$NON-NLS-1$
		String name = myBundle.getSymbolicName();
		return name == null ? Long.valueOf(myBundle.getBundleId()).toString() : name;
	}
","	public String toString() {
		Bundle myBundle = getBundle();
		if (myBundle == null)
			return """"; //$NON-NLS-1$
		String name = myBundle.getSymbolicName();
START 		return name == null ? Long.valueOf(myBundle.getBundleId()).toString() : name; END 
	}
","	public String toString() {
		Bundle myBundle = getBundle();
		if (myBundle == null)
			return """"; //$NON-NLS-1$
		String name = myBundle.getSymbolicName();
		return name == null ? String.valueOf(myBundle.getBundleId()) : name;
	}
"
1161,"The test on the ""else"" case isn't needed -- if it's anything but a TextSelection the text can be set to the emprty string.","	public void workbenchSelectionChanged(ISelection selection) {
		Object o = SelectionUtils.getSelectedObject(selection);
		if (o instanceof TextSelection) {
			String text = ((TextSelection) o).getText();
			m_sourceGraphControl.setSourceText(text);
		} else if (o == null) {
			m_sourceGraphControl.setSourceText(""""); //$NON-NLS-1$
		}
	}
","	public void workbenchSelectionChanged(ISelection selection) {
		Object o = SelectionUtils.getSelectedObject(selection);
		if (o instanceof TextSelection) {
			String text = ((TextSelection) o).getText();
			m_sourceGraphControl.setSourceText(text);
START 		} else if (o == null) { END 
			m_sourceGraphControl.setSourceText(""""); //$NON-NLS-1$
		}
	}
","	public void workbenchSelectionChanged(ISelection selection) {
		Object o = SelectionUtils.getSelectedObject(selection);
		if (o instanceof TextSelection) {
			String text = ((TextSelection) o).getText();
			m_sourceGraphControl.setSourceText(text);
		} else {
			m_sourceGraphControl.setSourceText(""""); //$NON-NLS-1$
		}
	}
"
1162,This could be private if you move the field creation to the holder as i suggested.,"	public JBlock getOnDestroyViewAfterSuperBlock() {
		if (onDestroyViewAfterSuperBlock == null) {
			setContentViewRelatedMethods();
		}
		return onDestroyViewAfterSuperBlock;
	}
","START 	public JBlock getOnDestroyViewAfterSuperBlock() { END 
		if (onDestroyViewAfterSuperBlock == null) {
			setContentViewRelatedMethods();
		}
		return onDestroyViewAfterSuperBlock;
	}
","	private JBlock getOnDestroyViewAfterSuperBlock() {
		if (onDestroyViewAfterSuperBlock == null) {
			setContentViewRelatedMethods();
		}
		return onDestroyViewAfterSuperBlock;
	}
"
1163,Use isEmpty() to check whether the collection is empty or not.,"		public boolean hasChildren(Object element) {
			return ((MyModel) element).children.size() > 0;
		}
","		public boolean hasChildren(Object element) {
START 			return ((MyModel) element).children.size() > 0; END 
		}
","		public boolean hasChildren(Object element) {
			return !((MyModel) element).children.isEmpty();
		}
"
1164,I believe we can remove the `try`/`catch` wrappers. No checked Exceptions are thrown. Is there a particular Exception you are anticipating?,"    public GroupedPropertyList getPropertyList() {
        if (propertyList == null) {
        	try{
        		boolean parallel = true;
        		long t1 = System.currentTimeMillis();
        		propertyList = new GroupedPropertyList(individual, vreq, editing,parallel);
        		log.debug("" getPropertyList parallel: ""+parallel+"" time :""+(System.currentTimeMillis()-t1)+"" ms"");
        	}catch(Exception e) {
        		e.printStackTrace();
        	}
        	}
        return propertyList;
    }
","    public GroupedPropertyList getPropertyList() {
        if (propertyList == null) {
START         	try{ END 
        		boolean parallel = true;
        		long t1 = System.currentTimeMillis();
        		propertyList = new GroupedPropertyList(individual, vreq, editing,parallel);
        		log.debug("" getPropertyList parallel: ""+parallel+"" time :""+(System.currentTimeMillis()-t1)+"" ms"");
        	}catch(Exception e) {
        		e.printStackTrace();
        	}
        	}
        return propertyList;
    }
","    public GroupedPropertyList getPropertyList() throws Exception {
        propertyList = new GroupedPropertyList(individual, vreq, editing);
        return propertyList;
    }
"
1165,Remove this ones,"    private void doTheTest(UserGroup g0) {
        String s = MARSHALER.marshal(g0);
        UserGroup ug = MARSHALER.unmarshal(s);

        System.out.println(g0);
        System.out.println(ug);
        System.out.println(s);

        assertTrue(g0.equals(ug));
    }
","    private void doTheTest(UserGroup g0) {
        String s = MARSHALER.marshal(g0);
        UserGroup ug = MARSHALER.unmarshal(s);

START         System.out.println(g0); END 
        System.out.println(ug);
        System.out.println(s);

        assertTrue(g0.equals(ug));
    }
","    private void doTheTest(UserGroup g0) {
        String s = MARSHALER.marshal(g0);
        UserGroup ug = MARSHALER.unmarshal(s);

        assertTrue(g0.equals(ug));
    }
"
1166,This too would benefit from the (proposed) `ConstraintType.EMPTY` enumeration item.,"    String getConstraintType() {

        final ConstraintType constraintType = presenter.getConstraintType();

        if (constraintType == null) {
            return presenter.inferComponentType(presenter.getConstraintValue()).value();
        } else {
            return constraintType.toString();
        }
    }
","    String getConstraintType() {

        final ConstraintType constraintType = presenter.getConstraintType();

START         if (constraintType == null) { END 
            return presenter.inferComponentType(presenter.getConstraintValue()).value();
        } else {
            return constraintType.toString();
        }
    }
","    private String getConstraintType() {
        if (presenter.getConstraintType() == null) {
            return presenter.inferComponentType(presenter.getConstraintValue()).value();
        } else {
            return presenter.getConstraintType().toString();
        }
    }
"
1167,How about WikipediaApp.getInstance() instead?,"    private WikipediaApp getApplication() {
        return (WikipediaApp) getPageActivity().getApplication();
    }
","    private WikipediaApp getApplication() {
START         return (WikipediaApp) getPageActivity().getApplication(); END 
    }
","    private WikipediaApp getApplication() {
        return WikipediaApp.getInstance();
    }
"
1168,Should this be public or private? It is used only in the validator,"    public boolean isHostedEngineDirectLunDisk() {
        return disk.getDiskStorageType() == DiskStorageType.LUN &&
                    StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias());
    }
","START     public boolean isHostedEngineDirectLunDisk() { END 
        return disk.getDiskStorageType() == DiskStorageType.LUN &&
                    StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias());
    }
","    private boolean isHostedEngineDirectLunDisk() {
        return disk.getDiskStorageType() == DiskStorageType.LUN &&
                    StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias());
    }
"
1169,"Same here, JavaDocs for this method please","    public CommunityRest getParentCommunity(@Nullable HttpServletRequest httpServletRequest,
                                            UUID collectionId,
                                            @Nullable Pageable optionalPageable,
                                            Projection projection) {
        try {
            Context context = obtainContext();
            Collection collection = collectionService.find(context, collectionId);
            Community parentCommunity = (Community) collectionService.getParentObject(context, collection);
            if (collection == null) {
                throw new ResourceNotFoundException(""No such collection: "" + collectionId);
            }
            return converter.toRest(parentCommunity, projection);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
","START     public CommunityRest getParentCommunity(@Nullable HttpServletRequest httpServletRequest, END 
                                            UUID collectionId,
                                            @Nullable Pageable optionalPageable,
                                            Projection projection) {
        try {
            Context context = obtainContext();
            Collection collection = collectionService.find(context, collectionId);
            Community parentCommunity = (Community) collectionService.getParentObject(context, collection);
            if (collection == null) {
                throw new ResourceNotFoundException(""No such collection: "" + collectionId);
            }
            return converter.toRest(parentCommunity, projection);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
","    public CommunityRest getParentCommunity(@Nullable HttpServletRequest httpServletRequest,
                                            UUID collectionId,
                                            @Nullable Pageable optionalPageable,
                                            Projection projection) {
        try {
            Context context = obtainContext();
            Collection collection = collectionService.find(context, collectionId);
            if (collection == null) {
                throw new ResourceNotFoundException(""No such collection: "" + collectionId);
            }
            Community parentCommunity = (Community) collectionService.getParentObject(context, collection);
            return converter.toRest(parentCommunity, projection);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
"
1170,Immutable,"	public List<WorkflowAction> findActions(List<WorkflowStep> steps, User user) throws DotDataException,
			DotSecurityException {
		List<WorkflowAction> actions = new ArrayList<>();
        for(WorkflowStep step : steps) {
			actions.addAll(workFlowFactory.findActions(step));
		}
		actions = APILocator.getPermissionAPI().filterCollection(actions, PermissionAPI.PERMISSION_USE, true, user);
		return actions;
	}
","	public List<WorkflowAction> findActions(List<WorkflowStep> steps, User user) throws DotDataException,
			DotSecurityException {
START 		List<WorkflowAction> actions = new ArrayList<>(); END 
        for(WorkflowStep step : steps) {
			actions.addAll(workFlowFactory.findActions(step));
		}
		actions = APILocator.getPermissionAPI().filterCollection(actions, PermissionAPI.PERMISSION_USE, true, user);
		return actions;
	}
","	public List<WorkflowAction> findActions(List<WorkflowStep> steps, User user) throws DotDataException,
			DotSecurityException {
		final ImmutableList.Builder<WorkflowAction> actions = new ImmutableList.Builder<>();
        for(WorkflowStep step : steps) {
			actions.addAll(workFlowFactory.findActions(step));
		}

		return APILocator.getPermissionAPI().filterCollection(actions.build(), PermissionAPI.PERMISSION_USE, true, user);
	}
"
1171,"This code raises two more (previously existing) concerns:
1. Which iconURI has higher priority the descriptor or the part?
2. What happens if the iconURI of the descriptor is changed?","	private String updateIconUri(MPart part) {
		MPartDescriptor desc = modelService.getPartDescriptor(part.getElementId());
		String iconURI = desc != null && desc.getIconURI() != null ? desc.getIconURI() : part.getIconURI();
		part.getTransientData().put(ICON_URI_FOR_PART, iconURI);
		return iconURI;
	}
","	private String updateIconUri(MPart part) {
		MPartDescriptor desc = modelService.getPartDescriptor(part.getElementId());
START 		String iconURI = desc != null && desc.getIconURI() != null ? desc.getIconURI() : part.getIconURI(); END 
		part.getTransientData().put(ICON_URI_FOR_PART, iconURI);
		return iconURI;
	}
","	private String updateIconUri(MPart part) {
		MPartDescriptor desc = modelService.getPartDescriptor(part.getElementId());
		String iconURI = part.getIconURI();
		if (iconURI == null && desc != null) {
			iconURI = desc.getIconURI();
		}
		part.getTransientData().put(ICON_URI_FOR_PART, iconURI);
		return iconURI;
	}
"
1172,This will throw redundancy warnings in IntelliJ,"  private Map<String, Pair<Class, Object>> getOverriddenReturnTypes(){
    //Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes
    //Provide the attribute name as key, and a pair of returntype (Class) and a Object to be used as test value
    Map<String, Pair<Class, Object>> map = new HashMap<>();
    return map;
    }
","  private Map<String, Pair<Class, Object>> getOverriddenReturnTypes(){
    //Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes
    //Provide the attribute name as key, and a pair of returntype (Class) and a Object to be used as test value
    Map<String, Pair<Class, Object>> map = new HashMap<>();
START     return map; END 
    }
","  private Map<String, Pair<Class, Object>> getOverriddenReturnTypes(){
    //Add attributes with 'smart' getters and setters that convert back and forth to correct values for MOLGENIS datatypes
    //Provide the attribute name as key, and a pair of return type (Class) and an Object to be used as test value
    return new HashMap<>();
    }
"
1173,why is it public?,"    public String getParentId(String testId) {
        return (String) getHibernateTemplate().find(""select distinct w.parentId from WorkloadData w where w.taskId=? and w.sessionId=?"", testId, sessionId).get(0);
    }
","START     public String getParentId(String testId) { END 
        return (String) getHibernateTemplate().find(""select distinct w.parentId from WorkloadData w where w.taskId=? and w.sessionId=?"", testId, sessionId).get(0);
    }
","    private String getParentId(String testId) {
        return (String) getHibernateTemplate().find(""select distinct w.parentId from WorkloadData w where w.taskId=? and w.sessionId=?"", testId, sessionId).get(0);
    }
"
1174,"Why can't you just return diskList? If I'm not mistaken DbFacade does not return null lists, only empty","    protected void executeQueryCommand() {
        List<Disk> diskList = DbFacade.getInstance()
                .getDiskDao()
                .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(),
                        getParameters().getVmId(),
                        getUserID(),
                        getParameters().isFiltered());
        if (CollectionUtils.isEmpty(diskList)) {
            setReturnValue(new ArrayList<>());
            return;
        }

        setReturnValue(filterDisks(diskList));
    }
","    protected void executeQueryCommand() {
        List<Disk> diskList = DbFacade.getInstance()
                .getDiskDao()
                .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(),
                        getParameters().getVmId(),
                        getUserID(),
                        getParameters().isFiltered());
        if (CollectionUtils.isEmpty(diskList)) {
START             setReturnValue(new ArrayList<>()); END 
            return;
        }

        setReturnValue(filterDisks(diskList));
    }
","    protected void executeQueryCommand() {
        List<Disk> diskList = DbFacade.getInstance()
                .getDiskDao()
                .getAllAttachableDisksByPoolId(getParameters().getStoragePoolId(),
                        getParameters().getVmId(),
                        getUserID(),
                        getParameters().isFiltered());
        if (CollectionUtils.isEmpty(diskList)) {
            setReturnValue(diskList);
            return;
        }

        setReturnValue(filterDisks(diskList));
    }
"
1175,"Oh, is this why we don't need thread-safety on filter hashcode methods i guess? This seems kind of a funny way to prime them with the cached values, I think maybe the supplier.memoize pattern would be a little cleaner and make this not necessary?","  public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent(
      Filter filter,
      List<JoinableClause> clauses,
      VirtualColumns virtualColumns
  )
  {
    // Some filters have potentially expensive hash codes that are lazily computed and cached.
    // We call hashCode() here in a synchronized block before we attempt to use the Filter in the analyses map,
    // to ensure that the hashCode is only computed once per Filter since the Filter interface is not thread-safe.
    synchronized (analyses) {
      if (filter != null) {
        filter.hashCode();
      }
    }

    JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns);
    return analyses.computeIfAbsent(
        key,
        (groupKey) -> {
          return JoinFilterAnalyzer.computeJoinFilterPreAnalysis(
              JoinableClauses.fromList(clauses),
              virtualColumns,
              filter,
              joinFilterRewriteConfig
          );
        }
    );
  }
","  public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent(
      Filter filter,
      List<JoinableClause> clauses,
      VirtualColumns virtualColumns
  )
  {
    // Some filters have potentially expensive hash codes that are lazily computed and cached.
    // We call hashCode() here in a synchronized block before we attempt to use the Filter in the analyses map,
    // to ensure that the hashCode is only computed once per Filter since the Filter interface is not thread-safe.
    synchronized (analyses) {
      if (filter != null) {
START         filter.hashCode(); END 
      }
    }

    JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns);
    return analyses.computeIfAbsent(
        key,
        (groupKey) -> {
          return JoinFilterAnalyzer.computeJoinFilterPreAnalysis(
              JoinableClauses.fromList(clauses),
              virtualColumns,
              filter,
              joinFilterRewriteConfig
          );
        }
    );
  }
","  public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent(
      Filter filter,
      List<JoinableClause> clauses,
      VirtualColumns virtualColumns
  )
  {
    JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns);
    return analyses.computeIfAbsent(
        key,
        (groupKey) -> {
          return JoinFilterAnalyzer.computeJoinFilterPreAnalysis(
              JoinableClauses.fromList(clauses),
              virtualColumns,
              filter,
              joinFilterRewriteConfig
          );
        }
    );
  }
"
1176,"there is already a constr, which takes (id,groupId,resource, dataSource,interval)
Can we use that in indexTask, instead of adding a new one ?","  protected AbstractFixedIntervalTask(
      String id,
      TaskResource taskResource,
      String dataSource,
      Interval interval
  )
  {
    this(id, id, taskResource, dataSource, interval);
  }
","  protected AbstractFixedIntervalTask(
      String id,
START       TaskResource taskResource, END 
      String dataSource,
      Interval interval
  )
  {
    this(id, id, taskResource, dataSource, interval);
  }
","  protected AbstractFixedIntervalTask(
      String id,
      TaskResource taskResource,
      String dataSource,
      Interval interval
  )
  {
    this(
        id,
        id,
        taskResource == null ? new TaskResource(id, 1) : taskResource,
        dataSource,
        interval
    );
  }
"
1177,You can use the expectedExceptions and expectedExceptionsMessageRegExp attributes of the @Test annotation,"  private Object[][] finderSupportedResourceTypeData()
  {
    return new Object[][]
        {
            { FinderSupportedAssociationDataResource.class },
            { FinderSupportedComplexKeyDataResource.class },
            { FinderWithActionResource.class }
        };
  }
","  private Object[][] finderSupportedResourceTypeData()
  {
    return new Object[][]
START         { END 
            { FinderSupportedAssociationDataResource.class },
            { FinderSupportedComplexKeyDataResource.class },
            { FinderWithActionResource.class }
        };
  }
","  private Object[][] finderSupportedResourceTypeData()
  {
    return new Object[][]
        {
            { FinderSupportedAssociationDataResource.class },
            { FinderSupportedComplexKeyDataResource.class }
        };
  }
"
1178,"We actually don't need this line at all.
The test check something else","    public void addNotEmptyIdConnection() {
        StorageServerConnections newPosixConnection =
                createPosixConnection(""multipass.my.domain.tlv.company.com:/export/allstorage/data1"",
                        StorageType.POSIXFS,
                        ""nfs"",
                        ""timeo=30"");
        newPosixConnection.setId(Guid.newGuid().toString());
        parameters.setStorageServerConnection(newPosixConnection);
        parameters.setVdsId(Guid.Empty);
        doReturn(newPosixConnection.getId()).when(command).isConnWithSameDetailsExists(newPosixConnection, null);
        ValidateTestUtils.runAndAssertValidateFailure(command,
                EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
","    public void addNotEmptyIdConnection() {
        StorageServerConnections newPosixConnection =
                createPosixConnection(""multipass.my.domain.tlv.company.com:/export/allstorage/data1"",
                        StorageType.POSIXFS,
                        ""nfs"",
                        ""timeo=30"");
        newPosixConnection.setId(Guid.newGuid().toString());
        parameters.setStorageServerConnection(newPosixConnection);
        parameters.setVdsId(Guid.Empty);
        START  doReturn(newPosixConnection.getId()).when(command).isConnWithSameDetailsExists(newPosixConnection, null); END 
        ValidateTestUtils.runAndAssertValidateFailure(command,
                EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
","    public void addNotEmptyIdConnection() {
        StorageServerConnections newPosixConnection =
                createPosixConnection(""multipass.my.domain.tlv.company.com:/export/allstorage/data1"",
                        StorageType.POSIXFS,
                        ""nfs"",
                        ""timeo=30"");
        newPosixConnection.setId(Guid.newGuid().toString());
        parameters.setStorageServerConnection(newPosixConnection);
        parameters.setVdsId(Guid.Empty);
        ValidateTestUtils.runAndAssertValidateFailure(command,
                EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ID_NOT_EMPTY);
    }
"
1179,"I think if it's not visible, click should fail, so is the assertion needed?","  public void mercury_topbar_wikiaLogoRedirectsToFandomPage() {
    TopBar topBar =
        new ArticlePage()
            .open(MercurySubpages.MAIN_PAGE)
            .getTopBar();

    Assertion.assertTrue(topBar.isLogoVisible());
    topBar.clickWikiaLogo();

    Assertion.assertTrue(topBar.getCurrentUrl().contains(""www.wikia.com/fandom""));
  }
","  public void mercury_topbar_wikiaLogoRedirectsToFandomPage() {
    TopBar topBar =
        new ArticlePage()
            .open(MercurySubpages.MAIN_PAGE)
            .getTopBar();

START     Assertion.assertTrue(topBar.isLogoVisible()); END 
    topBar.clickWikiaLogo();

    Assertion.assertTrue(topBar.getCurrentUrl().contains(""www.wikia.com/fandom""));
  }
","  public void mercury_topbar_wikiaLogoRedirectsToFandomPage() {
    TopBar topBar =
        new ArticlePage()
            .open(MercurySubpages.MAIN_PAGE)
            .getTopBar();

    topBar.clickWikiaLogo();

    Assertion.assertTrue(topBar.getCurrentUrl().contains(""www.wikia.com/fandom""));
  }
"
1180,Should this be initialized in a static / thread-safe context?,"    private ConfigurationServiceImplService getConfigService() throws ConnectionManagerException, MalformedURLException{
        String url = oProxyHelper.getAdapterEndPointFromConnectionManager(DirectConfigConstants.DIRECT_CONFIG_SERVICE_NAME);
        
        if(cfService == null) {
            cfService = new ConfigurationServiceImplService(new URL(url+""?wsdl""));
        }
        
        return cfService;
    }
","    private ConfigurationServiceImplService getConfigService() throws ConnectionManagerException, MalformedURLException{
        String url = oProxyHelper.getAdapterEndPointFromConnectionManager(DirectConfigConstants.DIRECT_CONFIG_SERVICE_NAME);
        
        if(cfService == null) {
START             cfService = new ConfigurationServiceImplService(new URL(url+""?wsdl"")); END 
        }
        
        return cfService;
    }
","    protected ConfigurationServiceImplService getConfigService() throws ConnectionManagerException, MalformedURLException{
        return cfService;
    }
"
1181,"This is a minor detail but the the assertZZZ methods work like this assertZZZ(expected, actual), this is valid for the whole of your test files. Also please format the file as some "","" have no space after them.","    void testDtoListResponses() {
        FlowJsonObjectReader reader = new FlowJsonObjectReader();
        TypeReference<SurveyGroupDto> typeReference = new TypeReference<SurveyGroupDto>() {};
        List<SurveyGroupDto> surveyList = null;

        try {
            surveyList = reader.readDtoListObject(DTO_LIST_JSON_OBJECT, typeReference);
        } catch (IOException e) {
            //
        }

        assertNotEquals(surveyList, null);
        assertEquals(surveyList.size(), 1);
        assertEquals(surveyList.get(0).getName(),""1.10.36 all questions"");
    }
","    void testDtoListResponses() {
        FlowJsonObjectReader reader = new FlowJsonObjectReader();
        TypeReference<SurveyGroupDto> typeReference = new TypeReference<SurveyGroupDto>() {};
        List<SurveyGroupDto> surveyList = null;

        try {
            surveyList = reader.readDtoListObject(DTO_LIST_JSON_OBJECT, typeReference);
        } catch (IOException e) {
            //
        }

        assertNotEquals(surveyList, null);
        assertEquals(surveyList.size(), 1);
START         assertEquals(surveyList.get(0).getName(),""1.10.36 all questions""); END 
    }
","    void testDtoListResponses() {
        FlowJsonObjectReader reader = new FlowJsonObjectReader();
        TypeReference<SurveyGroupDto> typeReference = new TypeReference<SurveyGroupDto>() {};
        List<SurveyGroupDto> surveyList = null;

        try {
            surveyList = reader.readDtoListObject(DTO_LIST_JSON_OBJECT, typeReference);
        } catch (IOException e) {
            // ignoring exception
        }

        assertNotEquals(null, surveyList);
        assertEquals(1, surveyList.size());
        assertEquals(""1.10.36 all questions"", surveyList.get(0).getName());
    }
"
1182,We should replace null columns with all_columns before verification or we will get exception. You have changed initial order of statements.,"  public GroupScan clone(List<SchemaPath> columns) {
    HBaseUtils.verifyColumns(columns, hTableDesc);
    HBaseGroupScan newScan = new HBaseGroupScan(this);
    newScan.columns = columns == null ? ALL_COLUMNS : columns;
    return newScan;
  }
","  public GroupScan clone(List<SchemaPath> columns) {
START     HBaseUtils.verifyColumns(columns, hTableDesc); END 
    HBaseGroupScan newScan = new HBaseGroupScan(this);
    newScan.columns = columns == null ? ALL_COLUMNS : columns;
    return newScan;
  }
","  public GroupScan clone(List<SchemaPath> columns) {
    HBaseGroupScan newScan = new HBaseGroupScan(this);
    newScan.columns = columns == null ? ALL_COLUMNS : columns;
    HBaseUtils.verifyColumns(columns, hTableDesc);
    return newScan;
  }
"
1183,Can be private method.,"    static <T, U> Function<T, Result<U>> reportMissing(Class<?> expectedClass) {
        return t ->
                Result.failure(
                        ""Not yet implemented: "" +
                                Optional.ofNullable(t)
                                        .map(o -> o.getClass().getCanonicalName())
                                        .orElse(""null -- expected "" + expectedClass.getCanonicalName()));
    }
","START     static <T, U> Function<T, Result<U>> reportMissing(Class<?> expectedClass) { END 
        return t ->
                Result.failure(
                        ""Not yet implemented: "" +
                                Optional.ofNullable(t)
                                        .map(o -> o.getClass().getCanonicalName())
                                        .orElse(""null -- expected "" + expectedClass.getCanonicalName()));
    }
","    private static <T, U> Function<T, Result<U>> reportMissing(Class<?> expectedClass) {
        return t ->
                Result.failure(
                        ""Not yet implemented: "" +
                                Optional.ofNullable(t)
                                        .map(o -> o.getClass().getCanonicalName())
                                        .orElse(""null -- expected "" + expectedClass.getCanonicalName()));
    }
"
1184,"hmm, I don't think this can get build pass.","    private void rematchAllNetworksAndRequests() {
        // TODO: This may be slow, and should be optimized.
        final long now = SystemClock.elapsedRealtime();
        final NetworkReassignment changes = computeNetworkReassignment();
        if (VDBG || DDBG) log(changes.toString());
        applyNetworkReassignment(changes, oldDefaultNetwork, now);
    }
","    private void rematchAllNetworksAndRequests() {
        // TODO: This may be slow, and should be optimized.
        final long now = SystemClock.elapsedRealtime();
        final NetworkReassignment changes = computeNetworkReassignment();
        if (VDBG || DDBG) log(changes.toString());
        applyNetworkReassignment(changes, START  oldDefaultNetwork, now); END 
    }
","    private void rematchAllNetworksAndRequests() {
        // TODO: This may be slow, and should be optimized.
        final long now = SystemClock.elapsedRealtime();
        final NetworkReassignment changes = computeNetworkReassignment();
        if (VDBG || DDBG) log(changes.toString());
        applyNetworkReassignment(changes, now);
    }
"
1185,"wdyt if we replace it by ` return Objects.requireNonNullElse(scroller, DEFAULT_SCROLLER)` if you agree you will have some adaptation on 10.10 (java 8)","    public String getScroller() {
        return scroller == null ? DEFAULT_SCROLLER : scroller;
    }
","    public String getScroller() {
START         return scroller == null ? DEFAULT_SCROLLER : scroller; END 
    }
","    public String getScroller() {
        return scroller;
    }
"
1186,Nit: unnecessary this.,"  public String getMessage(){
    return this.message;
  }
","  public String getMessage(){
START     return this.message; END 
  }
","  public String getMessage(){
    return message;
  }
"
1187,no need for `.toString()`,"    public Type convertReadValueToType(String pvReadValue) {
        Type lvType = convertReadValueToUnmodifiedType(pvReadValue);

        for (InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList()) {
            logger.debug(""type of {} before modifier:{} type={}"", getDevicePropertyPath(),
                    lvTypeModifier.getModifierName(), lvType.toString());
            lvType = lvTypeModifier.modify4Read(lvType);
            logger.debug(""type of {} after modifier:{} type={}"", getDevicePropertyPath(),
                    lvTypeModifier.getModifierName(), lvType.toString());
        }

        return lvType;
    }
","    public Type convertReadValueToType(String pvReadValue) {
        Type lvType = convertReadValueToUnmodifiedType(pvReadValue);

        for (InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList()) {
            logger.debug(""type of {} before modifier:{} type={}"", getDevicePropertyPath(),
START                     lvTypeModifier.getModifierName(), lvType.toString()); END 
            lvType = lvTypeModifier.modify4Read(lvType);
            logger.debug(""type of {} after modifier:{} type={}"", getDevicePropertyPath(),
                    lvTypeModifier.getModifierName(), lvType.toString());
        }

        return lvType;
    }
","    public Type convertReadValueToType(String pvReadValue) {
        Type lvType = convertReadValueToUnmodifiedType(pvReadValue);

        for (InterfaceOneWireTypeModifier lvTypeModifier : getTypeModifieryList()) {
            logger.debug(""type of {} before modifier:{} type={}"", getDevicePropertyPath(),
                    lvTypeModifier.getModifierName(), lvType);
            lvType = lvTypeModifier.modify4Read(lvType);
            logger.debug(""type of {} after modifier:{} type={}"", getDevicePropertyPath(),
                    lvTypeModifier.getModifierName(), lvType);
        }

        return lvType;
    }
"
1188,this should be synchronized as well,"    public void clear() {
        this.domainsVisibility.clear();
    }
","START     public void clear() { END 
        this.domainsVisibility.clear();
    }
","    public synchronized void clear() {
        this.domainsVisibility.clear();
    }
"
1189,"Since you are at it, can you please change this to `long` primitive type? :)","    public static Comment newComment(long issueId, int newCommentId, String comment) {
        DateTime now = DateTime.now();
        Long id = Long.parseLong(issueId + ""0"" + newCommentId);
        URI selfUri = URI.create(TEST_JIRA_URL + ""/rest/api/latest/issue/"" + issueId + ""/comment"");
        return new Comment(selfUri, comment, null, null, now, null, null, id);
    }
","    public static Comment newComment(long issueId, int newCommentId, String comment) {
        DateTime now = DateTime.now();
START         Long id = Long.parseLong(issueId + ""0"" + newCommentId); END 
        URI selfUri = URI.create(TEST_JIRA_URL + ""/rest/api/latest/issue/"" + issueId + ""/comment"");
        return new Comment(selfUri, comment, null, null, now, null, null, id);
    }
","    public static Comment newComment(long issueId, int newCommentId, String comment) {
        DateTime now = DateTime.now();
        long id = Long.parseLong(issueId + ""0"" + newCommentId);
        URI selfUri = URI.create(TEST_JIRA_URL + ""/rest/api/latest/issue/"" + issueId + ""/comment"");
        return new Comment(selfUri, comment, null, null, now, null, null, id);
    }
"
1190,I don't think this works. We're swapping out `context` with a different instance.  We should probably use a constant as a monitor.,"        private void registerGlueCodeScope(ConfigurableApplicationContext context) {
            do {
                synchronized (context) {
                    context.getBeanFactory().registerScope(SCOPE_CUCUMBER_GLUE, new GlueCodeScope());
                    context = (ConfigurableApplicationContext) context.getParent();
                }
            } while (context != null);
        }
","        private void registerGlueCodeScope(ConfigurableApplicationContext context) {
            do {
START                 synchronized (context) { END 
                    context.getBeanFactory().registerScope(SCOPE_CUCUMBER_GLUE, new GlueCodeScope());
                    context = (ConfigurableApplicationContext) context.getParent();
                }
            } while (context != null);
        }
","        private void registerGlueCodeScope(ConfigurableApplicationContext context) {
            do {
                context.getBeanFactory().registerScope(SCOPE_CUCUMBER_GLUE, new GlueCodeScope());
                context = (ConfigurableApplicationContext) context.getParent();
            } while (context != null);
        }
"
1191,"This line will actually return a substring of length maxLength + 1. If the substring indeed needs to be no longer than maxLength, then replace ""maxLength + 1"" with just ""maxLength"".","    private String truncateMessageLength(String message, int maxLength) {
        if (message.length() > maxLength) {
            message = message.substring(0, maxLength + 1);
        }
        return message;
    }
","    private String truncateMessageLength(String message, int maxLength) {
        if (message.length() > maxLength) {
START             message = message.substring(0, maxLength + 1); END 
        }
        return message;
    }
","    private String truncateMessageLength(String message, int maxLength) {
        if (message.length() > maxLength) {
            message = message.substring(0, maxLength);
        }
        return message;
    }
"
1192,double `;`,"    public void testErrorReceived() {
        TestObserver<Object> ts = new TestObserver<Object>();
        TestException ex = new TestException(""boo"");
        Flowable.error(ex).ignoreElements().subscribe(ts);
        ts.assertNoValues();
        ts.assertTerminated();;
        ts.assertError(TestException.class);
        ts.assertErrorMessage(""boo"");
    }
","    public void testErrorReceived() {
        TestObserver<Object> ts = new TestObserver<Object>();
        TestException ex = new TestException(""boo"");
        Flowable.error(ex).ignoreElements().subscribe(ts);
        ts.assertNoValues();
START         ts.assertTerminated();; END 
        ts.assertError(TestException.class);
        ts.assertErrorMessage(""boo"");
    }
","    public void testErrorReceived() {
        TestObserver<Object> ts = new TestObserver<Object>();
        TestException ex = new TestException(""boo"");
        Flowable.error(ex).ignoreElements().subscribe(ts);
        ts.assertNoValues();
        ts.assertTerminated();
        ts.assertError(TestException.class);
        ts.assertErrorMessage(""boo"");
    }
"
1193,unnecessary linebreak,"	public boolean select(Viewer viewer, Object parentElement,
			Object element) {
		if (!(element instanceof DisplayItem)) {
			return false;
		}
		if (actionSet == null) {
			return false;
		}
		return CustomizePerspectiveDialog.includeInSetStructure((DisplayItem) element, actionSet);
	}
","	public boolean select(Viewer viewer, Object parentElement,
START 			Object element) { END 
		if (!(element instanceof DisplayItem)) {
			return false;
		}
		if (actionSet == null) {
			return false;
		}
		return CustomizePerspectiveDialog.includeInSetStructure((DisplayItem) element, actionSet);
	}
","	public boolean select(Viewer viewer, Object parentElement, Object element) {
		if (!(element instanceof DisplayItem) || actionSet == null) {
			return false;
		}
		return CustomizePerspectiveDialog.includeInSetStructure((DisplayItem) element, actionSet);
	}
"
1194,Why not just bump it up to `180` across the board?,"    public static void runJSTestSuite() throws InterruptedException {
        // FIXME Update this when we stop using ARM Emulators
        int timeout = Build.SUPPORTED_ABIS[0].contains(""armeabi"") ? 180 : 60;
        JSTestCase.runJSTestSuite(JS_SUITE, data(), timeout);
    }
","    public static void runJSTestSuite() throws InterruptedException {
        // FIXME Update this when we stop using ARM Emulators
        int timeout = Build.SUPPORTED_ABIS[0].contains(""armeabi"") ? 180 : 60;
START         JSTestCase.runJSTestSuite(JS_SUITE, data(), timeout); END 
    }
","    public static void runJSTestSuite() throws InterruptedException {
        // FIXME Change timeout back to 60 when we stop using ARM Emulators
        JSTestCase.runJSTestSuite(JS_SUITE, data(), 180);
    }
"
1195,Nit: declare as `Map`,"    public Map<String, String> getSystemSessionProperties(SessionConfigurationContext context)
    {
        HashMap<String, String> combinedProperties = new HashMap<>();
        for (SessionMatchSpec sessionMatchSpec : sessionMatchSpecs) {
            combinedProperties.putAll(sessionMatchSpec.match(context));
        }

        return ImmutableMap.copyOf(combinedProperties);
    }
","    public Map<String, String> getSystemSessionProperties(SessionConfigurationContext context)
    {
START         HashMap<String, String> combinedProperties = new HashMap<>(); END 
        for (SessionMatchSpec sessionMatchSpec : sessionMatchSpecs) {
            combinedProperties.putAll(sessionMatchSpec.match(context));
        }

        return ImmutableMap.copyOf(combinedProperties);
    }
","    public Map<String, String> getSystemSessionProperties(SessionConfigurationContext context)
    {
        // later properties override earlier properties
        Map<String, String> combinedProperties = new HashMap<>();
        for (SessionMatchSpec sessionMatchSpec : sessionMatchSpecs) {
            combinedProperties.putAll(sessionMatchSpec.match(context));
        }

        return ImmutableMap.copyOf(combinedProperties);
    }
"
1196,"I thought it would be something like

```
LOG.info(""Request ID: {} access from: {} principal: {} operation: {}"",
                 requestId, remoteAddress, principal, operation);
```

and ThriftAccessLogger.log would just go away","  public static void logAccess(Integer requestId, InetAddress remoteAddress, Principal principal, String operation) {
    new ThriftAccessLogger().log(
      String.format(""Request ID: {} access from: {} principal: {} operation: {}"",
                    requestId, remoteAddress, principal, operation));
  } 
","  public static void logAccess(Integer requestId, InetAddress remoteAddress, Principal principal, String operation) {
    new ThriftAccessLogger().log(
      String.format(""Request ID: {} access from: {} principal: {} operation: {}"",
                    requestId, remoteAddress, principal, operation));
START   }  END 
","    public static void logAccess(Integer requestId, InetAddress remoteAddress,
                                 Principal principal, String operation) {
        LOG.info(""Request ID: {} access from: {} principal: {} operation: {}"",
                 requestId, remoteAddress, principal, operation);
    }
"
1197,"`getActiveInstance` is deprecated, please use good old `getInstance`.","    public static List<String> getComputerNames() {
        final ArrayList<String> names = new ArrayList<String>();
        for (Computer c : Jenkins.getActiveInstance().getComputers()) {
            if (!c.getName().isEmpty()) {
                names.add(c.getName());
            }
        }
        return names;
    }
","    public static List<String> getComputerNames() {
        final ArrayList<String> names = new ArrayList<String>();
START         for (Computer c : Jenkins.getActiveInstance().getComputers()) { END 
            if (!c.getName().isEmpty()) {
                names.add(c.getName());
            }
        }
        return names;
    }
","    public static List<String> getComputerNames() {
        final ArrayList<String> names = new ArrayList<String>();
        for (Computer c : Jenkins.getInstance().getComputers()) {
            if (!c.getName().isEmpty()) {
                names.add(c.getName());
            }
        }
        return names;
    }
"
1198,"As above, you must perform both the read and the write in the critical section, otherwise there's no guarantee of consistency.","    public void unbind(final String eventName, final SubscriptionEventListener listener) {

        validateArguments(eventName, listener);

        final Set<SubscriptionEventListener> listeners = eventNameToListenerMap.get(eventName);
        synchronized (lock) {
            if (listeners != null) {
                listeners.remove(listener);
                if (listeners.isEmpty()) {
                        eventNameToListenerMap.remove(eventName);
                }
            }
        }
    }
","    public void unbind(final String eventName, final SubscriptionEventListener listener) {

        validateArguments(eventName, listener);

START         final Set<SubscriptionEventListener> listeners = eventNameToListenerMap.get(eventName); END 
        synchronized (lock) {
            if (listeners != null) {
                listeners.remove(listener);
                if (listeners.isEmpty()) {
                        eventNameToListenerMap.remove(eventName);
                }
            }
        }
    }
","    public void unbind(final String eventName, final SubscriptionEventListener listener) {

        validateArguments(eventName, listener);

        synchronized (lock) {
            final Set<SubscriptionEventListener> listeners = eventNameToListenerMap.get(eventName);
            if (listeners != null) {
                listeners.remove(listener);
                if (listeners.isEmpty()) {
                    eventNameToListenerMap.remove(eventName);
                }
            }
        }
    }
"
1199,"If list.get(ListKey.ALL) returns a reasonable upper bounds for the size, I think that an ArrayList would likely be faster.","  public Iterable<AccountGroup> all() {
    final List<AccountGroup> groups = new LinkedList<AccountGroup>();
    for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) {
      final AccountGroup group = get(groupName);
      if (group != null) {
        groups.add(group);
      }
    }
    return Collections.unmodifiableList(groups);
  }
","  public Iterable<AccountGroup> all() {
START     final List<AccountGroup> groups = new LinkedList<AccountGroup>(); END 
    for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) {
      final AccountGroup group = get(groupName);
      if (group != null) {
        groups.add(group);
      }
    }
    return Collections.unmodifiableList(groups);
  }
","  public Iterable<AccountGroup> all() {
    final List<AccountGroup> groups = new ArrayList<AccountGroup>();
    for (final AccountGroup.NameKey groupName : list.get(ListKey.ALL)) {
      final AccountGroup group = get(groupName);
      if (group != null) {
        groups.add(group);
      }
    }
    return Collections.unmodifiableList(groups);
  }
"
1200,"We have a large number of tests that don't use `TestHazelcastInstanceFactory` at all and call `Hazelcast.newHazelcastInstance()` directly (in combination with `Hazelcast.shutdownAll()` / `HazelcastInstanceFactory.shutdownAll()` / `HazelcastInstanceFactory.terminateAll()`). Shouldn't those be checked as well, somehow?","    public void terminate(HazelcastInstance instance) {
        try {
            Address address = getNode(instance).address;
            terminateInstance(instance);
            if (isMockNetwork) {
                registry.removeInstance(address);
            }
        } finally {
            TestJmxLeakHelper.checkJmxBeans(instance.getName());
        }
    }
","    public void terminate(HazelcastInstance instance) {
        try {
            Address address = getNode(instance).address;
            terminateInstance(instance);
            if (isMockNetwork) {
                registry.removeInstance(address);
            }
        } finally {
START             TestJmxLeakHelper.checkJmxBeans(instance.getName()); END 
        }
    }
","    public void terminate(HazelcastInstance instance) {
        Address address = getNode(instance).address;
        terminateInstance(instance);
        if (isMockNetwork) {
            registry.removeInstance(address);
        }
    }
"
1201,please change to setSucceeded,"    public void endSuccessfully() {
        super.endSuccessfully();
        if (getParameters().getImportAsTemplate()) {
            Guid newTemplateId = createTemplate();
            // No reason for this to happen, but checking just to make sure
            if (newTemplateId != null) {
                attachDiskToTemplate(newTemplateId);
            }
        }
        updateDiskStatus(ImageStatus.OK);
        getReturnValue().setSucceeded(true);
    }
","    public void endSuccessfully() {
        super.endSuccessfully();
        if (getParameters().getImportAsTemplate()) {
            Guid newTemplateId = createTemplate();
            // No reason for this to happen, but checking just to make sure
            if (newTemplateId != null) {
                attachDiskToTemplate(newTemplateId);
            }
        }
        updateDiskStatus(ImageStatus.OK);
START         getReturnValue().setSucceeded(true); END 
    }
","    public void endSuccessfully() {
        super.endSuccessfully();
        if (getParameters().getImportAsTemplate()) {
            Guid newTemplateId = createTemplate();
            // No reason for this to happen, but checking just to make sure
            if (newTemplateId != null) {
                attachDiskToTemplate(newTemplateId);
            }
        }
        updateDiskStatus(ImageStatus.OK);
        setSucceeded(true);
    }
"
1202,Interesting wrapping style :),"   void validate() {
      // No-op, no validation required
   }
","START    void validate() { END 
      // No-op, no validation required
   }
","   public void validate() {
      // No-op, no validation required
   }
"
1203,"deliverEvents does not handle interruptions, so this is essentially a no-op if `previous` is already executing.","    private void scheduleImmediateDelivery() {
        cancelDelayedDelivery();

        while (state == State.RUNNING) {
            DeliveryAttempt previous = immediateDelivery.get();
            if (previous != null && !previous.isDone())
                previous.cancel();

            DeliveryAttempt current = new DeliveryAttempt();
            if (immediateDelivery.compareAndSet(previous, current)) {
                current.executeNow();
                return;
            }
        }
    }
","    private void scheduleImmediateDelivery() {
        cancelDelayedDelivery();

        while (state == State.RUNNING) {
            DeliveryAttempt previous = immediateDelivery.get();
            if (previous != null && !previous.isDone())
START                 previous.cancel(); END 

            DeliveryAttempt current = new DeliveryAttempt();
            if (immediateDelivery.compareAndSet(previous, current)) {
                current.executeNow();
                return;
            }
        }
    }
","    private void scheduleImmediateDelivery() {
        cancelDelayedDelivery();

        while (state == State.RUNNING) {
            DeliveryAttempt previous = immediateDelivery.get();
            if (previous != null)
                previous.cancel();

            DeliveryAttempt current = new DeliveryAttempt();
            if (immediateDelivery.compareAndSet(previous, current)) {
                current.executeNow();
                return;
            }
        }
    }
"
1204,Why do gauges get timestamp twice?,"    private static ObjectNode handleGaugeRollup(GaugeRollup rollup) {
        ObjectNode rollupNode = JsonNodeFactory.instance.objectNode();
        rollupNode.put(""timestamp"", rollup.getTimestamp());
        SimpleNumber rollupValue = rollup.getLatestValue();
        rollupNode.put(""latestVal"", rollupValue.getDataType() == (SimpleNumber.Type.DOUBLE) ? rollupValue.getValue().doubleValue() : rollupValue.getValue().longValue());
        return handleBasicRollup(rollup, rollupNode);
    }
","    private static ObjectNode handleGaugeRollup(GaugeRollup rollup) {
        ObjectNode rollupNode = JsonNodeFactory.instance.objectNode();
START         rollupNode.put(""timestamp"", rollup.getTimestamp()); END 
        SimpleNumber rollupValue = rollup.getLatestValue();
        rollupNode.put(""latestVal"", rollupValue.getDataType() == (SimpleNumber.Type.DOUBLE) ? rollupValue.getValue().doubleValue() : rollupValue.getValue().longValue());
        return handleBasicRollup(rollup, rollupNode);
    }
","    private static ObjectNode handleGaugeRollup(GaugeRollup rollup) {
        ObjectNode rollupNode = JsonNodeFactory.instance.objectNode();
        SimpleNumber rollupValue = rollup.getLatestValue();
        rollupNode.put(""latestVal"", rollupValue.getDataType() == (SimpleNumber.Type.DOUBLE) ? rollupValue.getValue().doubleValue() : rollupValue.getValue().longValue());
        return handleBasicRollup(rollup, rollupNode);
    }
"
1205,"this doesn't need to have the ability and effect both be optional, just the ability is fine.","    public GarruksWarsteed(UUID ownerId, CardSetInfo setInfo) {
        super(ownerId, setInfo, new CardType[]{CardType.CREATURE}, ""{3}{G}{G}"");
        
        this.subtype.add(SubType.RHINO);
        this.power = new MageInt(3);
        this.toughness = new MageInt(5);

        // Vigilance
        this.addAbility(VigilanceAbility.getInstance());

        // When Garruk's Warsteed enters the battlefield, you may search your library and/or graveyard for a card named Garruk, Savage Herald, reveal it, and put it into your hand. If you search your library this way, shuffle it.
        this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryGraveyardPutInHandEffect(filter, false, true), true));
    }
","    public GarruksWarsteed(UUID ownerId, CardSetInfo setInfo) {
        super(ownerId, setInfo, new CardType[]{CardType.CREATURE}, ""{3}{G}{G}"");
        
        this.subtype.add(SubType.RHINO);
        this.power = new MageInt(3);
        this.toughness = new MageInt(5);

        // Vigilance
        this.addAbility(VigilanceAbility.getInstance());

        // When Garruk's Warsteed enters the battlefield, you may search your library and/or graveyard for a card named Garruk, Savage Herald, reveal it, and put it into your hand. If you search your library this way, shuffle it.
START         this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryGraveyardPutInHandEffect(filter, false, true), true)); END 
    }
","    public GarruksWarsteed(UUID ownerId, CardSetInfo setInfo) {
        super(ownerId, setInfo, new CardType[]{CardType.CREATURE}, ""{3}{G}{G}"");
        
        this.subtype.add(SubType.RHINO);
        this.power = new MageInt(3);
        this.toughness = new MageInt(5);

        // Vigilance
        this.addAbility(VigilanceAbility.getInstance());

        // When Garruk's Warsteed enters the battlefield, you may search your library and/or graveyard for a card named Garruk, Savage Herald, reveal it, and put it into your hand. If you search your library this way, shuffle it.
        this.addAbility(new EntersBattlefieldTriggeredAbility(new SearchLibraryGraveyardPutInHandEffect(filter, false, true)));
    }
"
1206,"markDead doesn't need to be under a lock. The caller should call tryRetain() after receiving, which will either prevent markDead from having an effect, if it is called before it.","    private void releaseFileChannel(long logId, CachedFileChannel cachedFileChannel) {
        lock.writeLock().lock();
        try {
            if (cachedFileChannel.markDead()) {
                try {
                    cachedFileChannel.fileChannel.close();
                } catch (IOException e) {
                    LOG.warn(""Exception occurred in ReferenceCountedFileChannel""
                            + "" while closing channel for log file: {}"", cachedFileChannel);
                } finally {
                    IOUtils.close(LOG, cachedFileChannel.fileChannel);
                }
                // to guarantee the removed cachedFileChannel is what we want to remove.
                fileChannels.remove(logId, cachedFileChannel);
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
","    private void releaseFileChannel(long logId, CachedFileChannel cachedFileChannel) {
        lock.writeLock().lock();
        try {
            if (cachedFileChannel.markDead()) {
START                 try { END 
                    cachedFileChannel.fileChannel.close();
                } catch (IOException e) {
                    LOG.warn(""Exception occurred in ReferenceCountedFileChannel""
                            + "" while closing channel for log file: {}"", cachedFileChannel);
                } finally {
                    IOUtils.close(LOG, cachedFileChannel.fileChannel);
                }
                // to guarantee the removed cachedFileChannel is what we want to remove.
                fileChannels.remove(logId, cachedFileChannel);
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
","    private void releaseFileChannel(long logId, CachedFileChannel cachedFileChannel) {
        if (cachedFileChannel.markDead()) {
            // to guarantee the removed cachedFileChannel is what we want to remove.
            fileChannels.remove(logId, cachedFileChannel);
            // close corresponding fileChannel
            try {
                cachedFileChannel.fileChannel.close();
            } catch (IOException e) {
                LOG.warn(""Exception occurred in ReferenceCountedFileChannel""
                        + "" while closing channel for log file: {}"", cachedFileChannel);
            } finally {
                IOUtils.close(LOG, cachedFileChannel.fileChannel);
            }
        }
    }
"
1207,"no need to declare this here, instead declare the type in line 141","	private static File getDefaultFile() {
		File netrc;

		File home = new File(System.getProperty(""user.home"")); //$NON-NLS-1$

		netrc = new File(home, "".netrc""); //$NON-NLS-1$
		if (netrc.exists())
			return netrc;

		netrc = new File(home, ""_netrc""); //$NON-NLS-1$
		if (netrc.exists())
			return netrc;

		return null;
	}
","	private static File getDefaultFile() {
START 		File netrc; END 

		File home = new File(System.getProperty(""user.home"")); //$NON-NLS-1$

		netrc = new File(home, "".netrc""); //$NON-NLS-1$
		if (netrc.exists())
			return netrc;

		netrc = new File(home, ""_netrc""); //$NON-NLS-1$
		if (netrc.exists())
			return netrc;

		return null;
	}
","	private static File getDefaultFile() {
		File home = new File(System.getProperty(""user.home"")); //$NON-NLS-1$

		File netrc = new File(home, "".netrc""); //$NON-NLS-1$
		if (netrc.exists())
			return netrc;

		netrc = new File(home, ""_netrc""); //$NON-NLS-1$
		if (netrc.exists())
			return netrc;

		return null;
	}
"
1208,I can see that the method body was already synchronised. Can you instead remove the outer if (serviceContext == null)? Because i see it duplicated in the inner block.,"	static synchronized ServiceContext getServiceContext() {
		if (serviceContext == null) {
			synchronized (Context.class) {
				if (serviceContext == null) {
					log.error(""serviceContext is null.  Creating new ServiceContext()"");
					serviceContext = ServiceContext.getInstance();
				}
			}
		}
		log.trace(""serviceContext: {}"", serviceContext);

		return ServiceContext.getInstance();
	}
","START 	static synchronized ServiceContext getServiceContext() { END 
		if (serviceContext == null) {
			synchronized (Context.class) {
				if (serviceContext == null) {
					log.error(""serviceContext is null.  Creating new ServiceContext()"");
					serviceContext = ServiceContext.getInstance();
				}
			}
		}
		log.trace(""serviceContext: {}"", serviceContext);

		return ServiceContext.getInstance();
	}
","	static synchronized ServiceContext getServiceContext() {
		
			synchronized (Context.class) {
				if (serviceContext == null) {
					log.error(""serviceContext is null.  Creating new ServiceContext()"");
					serviceContext = ServiceContext.getInstance();
				}
			}
		
		log.trace(""serviceContext: {}"", serviceContext);

		return ServiceContext.getInstance();
	}
"
1209,remove this line,"   public synchronized void activate() {
      OTELog.getLogger(""test"").debug(""something"");
      listener = new Slf4jLogListener();
      logService.addLogListener(listener);      
   }
","   public synchronized void activate() {
      START  OTELog.getLogger(""test"").debug(""something""); END 
      listener = new Slf4jLogListener();
      logService.addLogListener(listener);      
   }
","   public synchronized void activate() {
      listener = new Slf4jLogListener();
      logService.addLogListener(listener);      
   }
"
1210,I don't understand the need of this test. We have the next one which tests serialization and deserialization if I am not wrong. Or does this tests something more than the next one ?,"  public void testDeserialization() throws Exception {
    for (Short version : versions) {
      composedBlobIdAndDeserialize(version);
    }
  }
","START   public void testDeserialization() throws Exception { END 
    for (Short version : versions) {
      composedBlobIdAndDeserialize(version);
    }
  }
","  public void testDeserialization() throws Exception {
    composedBlobIdAndDeserialize(version);
  }
"
1211,"should be just return , no need for variable","    private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) {
        List<VMWithPlugInfo> vmsWithPlugInfo =
                getCallsHandler().executeReadList
                        (""GetVmsByDiskId"",
                                VMWithPlugInfoRowMapper.instance,
                                getCustomMapSqlParameterSource().addValue(""disk_guid"", id));
        return vmsWithPlugInfo;
    }
","    private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) {
START         List<VMWithPlugInfo> vmsWithPlugInfo = END 
                getCallsHandler().executeReadList
                        (""GetVmsByDiskId"",
                                VMWithPlugInfoRowMapper.instance,
                                getCustomMapSqlParameterSource().addValue(""disk_guid"", id));
        return vmsWithPlugInfo;
    }
","    private List<VMWithPlugInfo> getVmsWithPlugInfo(Guid id) {
        return getCallsHandler().executeReadList
                (""GetVmsByDiskId"",
                        VMWithPlugInfoRowMapper.instance,
                        getCustomMapSqlParameterSource().addValue(""disk_guid"", id));
    }
"
1212,"@nykolaslima 
How about handling selecting db by constructor of  BinaryJedis, as authentication takes place?","  public Jedis createResource() {
    Jedis jedis = new Jedis(this);
    try {
      jedis.select(db);
    } catch(JedisException e) {
      log.log(Level.SEVERE, ""Can't select database due a Redis connection problem"", e);
    }
      
    return jedis;
  }
","  public Jedis createResource() {
START     Jedis jedis = new Jedis(this); END 
    try {
      jedis.select(db);
    } catch(JedisException e) {
      log.log(Level.SEVERE, ""Can't select database due a Redis connection problem"", e);
    }
      
    return jedis;
  }
","  public Jedis createResource() {
    return new Jedis(this);
  }
"
1213,Please keep initialization code out of the Activator class.,"	public JSchUIConnectionManager(IRemoteServices services) {
		fConnMgr = (JSchConnectionManager) services.getConnectionManager();
		fConnMgr.setDefaultAuthenticatorFactory(new IUserAuthenticatorFactory() {
			@Override
			public IUserAuthenticator createUserAuthenticator(IRemoteConnection conn) {
				return new RemoteAuthenticator(conn);
			}
		});
	}
","	public JSchUIConnectionManager(IRemoteServices services) {
		fConnMgr = (JSchConnectionManager) services.getConnectionManager();
START 		fConnMgr.setDefaultAuthenticatorFactory(new IUserAuthenticatorFactory() { END 
			@Override
			public IUserAuthenticator createUserAuthenticator(IRemoteConnection conn) {
				return new RemoteAuthenticator(conn);
			}
		});
	}
","	public JSchUIConnectionManager(IRemoteServices services) {
		fConnMgr = (JSchConnectionManager) services.getConnectionManager();
	}
"
1214,"Nit: I think putAll is a no-op when the conf is empty, so you probably don't need to check.","        public BoltDeclarer addConfigurations(Map<String, Object> conf) {
            if (conf != null && !conf.isEmpty()) {
                component.componentConf.putAll(conf);
            }
            return this;
        }
","        public BoltDeclarer addConfigurations(Map<String, Object> conf) {
START             if (conf != null && !conf.isEmpty()) { END 
                component.componentConf.putAll(conf);
            }
            return this;
        }
","        public BoltDeclarer addConfigurations(Map<String, Object> conf) {
            if (conf != null) {
                component.componentConf.putAll(conf);
            }
            return this;
        }
"
1215,"Its a heavy read that bug! 
When you check if breakpoint
applicable probably better reverse instanceof check
and call. Instanceof is cheaper","	public void startTrackingBpForProcess(final IContainerDMContext containerDmc, final RequestMonitor rm) {
		final IBreakpointsTargetDMContext targetBpDmc = DMContexts.getAncestorOfType(containerDmc,
				IBreakpointsTargetDMContext.class);

		IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(fDebugModelId);
		for (IBreakpoint breakpoint : breakpoints) {
			if (supportsBreakpoint(breakpoint) && breakpoint instanceof ICBreakpoint) {
				setTargetFilter((ICBreakpoint) breakpoint, containerDmc);
			}
		}
		startTrackingBreakpoints(targetBpDmc, rm);
	}
","	public void startTrackingBpForProcess(final IContainerDMContext containerDmc, final RequestMonitor rm) {
		final IBreakpointsTargetDMContext targetBpDmc = DMContexts.getAncestorOfType(containerDmc,
				IBreakpointsTargetDMContext.class);

		IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(fDebugModelId);
		for (IBreakpoint breakpoint : breakpoints) {
START 			if (supportsBreakpoint(breakpoint) && breakpoint instanceof ICBreakpoint) { END 
				setTargetFilter((ICBreakpoint) breakpoint, containerDmc);
			}
		}
		startTrackingBreakpoints(targetBpDmc, rm);
	}
","	public void startTrackingBpForProcess(final IContainerDMContext containerDmc, final RequestMonitor rm) {
		final IBreakpointsTargetDMContext targetBpDmc = DMContexts.getAncestorOfType(containerDmc,
				IBreakpointsTargetDMContext.class);

		IBreakpoint[] breakpoints = DebugPlugin.getDefault().getBreakpointManager().getBreakpoints(fDebugModelId);
		for (IBreakpoint breakpoint : breakpoints) {
			if (breakpoint instanceof ICBreakpoint && supportsBreakpoint(breakpoint)) {
				setTargetFilter((ICBreakpoint) breakpoint, containerDmc);
			}
		}
		startTrackingBreakpoints(targetBpDmc, rm);
	}
"
1216,Put this logic into GarbageInformer together with waitUntilAllTasksFinish  as we discussed.,"    protected void startCompaction(CorfuRuntime rt, LogUnitServer logUnitServer) {
        // stop periodical tasks to prevent race condition
        rt.getGarbageInformer().stop();

        // wait until all garbage decisions are sent to logUnit servers.
        rt.getGarbageInformer().waitUntilAllTasksFinish();

        // send garbage decisions to logUnit servers
        while (rt.getGarbageInformer().getGarbageReceivingQueue().size() > 0) {
            rt.getGarbageInformer().gcUnsafe();
        }

        // run compaction on LogUnit servers
        logUnitServer.runCompaction();
        rt.getAddressSpaceView().resetCaches();
        rt.getAddressSpaceView().invalidateServerCaches();
    }
","    protected void startCompaction(CorfuRuntime rt, LogUnitServer logUnitServer) {
        // stop periodical tasks to prevent race condition
        rt.getGarbageInformer().stop();

        // wait until all garbage decisions are sent to logUnit servers.
        rt.getGarbageInformer().waitUntilAllTasksFinish();

        // send garbage decisions to logUnit servers
START         while (rt.getGarbageInformer().getGarbageReceivingQueue().size() > 0) {
            rt.getGarbageInformer().gcUnsafe();
        } END 

        // run compaction on LogUnit servers
        logUnitServer.runCompaction();
        rt.getAddressSpaceView().resetCaches();
        rt.getAddressSpaceView().invalidateServerCaches();
    }
","    protected void startCompaction(CorfuRuntime rt, LogUnitServer logUnitServer) {
        // stop periodical tasks to prevent race condition
        rt.getGarbageInformer().stop();

        // wait until all garbage decisions are sent to logUnit servers.
        rt.getGarbageInformer().waitUntilAllTasksFinish();

        // run compaction on LogUnit servers
        logUnitServer.runCompaction();
        rt.getAddressSpaceView().resetCaches();
        rt.getAddressSpaceView().invalidateServerCaches();
    }
"
1217,This addition is pointless,"  private void writeToChannelVersionOne(WritableByteChannel channel) throws IOException
  {
    try (ReadableByteChannel from = Channels.newChannel(combineStreams().getInput())) {
      ByteStreams.copy(from, channel);
      return;
    }

  }
","  private void writeToChannelVersionOne(WritableByteChannel channel) throws IOException
  {
    try (ReadableByteChannel from = Channels.newChannel(combineStreams().getInput())) {
      ByteStreams.copy(from, channel);
START       return; END 
    }

  }
","  private void writeToChannelVersionOne(WritableByteChannel channel) throws IOException
  {
    try (ReadableByteChannel from = Channels.newChannel(combineStreams().getInput())) {
      ByteStreams.copy(from, channel);
    }

  }
"
1218,Please remove that,"  protected void setUp() throws Exception {
    super.setUp();
    Statement stmt = con.createStatement();

    /* Drop the test table if it already exists for some reason. It is
    not an error if it doesn't exist. */
    TestUtil.createTable(con, ""testtz"", ""col1 INTEGER, col2 TIMESTAMP"");

    stmt.close();

    /* Generally recommended with batch updates. By default we run all
    tests in this test case with autoCommit disabled. */
    con.setAutoCommit(false);
  }
","  protected void setUp() throws Exception {
    super.setUp();
    Statement stmt = con.createStatement();

    /* Drop the test table if it already exists for some reason. It is
    not an error if it doesn't exist. */
    TestUtil.createTable(con, ""testtz"", ""col1 INTEGER, col2 TIMESTAMP"");

    stmt.close();

    /* Generally recommended with batch updates. By default we run all
    tests in this test case with autoCommit disabled. */
START     con.setAutoCommit(false); END 
  }
","  protected void setUp() throws Exception {
    super.setUp();
    Statement stmt = con.createStatement();

    /* Drop the test table if it already exists for some reason. It is
    not an error if it doesn't exist. */
    TestUtil.createTable(con, ""testtz"", ""col1 INTEGER, col2 TIMESTAMP"");

    stmt.close();
  }
"
1219,These null checks will disappear if using a multimap,"  public List<Currency> getCurrencyForName(final String name) {
    List<Currency> list = _namesToCurrency.get(name);
    if (list == null) {
      return new ArrayList<>();
    }
    return _namesToCurrency.get(name);
  }
","  public List<Currency> getCurrencyForName(final String name) {
    List<Currency> list = _namesToCurrency.get(name);
START     if (list == null) { END 
      return new ArrayList<>();
    }
    return _namesToCurrency.get(name);
  }
","  public List<Currency> getCurrencyForName(final String name) {
    return _namesToCurrency.get(name);
  }
"
1220,"What is the actual possible runtime type for the value? This seems overly defensive - I would expect the value will either be a string or a Boolean, not randomly changing from run to run.","  private static boolean parseAllowAlias(List<Option> options) {
    Option option = Option.findByName(options, ""allow_alias"");
    if (option != null) {
      Object value = option.getValue();
      return value instanceof Boolean ? (Boolean) value : ""true"".equals(value);
    }
    return false;
  }
","  private static boolean parseAllowAlias(List<Option> options) {
    Option option = Option.findByName(options, ""allow_alias"");
    if (option != null) {
      Object value = option.getValue();
START       return value instanceof Boolean ? (Boolean) value : ""true"".equals(value); END 
    }
    return false;
  }
","  private static boolean parseAllowAlias(List<Option> options) {
    Option option = Option.findByName(options, ""allow_alias"");
    if (option != null) {
      Object value = option.getValue();
      return value instanceof Boolean && (Boolean) value;
    }
    return false;
  }
"
1221,"Interesting approach. I guess I'd have tried to use qualifiers or the CDI alternative mechanism, but this seems the simplest.","		public WebArchive createDeployment() {
			if (resourceLocal) {
				archive.addClasses( MemberRegistrationWithResourceLocal.class, ResourceLocalResources.class );
			}
			else {
				archive.addClasses( MemberRegistrationWithJta.class, JtaResources.class );
			}
			return archive;
		}
","		public WebArchive createDeployment() {
START 			if (resourceLocal) { END 
				archive.addClasses( MemberRegistrationWithResourceLocal.class, ResourceLocalResources.class );
			}
			else {
				archive.addClasses( MemberRegistrationWithJta.class, JtaResources.class );
			}
			return archive;
		}
","		public WebArchive createDeployment() {
			if (resourceLocal) {
				archive.addClasses( MemberRegistrationWithResourceLocal.class );
			}
			else {
				archive.addClasses( MemberRegistrationWithJta.class, JtaResources.class );
			}
			return archive;
		}
"
1222,log.debug ?,"    private StorageDomain recoverStorageDomain(String sdUUID) {
        log.info(""about to recover SD {}"", sdUUID);
        StorageDomain storageDomain = new StorageDomain();
        storageDomain.setId(sdUUID);
        updateStorageDomain(storageDomain);
        return storageDomain;
    }
","    private StorageDomain recoverStorageDomain(String sdUUID) {
START         log.info(""about to recover SD {}"", sdUUID); END 
        StorageDomain storageDomain = new StorageDomain();
        storageDomain.setId(sdUUID);
        updateStorageDomain(storageDomain);
        return storageDomain;
    }
","    private StorageDomain recoverStorageDomain(String sdUUID) {
        log.warn(""about to recover SD {}"", sdUUID);
        StorageDomain storageDomain = new StorageDomain();
        storageDomain.setId(sdUUID);
        updateStorageDomain(storageDomain);
        return storageDomain;
    }
"
1223,We'll need the second usage of consumer.getId() replaced with consumer.getUuid() as well.,"    public Event complianceCreated(Consumer consumer,
        Set<Entitlement> entitlements, ComplianceStatus compliance) {
        return new Event(Event.Type.CREATED, Event.Target.COMPLIANCE,
            consumer.getName(), principalProvider.get(), consumer.getOwner().getId(), consumer.getUuid(),
            consumer.getId(), null, buildComplianceDataJson(consumer, entitlements, compliance), null,
            null);
    }
","    public Event complianceCreated(Consumer consumer,
        Set<Entitlement> entitlements, ComplianceStatus compliance) {
        return new Event(Event.Type.CREATED, Event.Target.COMPLIANCE,
            consumer.getName(), principalProvider.get(), consumer.getOwner().getId(), consumer.getUuid(),
START             consumer.getId(), null, buildComplianceDataJson(consumer, entitlements, compliance), null, END 
            null);
    }
","    public Event complianceCreated(Consumer consumer,
        Set<Entitlement> entitlements, ComplianceStatus compliance) {
        // Instead of an internal db id, compliance.created events now use
        // UUID for the 'consumerId' and 'entityId' fields, since Katello
        // is concerned only with the consumer UUID field. This is the first
        // part of a larger piece of work to simplify Event consumption.
        return new Event(Event.Type.CREATED, Event.Target.COMPLIANCE,
            consumer.getName(), principalProvider.get(), consumer.getOwner().getId(), consumer.getUuid(),
            consumer.getUuid(), null, buildComplianceDataJson(consumer, entitlements, compliance), null,
            null);
    }
"
1224,Use StringBuilder please.,"	public static String toHexString(byte[] digest) {
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i < digest.length; i++) {
			if ((digest[i] & 0xFF) < 0x10)
				buf.append('0');
			buf.append(Integer.toHexString(digest[i] & 0xFF));
		}
		return buf.toString();
	}
","	public static String toHexString(byte[] digest) {
START 		StringBuffer buf END  = new StringBuffer();
		for (int i = 0; i < digest.length; i++) {
			if ((digest[i] & 0xFF) < 0x10)
				buf.append('0');
			buf.append(Integer.toHexString(digest[i] & 0xFF));
		}
		return buf.toString();
	}
","	public static String toHexString(byte[] digest) {
		StringBuilder buf = new StringBuilder();
		for (byte element : digest) {
			if ((element & 0xFF) < 0x10)
				buf.append('0');
			buf.append(Integer.toHexString(element & 0xFF));
		}
		return buf.toString();
	}
"
1225,Invert this so it returns early,"    private boolean isLastKilledQueryGone()
    {
        boolean lastKilledQueryIsGone = (lastKilledQuery == null);

        if (!lastKilledQueryIsGone) {
            ClusterMemoryPool generalPool = pools.get(GENERAL_POOL);
            if (generalPool != null) {
                lastKilledQueryIsGone = generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery);
            }
        }
        return lastKilledQueryIsGone;
    }
","    private boolean isLastKilledQueryGone()
    {
        boolean lastKilledQueryIsGone = (lastKilledQuery == null);

START         if (!lastKilledQueryIsGone) { END 
            ClusterMemoryPool generalPool = pools.get(GENERAL_POOL);
            if (generalPool != null) {
                lastKilledQueryIsGone = generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery);
            }
        }
        return lastKilledQueryIsGone;
    }
","    private boolean isLastKilledQueryGone()
    {
        if (lastKilledQuery == null) {
            return true;
        }
        ClusterMemoryPool generalPool = pools.get(GENERAL_POOL);
        if (generalPool == null) {
            return false;
        }
        return generalPool.getQueryMemoryReservations().containsKey(lastKilledQuery);
    }
"
1226,Is this change that makes batcher immediately execute after create new instance of Batcher and then added tasks smaller than capacity size?,"    public Batcher(ScheduledExecutorService workExecutor,
                   int capacity,
                   long delay,
                   BatchProcessor<T> processor) {
        this.workExecutor = workExecutor;
        this.capacity = capacity;
        this.delay = delay;
        this.processor = processor;
        this.inbox = new ArrayList<T>();
        this.scheduled = false;
        this.lastProcessedTime = 0;
    }
","    public Batcher(ScheduledExecutorService workExecutor,
                   int capacity,
                   long delay,
                   BatchProcessor<T> processor) {
        this.workExecutor = workExecutor;
        this.capacity = capacity;
        this.delay = delay;
        this.processor = processor;
        this.inbox = new ArrayList<T>();
        this.scheduled = false;
START         this.lastProcessedTime = 0; END 
    }
","    public Batcher(ScheduledExecutorService workExecutor,
                   int capacity,
                   long delay,
                   BatchProcessor<T> processor) {
        this.workExecutor = workExecutor;
        this.capacity = capacity;
        this.delay = delay;
        this.processor = processor;
    }
"
1227,This line should also be removed.,"  public static void removeMagicResponseContextFields(Map<String, Object> responseContext)
  {
    responseContext.remove(DirectDruidClient.QUERY_FAIL_TIME);
    responseContext.remove(DirectDruidClient.QUERY_TOTAL_BYTES_GATHERED);
  }
","  public static void removeMagicResponseContextFields(Map<String, Object> responseContext)
  {
START     responseContext.remove(DirectDruidClient.QUERY_FAIL_TIME); END 
    responseContext.remove(DirectDruidClient.QUERY_TOTAL_BYTES_GATHERED);
  }
","  public static void removeMagicResponseContextFields(Map<String, Object> responseContext)
  {
    responseContext.remove(DirectDruidClient.QUERY_TOTAL_BYTES_GATHERED);
  }
"
1228,no Exception is thrown in this method,"  private void validateAndClose() throws Exception {
    try {
      info(""Validating static and Helix cluster maps"");
      verifyEquivalencyWithStaticClusterMap(staticClusterMap.hardwareLayout, staticClusterMap.partitionLayout);
      if (validatingHelixClusterManager != null) {
        ensureOrThrow(validatingHelixClusterManager.getErrorCount() == 0,
            ""Helix cluster manager should not have encountered any errors"");
      }
    } finally {
      if (validatingHelixClusterManager != null) {
        validatingHelixClusterManager.close();
      }
      for (HelixAdmin admin : adminForDc.values()) {
        admin.close();
      }
    }
  }
","  private void validateAndClose() throws Exception {
    try {
      info(""Validating static and Helix cluster maps"");
      verifyEquivalencyWithStaticClusterMap(staticClusterMap.hardwareLayout, staticClusterMap.partitionLayout);
      if (validatingHelixClusterManager != null) {
START         ensureOrThrow(validatingHelixClusterManager.getErrorCount() == 0, END 
            ""Helix cluster manager should not have encountered any errors"");
      }
    } finally {
      if (validatingHelixClusterManager != null) {
        validatingHelixClusterManager.close();
      }
      for (HelixAdmin admin : adminForDc.values()) {
        admin.close();
      }
    }
  }
","  private void validateAndClose() {
    try {
      info(""Validating static and Helix cluster maps"");
      verifyEquivalencyWithStaticClusterMap(staticClusterMap.hardwareLayout, staticClusterMap.partitionLayout);
      if (validatingHelixClusterManager != null) {
        ensureOrThrow(validatingHelixClusterManager.getErrorCount() == 0,
            ""Helix cluster manager should not have encountered any errors"");
      }
    } finally {
      if (validatingHelixClusterManager != null) {
        validatingHelixClusterManager.close();
      }
      for (HelixAdmin admin : adminForDc.values()) {
        admin.close();
      }
    }
  }
"
1229,"Consider:
`return currentOffset == NO_VALUES ? 0 : maxOffset - currentOffset - 1;`","  public int size() {
    if (currentOffset == NO_VALUES) {
      return 0;
    }
    return maxOffset - currentOffset - 1;
  }
","  public int size() {
    if (currentOffset == NO_VALUES) {
      return 0;
    }
START     return maxOffset - currentOffset - 1; END 
  }
","  public int size() {
    return isEmpty() ? 0 : maxOffset - currentOffset;
  }
"
1230,activatedPage is not used anymore,"	public void updateEditorPages(int activatedPage) {
		removeAllPages();
		addPages();
		if (backToActivePage > 0 && backToActivePage < this.getPageCount()) {
			setActivePage(backToActivePage);
		} else {
			//Set active page if the backToActivePage is out of the range
			setActivePage(0);
		}
		setPartName(getPartName());
	}
","START 	public void updateEditorPages(int activatedPage) { END 
		removeAllPages();
		addPages();
		if (backToActivePage > 0 && backToActivePage < this.getPageCount()) {
			setActivePage(backToActivePage);
		} else {
			//Set active page if the backToActivePage is out of the range
			setActivePage(0);
		}
		setPartName(getPartName());
	}
","	public void updateEditorPages(int activatedPage) {
		updateEditorPages();
	}
"
1231,"Looking at other HandlerUtil.getVariable() calls, the usual logic is to look for an instance of what you were looking for (in this case Boolean) and to treat any other situation as if null was provided.  This would remove the need to check for Boolean in checkForCompositeRename and having code to issue an error log message which should never occur.","	public Object execute(ExecutionEvent event) throws ExecutionException {
		Object checkCompositeRename= HandlerUtil.getVariable(event, LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY);
		if (checkCompositeRename != null) {
			return checkForCompositeRename(event, checkCompositeRename);
		} else {
			performRename(event);
		}
		return null;
	}
","	public Object execute(ExecutionEvent event) throws ExecutionException {
START 		Object checkCompositeRename= HandlerUtil.getVariable(event, LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY); END 
		if (checkCompositeRename != null) {
			return checkForCompositeRename(event, checkCompositeRename);
		} else {
			performRename(event);
		}
		return null;
	}
","	public Object execute(ExecutionEvent event) throws ExecutionException {
		Object checkCompositeRename= HandlerUtil.getVariable(event, LTK_CHECK_COMPOSITE_RENAME_PARAMETER_KEY);
		if (checkCompositeRename instanceof Boolean) {
			return checkForCompositeRename(event);
		} else {
			performRename(event);
		}
		return null;
	}
"
1232,Another non-permissible change,"    public Arguments setUntypedNullArgument(Argument untypedNullArgument) {
        if (untypedNullArgument == null) {
            throw new IllegalArgumentException(""the Argument itself may not be null"");
        }
        this.untypedNullArgument = untypedNullArgument;
        return this;
    }
","START     public Arguments setUntypedNullArgument(Argument untypedNullArgument) { END 
        if (untypedNullArgument == null) {
            throw new IllegalArgumentException(""the Argument itself may not be null"");
        }
        this.untypedNullArgument = untypedNullArgument;
        return this;
    }
","    public void setUntypedNullArgument(Argument untypedNullArgument) {
        if (untypedNullArgument == null) {
            throw new IllegalArgumentException(""the Argument itself may not be null"");
        }
        this.untypedNullArgument = untypedNullArgument;
    }
"
1233,"@ivandalbosco I see that you just copied this piece from JS, but it's not perfect there :) We can drop `.replace(""mn"", ""min"")` everywhere (3 places). This was done as many RSPECs had legacy `mn` for minutes. It should be fixed now. It there is still some RSPEC using `mn` and plugin fails, then you better update this RSPEC","    private DebtRemediationFunction remediationFunction(DebtRemediationFunctions drf) {
      if (func.startsWith(""Constant"")) {
        return drf.constantPerIssue(constantCost.replace(""mn"", ""min""));
      }
      if (""Linear"".equals(func)) {
        return drf.linear(linearFactor.replace(""mn"", ""min""));
      }
      return drf.linearWithOffset(linearFactor.replace(""mn"", ""min""), linearOffset.replace(""mn"", ""min""));
    }
","    private DebtRemediationFunction remediationFunction(DebtRemediationFunctions drf) {
      if (func.startsWith(""Constant"")) {
START         return drf.constantPerIssue(constantCost.replace(""mn"", ""min"")); END 
      }
      if (""Linear"".equals(func)) {
        return drf.linear(linearFactor.replace(""mn"", ""min""));
      }
      return drf.linearWithOffset(linearFactor.replace(""mn"", ""min""), linearOffset.replace(""mn"", ""min""));
    }
","    private DebtRemediationFunction remediationFunction(DebtRemediationFunctions drf) {
      if (func.startsWith(""Constant"")) {
        return drf.constantPerIssue(constantCost);
      }
      if (""Linear"".equals(func)) {
        return drf.linear(linearFactor);
      }
      return drf.linearWithOffset(linearFactor, linearOffset);
    }
"
1234,"I find it very unintuitive to find this here... I'd suggest moving the log to `PMD.doPMD`, which is guaranteed to run once and a little more natural","    public void setAnalysisCache(final AnalysisCache cache) {
        if (cache == null && isAnalysisCacheFunctional()) {
            analysisCache = new NoopAnalysisCache();

            // Log warning only once, if not explicitly disabled
            if (!isIgnoreIncrementalAnalysis() && LOG.isLoggable(Level.WARNING)) {
                final String version = PMDVersion.isUnknown() || PMDVersion.isSnapshot() ? ""latest"" : ""pmd-"" + PMDVersion.VERSION;
                LOG.warning(""This analysis could be faster, please consider using Incremental Analysis: ""
                                    + ""https://pmd.github.io/"" + version + ""/pmd_userdocs_getting_started.html#incremental-analysis"");
            }
        } else if (!isIgnoreIncrementalAnalysis()) { // ignore new value if incr. analysis is disabled
            analysisCache = cache;
        }
    }
","    public void setAnalysisCache(final AnalysisCache cache) {
        if (cache == null && isAnalysisCacheFunctional()) {
            analysisCache = new NoopAnalysisCache();

            // Log warning only once, if not explicitly disabled
            if (!isIgnoreIncrementalAnalysis() && LOG.isLoggable(Level.WARNING)) {
                final String version = PMDVersion.isUnknown() || PMDVersion.isSnapshot() ? ""latest"" : ""pmd-"" + PMDVersion.VERSION;
START                 LOG.warning(""This analysis could be faster, please consider using Incremental Analysis: "" END 
                                    + ""https://pmd.github.io/"" + version + ""/pmd_userdocs_getting_started.html#incremental-analysis"");
            }
        } else if (!isIgnoreIncrementalAnalysis()) { // ignore new value if incr. analysis is disabled
            analysisCache = cache;
        }
    }
","    public void setAnalysisCache(final AnalysisCache cache) {
        // the doc says it's a noop if incremental analysis was disabled,
        // but it's actually the getter that enforces that
        this.analysisCache = cache == null ? new NoopAnalysisCache() : cache;
    }
"
1235,Same here. Add clarifying parenthesis,"    private static double sortableLongToDouble(long value)
    {
        value = value ^ (value >> 63) & Long.MAX_VALUE;
        return Double.longBitsToDouble(value);
    }
","    private static double sortableLongToDouble(long value)
    {
START         value = value ^ (value >> 63) & Long.MAX_VALUE; END 
        return Double.longBitsToDouble(value);
    }
","    private static double sortableLongToDouble(long value)
    {
        value = value ^ ((value >> 63) & Long.MAX_VALUE);
        return Double.longBitsToDouble(value);
    }
"
1236,"```
    if (!(e instanceof ExecutionException) || e.getCause() == null) {
      return e;
    }
    Throwable cause = e.getCause();
    return cause instanceof Exception ? (Exception) cause : new Exception(cause);
```
How about making return statement simpler?","  public static Exception extractExecutionExceptionCause(Exception e) {
    if (!(e instanceof ExecutionException)) {
      return e;
    }
    Throwable cause = e.getCause();
    return cause == null ? e : (cause instanceof Exception ? (Exception) cause : new Exception(cause));
  }
","  public static Exception extractExecutionExceptionCause(Exception e) {
    if (!(e instanceof ExecutionException)) {
      return e;
    }
    Throwable cause = e.getCause();
    return cause == null ? e : (cause instanceof Exception ? (Exception) cause : new Exception(cause));
START   } END 
","  public static Exception extractExecutionExceptionCause(Exception e) {
    Throwable cause = e.getCause();
    if (!(e instanceof ExecutionException) || cause == null) {
      return e;
    }
    return cause instanceof Exception ? (Exception) cause : new Exception(cause);
  }
"
1237,minor: braces unnecessary,"  boolean isEmpty() {
    return (validIndexSegments.isEmpty());
  }
","  boolean isEmpty() {
START     return (validIndexSegments.isEmpty()); END 
  }
","  boolean isEmpty() {
    return validIndexSegments.isEmpty();
  }
"
1238,Please do only whitespace changes in this commit.,"	Set getDefaultIgnoreTypeNames() {
		Set ignored = new HashSet();
		String[] ignore = {""org.eclipse.core.runtime.Plugin"", ""java.lang.ClassLoader"", ""org.eclipse.team.internal.ccvs.core.CVSTeamProvider"", ""org.eclipse.core.internal.events.BuilderPersistentInfo"", ""org.eclipse.core.internal.resources.Workspace"", ""org.eclipse.core.internal.events.EventStats"", ""java.net.URL""}; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-6$
		for (String element : ignore) {
			ignored.add(element);
		}
		return ignored;
	}
","	Set getDefaultIgnoreTypeNames() {
		Set ignored = new HashSet();
		String[] ignore = {""org.eclipse.core.runtime.Plugin"", ""java.lang.ClassLoader"", ""org.eclipse.team.internal.ccvs.core.CVSTeamProvider"", ""org.eclipse.core.internal.events.BuilderPersistentInfo"", ""org.eclipse.core.internal.resources.Workspace"", ""org.eclipse.core.internal.events.EventStats"", ""java.net.URL""}; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-6$
START 		for (String element : ignore) { END 
			ignored.add(element);
		}
		return ignored;
	}
","	Set getDefaultIgnoreTypeNames() {
		Set ignored = new HashSet();
		String[] ignore = {""org.eclipse.core.runtime.Plugin"", ""java.lang.ClassLoader"", ""org.eclipse.team.internal.ccvs.core.CVSTeamProvider"", ""org.eclipse.core.internal.events.BuilderPersistentInfo"", ""org.eclipse.core.internal.resources.Workspace"", ""org.eclipse.core.internal.events.EventStats"", ""java.net.URL""}; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-6$
		for (int i = 0; i < ignore.length; i++) {
			ignored.add(ignore[i]);
		}
		return ignored;
	}
"
1239,child,"	public static boolean delete(File file) {
		if (!file.exists())
			return true;
		if (file.isDirectory()) {
			File[] children = file.listFiles();
			for (File children1 : children) {
				delete(children1);
			}
		}
		return file.delete();
	}
","	public static boolean delete(File file) {
		if (!file.exists())
			return true;
		if (file.isDirectory()) {
			File[] children = file.listFiles();
			for (File START  children1 : END  children) {
				delete(children1);
			}
		}
		return file.delete();
	}
","	public static boolean delete(File file) {
		if (!file.exists())
			return true;
		if (file.isDirectory()) {
			File[] children = file.listFiles();
			for (File child : children) {
				delete(child);
			}
		}
		return file.delete();
	}
"
1240,"Why do we call authenticate to log out? If we aren't already authenticated, why do we need to log out?","	public void logout(final IProgressMonitor monitor) throws XmlRpcException {
		userID = -1;
		token = null;
		(new BugzillaXmlRpcOperation<Integer>(this) {
			@SuppressWarnings(""serial"")
			@Override
			public Integer execute() throws XmlRpcException {
				try {
					bugzillaClient.authenticate(monitor);
				} catch (CoreException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				Object response = call(monitor, XML_USER_LOGOUT, null);
				return -1;
			}
		}).execute();
		return;
	}
","	public void logout(final IProgressMonitor monitor) throws XmlRpcException {
		userID = -1;
		token = null;
		(new BugzillaXmlRpcOperation<Integer>(this) {
			@SuppressWarnings(""serial"")
			@Override
			public Integer execute() throws XmlRpcException {
				try {
START 					bugzillaClient.authenticate(monitor); END 
				} catch (CoreException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				Object response = call(monitor, XML_USER_LOGOUT, null);
				return -1;
			}
		}).execute();
		return;
	}
","	public void logout(final IProgressMonitor monitor) throws XmlRpcException {
		(new BugzillaXmlRpcOperation<Integer>(this) {
			@SuppressWarnings(""serial"")
			@Override
			public Integer execute() throws XmlRpcException {
				Object response = call(monitor, XML_USER_LOGOUT, null);
				return -1;
			}
		}).execute();
		userID = -1;
		token = null;
		return;
	}
"
1241,"Could be simplified to:
```java
return dirtyNumber < 1 ? 0 : dirtyNumber;
```","  private double cleanNumber(double dirtyNumber) {
    double clean;
    if (dirtyNumber < 1)
      clean = 0;
    else
      clean = dirtyNumber;
    return clean;
  }
","  private double cleanNumber(double dirtyNumber) {
START     double clean; END 
    if (dirtyNumber < 1)
      clean = 0;
    else
      clean = dirtyNumber;
    return clean;
  }
","  private double cleanNumber(double dirtyNumber) {
    return dirtyNumber < 1 ? 0 : dirtyNumber;
  }
"
1242,Same here: The new flag `withAttempts` is not passed (used) the  `paymentProcessor#getAccountPayments`,"    public Pagination<Payment> getPayments(final Long offset, final Long limit, final String pluginName, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException {
        return paymentProcessor.getPayments(offset, limit, pluginName, withPluginInfo, properties, tenantContext, internalCallContextFactory.createInternalTenantContext(tenantContext));
    }
","    public Pagination<Payment> getPayments(final Long offset, final Long limit, final String pluginName, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException {
START         return paymentProcessor.getPayments(offset, limit, pluginName, withPluginInfo, properties, tenantContext, internalCallContextFactory.createInternalTenantContext(tenantContext)); END 
    }
","    public Pagination<Payment> getPayments(final Long offset, final Long limit, final String pluginName, final boolean withPluginInfo, final boolean withAttempts, final Iterable<PluginProperty> properties, final TenantContext tenantContext) throws PaymentApiException {
        return paymentProcessor.getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, properties, tenantContext, internalCallContextFactory.createInternalTenantContext(tenantContext));
    }
"
1243,"why do you need to convert the bundle to a map, instead of using it directly?","    private static Map<String, String> readMessagesFromBundle() {
        try {
            ResourceBundle bundle = ResourceBundle.getBundle(APP_ERRORS_MESSAGES_FILE_NAME);
            Map<String, String> messages = new HashMap<String, String>();
            for (String key : bundle.keySet()) {
                messages.put(key, bundle.getString(key));
            }
            return messages;
        } catch (MissingResourceException e) {
            log.error(""Could not load audit log messages from the file "" + APP_ERRORS_MESSAGES_FILE_NAME);
            throw new ApplicationException(e);
        }
    }
","START     private static Map<String, String> readMessagesFromBundle() { END 
        try {
            ResourceBundle bundle = ResourceBundle.getBundle(APP_ERRORS_MESSAGES_FILE_NAME);
            Map<String, String> messages = new HashMap<String, String>();
            for (String key : bundle.keySet()) {
                messages.put(key, bundle.getString(key));
            }
            return messages;
        } catch (MissingResourceException e) {
            log.error(""Could not load audit log messages from the file "" + APP_ERRORS_MESSAGES_FILE_NAME);
            throw new ApplicationException(e);
        }
    }
","    private static ResourceBundle readMessagesFromBundle() {
        try {
            return ResourceBundle.getBundle(APP_ERRORS_MESSAGES_FILE_NAME);
        } catch (MissingResourceException e) {
            log.error(""Could not load audit log messages from the file "" + APP_ERRORS_MESSAGES_FILE_NAME);
            throw new ApplicationException(e);
        }
    }
"
1244,Is this really needed? Maybe this should be removed for efficiency reasons (but I don't know how often this method is actually used...),"    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        BigFraction otherValue = ((ILScore)obj).getValue();
        return this.value.equals(otherValue);
    }
","    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
START         if (getClass() != obj.getClass()) return false; END 
        BigFraction otherValue = ((ILScore)obj).getValue();
        return this.value.equals(otherValue);
    }
","    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        BigFraction otherValue = ((ILScore)obj).getValue();
        return this.value.equals(otherValue);
    }
"
1245,"[optional] this could be shortened to:

 return control.forUser(user).isRefVisible();","  private boolean isValidReviewer(Account member, ChangeControl control) {
    if (member.isActive()) {
      IdentifiedUser user = identifiedUserFactory.create(member.getId());
      // Does not account for draft status as a user might want to let a
      // reviewer see a draft.
      if (control.forUser(user).isRefVisible()) {
        return true;
      }
    }
    return false;
  }
","  private boolean isValidReviewer(Account member, ChangeControl control) {
    if (member.isActive()) {
      IdentifiedUser user = identifiedUserFactory.create(member.getId());
      // Does not account for draft status as a user might want to let a
      // reviewer see a draft.
START       if (control.forUser(user).isRefVisible()) {
        return true;
      } END 
    }
    return false;
  }
","  private boolean isValidReviewer(Account member, ChangeControl control) {
    if (member.isActive()) {
      IdentifiedUser user = identifiedUserFactory.create(member.getId());
      // Does not account for draft status as a user might want to let a
      // reviewer see a draft.
      return control.forUser(user).isRefVisible();
    }
    return false;
  }
"
1246,please use == for enum comparisons like its done 2 lines above,"        private boolean support( ValueGroup[] valueGroups )
        {
            return valueGroups.length == 1 && ValueGroup.NUMBER.equals( valueGroups[0] );
        }
","        private boolean support( ValueGroup[] valueGroups )
        {
START             return valueGroups.length == 1 && ValueGroup.NUMBER.equals( valueGroups[0] ); END 
        }
","        private boolean support( ValueGroup[] valueGroups )
        {
            return valueGroups.length == 1 && valueGroups[0] == ValueGroup.NUMBER;
        }
"
1247,You can make this file `File`,"    public String getConfigFile()
    {
        return configFile;
    }
","START     public String getConfigFile() END 
    {
        return configFile;
    }
","    public File getConfigFile()
    {
        return configFile;
    }
"
1248,"Probably won't be used, but you should implement AutoCloseable, since you implement close() anyway.","    void close() {
        writeQueue.add(WriteOperation.SHUTDOWN);
        writerService.shutdown();
    }
","START     void close() { END 
        writeQueue.add(WriteOperation.SHUTDOWN);
        writerService.shutdown();
    }
","    public void close() {
        writeQueue.add(WriteOperation.SHUTDOWN);
        writerService.shutdown();
    }
"
1249,Wouldn't this be an `if/else`? If we just `unsubscribed` in the previous lines I don't think we should ever go through this flow.,"        private void completeInner() {
            // A group is removed, so check if we need to call `unsubscribe`
            if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) {
                // It means `groups.isEmpty() && child.isUnsubscribed()` is true
                unsubscribe();
            }
            // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer
            if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) {
                // completionEmitted ensures we only emit onCompleted once
                if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {
                    if (!child.isUnsubscribed()) {
                        child.onCompleted();
                    }
                }
            }
        }
","        private void completeInner() {
            // A group is removed, so check if we need to call `unsubscribe`
            if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) {
                // It means `groups.isEmpty() && child.isUnsubscribed()` is true
                unsubscribe();
            }
            // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer
START             if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) { END 
                // completionEmitted ensures we only emit onCompleted once
                if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {
                    if (!child.isUnsubscribed()) {
                        child.onCompleted();
                    }
                }
            }
        }
","        private void completeInner() {
            // A group is removed, so check if we need to call `unsubscribe`
            if (WIP_FOR_UNSUBSCRIBE_UPDATER.decrementAndGet(this) == 0) {
                // It means `groups.isEmpty() && child.isUnsubscribed()` is true
                unsubscribe();
            } else if (groups.isEmpty() && terminated == TERMINATED_WITH_COMPLETED) {
                // if we have no outstanding groups (all completed or unsubscribe) and terminated on outer
                // completionEmitted ensures we only emit onCompleted once
                if (COMPLETION_EMITTED_UPDATER.compareAndSet(this, 0, 1)) {
                    child.onCompleted();
                }
            }
        }
"
1250,"```suggestion
        logger.error(""Found one or more vector errors from {}"", opName);
```","    protected boolean startError() {
      if (errorCount == 0) {
        logger.error(""Found one or more vector errors from "" + opName);
      }
      errorCount++;
      if (errorCount >= MAX_ERRORS) {
        return false;
      }
      return true;
    }
","    protected boolean startError() {
      if (errorCount == 0) {
START         logger.error(""Found one or more vector errors from "" + opName); END 
      }
      errorCount++;
      if (errorCount >= MAX_ERRORS) {
        return false;
      }
      return true;
    }
","    protected boolean startError() {
      if (errorCount == 0) {
        warn(""Found one or more vector errors from "" + opName);
      }
      errorCount++;
      if (errorCount >= MAX_ERRORS) {
        return false;
      }
      return true;
    }
"
1251,"We use Java7, so you should use the try-with-resources feature.","  protected static List<Integer> grep(File fileName, String regexp, List<String> resultLines) {
    List<Integer> resultLineNumbers = new ArrayList<>();
    Reader reader = null;
    try {
      reader = new FileReader(fileName);
      resultLineNumbers =  grep(reader, regexp, resultLines);
    }catch (IOException e) {
      e.printStackTrace();
    } finally {
      closeQuietly(reader);
    }
    return resultLineNumbers;
  }
","  protected static List<Integer> grep(File fileName, String regexp, List<String> resultLines) {
    List<Integer> resultLineNumbers = new ArrayList<>();
    Reader reader = null;
    try {
      reader = new FileReader(fileName);
      resultLineNumbers =  grep(reader, regexp, resultLines);
    }catch (IOException e) {
      e.printStackTrace();
    } finally {
START       closeQuietly(reader); END 
    }
    return resultLineNumbers;
  }
","  protected static List<Integer> grep(File fileName, String regexp, List<String> resultLines) {
    List<Integer> resultLineNumbers = new ArrayList<>();
    try(Reader reader = new FileReader(fileName)) {
      resultLineNumbers =  grep(reader, regexp, resultLines);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return resultLineNumbers;
  }
"
1252,Missing `final` (was indicated on the previous patch as well).,"    private static void navigate(final Activity activity, final String destName, final String destCode, final Geopoint coords) {
        Intent launchIntent = new Intent(INTENT_ACTION);
        launchIntent.putExtra(Intents.EXTRA_NAME, destName);
        launchIntent.putExtra(Intents.EXTRA_GEOCODE, destCode);
        launchIntent.putExtra(Intents.EXTRA_LATITUDE, coords.getLatitude());
        launchIntent.putExtra(Intents.EXTRA_LONGITUDE, coords.getLongitude());
        activity.startService(launchIntent);
    }
","    private static void navigate(final Activity activity, final String destName, final String destCode, final Geopoint coords) {
START         Intent launchIntent = new Intent(INTENT_ACTION); END 
        launchIntent.putExtra(Intents.EXTRA_NAME, destName);
        launchIntent.putExtra(Intents.EXTRA_GEOCODE, destCode);
        launchIntent.putExtra(Intents.EXTRA_LATITUDE, coords.getLatitude());
        launchIntent.putExtra(Intents.EXTRA_LONGITUDE, coords.getLongitude());
        activity.startService(launchIntent);
    }
","    private static void navigate(final Activity activity, final String destName,
                                 final String destCode, final Geopoint coords) {
        final Intent launchIntent = new Intent(INTENT_ACTION);
        launchIntent.putExtra(Intents.EXTRA_NAME, destName)
                .putExtra(Intents.EXTRA_GEOCODE, destCode)
                .putExtra(Intents.EXTRA_LATITUDE, coords.getLatitude())
                .putExtra(Intents.EXTRA_LONGITUDE, coords.getLongitude());
        activity.startService(launchIntent);
    }
"
1253,static import,"	public TestMediaWikiApiImageFetchingStrategy(Map<String, String> serverContent) {
		Preconditions.checkNotNull(serverContent,
				""Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"");
		this.serverContent = ImmutableMap.copyOf(serverContent);
	}
","	public TestMediaWikiApiImageFetchingStrategy(Map<String, String> serverContent) {
START 		Preconditions.checkNotNull(serverContent, END 
				""Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"");
		this.serverContent = ImmutableMap.copyOf(serverContent);
	}
","	public TestMediaWikiApiImageFetchingStrategy(Map<String, String> serverContent) {
		checkNotNull(serverContent,
				""Please specify some server content for images used during the tests. See: TestMediaWikiApiImageFetchingStrategy#serverContent"");
		this.serverContent = ImmutableMap.copyOf(serverContent);
	}
"
1254,A redundant else statement,"    private static boolean shouldCreateMyHandler(PsiElement element) {
      if (element instanceof LeafPsiElement) {
        LeafPsiElement leaf = (LeafPsiElement)element;
        return leaf.getElementType() == GoTypes.RETURN || leaf.getElementType() == GoTypes.FUNC || isPanicCall(leaf);
      }
      else {
        return false;
      }
    }
","    private static boolean shouldCreateMyHandler(PsiElement element) {
      if (element instanceof LeafPsiElement) {
        LeafPsiElement leaf = (LeafPsiElement)element;
        return leaf.getElementType() == GoTypes.RETURN || leaf.getElementType() == GoTypes.FUNC || isPanicCall(leaf);
      }
START       else { END 
        return false;
      }
    }
","    private static boolean shouldCreateMyHandler(PsiElement element) {
      if (element instanceof LeafPsiElement) {
        LeafPsiElement leaf = (LeafPsiElement)element;
        return leaf.getElementType() == GoTypes.RETURN || leaf.getElementType() == GoTypes.FUNC || isPanicCall(leaf);
      }
      return false;
    }
"
1255,Wouldn't it be safer to make this method synchronized?,"    private void cancelRxCommands() {
        for (CommandHandle commandHandle : fRxCommands.values()) {
            if (commandHandle.getRequestMonitor() == null) continue;
            commandHandle.getRequestMonitor().setStatus(genStatus( ""Connection is shut down"")); //$NON-NLS-1$
            commandHandle.getRequestMonitor().done();
        }
        fRxCommands.clear();
    }
","START     private void cancelRxCommands() { END 
        for (CommandHandle commandHandle : fRxCommands.values()) {
            if (commandHandle.getRequestMonitor() == null) continue;
            commandHandle.getRequestMonitor().setStatus(genStatus( ""Connection is shut down"")); //$NON-NLS-1$
            commandHandle.getRequestMonitor().done();
        }
        fRxCommands.clear();
    }
","    private synchronized void cancelRxCommands() {
        for (CommandHandle commandHandle : fRxCommands.values()) {
            if (commandHandle.getRequestMonitor() == null) continue;
            commandHandle.getRequestMonitor().setStatus(genStatus( ""Connection is shut down"")); //$NON-NLS-1$
            commandHandle.getRequestMonitor().done();
        }
        fRxCommands.clear();
    }
"
1256,No need to expand the lambda,"    private Supplier<StorageStatement> storeStatementSupplier( NeoStores neoStores )
    {
        Supplier<IndexReaderFactory> indexReaderFactory = () -> new IndexReaderFactory.Caching( indexingService );
        LockService lockService = takePropertyReadLocks ? this.lockService : NO_LOCK_SERVICE;

        return new Supplier<StorageStatement>()
        {
            @Override
            public StorageStatement get()
            {
                return new StoreStatement( neoStores, indexReaderFactory, labelScanStore::newReader, lockService,
                        allocateCommandCreationContext() );
            }
        };
    }
","    private Supplier<StorageStatement> storeStatementSupplier( NeoStores neoStores )
    {
        Supplier<IndexReaderFactory> indexReaderFactory = () -> new IndexReaderFactory.Caching( indexingService );
        LockService lockService = takePropertyReadLocks ? this.lockService : NO_LOCK_SERVICE;

        return new Supplier<StorageStatement>()
        {
            @Override
            public StorageStatement get()
            {
                return new StoreStatement( neoStores, indexReaderFactory, labelScanStore::newReader, lockService,
                        allocateCommandCreationContext() );
            }
START         }; END 
    }
","    private Supplier<StorageStatement> storeStatementSupplier( NeoStores neoStores )
    {
        Supplier<IndexReaderFactory> indexReaderFactory = () -> new IndexReaderFactory.Caching( indexingService );
        LockService lockService = takePropertyReadLocks ? this.lockService : NO_LOCK_SERVICE;

        return () -> new StoreStatement( neoStores, indexReaderFactory, labelScanStore::newReader, lockService,
                allocateCommandCreationContext() );
    }
"
1257,Can be package-private?,"  public static byte[] convertBoolArrayToByteArray(boolean[] boolArr) {
    byte[] byteArr = new byte[(boolArr.length + 7) / 8];
    for (int i = 0; i < byteArr.length; i++) {
      byteArr[i] = readByte(boolArr, 8 * i);
    }
    return byteArr;
  }
","START   public static byte[] convertBoolArrayToByteArray(boolean[] boolArr) { END 
    byte[] byteArr = new byte[(boolArr.length + 7) / 8];
    for (int i = 0; i < byteArr.length; i++) {
      byteArr[i] = readByte(boolArr, 8 * i);
    }
    return byteArr;
  }
","  static byte[] convertBoolArrayToByteArray(boolean[] boolArr) {
    byte[] byteArr = new byte[(boolArr.length + 7) / 8];
    for (int i = 0; i < byteArr.length; i++) {
      byteArr[i] = readByte(boolArr, 8 * i);
    }
    return byteArr;
  }
"
1258,Minor: use AssertJ `org.assertj.core.util.List.list` and static import for readability.,"  public void all_composed_assertions_should_pass() {
    SoftAssertions delegate = new SoftAssertions();
    delegate.assertThat(1).isEqualTo(1);
    delegate.assertAll();

    softly.assertThat(1).isEqualTo(1);
    softly.assertThat(Lists.newArrayList(1, 2)).containsOnly(1, 2);
    softly.assertAlso(delegate);
    softly.assertAll();
    assertThat(softly.wasSuccess()).isTrue();
  }
","  public void all_composed_assertions_should_pass() {
    SoftAssertions delegate = new SoftAssertions();
    delegate.assertThat(1).isEqualTo(1);
    delegate.assertAll();

    softly.assertThat(1).isEqualTo(1);
START     softly.assertThat(Lists.newArrayList(1, 2)).containsOnly(1, 2); END 
    softly.assertAlso(delegate);
    softly.assertAll();
    assertThat(softly.wasSuccess()).isTrue();
  }
","  public void all_composed_assertions_should_pass() {
    // GIVEN
    SoftAssertions delegate = new SoftAssertions();
    delegate.assertThat(1).isEqualTo(1);
    delegate.assertAll();

    softly.assertThat(1).isEqualTo(1);
    softly.assertThat(list(1, 2)).containsOnly(1, 2);

    // WHEN
    softly.assertAlso(delegate);
    softly.assertAll();

    // THEN
    assertThat(softly.wasSuccess()).isTrue();
  }
"
1259,"* Why is super.reinitialize() not public?
* If you want super.reinitialize() protected, this class could ""open it up"" instead of defining a new method:

  @Override
  public void reinitialize() {
    super.reinitialize();
  }","    public void viewInfoUpdated() {
        this.reinitialize();
    }
","    public void viewInfoUpdated() {
START         this.reinitialize(); END 
    }
","    public void viewInfoUpdated() {
        reinitialize();
    }
"
1260,"This should either be a **protected/private/or default** constructor, and the **List** should be copied so the Pointer can't be modified outside of the class.

``` java
this.refTokens = refTokens.clone();
```

as it is now, I could do this:

``` java
Builder b = JSONPointer.builder().append(""key1"");
JSONPointer jp1 = b.build();
b.append(""key2"");
JSONPointer jp2 = b.build();
if(jp1.toString().equals(jp2.toString()){
    throw new Exception(""Oops, my pointers are sharing a backing array"");
}
```","    public JSONPointer(List<String> refTokens) {
        this.refTokens = refTokens;
    }
","START     public JSONPointer(List<String> refTokens) { END 
        this.refTokens = refTokens;
    }
","    public JSONPointer(List<String> refTokens) {
        this.refTokens = new ArrayList<String>(refTokens);
    }
"
1261,coudl be just ArrayList since now it is imported ^^ vv,"    public VM() {
        mVmStatic = new VmStatic();
        mVmDynamic = new VmDynamic();
        mVmStatistics = new VmStatistics();
        mVmStatic.setImages(new java.util.ArrayList<DiskImage>());
        mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>());
        mDiskMap = new java.util.HashMap<String, DiskImage>();
        mCdPath = """";
        mFloppyPath = """";
        mRunAndPause = false;
        _diskSize = 0;
    }
","    public VM() {
        mVmStatic = new VmStatic();
        mVmDynamic = new VmDynamic();
        mVmStatistics = new VmStatistics();
START         mVmStatic.setImages(new java.util.ArrayList<DiskImage>()); END 
        mVmStatic.setInterfaces(new java.util.ArrayList<VmNetworkInterface>());
        mDiskMap = new java.util.HashMap<String, DiskImage>();
        mCdPath = """";
        mFloppyPath = """";
        mRunAndPause = false;
        _diskSize = 0;
    }
","    public VM() {
        mVmStatic = new VmStatic();
        mVmDynamic = new VmDynamic();
        mVmStatistics = new VmStatistics();
        mVmStatic.setImages(new ArrayList<DiskImage>());
        mVmStatic.setInterfaces(new ArrayList<VmNetworkInterface>());
        mDiskMap = new java.util.HashMap<String, DiskImage>();
        mCdPath = """";
        mFloppyPath = """";
        mRunAndPause = false;
        _diskSize = 0;
    }
"
1262,Would suggest to make it `private`.,"    long consumerLag() {
      return consumerLag;
    }
","START     long consumerLag() { END 
      return consumerLag;
    }
","    private long consumerLag() {
      return consumerLag;
    }
"
1263,"In most other places we suppress boxing warnings by manually boxing in the code with Integer.valueOf() around the expression. This is especially true in MessageFormat.format invocations, which are very common in our error paths.

I think that is the general approach preferred within JGit.","	public RegexGroupFilter(final int groupIdx) {
		if (groupIdx < 1)
			throw new IllegalArgumentException(MessageFormat.format(HttpServerText.get().invalidIndex, groupIdx));
		this.groupIdx = groupIdx - 1;
	}
","	public RegexGroupFilter(final int groupIdx) {
		if (groupIdx < 1)
START 			throw new IllegalArgumentException(MessageFormat.format(HttpServerText.get().invalidIndex, groupIdx)); END 
		this.groupIdx = groupIdx - 1;
	}
","	public RegexGroupFilter(final int groupIdx) {
		if (groupIdx < 1)
			throw new IllegalArgumentException(MessageFormat.format(
					HttpServerText.get().invalidIndex, valueOf(groupIdx)));
		this.groupIdx = groupIdx - 1;
	}
"
1264,missing braces ? `blobSize` can end up to be 1 if `random.nextInt(10)` returns 0.,"  public void testChunkFillingBlobSizeMultipleOfChunkSize()
      throws Exception {
    blobSize = chunkSize * random.nextInt(10) + 1;
    fillChunksAndAssertSuccess();
  }
","  public void testChunkFillingBlobSizeMultipleOfChunkSize()
      throws Exception {
START     blobSize = chunkSize * random.nextInt(10) + 1; END 
    fillChunksAndAssertSuccess();
  }
","  public void testChunkFillingBlobSizeMultipleOfChunkSize()
      throws Exception {
    blobSize = chunkSize * (random.nextInt(10) + 1);
    fillChunksAndAssertSuccess();
  }
"
1265,Suggest protected to signal that this is for the subclass,"    EapAkaAttributeFactory() {}
","    START  EapAkaAttributeFactory() END  {}
","    protected EapAkaAttributeFactory() {}
"
1266,"I wouldn't implement this (just return null). A long has a fixed size, and we can use putLong() in HTInterval to write them to the file.

This method was more for string, structs, etc. that we want to serialize.","    public byte[] toByteArray() {
        return ByteBuffer.allocate(8).putLong(valueLong).array();
    }
","    public byte[] toByteArray() {
START         return ByteBuffer.allocate(8).putLong(valueLong).array(); END 
    }
","    public byte[] toByteArray() {
        return null;
    }
"
1267,there is no other way of getting article name?,"	public String getModeName() {
		String header = getHeader();
		return header.substring(0, header.indexOf(' '));
	}
","	public String getModeName() {
		String header = getHeader();
START 		return header.substring(0, header.indexOf(' ')); END 
	}
","	private String getModeName() {
		String header = getHeader();
		return header.substring(0, header.indexOf(' '));
	}
"
1268,@vilchik-elena Why not simply returning `bitSet`?,"  public int hashCode() {
    int result = bitSet;
    result = 31 * result + bitSet;
    return result;
  }
","  public int hashCode() {
    int result = bitSet;
    result = 31 * result + bitSet;
START     return result; END 
  }
","  public int hashCode() {
    return bitSet;
  }
"
1269,Not required,"  void setUnresolvedCompact(boolean unresolvedCompact) {
    this.unresolvedCompact = unresolvedCompact;
    if (outer != null) {
      outer.setUnresolvedCompact(true);
    }
  }
","  void setUnresolvedCompact(boolean unresolvedCompact) {
    this.unresolvedCompact = unresolvedCompact;
    if (outer != null) {
START       outer.setUnresolvedCompact(true); END 
    }
  }
","  void setUnresolvedCompact(boolean unresolvedCompact) {
    this.unresolvedCompact = unresolvedCompact;
  }
"
1270,"hrmmm, is this required? Will this happen already with the cluster teardown? And, is there redundant closing with the `after()` call?","  public static void afterClass() throws Exception {
    if (sLocalAlluxioJobCluster != null) {
      sLocalAlluxioJobCluster.stop();
    }
    sFileSystem.close();
  }
","  public static void afterClass() throws Exception {
    if (sLocalAlluxioJobCluster != null) {
      sLocalAlluxioJobCluster.stop();
    }
START     sFileSystem.close(); END 
  }
","  public static void afterClass() throws Exception {
    if (sLocalAlluxioJobCluster != null) {
      sLocalAlluxioJobCluster.stop();
    }
  }
"
1271,What If I give the empty string as an input of that method ?,"  public void testTrimLongSuffix() throws Exception {
    String longValue = ""12345"";
    assertThat(LiteralUtils.trimLongSuffix(longValue)).isEqualTo(longValue);
    assertThat(LiteralUtils.trimLongSuffix(longValue + ""l"")).isEqualTo(longValue);
    assertThat(LiteralUtils.trimLongSuffix(longValue + ""L"")).isEqualTo(longValue);
  }
","  public void testTrimLongSuffix() throws Exception {
START     String longValue = ""12345""; END 
    assertThat(LiteralUtils.trimLongSuffix(longValue)).isEqualTo(longValue);
    assertThat(LiteralUtils.trimLongSuffix(longValue + ""l"")).isEqualTo(longValue);
    assertThat(LiteralUtils.trimLongSuffix(longValue + ""L"")).isEqualTo(longValue);
  }
","  public void testTrimLongSuffix() throws Exception {
    assertThat(LiteralUtils.trimLongSuffix(null)).isEqualTo(null);
    assertThat(LiteralUtils.trimLongSuffix("""")).isEqualTo("""");
    String longValue = ""12345"";
    assertThat(LiteralUtils.trimLongSuffix(longValue)).isEqualTo(longValue);
    assertThat(LiteralUtils.trimLongSuffix(longValue + ""l"")).isEqualTo(longValue);
    assertThat(LiteralUtils.trimLongSuffix(longValue + ""L"")).isEqualTo(longValue);
  }
"
1272,spell out ret,"        public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context)
        {
            Map<TableScanNode, Void> ret = new IdentityHashMap<>();
            ret.put(node, null);
            return ret;
        }
","        public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context)
        {
START             Map<TableScanNode, Void> ret = new IdentityHashMap<>(); END 
            ret.put(node, null);
            return ret;
        }
","        public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context)
        {
            Map<TableScanNode, Void> result = new IdentityHashMap<>();
            result.put(node, null);
            return result;
        }
"
1273,should not be this private?,"        public int getStreamIndex()
        {
            return streamIndex;
        }
","        public int getStreamIndex()
        {
START             return streamIndex; END 
        }
","        private int getStreamIndex()
        {
            return streamIndex;
        }
"
1274,"simpler:

```
} catch (IOException e) {
  throw e;
} catch (Exception e) {
  throw new IOException(e);
}
```","        public Void call() throws IOException {
            if (task == null) {
                throw new IOException(""The callable "" + this + "" has been serialized somehow, but it is actually not serializable"");
            }
            try {
                return task.call();
            } catch (Exception ex) {
                if (ex instanceof IOException) {
                    throw (IOException)ex;
                }
                throw new IOException(ex);
            }
        }
","        public Void call() throws IOException {
            if (task == null) {
                throw new IOException(""The callable "" + this + "" has been serialized somehow, but it is actually not serializable"");
            }
            try {
                return task.call();
START             } catch (Exception ex) { END 
                if (ex instanceof IOException) {
                    throw (IOException)ex;
                }
                throw new IOException(ex);
            }
        }
","        public Void call() throws IOException {
            if (task == null) {
                throw new IOException(""The callable "" + this + "" has been serialized somehow, but it is actually not serializable"");
            }
            try {
                return task.call();
            } catch (IOException ex) {
                throw ex;
            } catch (Exception ex) {
                throw new IOException(ex);
            }
        }
"
1275,please remove the `try { .. } catch ( .. )` block altogether now.,"	public static File task(File projectDir, String dstName) throws IOException {
		File dstDir = new File(projectDir.getParent(), FileMetaDataExtractor.encodeSpecialCharsForFileSystem(dstName));

		try {
			if (projectDir.renameTo(dstDir)
					&& XstreamSerializer.renameProject(new File(dstDir, CODE_XML_FILE_NAME), dstName)) {
				return dstDir;
			} else {
				throw new IOException(""Cannot rename project directory "" + projectDir.getAbsolutePath() + "" to "" + dstName);
			}
		} catch (IOException e) {
			throw e;
		}
	}
","	public static File task(File projectDir, String dstName) throws IOException {
		File dstDir = new File(projectDir.getParent(), FileMetaDataExtractor.encodeSpecialCharsForFileSystem(dstName));

		try {
			if (projectDir.renameTo(dstDir)
					&& XstreamSerializer.renameProject(new File(dstDir, CODE_XML_FILE_NAME), dstName)) {
				return dstDir;
			} else {
				throw new IOException(""Cannot rename project directory "" + projectDir.getAbsolutePath() + "" to "" + dstName);
			}
		} catch (IOException e) {
START 			throw e; END 
		}
	}
","	public static File task(File projectDir, String dstName) throws IOException {
		File dstDir = new File(projectDir.getParent(), FileMetaDataExtractor.encodeSpecialCharsForFileSystem(dstName));

		if (projectDir.renameTo(dstDir)
				&& XstreamSerializer.renameProject(new File(dstDir, CODE_XML_FILE_NAME), dstName)) {
			return dstDir;
		} else {
			throw new IOException(""Cannot rename project directory "" + projectDir.getAbsolutePath() + "" to "" + dstName);
		}
	}
"
1276,Remove these extra variables that aren't used except in a setter.,"	private StockOperation createOperation(StockOperation operation, InventoryStockTake delegate) {
		operation.setStatus(StockOperationStatus.NEW);
		IStockOperationType operationType = WellKnownOperationTypes.getAdjustment();
		operation.setInstanceType(operationType);
		Stockroom stockroom;
		stockroom = delegate.getStockroom();
		operation.setSource(stockroom);
		operation.setOperationNumber(delegate.getOperationNumber());
		Date dNow = new Date();
		operation.setOperationDate(dNow);
		operation.setItems(createOperationsItemSet(operation, delegate.getItemStockSummaryList()));
		return operation;
	}
","	private StockOperation createOperation(StockOperation operation, InventoryStockTake delegate) {
		operation.setStatus(StockOperationStatus.NEW);
START 		IStockOperationType operationType = WellKnownOperationTypes.getAdjustment(); END 
		operation.setInstanceType(operationType);
		Stockroom stockroom;
		stockroom = delegate.getStockroom();
		operation.setSource(stockroom);
		operation.setOperationNumber(delegate.getOperationNumber());
		Date dNow = new Date();
		operation.setOperationDate(dNow);
		operation.setItems(createOperationsItemSet(operation, delegate.getItemStockSummaryList()));
		return operation;
	}
","	private StockOperation createOperation(StockOperation operation, InventoryStockTake delegate) {
		operation.setStatus(StockOperationStatus.NEW);
		IStockOperationType operationType = WellKnownOperationTypes.getAdjustment();
		operation.setInstanceType(operationType);
		Stockroom stockroom = delegate.getStockroom();
		operation.setSource(stockroom);
		operation.setOperationNumber(delegate.getOperationNumber());
		operation.setOperationDate(new Date());
		operation.setItems(createOperationsItemSet(operation, delegate.getItemStockSummaryList()));
		return operation;
	}
"
1277,"not sure if there's a reason for removing the parametrized type  MarshallingResponseBuilder<T>, see that when setting the messages you loose the type.
The other methods state, addMessage, and resout has the type.","        public MarshallingResponseBuilder messages(List<MarshallingMessage> messages) {
            this.messages.addAll(messages);
            return this;
        }
","START         public MarshallingResponseBuilder messages(List<MarshallingMessage> messages) { END 
            this.messages.addAll(messages);
            return this;
        }
","        public MarshallingResponseBuilder<T> messages(List<MarshallingMessage> messages) {
            this.messages.addAll(messages);
            return this;
        }
"
1278,nit: I think we generally prefer to explicitly state the access modifiers.,"    long getTokenCount() {
        return tokens.get();
    }
","START     long getTokenCount() { END 
        return tokens.get();
    }
","    protected long getTokenCount() {
        return tokens.get();
    }
"
1279,`printStackTrace()`? Isn't it better to use a logger?,"    public V getOrFill(K key, Callable<V> callable) {
        try {
            return callable.call() ;
        }
        catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
","    public V getOrFill(K key, Callable<V> callable) {
        try {
            return callable.call() ;
        }
        catch (Exception e) {
START             e.printStackTrace(); END 
            return null;
        }
    }
","    public V getOrFill(K key, Callable<V> callable) {
        try {
            return callable.call() ;
        }
        catch (Exception e) {
            return null;
        }
    }
"
1280,"This is too much specific logic that is spilling over into a very general function.  The only thing on which this needs to depend is Prefs.showActionFeedIndicator(), which it already does.","    void setUpHomeMenuIcon() {
        drawerIconDot.setVisibility(AccountUtil.isLoggedIn() && Prefs.showActionFeedIndicator() && ReleaseUtil.isPreBetaRelease() && Prefs.getTotalUserDescriptionsEdited() >= ACTION_DESCRIPTION_EDIT_UNLOCK_THRESHOLD ? VISIBLE : GONE);
    }
","    void setUpHomeMenuIcon() {
        drawerIconDot.setVisibility(AccountUtil.isLoggedIn() && Prefs.showActionFeedIndicator() && ReleaseUtil.isPreBetaRelease() START  && Prefs.getTotalUserDescriptionsEdited() >= ACTION_DESCRIPTION_EDIT_UNLOCK_THRESHOLD ? END  VISIBLE : GONE);
    }
","    void setUpHomeMenuIcon() {
        drawerIconDot.setVisibility(AccountUtil.isLoggedIn() && Prefs.showActionFeedIndicator() && ReleaseUtil.isPreBetaRelease() ? VISIBLE : GONE);
    }
"
1281,"Please remove unnecessary brackets:

 return Config.<Integer>getValue(
             configValue,
             compatibilityVersion != null ? compatibilityVersion.getValue() : Version.getLast().getValue()","    public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) {
        final ConfigValues configValue = getMaxMemConfigValueByOsId(osId);
        return Config.<Integer>getValue(
            configValue,
            (compatibilityVersion != null) ? compatibilityVersion.getValue() : Version.getLast().getValue()
        );
    }
","    public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) {
        final ConfigValues configValue = getMaxMemConfigValueByOsId(osId);
        return Config.<Integer>getValue(
            configValue,
START             (compatibilityVersion != null) ? compatibilityVersion.getValue() : Version.getLast().getValue() END 
        );
    }
","    public static int maxMemorySizeWithHotplugInMb(int osId, Version compatibilityVersion) {
        final ConfigValues configValue = getMaxMemConfigValueByOsId(osId);
        return Config.<Integer>getValue(
            configValue,
            compatibilityVersion != null ? compatibilityVersion.getValue() : Version.getLast().getValue()
        );
    }
"
1282,this is incorrect place for command,"    public void getPropertiesUpdatePlace(final TrendsPlace place){

        CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() {
            @Override
            public void onFailure(Throwable caught) {
                new ExceptionPanel(""Default properties will be used. Exception while properties retrieving: "" + caught.getMessage());
                updatePlace(place);
            }

            @Override
            public void onSuccess(WebClientProperties result) {
                webClientProperties = result;
                updateTagFilter();
                updatePlace(place);
            }
        });
    }
","    public void getPropertiesUpdatePlace(final TrendsPlace place){

        CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() {
            @Override
            public void onFailure(Throwable caught) {
                new ExceptionPanel(""Default properties will be used. Exception while properties retrieving: "" + caught.getMessage());
                updatePlace(place);
            }

            @Override
            public void onSuccess(WebClientProperties result) {
                webClientProperties = result;
START                 updateTagFilter(); END 
                updatePlace(place);
            }
        });
    }
","    public void getPropertiesUpdatePlace(final TrendsPlace place){

        CommonDataService.Async.getInstance().getWebClientProperties(new AsyncCallback<WebClientProperties>() {
            @Override
            public void onFailure(Throwable caught) {
                new ExceptionPanel(""Default properties will be used. Exception while properties retrieving: "" + caught.getMessage());
                updatePlace(place);
            }

            @Override
            public void onSuccess(WebClientProperties result) {
                webClientProperties = result;
                updatePlace(place);
            }
        });
    }
"
1283,What does this change bring? Did we need this to get the test working?,"  Context prepareDefaultContext(boolean parseAsFlume) {
    // Prepares a default context with Kafka Server Properties
    Context context = new Context();
    context.put(BOOTSTRAP_SERVERS_CONFIG, testUtil.getKafkaServerUrl());
    context.put(PARSE_AS_FLUME_EVENT, String.valueOf(parseAsFlume));
    context.put(""offsets.topic.replication.factor"", ""1"");
    context.put(TOPIC_CONFIG, topic);

    return context;
  }
","  Context prepareDefaultContext(boolean parseAsFlume) {
    // Prepares a default context with Kafka Server Properties
    Context context = new Context();
    context.put(BOOTSTRAP_SERVERS_CONFIG, testUtil.getKafkaServerUrl());
    context.put(PARSE_AS_FLUME_EVENT, String.valueOf(parseAsFlume));
START     context.put(""offsets.topic.replication.factor"", ""1""); END 
    context.put(TOPIC_CONFIG, topic);

    return context;
  }
","  Context prepareDefaultContext(boolean parseAsFlume) {
    // Prepares a default context with Kafka Server Properties
    Context context = new Context();
    context.put(BOOTSTRAP_SERVERS_CONFIG, testUtil.getKafkaServerUrl());
    context.put(PARSE_AS_FLUME_EVENT, String.valueOf(parseAsFlume));
    context.put(TOPIC_CONFIG, topic);

    return context;
  }
"
1284,Should probably return null,"    private String getDatacenter(InetAddressAndPort endpoint)
    {
        if (peersA.contains(endpoint))
            return ""datacenterA"";
        if (peersB.contains(endpoint))
            return ""datacenterB"";
        else if (peersC.contains(endpoint))
            return ""datacenterC"";
        return ""NA"";
    }
","    private String getDatacenter(InetAddressAndPort endpoint)
    {
        if (peersA.contains(endpoint))
            return ""datacenterA"";
        if (peersB.contains(endpoint))
            return ""datacenterB"";
        else if (peersC.contains(endpoint))
            return ""datacenterC"";
START         return ""NA""; END 
    }
","    private String getDatacenter(InetAddressAndPort endpoint)
    {
        if (peersA.contains(endpoint))
            return ""datacenterA"";
        if (peersB.contains(endpoint))
            return ""datacenterB"";
        else if (peersC.contains(endpoint))
            return ""datacenterC"";
        return null;
    }
"
1285,Constant simpleSum could even removed as this constant is never used outside this class.,"	private DateTimeFormatter getFormatter(){

		switch (this){

		case days:
			return DateTimeFormat.forPattern(""yyyy-MM-dd"");
		case months:
			return DateTimeFormat.forPattern(""yyyy/MM"");
		case weeks:
			return DateTimeFormat.forPattern(""yyyy/ww"");
		case years:
			return DateTimeFormat.forPattern(""yyyy"");
		case quarters:
			// has to be extended by the calling function
			return DateTimeFormat.forPattern(""yyyy"");
		case simpleSum:
			break;
		}
		return null;
	}
","	private DateTimeFormatter getFormatter(){

		switch (this){

		case days:
			return DateTimeFormat.forPattern(""yyyy-MM-dd"");
		case months:
			return DateTimeFormat.forPattern(""yyyy/MM"");
		case weeks:
			return DateTimeFormat.forPattern(""yyyy/ww"");
		case years:
			return DateTimeFormat.forPattern(""yyyy"");
		case quarters:
			// has to be extended by the calling function
			return DateTimeFormat.forPattern(""yyyy"");
		case simpleSum:
START 			break; END 
		}
		return null;
	}
","	private DateTimeFormatter getFormatter(){

		switch (this){

		case days:
			return DateTimeFormat.forPattern(""yyyy-MM-dd"");
		case months:
			return DateTimeFormat.forPattern(""yyyy/MM"");
		case weeks:
			return DateTimeFormat.forPattern(""yyyy/ww"");
		case years:
			return DateTimeFormat.forPattern(""yyyy"");
		case quarters:
			// has to be extended by the calling function
			return DateTimeFormat.forPattern(""yyyy"");
		}
		return null;
	}
"
1286,"I think this could be a one liner:

```java
this.defaultProperties = new HashMap<>(defaultProperties);
```","	public void setDefaultProperties(Map<String, Object> defaultProperties) {
		this.defaultProperties = new HashMap<>();
		for (Object key : Collections.list(defaultProperties.propertyNames())) {
			this.defaultProperties.put((String) key, defaultProperties.get(key));
		}
	}
","	public void setDefaultProperties(Map<String, Object> defaultProperties) {
START 		this.defaultProperties = new HashMap<>(); END 
		for (Object key : Collections.list(defaultProperties.propertyNames())) {
			this.defaultProperties.put((String) key, defaultProperties.get(key));
		}
	}
","	public void setDefaultProperties(Map<String, Object> defaultProperties) {
		this.defaultProperties = new HashMap<>(defaultProperties);
	}
"
1287,Can this be private?,"    protected MapSqlParameterSource createVnodeToPnodeParametersMapper(
            Integer pinnedIndex, Guid vNodeId) {
        return getCustomMapSqlParameterSource()
                .addValue(""id"", Guid.newGuid())
                .addValue(""vm_numa_node_id"", vNodeId)
                .addValue(""vds_numa_node_index"", pinnedIndex);
    }
","    START  protected END  MapSqlParameterSource createVnodeToPnodeParametersMapper(
            Integer pinnedIndex, Guid vNodeId) {
        return getCustomMapSqlParameterSource()
                .addValue(""id"", Guid.newGuid())
                .addValue(""vm_numa_node_id"", vNodeId)
                .addValue(""vds_numa_node_index"", pinnedIndex);
    }
","    private MapSqlParameterSource createVnodeToPnodeParametersMapper(
            Integer pinnedIndex, Guid vNodeId) {
        return getCustomMapSqlParameterSource()
                .addValue(""id"", Guid.newGuid())
                .addValue(""vm_numa_node_id"", vNodeId)
                .addValue(""vds_numa_node_index"", pinnedIndex);
    }
"
1288,"I would flip this for clarity:
`return data == null ? null : encode(cryptoBox.decrypt(iv, decode(data));`","    public String read(String key) {
        String data = dataManager.read(key);
        return (data != null) ? encode(cryptoBox.decrypt(iv, decode(data))) : data;
    }
","    public String read(String key) {
        String data = dataManager.read(key);
START         return (data != null) ? encode(cryptoBox.decrypt(iv, decode(data))) : data; END 
    }
","    public String read(String key) {
        String data = dataManager.read(key);
        return (data == null) ? null : encode(cryptoBox.decrypt(iv, decode(data)));
    }
"
1289,`super.init()` method never throw an exception.,"    public void setUp() throws Exception {
        super.init();
    }
","START     public void setUp() throws Exception { END 
        super.init();
    }
","    public void setUp() {
        super.init();
    }
"
1290,"`null` is not an acceptable value for `indexNullAs`. You can use `null` to represent ""no value was selected"", no need for an Optional.","	public S indexNullAs(F indexNullAs) {
		indexNullAsValue = Optional.of( indexNullAs );
		return thisAsS();
	}
","	public S indexNullAs(F indexNullAs) {
START 		indexNullAsValue = Optional.of( indexNullAs ); END 
		return thisAsS();
	}
","	public S indexNullAs(F indexNullAs) {
		indexNullAsValue = indexNullAs;
		return thisAsS();
	}
"
1291,import static Assert.assertEquals(),"    public void testGenericImageExtraction() {
        org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage());
        Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages());

        Assert.assertEquals(""http://ichef.bbci.co.uk/images/ic/1024x576/p028s846.png"", extractedGenericImage.getImage());
        Assert.assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType());
    }
","    public void testGenericImageExtraction() {
        org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage());
        Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages());

START         Assert.assertEquals(""http://ichef.bbci.co.uk/images/ic/1024x576/p028s846.png"", extractedGenericImage.getImage()); END 
        Assert.assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType());
    }
","    public void testGenericImageExtraction() {
        org.atlasapi.media.entity.Series extractedGenericImage = extractor.extract(seriesWithGenericImage());
        Image genericImage = Iterables.getOnlyElement(extractedGenericImage.getImages());

        assertEquals(""http://ichef.bbci.co.uk/images/ic/1024x576/p028s846.png"", extractedGenericImage.getImage());
        assertEquals(ImageType.GENERIC_IMAGE_CONTENT_ORIGINATOR, genericImage.getType());
    }
"
1292,How can a set be of a negative size?,"   void testDescribeInstances() {
      for (String region : ec2Api.getConfiguredRegions()) {
         Set<? extends Reservation<? extends RunningInstance>> allResults = client.describeInstancesInRegion(region);
         assertNotNull(allResults);
         assertTrue(allResults.size() >= 0);
      }
   }
","   void testDescribeInstances() {
      for (String region : ec2Api.getConfiguredRegions()) {
         Set<? extends Reservation<? extends RunningInstance>> allResults = client.describeInstancesInRegion(region);
         assertNotNull(allResults);
START          assertTrue(allResults.size() >= 0); END 
      }
   }
","   void testDescribeInstances() {
      for (String region : ec2Api.getConfiguredRegions()) {
         Set<? extends Reservation<? extends RunningInstance>> allResults = client.describeInstancesInRegion(region);
         assertNotNull(allResults);
      }
   }
"
1293,Package private should always be enough for testing. Use the same package for tests.,"    public static String quoteString(String s) {
        if (s == null) {
            return null;
        }
        if (!s.matches(""^\"".*\""$"")) {
            return ""\"""" + s + ""\"""";
        } else {
            return s;
        }
    }
","START     public static String quoteString(String s) { END 
        if (s == null) {
            return null;
        }
        if (!s.matches(""^\"".*\""$"")) {
            return ""\"""" + s + ""\"""";
        } else {
            return s;
        }
    }
","    static String quoteString(String s) {
        if (s == null) {
            return null;
        }
        if (!s.matches(""^\"".*\""$"")) {
            return ""\"""" + s + ""\"""";
        } else {
            return s;
        }
    }
"
1294,"Had an offline discussion with Aman, we can remove this check and serialize everything using getBytes()","    public Object getMin() {
      if (primitiveType == PrimitiveTypeName.BINARY) {
        if (originalType == OriginalType.UTF8) {
          return ((Binary) min).toStringUsingUTF8();
        } else {
           return new String(((Binary) min).getBytes());
        }
      }
      return min;
    }
","    public Object getMin() {
      if (primitiveType == PrimitiveTypeName.BINARY) {
START         if (originalType == OriginalType.UTF8) { END 
          return ((Binary) min).toStringUsingUTF8();
        } else {
           return new String(((Binary) min).getBytes());
        }
      }
      return min;
    }
","    public Object getMin() {
      if (primitiveType == PrimitiveTypeName.BINARY && min != null) {
         return new String(((Binary) min).getBytes());
      }
      return min;
    }
"
1295,fullName should be enough here too.,"   public int hashCode() {
      int result = name.hashCode();
      result = 31 * result + fullName.hashCode();
      return result;
   }
","   public int hashCode() {
START       int result = name.hashCode(); END 
      result = 31 * result + fullName.hashCode();
      return result;
   }
","   public int hashCode() {
      return fullName.hashCode();
   }
"
1296,"I think rather than checking `> 0`, it would make things clearer if you had a static value like `DEFAULT_TIMEOUT = -1` and then use that in `createHttpClient` and change these checks to be `socketTimeout != DEFAULT_TIMEOUT`.  Or something along those lines.","  private SocketConfig createSocketConfig(int socketTimeout) {
    return SocketConfig.custom()
        .setSoReuseAddress(true)
        .setSoTimeout(socketTimeout > 0 ? socketTimeout : TIMEOUT_THREE_HOURS)
        .build();
  }
","  private SocketConfig createSocketConfig(int socketTimeout) {
    return SocketConfig.custom()
        .setSoReuseAddress(true)
START         .setSoTimeout(socketTimeout > 0 ? socketTimeout : TIMEOUT_THREE_HOURS) END 
        .build();
  }
","  private SocketConfig createSocketConfig(int socketTimeout) {
    return SocketConfig.custom()
        .setSoReuseAddress(true)
        .setSoTimeout(socketTimeout)
        .build();
  }
"
1297,"nit: line break after ( or before "".set"" here.","  CommentBox(CodeMirror cm, CommentInfo info) {
    this.cm = cm;
    CommentRange range = info.range();
    if (range != null) {
      fromTo = FromTo.fromCommentRange(range);
      rangeMarker = cm.markText(
          fromTo.getFrom(),
          fromTo.getTo(),
          Configuration.create().set(""className"",
              DiffTable.style.range()));
    }
  }
","  CommentBox(CodeMirror cm, CommentInfo info) {
    this.cm = cm;
    CommentRange range = info.range();
    if (range != null) {
      fromTo = FromTo.fromCommentRange(range);
      rangeMarker = cm.markText(
          fromTo.getFrom(),
          fromTo.getTo(),
START           Configuration.create().set(""className"", END 
              DiffTable.style.range()));
    }
  }
","  CommentBox(CodeMirror cm, CommentInfo info) {
    this.cm = cm;
    CommentRange range = info.range();
    if (range != null) {
      fromTo = FromTo.create(range);
      rangeMarker = cm.markText(
          fromTo.getFrom(),
          fromTo.getTo(),
          Configuration.create()
              .set(""className"", DiffTable.style.range()));
    }
  }
"
1298,This is pretty lonely semicolon :wink:,"	public void removeTagFromImage(String imageName, String tagToBeRemoved) {
		selectImage(imageName);
		new ContextMenu(""Remove Tag"").select();
		String fullTag = """";
		Combo combo = new DefaultCombo();
		List<String> comboItems = combo.getItems();
		for (String item : comboItems) {
			if (item.contains(tagToBeRemoved)) {
				fullTag = item;
				break;
			}
		}
		combo.setSelection(fullTag);
		;
		new FinishButton().click();
	}
","	public void removeTagFromImage(String imageName, String tagToBeRemoved) {
		selectImage(imageName);
		new ContextMenu(""Remove Tag"").select();
		String fullTag = """";
		Combo combo = new DefaultCombo();
		List<String> comboItems = combo.getItems();
		for (String item : comboItems) {
			if (item.contains(tagToBeRemoved)) {
				fullTag = item;
				break;
			}
		}
		combo.setSelection(fullTag);
START 		; END 
		new FinishButton().click();
	}
","	public void removeTagFromImage(String imageName, String tagToBeRemoved) {
		selectImage(imageName);
		new ContextMenu(""Remove Tag"").select();
		String fullTag = """";
		Combo combo = new DefaultCombo();
		List<String> comboItems = combo.getItems();
		for (String item : comboItems) {
			if (item.contains(tagToBeRemoved)) {
				fullTag = item;
				break;
			}
		}
		combo.setSelection(fullTag);
		new FinishButton().click();
	}
"
1299,"do we really need this log? now that it is a command we should have a log for running a command, no?","    public void processOnVmStop(Collection<Guid> vmIds) {
        for (final Guid vmId : vmIds) {
            log.infoFormat(""process VM {0} that went down"", vmId);
            ThreadPoolUtil.execute(new Runnable() {
                @Override
                public void run() {
                    Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm,
                            new IdParameters(vmId),
                            ExecutionHandler.createInternalJobContext());
                }
            });
        }
    }
","    public void processOnVmStop(Collection<Guid> vmIds) {
        for (final Guid vmId : vmIds) {
START             log.infoFormat(""process VM {0} that went down"", vmId); END 
            ThreadPoolUtil.execute(new Runnable() {
                @Override
                public void run() {
                    Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm,
                            new IdParameters(vmId),
                            ExecutionHandler.createInternalJobContext());
                }
            });
        }
    }
","    public void processOnVmStop(Collection<Guid> vmIds) {
        for (final Guid vmId : vmIds) {
            ThreadPoolUtil.execute(new Runnable() {
                @Override
                public void run() {
                    Backend.getInstance().runInternalAction(VdcActionType.ProcessDownVm,
                            new IdParameters(vmId));
                }
            });
        }
    }
"
1300,nit: can just do this.defaultFilter = Preconditions.checkNotNull(defaultFilter),"  public BatchServerInventoryView(
      final ZkPathsConfig zkPaths,
      final CuratorFramework curator,
      final ObjectMapper jsonMapper,
      final Predicate<Pair<DruidServerMetadata, DataSegment>> defaultFilter
  )
  {
    super(
        log,
        zkPaths.getAnnouncementsPath(),
        zkPaths.getLiveSegmentsPath(),
        curator,
        jsonMapper,
        new TypeReference<Set<DataSegment>>()
        {
        }
    );

    Preconditions.checkNotNull(defaultFilter);
    this.defaultFilter = defaultFilter;
  }
","  public BatchServerInventoryView(
      final ZkPathsConfig zkPaths,
      final CuratorFramework curator,
      final ObjectMapper jsonMapper,
      final Predicate<Pair<DruidServerMetadata, DataSegment>> defaultFilter
  )
  {
    super(
        log,
        zkPaths.getAnnouncementsPath(),
        zkPaths.getLiveSegmentsPath(),
        curator,
        jsonMapper,
        new TypeReference<Set<DataSegment>>()
        {
        }
    );

    Preconditions.checkNotNull(defaultFilter);
START     this.defaultFilter = defaultFilter; END 
  }
","  public BatchServerInventoryView(
      final ZkPathsConfig zkPaths,
      final CuratorFramework curator,
      final ObjectMapper jsonMapper,
      final Predicate<Pair<DruidServerMetadata, DataSegment>> defaultFilter
  )
  {
    super(
        log,
        zkPaths.getAnnouncementsPath(),
        zkPaths.getLiveSegmentsPath(),
        curator,
        jsonMapper,
        new TypeReference<Set<DataSegment>>()
        {
        }
    );

    this.defaultFilter = Preconditions.checkNotNull(defaultFilter);
  }
"
1301,"Actually I don't think this is how it should work? We do not expose jackson directly to the user, and all the encoding and decoding happens on the spring side and not with the SDK itself.. shouldn't this go into the mapper/converter logic instead?","	protected void configureEnvironment(final ClusterEnvironment.Builder builder) {
		Jackson2ObjectMapperBuilder jacksonBuilder = new Jackson2ObjectMapperBuilder();
		jacksonBuilder.serializationInclusion(JsonInclude.Include.NON_NULL);

		jacksonBuilder.modules(new CouchbaseJacksonModule(), new JsonValueModule());
		ObjectMapper objectMapper = new ObjectMapper();
		objectMapper.registerModule(new CouchbaseJacksonModule());
		objectMapper.registerModule(new JsonValueModule());
		builder.jsonSerializer(JacksonJsonSerializer.create(objectMapper));
	}
","	protected void configureEnvironment(final ClusterEnvironment.Builder builder) {
START 		Jackson2ObjectMapperBuilder jacksonBuilder = new Jackson2ObjectMapperBuilder(); END 
		jacksonBuilder.serializationInclusion(JsonInclude.Include.NON_NULL);

		jacksonBuilder.modules(new CouchbaseJacksonModule(), new JsonValueModule());
		ObjectMapper objectMapper = new ObjectMapper();
		objectMapper.registerModule(new CouchbaseJacksonModule());
		objectMapper.registerModule(new JsonValueModule());
		builder.jsonSerializer(JacksonJsonSerializer.create(objectMapper));
	}
","	protected void configureEnvironment(final ClusterEnvironment.Builder builder) {
		ObjectMapper objectMapper = new ObjectMapper();
		objectMapper.registerModule(new CouchbaseJacksonModule());
		objectMapper.registerModule(new JsonValueModule());
		builder.jsonSerializer(JacksonJsonSerializer.create(objectMapper));
	}
"
1302,"Just doing updateTopologyConfigID is not enough. While process a topology change event, the discovery service does more work refer to processTopologyChangeNotification. 

While combining two events topology change and leadership change together, it is a bit complex. 

Would suggest to not call the fetchTopologyFromClusterManager.  First, the topology change is a notification API from clusterManager. Even with this call, it will fetch the cached value from clusterManagerAdapter. Second, it just add more complexity and doesn't completely solve the problem.","    public void processLockAcquire() {
        log.debug(""Process lock acquire event"");
        isLeader = true;

        // Regardless of the role of this node, on leadership acquisition
        // we shall query the topology provider to get the most up to date
        // topologyConfigId, which might have changed during our time as non-leaders
        // and for which we might have missed the change notification and update it on
        // the sink manager so the value is cached to filter messages upon receive.
        fetchTopologyFromClusterManager();
        updateTopologyConfigId(topologyDescriptor.getTopologyConfigId());
        onLeadershipAcquire();
    }
","    public void processLockAcquire() {
        log.debug(""Process lock acquire event"");
        isLeader = true;

        // Regardless of the role of this node, on leadership acquisition
        // we shall query the topology provider to get the most up to date
        // topologyConfigId, which might have changed during our time as non-leaders
        // and for which we might have missed the change notification and update it on
        // the sink manager so the value is cached to filter messages upon receive.
        fetchTopologyFromClusterManager();
START         updateTopologyConfigId(topologyDescriptor.getTopologyConfigId()); END 
        onLeadershipAcquire();
    }
","    public void processLockAcquire() {
        log.debug(""Process lock acquire event"");
        isLeader.set(true);
        onLeadershipAcquire();
    }
"
1303,"Normally you just return mClientModeImpl.getSyncDhcpInfo.

If you really want to introduce a local make it final.","    public DhcpInfo getDhcpInfo() {
        enforceAccessPermission();
        if (mVerboseLoggingEnabled) {
            mLog.info(""getDhcpInfo uid=%"").c(Binder.getCallingUid()).flush();
        }
        DhcpInfo dhcpInfo = mClientModeImpl.syncGetDhcpInfo();
        return dhcpInfo;
    }
","    public DhcpInfo getDhcpInfo() {
        enforceAccessPermission();
        if (mVerboseLoggingEnabled) {
            mLog.info(""getDhcpInfo uid=%"").c(Binder.getCallingUid()).flush();
        }
        START  DhcpInfo dhcpInfo = mClientModeImpl.syncGetDhcpInfo();
        return dhcpInfo; END 
    }
","    public DhcpInfo getDhcpInfo() {
        enforceAccessPermission();
        if (mVerboseLoggingEnabled) {
            mLog.info(""getDhcpInfo uid=%"").c(Binder.getCallingUid()).flush();
        }
        return mClientModeImpl.syncGetDhcpInfo();
    }
"
1304,why do we use strings here?,"  public void setUp() throws Exception {
    MetadataStorageConnectorConfig config = jsonReadWriteRead(
          ""{""
        + ""\""type\"" : \""db\"",\n""
        + ""\""segmentTable\"" : \""segments\""\n""
        + ""}"",
        MetadataStorageConnectorConfig.class
    );

    connector = new TestDerbyConnector(
        Suppliers.ofInstance(config),
        Suppliers.ofInstance(tablesConfig)
    );
  }
","  public void setUp() throws Exception {
START     MetadataStorageConnectorConfig config = jsonReadWriteRead( END 
          ""{""
        + ""\""type\"" : \""db\"",\n""
        + ""\""segmentTable\"" : \""segments\""\n""
        + ""}"",
        MetadataStorageConnectorConfig.class
    );

    connector = new TestDerbyConnector(
        Suppliers.ofInstance(config),
        Suppliers.ofInstance(tablesConfig)
    );
  }
","  public void setUp() throws Exception {
    connector = new TestDerbyConnector(
        Suppliers.ofInstance(new MetadataStorageConnectorConfig()),
        Suppliers.ofInstance(tablesConfig)
    );
  }
"
1305,"You should use `HttpServletResponse.SC_...` everywhere, no need for `HttpStatus` here.","    protected void sendHealthCheckResponse(HttpServletResponse resp, HealthCheckResult result) throws IOException {
        if (result.healthy) {
            resp.setStatus(HttpServletResponse.SC_OK);
        } else {
            resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR);
        }
        sendResponse(resp, result.toJson());
    }
","    protected void sendHealthCheckResponse(HttpServletResponse resp, HealthCheckResult result) throws IOException {
        if (result.healthy) {
            resp.setStatus(HttpServletResponse.SC_OK);
        } else {
START             resp.setStatus(HttpStatus.SC_INTERNAL_SERVER_ERROR); END 
        }
        sendResponse(resp, result.toJson());
    }
","    protected void sendHealthCheckResponse(HttpServletResponse resp, HealthCheckResult result) throws IOException {
        if (result.healthy) {
            resp.setStatus(HttpServletResponse.SC_OK);
        } else {
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        }
        sendResponse(resp, result.toJson());
    }
"
1306,Same for detach,"    public DeviceInfoReturn attachManagedBlockStorageVolume(Guid volumeId, Map<String, Object> connectionInfo) {
        JsonRpcRequest request =
                new RequestBuilder(""ManagedVolume.attach_volume"")
                        .withParameter(""vol_id"", volumeId)
                        .withParameter(""connection_info"", connectionInfo)
                        .build();
        Map<String, Object> response = new FutureMap(this.client, request);
        Map<String, Object> info = (Map<String, Object>) response.get(""info"");
        return new DeviceInfoReturn(info);
    }
","    public DeviceInfoReturn attachManagedBlockStorageVolume(Guid volumeId, Map<String, Object> connectionInfo) {
        JsonRpcRequest request =
                new RequestBuilder(""ManagedVolume.attach_volume"")
                        .withParameter(""vol_id"", START  volumeId) END 
                        .withParameter(""connection_info"", connectionInfo)
                        .build();
        Map<String, Object> response = new FutureMap(this.client, request);
        Map<String, Object> info = (Map<String, Object>) response.get(""info"");
        return new DeviceInfoReturn(info);
    }
","    public DeviceInfoReturn attachManagedBlockStorageVolume(Guid volumeId, Map<String, Object> connectionInfo) {
        JsonRpcRequest request =
                new RequestBuilder(""ManagedVolume.attach_volume"")
                        .withParameter(""vol_id"", volumeId.toString())
                        .withParameter(""connection_info"", connectionInfo)
                        .build();
        Map<String, Object> response = new FutureMap(this.client, request);
        Map<String, Object> info = (Map<String, Object>) response.get(""info"");
        return new DeviceInfoReturn(info);
    }
"
1307,"As a paranoia sufferer, I would invert the equals to avoid the remote possibility of a NPE:
```java
if (MantaHttpHeaders.REQUEST_ID.equals(header.getName())) {
```","    public static void addHeaders(final HttpMessage httpMessage, final Header... headers) {
        Validate.notNull(httpMessage, ""HttpMessage must not be null"");
        for (final Header header : headers) {
            if (header.getName().equals(MantaHttpHeaders.REQUEST_ID)) {
                continue;
            }

            httpMessage.addHeader(header);
        }
    }
","    public static void addHeaders(final HttpMessage httpMessage, final Header... headers) {
        Validate.notNull(httpMessage, ""HttpMessage must not be null"");
        for (final Header header : headers) {
START             if (header.getName().equals(MantaHttpHeaders.REQUEST_ID)) { END 
                continue;
            }

            httpMessage.addHeader(header);
        }
    }
","    public static void addHeaders(final HttpMessage httpMessage, final Header... headers) {
        Validate.notNull(httpMessage, ""HttpMessage must not be null"");
        for (final Header header : headers) {
            if (MantaHttpHeaders.REQUEST_ID.equals(header.getName())) {
                continue;
            }

            httpMessage.addHeader(header);
        }
    }
"
1308,`this.path` is initialized to a value so this is not necessary.,"		public String getServletMapping() {
			if ("""".equals(this.path) || ""/"".equals(this.path)) {
				return ""/"";
			}
			if (this.path.endsWith(""/"")) {
				return this.path + ""*"";
			}
			return this.path + ""/*"";
		}
","		public String getServletMapping() {
START 			if ("""".equals(this.path) || ""/"".equals(this.path)) { END 
				return ""/"";
			}
			if (this.path.endsWith(""/"")) {
				return this.path + ""*"";
			}
			return this.path + ""/*"";
		}
","		public String getServletMapping() {
			if (this.path.equals("""") || this.path.equals(""/"")) {
				return ""/"";
			}
			if (this.path.endsWith(""/"")) {
				return this.path + ""*"";
			}
			return this.path + ""/*"";
		}
"
1309,"Now that this is a standalone function. You can just do `return InetAdress.get...` here, and remove the temporary variable.","    private static InetAddress toInetAddress(Slice ipAddress)
    {
        InetAddress address;
        try {
            address = InetAddress.getByAddress(ipAddress.getBytes());
        }
        catch (UnknownHostException e) {
            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, ""Invalid IP address binary: "" + ipAddress.toStringUtf8(), e);
        }
        return address;
    }
","    private static InetAddress toInetAddress(Slice ipAddress)
    {
        InetAddress address;
        try {
START             address = InetAddress.getByAddress(ipAddress.getBytes()); END 
        }
        catch (UnknownHostException e) {
            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, ""Invalid IP address binary: "" + ipAddress.toStringUtf8(), e);
        }
        return address;
    }
","    private static InetAddress toInetAddress(Slice ipAddress)
    {
        try {
            return InetAddress.getByAddress(ipAddress.getBytes());
        }
        catch (UnknownHostException e) {
            throw new PrestoException(INVALID_FUNCTION_ARGUMENT, ""Invalid IP address binary: "" + ipAddress.toStringUtf8(), e);
        }
    }
"
1310,EqualsVerifier test please for equals and hashcode,"  public int hashCode()
  {
    return Objects.hash(sqls, sqlFirehoseDatabaseConnector, objectMapper, foldCase);
  }
","  public int hashCode()
  {
    return Objects.hash(sqls, sqlFirehoseDatabaseConnector, objectMapper, foldCase);
START   } END 
","  public int hashCode()
  {
    return Objects.hash(sqls, sqlFirehoseDatabaseConnector, foldCase);
  }
"
1311,Can we return an empty list here instead?,"    protected final List<ResultDocument> getSearchResults(ExecutionContext ctx) {
        return null;
    }
","    protected final List<ResultDocument> getSearchResults(ExecutionContext ctx) {
START         return null; END 
    }
","    protected final List<ResultDocument> getSearchResults(ExecutionContext ctx) {
        // This should be called at all
        throw new IllegalStateException();
    }
"
1312,"Seems like there's a spacing issue here, two spaces instead of 4.","    protected boolean isAppConfiguredInSourceServerXml(String fileName) {

    	boolean bConfigured = false; 

    	Set<String> locations = getAppConfigLocationsFromSourceServerXml();

        if (locations.contains(fileName)) {
            log.debug(""Application configuration is found in server.xml : "" + fileName);
            bConfigured = true;
        }
        
        return bConfigured;
    }
","    protected boolean isAppConfiguredInSourceServerXml(String fileName) {

START     	boolean bConfigured = false;  END 

    	Set<String> locations = getAppConfigLocationsFromSourceServerXml();

        if (locations.contains(fileName)) {
            log.debug(""Application configuration is found in server.xml : "" + fileName);
            bConfigured = true;
        }
        
        return bConfigured;
    }
","    protected boolean isAppConfiguredInSourceServerXml(String fileName) {

        Set<String> locations = getAppConfigLocationsFromSourceServerXml();

        if (locations.contains(fileName)) {
            log.debug(""Application configuration is found in server.xml : "" + fileName);
            return true;
        } else {
            return false;
        }
    }
"
1313,log.debug ?,"    private DataCenter reInitializeDataCenter(String dcId) throws RuntimeException {
        log.info(""about to reinitialize dc"");
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(dcId);
        updateDataCenter(dataCenter);
        return dataCenter;
    }
","    private DataCenter reInitializeDataCenter(String dcId) throws RuntimeException {
START         log.info(""about to reinitialize dc""); END 
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(dcId);
        updateDataCenter(dataCenter);
        return dataCenter;
    }
","    private DataCenter reInitializeDataCenter(String dcId) throws RuntimeException {
        log.warn(""about to reinitialize dc"");
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(dcId);
        updateDataCenter(dataCenter);
        return dataCenter;
    }
"
1314,who releases the request if an IOException is thrown?,"  public void send(Send request) throws IOException {
    if (!connected) {
      throw new ClosedChannelException();
    }
    while (!request.isSendComplete()) {
      request.writeTo(writeChannel);
    }
    request.release();
  }
","  public void send(Send request) throws IOException {
    if (!connected) {
      throw new ClosedChannelException();
    }
    while (!request.isSendComplete()) {
      request.writeTo(writeChannel);
    }
START     request.release(); END 
  }
","  public void send(Send request) throws IOException {
    try {
      if (!connected) {
        throw new ClosedChannelException();
      }
      while (!request.isSendComplete()) {
        request.writeTo(writeChannel);
      }
    } finally {
      request.release();
    }
  }
"
1315,Can we revert this and keep the order deterministic?,"    public void canParseNamedCaptureGroupsFromPattern() {
        assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""""), hasSize(0));
        assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""(?<user>.*)""), contains(""user""));
        assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""Node /(?<poolName>.*?)/(?<poolMember>\\S+) address (?<poolAddr>\\S+) monitor status down. .*\\(slot(?<slotNum>[0-9]+)\\)""),
                containsInAnyOrder(""poolName"", ""poolMember"", ""poolAddr"", ""slotNum""));
    }
","    public void canParseNamedCaptureGroupsFromPattern() {
        assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""""), hasSize(0));
        assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""(?<user>.*)""), contains(""user""));
        assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""Node /(?<poolName>.*?)/(?<poolMember>\\S+) address (?<poolAddr>\\S+) monitor status down. .*\\(slot(?<slotNum>[0-9]+)\\)""),
START                 containsInAnyOrder(""poolName"", ""poolMember"", ""poolAddr"", ""slotNum"")); END 
    }
","    public void canParseNamedCaptureGroupsFromPattern() {
        assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""""), hasSize(0));
        assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""(?<user>.*)""), contains(""user""));
        assertThat(RegexUtils.getNamedCaptureGroupsFromPattern(""Node /(?<poolName>.*?)/(?<poolMember>\\S+) address (?<poolAddr>\\S+) monitor status down. .*\\(slot(?<slotNum>[0-9]+)\\)""),
                contains(""poolName"", ""poolMember"", ""poolAddr"", ""slotNum""));
    }
"
1316,"I'd then check the exception class plus parameters, not the message that isn't even sent to the user.","	public void testActivateAppUnknownApp() throws Exception
	{
		App app = when(mock(App.class).isActive()).thenReturn(false).getMock();
		MvcResult result = mockMvc.perform(post(AppsController.URI + ""/id/activate"")).andReturn();

		assertEquals(result.getResolvedException().getMessage(), ""Unknown app 'id'"");
	}
","	public void testActivateAppUnknownApp() throws Exception
	{
		App app = when(mock(App.class).isActive()).thenReturn(false).getMock();
		MvcResult result = mockMvc.perform(post(AppsController.URI + ""/id/activate"")).andReturn();

START 		assertEquals(result.getResolvedException().getMessage(), ""Unknown app 'id'""); END 
	}
","	public void testActivateAppUnknownApp() throws Exception
	{
		App app = when(mock(App.class).isActive()).thenReturn(false).getMock();
		MvcResult result = mockMvc.perform(post(AppsController.URI + ""/id/activate"")).andReturn();

		throw result.getResolvedException();
	}
"
1317,"Doesn't the InstallReceiver depend on a WikipediaApp instance being created by the system? Since NotificationPollService.start() is already called there, I think this would call it a second time","    public void onReceive(Context ctx, Intent intent) {
        String action = intent.getAction();
        switch (action) {
            case INSTALL_ACTION:
                // for play store devices only:
                // * invoke the receiver and open the page:
                //     `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es ""referrer"" ""referrer_url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWombat&campaign_id=foo&install_id=bar""`
                // * invoke the receiver but don't open the app (bad url):
                //     `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es ""referrer"" ""referrer_url=gibberish&campaign_id=foo&install_id=bar""`
                installReferrer(ctx, intent);
                break;
            case Intent.ACTION_BOOT_COMPLETED:
                // `adb shell am broadcast -a android.intent.action.BOOT_COMPLETED`
                recordChannelId(ctx);
                NotificationPollService.start(ctx.getApplicationContext());
                break;
            default:
                L.d(""action="" + action);
                break;
        }
    }
","    public void onReceive(Context ctx, Intent intent) {
        String action = intent.getAction();
        switch (action) {
            case INSTALL_ACTION:
                // for play store devices only:
                // * invoke the receiver and open the page:
                //     `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es ""referrer"" ""referrer_url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWombat&campaign_id=foo&install_id=bar""`
                // * invoke the receiver but don't open the app (bad url):
                //     `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es ""referrer"" ""referrer_url=gibberish&campaign_id=foo&install_id=bar""`
                installReferrer(ctx, intent);
                break;
            case Intent.ACTION_BOOT_COMPLETED:
                // `adb shell am broadcast -a android.intent.action.BOOT_COMPLETED`
                recordChannelId(ctx);
                NotificationPollService.start(ctx.getApplicationContext());
                break;
START             default: END 
                L.d(""action="" + action);
                break;
        }
    }
","    public void onReceive(Context ctx, Intent intent) {
        String action = intent.getAction();
        switch (action) {
            case INSTALL_ACTION:
                // for play store devices only:
                // * invoke the receiver and open the page:
                //     `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es ""referrer"" ""referrer_url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWombat&campaign_id=foo&install_id=bar""`
                // * invoke the receiver but don't open the app (bad url):
                //     `adb shell am broadcast -a com.android.vending.INSTALL_REFERRER -n org.wikipedia.dev/org.wikipedia.analytics.InstallReceiver --es ""referrer"" ""referrer_url=gibberish&campaign_id=foo&install_id=bar""`
                installReferrer(ctx, intent);
                break;
            case Intent.ACTION_BOOT_COMPLETED:
                // `adb shell am broadcast -a android.intent.action.BOOT_COMPLETED`
                recordChannelId(ctx);
                break;
            default:
                L.d(""action="" + action);
                break;
        }
    }
"
1318,"can this have an overloaded method please so we don't have to pass null around?
```suggestion
            StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId);
```","    private String getTokenToUse(String authTokenCredentialId, String token) {
        if (!StringUtils.isEmpty(authTokenCredentialId)) {
            StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId, null);
            if (credentials != null) {
                logger.fine(""Using Integration Token Credential ID."");
                return credentials.getSecret().getPlainText();
            }
        }

        logger.fine(""Using Integration Token."");
        return token;
    }
","    private String getTokenToUse(String authTokenCredentialId, String token) {
        if (!StringUtils.isEmpty(authTokenCredentialId)) {
START             StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId, null); END 
            if (credentials != null) {
                logger.fine(""Using Integration Token Credential ID."");
                return credentials.getSecret().getPlainText();
            }
        }

        logger.fine(""Using Integration Token."");
        return token;
    }
","    private String getTokenToUse(String authTokenCredentialId, String token) {
        if (!StringUtils.isEmpty(authTokenCredentialId)) {
            StringCredentials credentials = CredentialsObtainer.lookupCredentials(authTokenCredentialId);
            if (credentials != null) {
                logger.fine(""Using Integration Token Credential ID."");
                return credentials.getSecret().getPlainText();
            }
        }

        logger.fine(""Using Integration Token."");
        return token;
    }
"
1319,and then you may be able to drop the `options != null` check.,"  void onGetBlobError(Exception e, GetBlobOptions options) {
    if (options != null && options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) {
      onGetBlobInfoError(e);
    } else {
      onGetBlobDataError(e, options);
    }
  }
","  void onGetBlobError(Exception e, GetBlobOptions options) {
START     if (options != null && options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) { END 
      onGetBlobInfoError(e);
    } else {
      onGetBlobDataError(e, options);
    }
  }
","  void onGetBlobError(Exception e, GetBlobOptions options) {
    if (options.getOperationType() == GetBlobOptions.OperationType.BlobInfo) {
      onGetBlobInfoError(e);
    } else {
      onGetBlobDataError(e, options);
    }
  }
"
1320,"If you add `@NonNull` here than it's not worth checking the `null` again inside. You should safely assume that the client of the method is fulfilling the non null pre-condition. The IDE will tell the client of the method that a null argument should not be passed. So, either you remove `@NonNull` or remove the check for `!= null` inside.","        public void setSelectedChapter(@NonNull Chapter chapter) {
            if (mSelectedChapter != null) {
                trackView();
            }
            this.mSelectedChapter = chapter;
        }
","START         public void setSelectedChapter(@NonNull Chapter chapter) { END 
            if (mSelectedChapter != null) {
                trackView();
            }
            this.mSelectedChapter = chapter;
        }
","        public void setSelectedChapter(@NonNull Chapter chapter) {
            if (mSelectedChapter != null) {
                trackView();
            }
            mSelectedChapter = chapter;
        }
"
1321,"we always use parentheses, also for one-line statements.","	public void open(GenericInputSplit split) throws IOException {
        super.open(split);
		if (serializableIter != null)
			it = serializableIter;
		else
			it = this.dataSet.iterator();
	}
","	public void open(GenericInputSplit split) throws IOException {
        super.open(split);
START 		if (serializableIter != null) END 
			it = serializableIter;
		else
			it = this.dataSet.iterator();
	}
","	public void open(GenericInputSplit split) throws IOException {
        super.open(split);
		if (serializableIter != null) {
			it = serializableIter;
        }
		else {
			it = this.dataSet.iterator();
        }
	}
"
1322,Can we remove this? I realize what it was for but I don't think it should be kept around in the example.,"  @Override protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    TextView tv = new TextView(this);
    tv.setText(""Check logcat!"");
    setContentView(tv);

    printArgs(""The"", ""Quick"", ""Brown"", ""Fox"");

    Log.i(""Fibonacci"", ""fibonacci's 4th number is "" + fibonacci(4));

    Greeter greeter = new Greeter(""Jake"");
    Log.d(""Greeting"", greeter.sayHello());

    startSleepyThread();

    synchronized (Boolean.TRUE){}
  }
","  @Override protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    TextView tv = new TextView(this);
    tv.setText(""Check logcat!"");
    setContentView(tv);

    printArgs(""The"", ""Quick"", ""Brown"", ""Fox"");

    Log.i(""Fibonacci"", ""fibonacci's 4th number is "" + fibonacci(4));

    Greeter greeter = new Greeter(""Jake"");
    Log.d(""Greeting"", greeter.sayHello());

    startSleepyThread();

START     synchronized (Boolean.TRUE){} END 
  }
","  @Override protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    TextView tv = new TextView(this);
    tv.setText(""Check logcat!"");
    setContentView(tv);

    printArgs(""The"", ""Quick"", ""Brown"", ""Fox"");

    Log.i(""Fibonacci"", ""fibonacci's 4th number is "" + fibonacci(4));

    Greeter greeter = new Greeter(""Jake"");
    Log.d(""Greeting"", greeter.sayHello());

    startSleepyThread();
  }
"
1323,Please remove `mAfterKeys` while you're at it. It was only a workaround for the absence of `ContentValues.keySet()` on Android 2.x. Since we don't support Android 2 any more you can remove it in most places and replace by `mAfterContentValues.keySet()` where it's being read.,"    private ContentValues ensureAfter()
    {
        ContentValues values = mAfterContentValues;
        if (values == null)
        {
            values = new ContentValues();
            mAfterContentValues = values;
            // also create mAfterKeys
            mAfterKeys = new HashSet<>();
        }
        return values;
    }
","    private ContentValues ensureAfter()
    {
        ContentValues values = mAfterContentValues;
        if (values == null)
        {
            values = new ContentValues();
            mAfterContentValues = values;
            // also create mAfterKeys
START             mAfterKeys = new HashSet<>(); END 
        }
        return values;
    }
","    private ContentValues ensureAfter()
    {
        ContentValues values = mAfterContentValues;
        if (values == null)
        {
            values = new ContentValues();
            mAfterContentValues = values;
        }
        return values;
    }
"
1324,The parameter can bee removed,"  private Task<? extends Serializable> createDbTask(Database dbObj) {
    // note that we do not set location - for repl load, we want that auto-created.
    CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc(dbObj.getName(), dbObj.getDescription(), null, false,
        updateDbProps(dbObj, context.dumpDirectory, true));
    // If it exists, we want this to be an error condition. Repl Load is not intended to replace a
    // db.
    // TODO: we might revisit this in create-drop-recreate cases, needs some thinking on.
    DDLWork2 work = new DDLWork2(new HashSet<>(), new HashSet<>(), createDbDesc);
    return TaskFactory.get(work, context.hiveConf);
  }
","  private Task<? extends Serializable> createDbTask(Database dbObj) {
    // note that we do not set location - for repl load, we want that auto-created.
    CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc(dbObj.getName(), dbObj.getDescription(), null, false,
START         updateDbProps(dbObj, context.dumpDirectory, true)); END 
    // If it exists, we want this to be an error condition. Repl Load is not intended to replace a
    // db.
    // TODO: we might revisit this in create-drop-recreate cases, needs some thinking on.
    DDLWork2 work = new DDLWork2(new HashSet<>(), new HashSet<>(), createDbDesc);
    return TaskFactory.get(work, context.hiveConf);
  }
","  private Task<? extends Serializable> createDbTask(Database dbObj) {
    // note that we do not set location - for repl load, we want that auto-created.
    CreateDatabaseDesc createDbDesc = new CreateDatabaseDesc(dbObj.getName(), dbObj.getDescription(), null, false,
        updateDbProps(dbObj, context.dumpDirectory));
    // If it exists, we want this to be an error condition. Repl Load is not intended to replace a
    // db.
    // TODO: we might revisit this in create-drop-recreate cases, needs some thinking on.
    DDLWork2 work = new DDLWork2(new HashSet<>(), new HashSet<>(), createDbDesc);
    return TaskFactory.get(work, context.hiveConf);
  }
"
1325,what is the purpose of maxWriteTimeInMs now? how is it being used?,"  public long writeTo(Write writeChannel)
      throws IOException {
    long sizeWritten = 0;
    ReadableByteChannel readableByteChannel = Channels.newChannel(streamToWrite);
    sizeWritten = writeChannel.appendFrom(readableByteChannel, sizeToWrite);
    if(sizeWritten != sizeToWrite) {
      throw new IOException(""Not able to write fully. Expected : "" + sizeToWrite +
          "" Actual : "" + sizeWritten );
    }
    return sizeWritten;
  }
","  public long writeTo(Write writeChannel)
      throws IOException {
    long sizeWritten = 0;
    ReadableByteChannel readableByteChannel = Channels.newChannel(streamToWrite);
    sizeWritten = writeChannel.appendFrom(readableByteChannel, sizeToWrite);
    if(sizeWritten != sizeToWrite) {
      throw new IOException(""Not able to write fully. Expected : "" + sizeToWrite +
          "" Actual : "" + sizeWritten );
    }
START     return sizeWritten; END 
  }
","  public long writeTo(Write writeChannel)
      throws IOException {
    ReadableByteChannel readableByteChannel = Channels.newChannel(streamToWrite);
    writeChannel.appendFrom(readableByteChannel, sizeToWrite);
    return sizeToWrite;
  }
"
1326,"exists check is not done for SNAPSHOT jars intentionally so that they get updated everytime. SNAPSHOT jars are to be used for testing only and are designed to get updated on each run. Or else there would be no reason for method 'addSnapshotJarToClassPath' to exist.
i guess your failure is a result of running concurrent jobs with SNAPSHOT jars.","  static void addSnapshotJarToClassPath(
      File jarFile,
      Path intermediateClassPath,
      FileSystem fs,
      Job job
  ) throws IOException
  {
    // Snapshot jars are uploaded to non shared intermediate directory.
    final Path hdfsPath = new Path(intermediateClassPath, jarFile.getName());

    // existing is used to prevent uploading file multiple times in same run.
    if (!existing.contains(hdfsPath) || !fs.exists(hdfsPath)) {
      uploadJar(jarFile, hdfsPath, fs);
      existing.add(hdfsPath);
    }
    job.addFileToClassPath(hdfsPath);
  }
","  static void addSnapshotJarToClassPath(
      File jarFile,
      Path intermediateClassPath,
      FileSystem fs,
      Job job
  ) throws IOException
  {
    // Snapshot jars are uploaded to non shared intermediate directory.
    final Path hdfsPath = new Path(intermediateClassPath, jarFile.getName());

    // existing is used to prevent uploading file multiple times in same run.
START     if (!existing.contains(hdfsPath) || !fs.exists(hdfsPath)) { END 
      uploadJar(jarFile, hdfsPath, fs);
      existing.add(hdfsPath);
    }
    job.addFileToClassPath(hdfsPath);
  }
","  static void addSnapshotJarToClassPath(
      File jarFile,
      Path intermediateClassPath,
      FileSystem fs,
      Job job
  ) throws IOException
  {
    // Snapshot jars are uploaded to non shared intermediate directory.
    final Path hdfsPath = new Path(intermediateClassPath, jarFile.getName());
    // Prevent uploading same file multiple times in same run.
    if (!fs.exists(hdfsPath)) {
      uploadJar(jarFile, hdfsPath, fs);
    }
    job.addFileToClassPath(hdfsPath);
  }
"
1327,It's better to make the listener unregister itself at stop time instead of storing a boolean. See for instance `WorkManagerImpl.init` and the implementation of `afterStop`.,"    public void start(ComponentContext context) {
        super.start(context);
        configs.forEach(this::createStreamIfNotExists);
        processorDescriptors.forEach(this::initProcessor);
        if (! componentListenerAdded) {
            // this must be done only once while start method can be called multiple time on hot reload
            Framework.getRuntime().getComponentManager().addListener(new ComponentsLifeCycleListener());
            componentListenerAdded = true;
        }
    }
","    public void start(ComponentContext context) {
        super.start(context);
        configs.forEach(this::createStreamIfNotExists);
        processorDescriptors.forEach(this::initProcessor);
        if (! componentListenerAdded) {
            // this must be done only once while start method can be called multiple time on hot reload
            Framework.getRuntime().getComponentManager().addListener(new ComponentsLifeCycleListener());
START             componentListenerAdded = true; END 
        }
    }
","    public void start(ComponentContext context) {
        super.start(context);
        configs.forEach(this::createStreamIfNotExists);
        processorDescriptors.forEach(this::initProcessor);
        Framework.getRuntime().getComponentManager().addListener(new ComponentsLifeCycleListener());
    }
"
1328,Please keep it in info level.,"	public void reportTaskStatus(int id, Task.TaskStatus status, long miliseconds) throws JMSException {
		TextMessage message = session.createTextMessage(""task:""
				+ propertiesBean.getProperty(""engine.unique.id"") + "":""
				+ id + "":"" + status + "":"" + miliseconds);
		producer.send(message, DeliveryMode.PERSISTENT, 6, 0);
		log.debug(""[{}] Task state {} sent to dispatcher."", id, status);
	}
","	public void reportTaskStatus(int id, Task.TaskStatus status, long miliseconds) throws JMSException {
		TextMessage message = session.createTextMessage(""task:""
				+ propertiesBean.getProperty(""engine.unique.id"") + "":""
				+ id + "":"" + status + "":"" + miliseconds);
		producer.send(message, DeliveryMode.PERSISTENT, 6, 0);
START 		log.debug(""[{}] Task state {} sent to dispatcher."", id, status); END 
	}
","	public void reportTaskStatus(int id, Task.TaskStatus status, long miliseconds) throws JMSException {
		TextMessage message = session.createTextMessage(""task:""
				+ propertiesBean.getProperty(""engine.unique.id"") + "":""
				+ id + "":"" + status + "":"" + miliseconds);
		producer.send(message, DeliveryMode.PERSISTENT, 6, 0);
		log.info(""[{}] Task state {} sent to dispatcher."", id, status);
	}
"
1329,Why is it done lazily? Seems we'll need it in any case?,"	public final BeanMetaData<T> getCurrentBeanMetaData() {
		if ( currentBeanType != null && currentBeanMetaData == null ) {
			currentBeanMetaData = beanMetaDataManager.getBeanMetaData( currentBeanType );
		}
		return currentBeanMetaData;
	}
","	public final BeanMetaData<T> getCurrentBeanMetaData() {
START 		if ( currentBeanType != null && currentBeanMetaData == null ) { END 
			currentBeanMetaData = beanMetaDataManager.getBeanMetaData( currentBeanType );
		}
		return currentBeanMetaData;
	}
","	public final BeanMetaData<T> getCurrentBeanMetaData() {
		return currentBeanMetaData;
	}
"
1330,"Given this is configuration, wouldn't it make more sense to show the parameters in the output, accept them in input, and then fix validation like it's done in the UI?","    protected Object handleObjectGet() throws Exception {
        String workspace = getAttribute(""workspace"");
        ServiceInfo service;
        if (workspace != null) {
            WorkspaceInfo ws = geoServer.getCatalog().getWorkspaceByName(workspace);

            service = geoServer.getService(ws, clazz);
        } else {
            service = geoServer.getService(clazz);
        }
        if (service == null) {
            throw new RestletException(""Service for workspace "" + workspace + "" does not exist"",
                    Status.CLIENT_ERROR_NOT_FOUND);
        }

        return service.clone(true);
    }
","    protected Object handleObjectGet() throws Exception {
        String workspace = getAttribute(""workspace"");
        ServiceInfo service;
        if (workspace != null) {
            WorkspaceInfo ws = geoServer.getCatalog().getWorkspaceByName(workspace);

            service = geoServer.getService(ws, clazz);
        } else {
            service = geoServer.getService(clazz);
        }
        if (service == null) {
            throw new RestletException(""Service for workspace "" + workspace + "" does not exist"",
                    Status.CLIENT_ERROR_NOT_FOUND);
        }

START         return service.clone(true); END 
    }
","    protected Object handleObjectGet() throws Exception {
        String workspace = getAttribute(""workspace"");
        ServiceInfo service;
        if (workspace != null) {
            WorkspaceInfo ws = geoServer.getCatalog().getWorkspaceByName(workspace);
            
            service = geoServer.getService(ws, clazz);
        } else {
            service = geoServer.getService(clazz);
        }
        if (service == null) {
            throw new RestletException(""Service for workspace "" + workspace + "" does not exist"",
                    Status.CLIENT_ERROR_NOT_FOUND);
        }

        return service;
    }
"
1331,Return the result of `sha256` instead of using the local variable.,"   private String buildHashedPayload(HttpRequest request) {
      String hashedPayload = """";
      try {
         byte[] unhashedBytes = request.getPayload() == null ? """".getBytes() : ByteStreams.toByteArray(request
               .getPayload().getInput());
         hashedPayload = sha256(unhashedBytes);
      } catch (IOException e) {
         throw new HttpException(""Error signing request"", e);
      }
      return hashedPayload;
   }
","   private String buildHashedPayload(HttpRequest request) {
      String hashedPayload = """";
      try {
         byte[] unhashedBytes = request.getPayload() == null ? """".getBytes() : ByteStreams.toByteArray(request
               .getPayload().getInput());
START          hashedPayload = sha256(unhashedBytes); END 
      } catch (IOException e) {
         throw new HttpException(""Error signing request"", e);
      }
      return hashedPayload;
   }
","   private static String buildHashedPayload(HttpRequest request) {
      try {
         byte[] unhashedBytes = request.getPayload() == null ? """".getBytes() : ByteStreams.toByteArray(request
               .getPayload().getInput());
         return sha256(unhashedBytes);
      } catch (IOException e) {
         throw new HttpException(""Error signing request"", e);
      }
   }
"
1332,"It's a little harsh to return null because the deprecated method should work as the original implementation, right? Can't this method read the StreamInputReader and get the information from there?","    public Map<Long, EventDefinition> getEventDefs(StreamInput id) {
        return null;
    }
","    public Map<Long, EventDefinition> getEventDefs(StreamInput id) {
START         return null; END 
    }
","    public Map<Long, EventDefinition> getEventDefs(StreamInput id) {
        return new HashMap<Long, EventDefinition>();
    }
"
1333,You don't need this. onView() will wait,"    public void testSetTitleIconStartMargin() throws Throwable {
        int startMargin = 100;
        int navIconWidth = 100;
        mActivityRule.runOnUiThread(() -> {
            mToolbar.setNavigationIconContainerWidth(navIconWidth);
            mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon);
            mToolbar.setTitleIconStartMargin(startMargin);
        });
        InstrumentationRegistry.getInstrumentation().waitForIdleSync();

        onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin)));
    }
","    public void testSetTitleIconStartMargin() throws Throwable {
        int startMargin = 100;
        int navIconWidth = 100;
        mActivityRule.runOnUiThread(() -> {
            mToolbar.setNavigationIconContainerWidth(navIconWidth);
            mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon);
            mToolbar.setTitleIconStartMargin(startMargin);
        });
START         InstrumentationRegistry.getInstrumentation().waitForIdleSync(); END 

        onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin)));
    }
","    public void testSetTitleIconStartMargin() throws Throwable {
        int startMargin = 100;
        int navIconWidth = 100;
        mActivityRule.runOnUiThread(() -> {
            mToolbar.setNavigationIconContainerWidth(navIconWidth);
            mToolbar.setTitleIcon(android.R.drawable.sym_def_app_icon);
            mToolbar.setTitleIconStartMargin(startMargin);
        });

        onView(withId(R.id.title_icon)).check(matches(withLeft(navIconWidth + startMargin)));
    }
"
1334,static import,"  Publisher<CoreEvent> getDownstreamPublisher() {
    return downstreamFlux
        .compose(downstreamPublisher -> Mono.subscriberContext()
            .flatMapMany(downstreamContext -> downstreamPublisher.doOnSubscribe(s -> {
              innerFlux.subscriberContext(downstreamContext).subscribe();
              upstreamFlux.subscriberContext(downstreamContext).subscribe();
            })));
  }
","  Publisher<CoreEvent> getDownstreamPublisher() {
    return downstreamFlux
START         .compose(downstreamPublisher -> Mono.subscriberContext() END 
            .flatMapMany(downstreamContext -> downstreamPublisher.doOnSubscribe(s -> {
              innerFlux.subscriberContext(downstreamContext).subscribe();
              upstreamFlux.subscriberContext(downstreamContext).subscribe();
            })));
  }
","  Publisher<CoreEvent> getDownstreamPublisher() {
    return downstreamFlux
        .compose(downstreamPublisher -> subscriberContext()
            .flatMapMany(downstreamContext -> downstreamPublisher.doOnSubscribe(s -> {
              innerFlux.subscriberContext(downstreamContext).subscribe();
              upstreamFlux.subscriberContext(downstreamContext).subscribe();
            })));
  }
"
1335,"This change may cause the lock not to be released in some cases.

With this change, in case of a failure VdsManager is responsible for releasing the lock. 
The VdsManager releases the lock only in case it catches an immediate exception.

In case of a time-out or other SetupNetworks vdsm failure, the lock will never be unlocked.","        public void onFailure(Throwable t) {
            log.error(""Unable to RefreshCapabilities: {}"", ExceptionUtils.getRootCauseMessage(t));
            log.debug(""Exception"", t);
            postProcessRefresh(false, releaseLock.getAndSet(false));
        }
","        public void onFailure(Throwable t) {
            log.error(""Unable to RefreshCapabilities: {}"", ExceptionUtils.getRootCauseMessage(t));
            log.debug(""Exception"", t);
START             postProcessRefresh(false, releaseLock.getAndSet(false)); END 
        }
","        public void onFailure(Throwable t) {
            log.error(""Unable to RefreshCapabilities: {}"", ExceptionUtils.getRootCauseMessage(t));
            log.debug(""Exception"", t);
            postProcessRefresh(false);
        }
"
1336,There is no reason to create new instance if SilentMigrationProgressMonitor here since NO_OP_SECTION is static,"    public CountsComputer( long lastCommittedTransactionId, NodeStore nodes, RelationshipStore relationships,
            int highLabelId, int highRelationshipTypeId )
    {
        this( lastCommittedTransactionId, nodes, relationships, highLabelId, highRelationshipTypeId,
                new SilentMigrationProgressMonitor().NO_OP_SECTION );
    }
","    public CountsComputer( long lastCommittedTransactionId, NodeStore nodes, RelationshipStore relationships,
            int highLabelId, int highRelationshipTypeId )
    {
        this( lastCommittedTransactionId, nodes, relationships, highLabelId, highRelationshipTypeId,
START                 new SilentMigrationProgressMonitor().NO_OP_SECTION ); END 
    }
","    public CountsComputer( long lastCommittedTransactionId, NodeStore nodes, RelationshipStore relationships,
            int highLabelId, int highRelationshipTypeId )
    {
        this( lastCommittedTransactionId, nodes, relationships, highLabelId, highRelationshipTypeId,
                SilentMigrationProgressMonitor.NO_OP_SECTION );
    }
"
1337,@vilchik-elena can't we directly use commaTokens?,"  public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements(List<InternalSyntaxToken> commaTokens) {
    List<Tree> commas = Lists.newArrayList();

    for (InternalSyntaxToken comma : commaTokens) {
      commas.add(comma);
    }

    return new ArrayLiteralTreeImpl(commas);
  }
","  public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements(List<InternalSyntaxToken> commaTokens) {
    List<Tree> commas = Lists.newArrayList();

    for (InternalSyntaxToken comma : commaTokens) {
      commas.add(comma);
    }

START     return new ArrayLiteralTreeImpl(commas); END 
  }
","  public ArrayLiteralTreeImpl newArrayLiteralWithElidedElements(List<InternalSyntaxToken> commaTokens) {
    return new ArrayLiteralTreeImpl(new ArrayList<Tree>(commaTokens));
  }
"
1338,why not to rely on AbstractCollection..toString?,"            public void onSuccess() {
                log.debug(""Command succeeded, releasing macs {}."", Arrays.toString(super.macs.toArray()));
                releaseMacs();
            }
","            public void onSuccess() {
                log.debug(""Command succeeded, releasing macs {}."", START  Arrays.toString(super.macs.toArray())); END 
                releaseMacs();
            }
","            public void onSuccess() {
                log.debug(""Command succeeded, releasing macs {}."", super.macs);
                releaseMacs();
            }
"
1339,Make the constructor public,"	SubresourceParameter(String value) {
		super(""t"", value);
	}
","START 	SubresourceParameter(String value) { END 
		super(""t"", value);
	}
","	public SubresourceParameter(String value) {
		super(""t"", value);
	}
"
1340,"flip the order of the checks - more intuitive IMO. Something like saying ""time is valid and is less than"" rather than ""time is less than and valid""","  private boolean isExpired(long expirationTimeInMs, long referenceTimeInMs) {
    return expirationTimeInMs < referenceTimeInMs && expirationTimeInMs != Utils.Infinite_Time;
  }
","  private boolean isExpired(long expirationTimeInMs, long referenceTimeInMs) {
START     return expirationTimeInMs < referenceTimeInMs && expirationTimeInMs != Utils.Infinite_Time; END 
  }
","  private boolean isExpired(long expirationTimeInMs, long referenceTimeInMs) {
    return expirationTimeInMs != Utils.Infinite_Time && expirationTimeInMs < referenceTimeInMs;
  }
"
1341,Please do not print to stdout/stderr. Please log instead so output can be silenced by the build infrastructure.,"    public void testEncodeSpatial() throws Exception {
        Document doc = encode(FilterMockData.intersects(), FES.Filter);
        assertEquals(""fes:Filter"", doc.getDocumentElement().getNodeName());
        
        Element e = getElementByQName(doc, FES.Intersects);
        assertNotNull(e);
        print(e);

        assertNotNull(getElementByQName(e, FES.ValueReference));
        assertNotNull(getElementByQName(e, GML.Point));
    }
","    public void testEncodeSpatial() throws Exception {
        Document doc = encode(FilterMockData.intersects(), FES.Filter);
        assertEquals(""fes:Filter"", doc.getDocumentElement().getNodeName());
        
        Element e = getElementByQName(doc, FES.Intersects);
        assertNotNull(e);
START         print(e); END 

        assertNotNull(getElementByQName(e, FES.ValueReference));
        assertNotNull(getElementByQName(e, GML.Point));
    }
","    public void testEncodeSpatial() throws Exception {
        Document doc = encode(FilterMockData.intersects(), FES.Filter);
        assertEquals(""fes:Filter"", doc.getDocumentElement().getNodeName());
        
        Element e = getElementByQName(doc, FES.Intersects);
        assertNotNull(e);

        assertNotNull(getElementByQName(e, FES.ValueReference));
        assertNotNull(getElementByQName(e, GML.Point));
    }
"
1342,The local variable is declared in bad scope.,"	public View getTopContainer(final View view) {
		View topView = null;
		EObject container;
		if (view != null) {
			container = view.eContainer();
			if (isStereotypeCompartment(container) || isStereotypeBrace(container) || isStereotypeLabel(container)) {
				container = container.eContainer();
			}
			if (container instanceof View) {
				topView = (View) container;
			}
		}


		return topView;
	}
","	public View getTopContainer(final View view) {
		View topView = null;
START 		EObject container; END 
		if (view != null) {
			container = view.eContainer();
			if (isStereotypeCompartment(container) || isStereotypeBrace(container) || isStereotypeLabel(container)) {
				container = container.eContainer();
			}
			if (container instanceof View) {
				topView = (View) container;
			}
		}


		return topView;
	}
","	public View getTopContainer(final View view) {
		View topView = null;
		if (view != null) {
			EObject container = view.eContainer();
			if (isStereotypeCompartment(container) || isStereotypeBrace(container) || isStereotypeLabel(container)) {
				container = container.eContainer();
			}
			if (container instanceof View) {
				topView = (View) container;
			}
		}


		return topView;
	}
"
1343,I don't think this method should be called in a constructor.,"	public StreamDeployer(ZooKeeperConnection zkConnection, StreamDefinitionRepository repository,
			StreamRepository streamRepository, XDParser parser) {
		super(zkConnection, repository, streamRepository, parser, stream);
		this.zkConnection = zkConnection;
		this.parser = parser;
		updateModuleDefinitions();
	}
","	public StreamDeployer(ZooKeeperConnection zkConnection, StreamDefinitionRepository repository,
			StreamRepository streamRepository, XDParser parser) {
		super(zkConnection, repository, streamRepository, parser, stream);
		this.zkConnection = zkConnection;
		this.parser = parser;
START 		updateModuleDefinitions(); END 
	}
","	public StreamDeployer(ZooKeeperConnection zkConnection, StreamDefinitionRepository repository,
			StreamRepository streamRepository, XDParser parser) {
		super(zkConnection, repository, streamRepository, parser, stream);
		this.zkConnection = zkConnection;
		this.parser = parser;
	}
"
1344,Is this really necessary? AFAIK the scope and key should never be MarshalledValues.,"   public String toString() {
      Object oScope = scope;
      Object oKey = key;
      if (oScope instanceof MarshalledValue) {
          oScope = ((MarshalledValue) oScope).get();
      }
      if (oKey instanceof MarshalledValue) {
          oKey = ((MarshalledValue) oKey).get();
      }
      return ""ScopedKey{scope = "" + oScope + "", key = "" + oKey + ""}"";
   }
","   public String toString() {
      Object oScope = scope;
      Object oKey = key;
START       if (oScope instanceof MarshalledValue) { END 
          oScope = ((MarshalledValue) oScope).get();
      }
      if (oKey instanceof MarshalledValue) {
          oKey = ((MarshalledValue) oKey).get();
      }
      return ""ScopedKey{scope = "" + oScope + "", key = "" + oKey + ""}"";
   }
","   public String toString() {
      return ""ScopedKey{scope = "" + scope + "", key = "" + key + ""}"";
   }
"
1345,"`str == null` cannot be true here as this was already checked upfront by https://github.com/crate/crate/pull/8879/files#diff-7a2324ee3f0c0f2c921e7ffeb1740058R70 (it also correctly results in `null` there).
We could also move this empty string or 0 length up under that check as it would be same for both functions.","    static String left(String str, int len) {
        if (str == null || str.isEmpty() || len == 0) {
            return """";
        }

        if (len > 0) {
            return str.substring(0, Math.min(len, str.length()));
        }

        final int finalLen = str.length() + len;
        return finalLen > 0 ? str.substring(0, finalLen) : """";
    }
","    static String left(String str, int len) {
START         if (str == null || str.isEmpty() || len == 0) { END 
            return """";
        }

        if (len > 0) {
            return str.substring(0, Math.min(len, str.length()));
        }

        final int finalLen = str.length() + len;
        return finalLen > 0 ? str.substring(0, finalLen) : """";
    }
","    private static String left(String str, int len) {
        if (len > 0) {
            return str.substring(0, Math.min(len, str.length()));
        }
        final int finalLen = str.length() + len;
        return finalLen > 0 ? str.substring(0, finalLen) : """";
    }
"
1346,"It should never happen, since 

`org.springframework.web.bind.annotation.RequestBody#required` is `default true`","    public ResponseEntity addRole(@RequestBody @Validated RoleForm roleForm,
                                  BindingResult bindingResult,
                                  @RequestHeader(HttpHeaders.ACCEPT) String acceptHeader)
    {
        if (roleForm == null)
        {
            throw new RequestBodyValidationException(""Empty request body"", bindingResult);
        }
        if (bindingResult.hasErrors())
        {
            throw new RequestBodyValidationException(FAILED_ADD_ROLE, bindingResult);
        }

        // Convert RoleForm to Role
        Role role = conversionService.convert(roleForm, Role.class);

        return processConfig(config -> addRole(config, role), () -> SUCCESSFUL_ADD_ROLE, acceptHeader);
    }
","    public ResponseEntity addRole(@RequestBody @Validated RoleForm roleForm,
                                  BindingResult bindingResult,
                                  @RequestHeader(HttpHeaders.ACCEPT) String acceptHeader)
    {
START         if (roleForm == null) END 
        {
            throw new RequestBodyValidationException(""Empty request body"", bindingResult);
        }
        if (bindingResult.hasErrors())
        {
            throw new RequestBodyValidationException(FAILED_ADD_ROLE, bindingResult);
        }

        // Convert RoleForm to Role
        Role role = conversionService.convert(roleForm, Role.class);

        return processConfig(config -> addRole(config, role), () -> SUCCESSFUL_ADD_ROLE, acceptHeader);
    }
","    public ResponseEntity addRole(@RequestBody @Validated RoleForm roleForm,
                                  BindingResult bindingResult,
                                  @RequestHeader(HttpHeaders.ACCEPT) String acceptHeader)
    {
        if (bindingResult.hasErrors())
        {
            throw new RequestBodyValidationException(FAILED_ADD_ROLE, bindingResult);
        }

        Role role = conversionService.convert(roleForm, Role.class);

        return processConfig(config -> addRole(config, role), () -> SUCCESSFUL_ADD_ROLE, acceptHeader);
    }
"
1347,Minor: you can decrease the visibility modifier for some methods here and change some methods to be static.,"    public AbstractJsonGetter(Getter parent) {
        super(parent);
    }
","START     public AbstractJsonGetter(Getter parent) { END 
        super(parent);
    }
","    AbstractJsonGetter(Getter parent) {
        super(parent);
    }
"
1348,"how about 
this.vdsNumaNodeDao = Objects.requireNonNull(vdsNumaNodeDao)
?","    NumaValidator(VdsNumaNodeDao vdsNumaNodeDao) {
        Objects.requireNonNull(vdsNumaNodeDao);
        this.vdsNumaNodeDao = vdsNumaNodeDao;
    }
","    NumaValidator(VdsNumaNodeDao vdsNumaNodeDao) {
        Objects.requireNonNull(vdsNumaNodeDao);
START         this.vdsNumaNodeDao = vdsNumaNodeDao; END 
    }
","    NumaValidator(VdsNumaNodeDao vdsNumaNodeDao) {
        this.vdsNumaNodeDao = Objects.requireNonNull(vdsNumaNodeDao);
    }
"
1349,"getClients(this, null, null)","    public List<ClientModel> getClients() {
        return session.realms().getClients(this, 0, session.realms().getClientsCount(this).intValue());
    }
","    public List<ClientModel> getClients() {
START         return session.realms().getClients(this, 0, session.realms().getClientsCount(this).intValue()); END 
    }
","    public List<ClientModel> getClients() {
        return session.realms().getClients(this);
    }
"
1350,"Coding best practices:
Interface i = new Implementation();","    public List<String> getTokens() {
        ArrayList<String> ret = new ArrayList<>(this.tokenCount);

        for (int i = 0; i < this.tokenCount; i++) {
            ret.add(getToken(i));
        }

        return ret;
    }
","    public List<String> getTokens() {
        ArrayList<String> ret = new ArrayList<>(this.tokenCount);
START  END 
        for (int i = 0; i < this.tokenCount; i++) {
            ret.add(getToken(i));
        }

        return ret;
    }
","    public List<String> getTokens() {
        List<String> ret = new ArrayList<String>(tokenCount);

        for (int i = 0; i < tokenCount; i++) {
            ret.add(getToken(i));
        }

        return ret;
    }
"
1351,Not needed. By default it will always be initialized to 0,"  public EndpointAffinity(final DrillbitEndpoint endpoint, final double affinity, final boolean mandatory,
      final int maxWidth) {
    Preconditions.checkArgument(maxWidth >= 1, ""MaxWidth for given endpoint should be at least one."");
    this.endpoint = endpoint;
    this.affinity = affinity;
    this.mandatory = mandatory;
    this.maxWidth = maxWidth;
    this.numLocalWorkUnits = 0;
  }
","  public EndpointAffinity(final DrillbitEndpoint endpoint, final double affinity, final boolean mandatory,
      final int maxWidth) {
    Preconditions.checkArgument(maxWidth >= 1, ""MaxWidth for given endpoint should be at least one."");
    this.endpoint = endpoint;
    this.affinity = affinity;
    this.mandatory = mandatory;
    this.maxWidth = maxWidth;
START     this.numLocalWorkUnits = 0; END 
  }
","  public EndpointAffinity(final DrillbitEndpoint endpoint, final double affinity, final boolean mandatory, final int maxWidth) {
    Preconditions.checkArgument(maxWidth >= 1, ""MaxWidth for given endpoint should be at least one."");
    this.endpoint = endpoint;
    this.affinity = affinity;
    this.mandatory = mandatory;
    this.maxWidth = maxWidth;
  }
"
1352,Intentional change. Keep the originial.,"        public void run() {
            LOG.trace(""BacklogMetricEmitter running for entities"");
            executor = new ScheduledThreadPoolExecutor(10);
            List<Future> futures = new ArrayList<>();
            try {
                for (Entity entity : entityBacklogs.keySet()) {
                    futures.add(executor.submit(new BacklogCalcService(entity, entityBacklogs.get(entity))));
                }
                waitForFuturesToComplete(futures);
            } finally {
                executor.shutdown();
            }
        }
","        public void run() {
START             LOG.trace(""BacklogMetricEmitter running for entities""); END 
            executor = new ScheduledThreadPoolExecutor(10);
            List<Future> futures = new ArrayList<>();
            try {
                for (Entity entity : entityBacklogs.keySet()) {
                    futures.add(executor.submit(new BacklogCalcService(entity, entityBacklogs.get(entity))));
                }
                waitForFuturesToComplete(futures);
            } finally {
                executor.shutdown();
            }
        }
","        public void run() {
            LOG.debug(""BacklogMetricEmitter running for entities"");
            executor = new ScheduledThreadPoolExecutor(10);
            List<Future> futures = new ArrayList<>();
            try {
                for (Entity entity : entityBacklogs.keySet()) {
                    futures.add(executor.submit(new BacklogCalcService(entity, entityBacklogs.get(entity))));
                }
                waitForFuturesToComplete(futures);
            } finally {
                executor.shutdown();
            }
        }
"
1353,"projectListFragment is always set, no null check needed
Please remove log output","	public void onBackPressed() {
		if (projectListFragment != null) {
			projectListFragment.cancelLoadProjectTask();
			Log.d(TAG, ""Back press detected!"");
		}
		super.onBackPressed();
	}
","	public void onBackPressed() {
		if (projectListFragment != null) {
			projectListFragment.cancelLoadProjectTask();
			Log.d(TAG, ""Back press detected!"");
START 		} END 
		super.onBackPressed();
	}
","	public void onBackPressed() {
		projectListFragment.cancelLoadProjectTask();
		super.onBackPressed();
	}
"
1354,not needed (the value is null and won't be used anyway),"    private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) {
        // do the state transition only if that VM is really running on SRC
        if (getParameters().getVdsId().equals(curVm.getRunOnVds())) {
            ResourceManager.getInstance().InternalSetVmStatus(curVm,
                    parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down, curVm.getStatusUpdatedTime());
        }
    }
","    private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) {
        // do the state transition only if that VM is really running on SRC
        if (getParameters().getVdsId().equals(curVm.getRunOnVds())) {
            ResourceManager.getInstance().InternalSetVmStatus(curVm,
START                     parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down, curVm.getStatusUpdatedTime()); END 
        }
    }
","    private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) {
        // do the state transition only if that VM is really running on SRC
        if (getParameters().getVdsId().equals(curVm.getRunOnVds())) {
            ResourceManager.getInstance().InternalSetVmStatus(curVm,
                    parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down);
        }
    }
"
1355,Should this be private?,"    public TransactionQuery(Selection selection, Publisher publisher, Optional<String> contentUri, 
            Optional<String> transactionId, Optional<TransactionStateType> transactionStatus) {
        this.selection = checkNotNull(selection);
        this.publisher = checkNotNull(publisher);
        this.contentUri = checkNotNull(contentUri);
        this.transactionId = checkNotNull(transactionId);
        this.transactionStatus = checkNotNull(transactionStatus);
    }
","START     public TransactionQuery(Selection selection, Publisher publisher, Optional<String> contentUri,  END 
            Optional<String> transactionId, Optional<TransactionStateType> transactionStatus) {
        this.selection = checkNotNull(selection);
        this.publisher = checkNotNull(publisher);
        this.contentUri = checkNotNull(contentUri);
        this.transactionId = checkNotNull(transactionId);
        this.transactionStatus = checkNotNull(transactionStatus);
    }
","    private TransactionQuery(Selection selection, Publisher publisher, Optional<String> contentUri, 
            Optional<String> transactionId, Optional<TransactionStateType> transactionStatus) {
        this.selection = checkNotNull(selection);
        this.publisher = checkNotNull(publisher);
        this.contentUri = checkNotNull(contentUri);
        this.transactionId = checkNotNull(transactionId);
        this.transactionStatus = checkNotNull(transactionStatus);
    }
"
1356,"maybe not necessary, but protocol is case-insensitive - maybe should be equalsIgnoreCase used?","    private static boolean appendPort(final String scheme, final int port) {
        return port > -1 && ((HTTP.equals(scheme) && port != 80) || (HTTPS.equals(scheme) && port != 443));
    }
","    private static boolean appendPort(final String scheme, final int port) {
START         return port > -1 && ((HTTP.equals(scheme) && port != 80) || (HTTPS.equals(scheme) && port != 443)); END 
    }
","    private static boolean appendPort(final String scheme, final int port) {
        return port > -1 && ((HTTP.equalsIgnoreCase(scheme) && port != 80) || (HTTPS.equalsIgnoreCase(scheme) && port != 443));
    }
"
1357,We can inline these two vars,"    public void addPage(BenchmarkData data)
    {
        int pageCount = data.getPageCount();
        Page page = data.getDataPage();
        PartitionedOutputOperator operator = data.createPartitionedOutputOperator();
        for (int i = 0; i < pageCount; i++) {
            operator.addInput(page);
        }
        operator.finish();
    }
","    public void addPage(BenchmarkData data)
    {
        int pageCount = data.getPageCount();
START         Page page = data.getDataPage(); END 
        PartitionedOutputOperator operator = data.createPartitionedOutputOperator();
        for (int i = 0; i < pageCount; i++) {
            operator.addInput(page);
        }
        operator.finish();
    }
","    public void addPage(BenchmarkData data)
    {
        PartitionedOutputOperator operator = data.createPartitionedOutputOperator();
        for (int i = 0; i < data.getPageCount(); i++) {
            operator.addInput(data.getDataPage());
        }
        operator.finish();
    }
"
1358,Use import static,"	private Element timeZone() {
		return textElement(BlogConstants.TIMEZONE, entity.getTimeZone());
	}
","	private Element timeZone() {
START 		return textElement(BlogConstants.TIMEZONE, entity.getTimeZone()); END 
	}
","	private Element timeZone() {
		return textElement(TIMEZONE, entity.getTimeZone());
	}
"
1359,so do not resolve groups and no recursive as you going to search it anyway.,"    private DbUser getDbUserForPrincipalName(String principalName, String authzName) {
        ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(
                EngineExtensionsManager.getInstance().getExtensionByName(authzName),
                principalName, true, true);
        if (principalRecord == null) {
            throw new RuntimeException(String.format(""Unable to find principal %s in domain '%s'"", principalName, authzName));
        }
        return new DbUser(DirectoryUtils.mapPrincipalRecordToDirectoryUser(authzName, principalRecord));
    }
","    private DbUser getDbUserForPrincipalName(String principalName, String authzName) {
        ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(
                EngineExtensionsManager.getInstance().getExtensionByName(authzName),
START                 principalName, true, true); END 
        if (principalRecord == null) {
            throw new RuntimeException(String.format(""Unable to find principal %s in domain '%s'"", principalName, authzName));
        }
        return new DbUser(DirectoryUtils.mapPrincipalRecordToDirectoryUser(authzName, principalRecord));
    }
","    private DbUser getDbUserForPrincipalName(String principalName, String authzName) {
        ExtMap principalRecord = AuthzUtils.fetchPrincipalRecord(
                EngineExtensionsManager.getInstance().getExtensionByName(authzName),
                principalName, false, false);
        if (principalRecord == null) {
            throw new RuntimeException(String.format(""Unable to find principal %s in domain '%s'"", principalName, authzName));
        }
        return new DbUser(DirectoryUtils.mapPrincipalRecordToDirectoryUser(authzName, principalRecord));
    }
"
1360,lambda?,"    public PatternScatterGraphView() {
        super(ID);
        this.addPartPropertyListener(new IPropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent event) {
                if (event.getProperty().equals(TmfXmlStrings.XML_LATENCY_OUTPUT_DATA)) {
                    Object newValue = event.getNewValue();
                    if (newValue instanceof String) {
                        String data = (String) newValue;
                        fViewInfo.setViewData(data);
                        setPartName(fViewInfo.getLabel());
                        loadLatencyView();
                    }
                }
            }
        });
    }
","    public PatternScatterGraphView() {
        super(ID);
        START this.addPartPropertyListener(new IPropertyChangeListener() {
            @Override
            public void propertyChange(PropertyChangeEvent event) {
                if (event.getProperty().equals(TmfXmlStrings.XML_LATENCY_OUTPUT_DATA)) {
                    Object newValue = event.getNewValue();
                    if (newValue instanceof String) {
                        String data = (String) newValue;
                        fViewInfo.setViewData(data);
                        setPartName(fViewInfo.getLabel());
                        loadLatencyView(); END 
                    }
                }
            }
        });
    }
","    public PatternScatterGraphView() {
        super(ID);
        this.addPartPropertyListener(event -> {
            if (event.getProperty().equals(TmfXmlStrings.XML_LATENCY_OUTPUT_DATA)) {
                Object newValue = event.getNewValue();
                if (newValue instanceof String) {
                    String data = (String) newValue;
                    fViewInfo.setViewData(data);
                    setPartName(fViewInfo.getLabel());
                    loadLatencyView();
                }
            }
        });
    }
"
1361,I believe `&&` should be here also,"    public void setMaxSpeed(double maxSpeed) {
        if (this.maxSpeed == null || maxSpeed > this.maxSpeed) {
            this.maxSpeed = maxSpeed;
        }
    }
","    public void setMaxSpeed(double maxSpeed) {
START         if (this.maxSpeed == null || maxSpeed > this.maxSpeed) { END 
            this.maxSpeed = maxSpeed;
        }
    }
","    public void setMaxSpeed(double maxSpeed) {
        if (maxSpeed > this.maxSpeed) {
            this.maxSpeed = maxSpeed;
        }
    }
"
1362,Minor: can remove `throws`,"    Object getValue(Object obj) throws Exception {
        throw new HazelcastException(""Path agnostic value extraction is not supported"");

    }
","START     Object getValue(Object obj) throws Exception { END 
        throw new HazelcastException(""Path agnostic value extraction is not supported"");

    }
","    Object getValue(Object obj) {
        throw new HazelcastException(""Path agnostic value extraction is not supported"");

    }
"
1363,"Except for debugging purpose, the ""result"" local does not seem necessary.","        public boolean apply(Resource resource) {
            Predicate<EObject> hasOuterRef = new EObjectHasReferencesTo(modifiedResources);
            boolean result = Iterators.any(EcoreUtil.<EObject> getAllProperContents(resource, false), hasOuterRef);
            return result;
        }
","        public boolean apply(Resource resource) {
            Predicate<EObject> hasOuterRef = new EObjectHasReferencesTo(modifiedResources);
START             boolean result = Iterators.any(EcoreUtil.<EObject> getAllProperContents(resource, false), hasOuterRef); END 
            return result;
        }
","        public boolean apply(Resource resource) {
            Predicate<EObject> hasOuterRef = new EObjectHasReferencesTo(modifiedResources);
            return Iterators.any(EcoreUtil.<EObject> getAllProperContents(resource, false), hasOuterRef);
        }
"
1364,`clientRegistration` may be `null`. Please add a null check here.,"	private URI endSessionEndpoint(OAuth2AuthenticationToken token) {
		String registrationId = token.getAuthorizedClientRegistrationId();
		ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId);
		Object endSessionEndpoint = clientRegistration.getProviderDetails().getConfigurationMetadata().get(""end_session_endpoint"");

		URI result = null;
		if (endSessionEndpoint != null) {
			result = URI.create(endSessionEndpoint.toString());
		}

		return result;
	}
","	private URI endSessionEndpoint(OAuth2AuthenticationToken token) {
		String registrationId = token.getAuthorizedClientRegistrationId();
START 		ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId); END 
		Object endSessionEndpoint = clientRegistration.getProviderDetails().getConfigurationMetadata().get(""end_session_endpoint"");

		URI result = null;
		if (endSessionEndpoint != null) {
			result = URI.create(endSessionEndpoint.toString());
		}

		return result;
	}
","	private URI endSessionEndpoint(OAuth2AuthenticationToken token) {
		String registrationId = token.getAuthorizedClientRegistrationId();
		ClientRegistration clientRegistration = this.clientRegistrationRepository.findByRegistrationId(registrationId);

		URI result = null;
		if (clientRegistration != null) {
			Object endSessionEndpoint = clientRegistration.getProviderDetails().getConfigurationMetadata().get(""end_session_endpoint"");
			if (endSessionEndpoint != null) {
				result = URI.create(endSessionEndpoint.toString());
			}
		}

		return result;
	}
"
1365,bitmap.,"	public AddUnseenToBitmapFilter(BitmapBuilder seen, BitmapBuilder bitmap) {
		this.seen = seen;
		this.bitmap = bitmapResult;
	}
","	public AddUnseenToBitmapFilter(BitmapBuilder seen, BitmapBuilder bitmap) {
		this.seen = seen;
		this.bitmap = START  bitmapResult; END 
	}
","	public AddUnseenToBitmapFilter(BitmapBuilder seen, BitmapBuilder bitmap) {
		this.seen = seen;
		this.bitmap = bitmap;
	}
"
1366,"I see some surprising results here when adding additional test cases for doubles:

* `Double.NaN` as the input value returns 1.0
(Edit: Double.MIN_VALUE is fine, I forgot this was just slightly greater than 0)","    public void testQuantileAtValueBigint()
    {
        QuantileDigest qdigest = new QuantileDigest(1);
        addAll(qdigest, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
        functionAssertions.assertFunction(format(""quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 20)"", toHexString(qdigest)),
                DOUBLE,
                1.0);
        functionAssertions.assertFunction(format(""quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 6)"", toHexString(qdigest)),
                DOUBLE,
                0.6);
        functionAssertions.assertFunction(format(""quantile_at_value(CAST(X'%s' AS qdigest(bigint)), -1)"", toHexString(qdigest)),
                DOUBLE,
                0.0);
    }
","    public void testQuantileAtValueBigint()
    {
        QuantileDigest qdigest = new QuantileDigest(1);
        addAll(qdigest, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
        functionAssertions.assertFunction(format(""quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 20)"", toHexString(qdigest)),
START                 DOUBLE, END 
                1.0);
        functionAssertions.assertFunction(format(""quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 6)"", toHexString(qdigest)),
                DOUBLE,
                0.6);
        functionAssertions.assertFunction(format(""quantile_at_value(CAST(X'%s' AS qdigest(bigint)), -1)"", toHexString(qdigest)),
                DOUBLE,
                0.0);
    }
","    public void testQuantileAtValueBigint()
    {
        QuantileDigest qdigest = new QuantileDigest(1);
        addAll(qdigest, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
        functionAssertions.assertFunction(format(""quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 20)"", toHexString(qdigest)),
                DOUBLE,
                null);
        functionAssertions.assertFunction(format(""quantile_at_value(CAST(X'%s' AS qdigest(bigint)), 6)"", toHexString(qdigest)),
                DOUBLE,
                0.6);
        functionAssertions.assertFunction(format(""quantile_at_value(CAST(X'%s' AS qdigest(bigint)), -1)"", toHexString(qdigest)),
                DOUBLE,
                null);
    }
"
1367,I'm ok with either capitalization. But it needs to be consistent. The `overutilized` 2 lines above is capitalized differently.,"    public boolean isOverutilized()
    {
        return memoryManager.isOverUtilized();
    }
","    public boolean isOverutilized()
    {
START         return memoryManager.isOverUtilized(); END 
    }
","    public boolean isOverutilized()
    {
        return memoryManager.isOverutilized();
    }
"
1368,"c4query should also be synchronized. Move c4query checks to the check method itself.

The same thing for the execute() method.

See https://github.com/couchbase/couchbase-lite-ios/blob/feature/2.0/Objective-C/CBLQuery.mm#L605-L606","    public String explain() throws CouchbaseLiteException {
        if (c4query == null)
            check();
        synchronized (getDatabase().getLock()) {
            return c4query.explain();
        }
    }
","    public String explain() throws CouchbaseLiteException {
START         if (c4query == null) END 
            check();
        synchronized (getDatabase().getLock()) {
            return c4query.explain();
        }
    }
","    public String explain() throws CouchbaseLiteException {
        synchronized (getDatabase().getLock()) {
            check();
            return c4query.explain();
        }
    }
"
1369,just return `false` here.,"   	public boolean isObjectFactory() {
   		return getTargetTypeParameter() != null || getParameters().isEmpty();
   	}
","   	public boolean isObjectFactory() {
START    		return getTargetTypeParameter() != null || getParameters().isEmpty(); END 
   	}
","    public boolean isObjectFactory() {
        return false;
    }
"
1370,"Shound't this ctor be `public` or at least `protected`? 

Otherwise I don't see reason in all those `protected` methods below.","		StandardRotationPolicy(DelegatingSessionFactory<?> factory, List<KeyDirectory> keyDirectories,
				boolean fair) {
			Assert.notNull(factory, ""factory cannot be null"");
			Assert.notNull(keyDirectories, ""keyDirectories cannot be null"");
			Assert.isTrue(keyDirectories.size() > 0, ""At least one KeyDirectory is required"");
			this.factory = factory;
			this.keyDirectories.addAll(keyDirectories);
			this.fair = fair;
			this.iterator = this.keyDirectories.iterator();
		}
","START 		StandardRotationPolicy(DelegatingSessionFactory<?> factory, List<KeyDirectory> keyDirectories, END 
				boolean fair) {
			Assert.notNull(factory, ""factory cannot be null"");
			Assert.notNull(keyDirectories, ""keyDirectories cannot be null"");
			Assert.isTrue(keyDirectories.size() > 0, ""At least one KeyDirectory is required"");
			this.factory = factory;
			this.keyDirectories.addAll(keyDirectories);
			this.fair = fair;
			this.iterator = this.keyDirectories.iterator();
		}
","		public StandardRotationPolicy(DelegatingSessionFactory<?> factory, List<KeyDirectory> keyDirectories,
				boolean fair) {

			Assert.notNull(factory, ""factory cannot be null"");
			Assert.notNull(keyDirectories, ""keyDirectories cannot be null"");
			Assert.isTrue(keyDirectories.size() > 0, ""At least one KeyDirectory is required"");
			this.factory = factory;
			this.keyDirectories.addAll(keyDirectories);
			this.fair = fair;
			this.iterator = this.keyDirectories.iterator();
		}
"
1371,Tricky! `validateAddAllowed` currently checks if you have the WRITE_META permission on the entity. Acl gets created after the check. This breaks OneClickImporter,"	public void add(EntityType entity)
	{
		validateAddAllowed(entity);
		createAcl(entity);
		super.add(entity);
	}
","	public void add(EntityType entity)
	{
		validateAddAllowed(entity);
START 		createAcl(entity); END 
		super.add(entity);
	}
","	public void add(EntityType entity)
	{
		createAcl(entity);
		super.add(entity);
	}
"
1372,@adavid9 can you please add `throws IOException` here and use `TrowingFunction` at `GroupRepositoryProvider.search` ?,"    private ArtifactCoordinates getArtifactCoordinates(Path p)
    {
        return ThrowingFunction.unchecked(RepositoryFiles::readCoordinates).apply((RepositoryPath) p);
    }
","    private ArtifactCoordinates getArtifactCoordinates(Path p)
    {
START         return ThrowingFunction.unchecked(RepositoryFiles::readCoordinates).apply((RepositoryPath) p); END 
    }
","    private ArtifactCoordinates getArtifactCoordinates(Path p) throws IOException
    {
        return RepositoryFiles.readCoordinates((RepositoryPath) p);
    }
"
1373,"To avoid accidental class casts, you can use the following signature:

public <T extends ActivityNode> IPinUpdater<T> instantiate(T node)

Then unchecked casts can be regrouped into this method (Rather than in each Clients)","	public IPinUpdater<? extends ActivityNode> instantiate(ActivityNode node){
		IPinUpdater<? extends ActivityNode> updater = null; 
		if(node instanceof CallBehaviorAction){
			updater = new CallBehaviorActionPinUpdater(); 
		}else if(node instanceof CallOperationAction){
			updater = new CallOperationActionPinUpdater();
		}else if(node instanceof SendSignalAction){
			updater = new SendSignalActionPinUpdater();
		}
		return updater;
	}
","START 	public IPinUpdater<? extends ActivityNode> instantiate(ActivityNode node){ END 
		IPinUpdater<? extends ActivityNode> updater = null; 
		if(node instanceof CallBehaviorAction){
			updater = new CallBehaviorActionPinUpdater(); 
		}else if(node instanceof CallOperationAction){
			updater = new CallOperationActionPinUpdater();
		}else if(node instanceof SendSignalAction){
			updater = new SendSignalActionPinUpdater();
		}
		return updater;
	}
","	public <T extends ActivityNode> IPinUpdater<T> instantiate(ActivityNode node) {
		IPinUpdater<T> updater = null;
		if (node instanceof CallBehaviorAction) {
			updater = (IPinUpdater<T>) new CallBehaviorActionPinUpdater();
		} else if (node instanceof CallOperationAction) {
			updater = (IPinUpdater<T>) new CallOperationActionPinUpdater();
		} else if (node instanceof SendSignalAction) {
			updater = (IPinUpdater<T>) new SendSignalActionPinUpdater();
		}
		return updater;
	}
"
1374,Please don't do cleanups in the same commit as bugfixes/features/improvements,"    public boolean supportsScroll() {
        StorageConfiguration conf = coreFeature.getStorageConfiguration();
        // DBS mem and marklogic are not yet supported
        return conf.isDBSMongoDB() || conf.isVCS();
    }
","    public boolean supportsScroll() {
        StorageConfiguration conf = coreFeature.getStorageConfiguration();
        // DBS mem and marklogic are not yet supported
START         return conf.isDBSMongoDB() || conf.isVCS(); END 
    }
","    public boolean supportsScroll() {
        StorageConfiguration conf = coreFeature.getStorageConfiguration();
        // DBS mem and marklogic are not yet supported
        return (conf.isDBSMongoDB() || conf.isVCS());
    }
"
1375,Style issue: please use braces in a multiline conditional.,"    public void onResume() {
        super.onResume();
        addCachedDevices();
        if (mLocalAdapter.getBluetoothState() != BluetoothAdapter.STATE_ON)
            removeAllDevices();
        if (mStartScanOnResume) {
            mLocalAdapter.startScanning(true);
            mStartScanOnResume = false;
        }
    }
","    public void onResume() {
        super.onResume();
        addCachedDevices();
START         if (mLocalAdapter.getBluetoothState() != BluetoothAdapter.STATE_ON) END 
            removeAllDevices();
        if (mStartScanOnResume) {
            mLocalAdapter.startScanning(true);
            mStartScanOnResume = false;
        }
    }
","    public void onResume() {
        super.onResume();
        addCachedDevices();
        if (mLocalAdapter.getBluetoothState() != BluetoothAdapter.STATE_ON) {
            removeAllDevices();
        }
        if (mStartScanOnResume) {
            mLocalAdapter.startScanning(true);
            mStartScanOnResume = false;
        }
    }
"
1376,"Not sure i'd go with events (yet). Model upgrade was not emitting events either, and Status flags with this change would be properly set.

Let's go with baby steps, and not introduce events for these yet (unless some other good reason mentioned for it's need)","    protected void upgradeNexusVersion()
        throws IOException
    {
        final String currentVersion = checkNotNull( applicationStatusSource.getSystemStatus().getVersion() );
        final String previousVersion = getConfiguration().getNexusVersion();
        if ( currentVersion.equals( previousVersion ) )
        {
            setInstanceUpgraded( false );
        }
        else
        {
            setInstanceUpgraded( true );
            getConfiguration().setNexusVersion( currentVersion );
            storeConfiguration();
            eventMulticaster.notifyEventListeners( new NexusVersionChangedEvent( this, previousVersion,
                currentVersion ) );
        }

    }
","    protected void upgradeNexusVersion()
        throws IOException
    {
        final String currentVersion = checkNotNull( applicationStatusSource.getSystemStatus().getVersion() );
        final String previousVersion = getConfiguration().getNexusVersion();
        if ( currentVersion.equals( previousVersion ) )
        {
            setInstanceUpgraded( false );
        }
        else
        {
            setInstanceUpgraded( true );
            getConfiguration().setNexusVersion( currentVersion );
            storeConfiguration();
START             eventMulticaster.notifyEventListeners( new NexusVersionChangedEvent( this, previousVersion, END 
                currentVersion ) );
        }

    }
","    protected void upgradeNexusVersion()
        throws IOException
    {
        final String currentVersion = checkNotNull( applicationStatusSource.getSystemStatus().getVersion() );
        final String previousVersion = getConfiguration().getNexusVersion();
        if ( currentVersion.equals( previousVersion ) )
        {
            setInstanceUpgraded( false );
        }
        else
        {
            setInstanceUpgraded( true );
            getConfiguration().setNexusVersion( currentVersion );
            storeConfiguration();
        }

    }
"
1377,Can you make the old constructor call the new one (with a default value for the additional parameter)?,"	public DefDeclaration(String name, Type returnType, List<NameBinding> argNames,
						  TypedAST body, boolean isClassDef, FileLocation location) {
		if (argNames == null) { argNames = new LinkedList<NameBinding>(); }
		this.type = getMethodType(argNames, returnType);
		this.name = name;
		this.body = (ExpressionAST) body;
		this.argNames = argNames;
		this.isClass = isClassDef;
		this.location = location;
	}
","START 	public DefDeclaration(String name, Type returnType, List<NameBinding> argNames, END 
						  TypedAST body, boolean isClassDef, FileLocation location) {
		if (argNames == null) { argNames = new LinkedList<NameBinding>(); }
		this.type = getMethodType(argNames, returnType);
		this.name = name;
		this.body = (ExpressionAST) body;
		this.argNames = argNames;
		this.isClass = isClassDef;
		this.location = location;
	}
","	public DefDeclaration(String name, Type returnType, List<NameBinding> argNames,
						  TypedAST body, boolean isClassDef, FileLocation location) {
        this(name, returnType, null, argNames, body, isClassDef, location);
	}
"
1378,Can we all add the generic parameters for the acceptors? (Like `HttpFailureStatusAcceptor<HeadBucketResult>`?),"    public Waiter<HeadBucketRequest> bucketNotExists() {

        return new WaiterBuilder<HeadBucketRequest, HeadBucketResult>()
                .withSdkFunction(new HeadBucketFunction(client))
                .withAcceptors(
                        new HttpFailureStatusAcceptor(404, WaiterState.SUCCESS))
                .withDefaultPollingStrategy(
                        new PollingStrategy(new MaxAttemptsRetryStrategy(20),
                                new FixedDelayStrategy(5)))
                .withExecutorService(executorService).build();
    }
","START     public Waiter<HeadBucketRequest> bucketNotExists() { END 

        return new WaiterBuilder<HeadBucketRequest, HeadBucketResult>()
                .withSdkFunction(new HeadBucketFunction(client))
                .withAcceptors(
                        new HttpFailureStatusAcceptor(404, WaiterState.SUCCESS))
                .withDefaultPollingStrategy(
                        new PollingStrategy(new MaxAttemptsRetryStrategy(20),
                                new FixedDelayStrategy(5)))
                .withExecutorService(executorService).build();
    }
","    public Waiter<HeadBucketRequest> bucketNotExists() {

        return new WaiterBuilder<HeadBucketRequest, HeadBucketResult>()
                .withSdkFunction(new HeadBucketFunction(client))
                .withAcceptors(
                        new HttpFailureStatusAcceptor<HeadBucketResult>(404, WaiterState.SUCCESS))
                .withDefaultPollingStrategy(
                        new PollingStrategy(new MaxAttemptsRetryStrategy(20),
                                new FixedDelayStrategy(5)))
                .withExecutorService(executorService).build();
    }
"
1379,"@jomarko 
A couple of question:
1) from the ticket description it seems that somehow both TAB and ESC should be managed (in different way) but I do not see that here: is the ESC managed elsewhere or in different way?
2) is this kind of interaction specific ot ScenarioSImulation? Is it not the same for other grid editor? If the behavior should be the same on different component, then it should be better to create a builder/getter somewhere else (some abstract/parent class) to avoid duplicate this snippet","    public TextArea createWidget() {
        final TextArea textArea = GWT.create(TextArea.class);
        textArea.addKeyDownHandler(keyDownEvent -> {
            final int keyCode = keyDownEvent.getNativeKeyCode();
            if (keyCode == KeyCodes.KEY_TAB) {
                destroyResources();
                gridPanel.setFocus(true);
                keyDownEvent.preventDefault();
            }

            keyDownEvent.stopPropagation();
        });
        textArea.addMouseDownHandler(DomEvent::stopPropagation);
        return textArea;
    }
","    public TextArea createWidget() {
        final TextArea textArea = GWT.create(TextArea.class);
        textArea.addKeyDownHandler(keyDownEvent -> {
            final int keyCode = keyDownEvent.getNativeKeyCode();
START             if (keyCode == KeyCodes.KEY_TAB) { END 
                destroyResources();
                gridPanel.setFocus(true);
                keyDownEvent.preventDefault();
            }

            keyDownEvent.stopPropagation();
        });
        textArea.addMouseDownHandler(DomEvent::stopPropagation);
        return textArea;
    }
","    public TextArea createWidget() {
        final TextArea textArea = GWT.create(TextArea.class);
        textArea.addMouseDownHandler(DomEvent::stopPropagation);
        return textArea;
    }
"
1380,Why is setupDataForMockito() called here when it is designated with the @Before keyword below?  I have seen this in a few other tests as well.,"	public void testHierarchyView() {
		DockerImagesTab imageTab = openDockerImagesTab();

		buildImage(IMAGE_TEST_BUILD, DOCKERFILE_FOLDER, imageTab);
		if (mockitoIsUsed()) {
			setupDataForMockito();
		}

		DockerImageHierarchyTab hierarchyTab = openDockerImageHierarchyTab();
		List<TreeItem> treeItems = hierarchyTab.getTreeItems();
		compareTextInFirstNode(treeItems, ""alpine:3.3"");
		List<TreeItem> treeItems2 = treeItems.get(0).getItems();
		compareTextInFirstNode(treeItems2, IMAGE_TEST_BUILD + NAME_TAG_SEPARATOR + IMAGE_TAG_LATEST);
	}
","	public void testHierarchyView() {
		DockerImagesTab imageTab = openDockerImagesTab();

		buildImage(IMAGE_TEST_BUILD, DOCKERFILE_FOLDER, imageTab);
		if (mockitoIsUsed()) {
START 			setupDataForMockito(); END 
		}

		DockerImageHierarchyTab hierarchyTab = openDockerImageHierarchyTab();
		List<TreeItem> treeItems = hierarchyTab.getTreeItems();
		compareTextInFirstNode(treeItems, ""alpine:3.3"");
		List<TreeItem> treeItems2 = treeItems.get(0).getItems();
		compareTextInFirstNode(treeItems2, IMAGE_TEST_BUILD + NAME_TAG_SEPARATOR + IMAGE_TAG_LATEST);
	}
","	public void testHierarchyView() {
		DockerImagesTab imageTab = openDockerImagesTab();

		buildImage(IMAGE_TEST_BUILD, DOCKERFILE_FOLDER, imageTab);

		if (mockitoIsUsed()) {
			buildImage();
		}

		DockerImageHierarchyTab hierarchyTab = openDockerImageHierarchyTab();
		List<TreeItem> treeItems = hierarchyTab.getTreeItems();
		compareTextInFirstNode(treeItems, ""alpine:3.3"");
		List<TreeItem> treeItems2 = treeItems.get(0).getItems();
		compareTextInFirstNode(treeItems2, IMAGE_TEST_BUILD + NAME_TAG_SEPARATOR + IMAGE_TAG_LATEST);
	}
"
1381,private,"  void doBadOffsetInputTest(String name, long offset) {
    try {
      new Offset(name, offset);
      fail(""Should have thrown because one of the inputs is invalid"");
    } catch (IllegalArgumentException e) {
      // expected.
    }
  }
","START   void doBadOffsetInputTest(String name, long offset) { END 
    try {
      new Offset(name, offset);
      fail(""Should have thrown because one of the inputs is invalid"");
    } catch (IllegalArgumentException e) {
      // expected.
    }
  }
","  private void doBadOffsetInputTest(String name, long offset) {
    try {
      new Offset(name, offset);
      fail(""Should have thrown because one of the inputs is invalid"");
    } catch (IllegalArgumentException e) {
      // expected.
    }
  }
"
1382,why is the same code still present in the SettingsActivity?,"	private void enablePhiro() {
		SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);

		if (!sharedPreferences.getBoolean(Constants.PHIRO_INITIALIZED, false)) {
			BaseSettingsActivity.setPhiroSharedPreferenceEnabled(this, true);
			sharedPreferences.edit().putBoolean(Constants.PHIRO_INITIALIZED, true).apply();
		}
	}
","	private void enablePhiro() {
		SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);

		if (!sharedPreferences.getBoolean(Constants.PHIRO_INITIALIZED, false)) {
START 			BaseSettingsActivity.setPhiroSharedPreferenceEnabled(this, true); END 
			sharedPreferences.edit().putBoolean(Constants.PHIRO_INITIALIZED, true).apply();
		}
	}
","	private void enablePhiro() {
		SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this);

		if (!sharedPreferences.getBoolean(PHIRO_INITIALIZED, false)) {
			BaseSettingsActivity.setPhiroSharedPreferenceEnabled(this, true);
			sharedPreferences.edit().putBoolean(PHIRO_INITIALIZED, true).apply();
		}
	}
"
1383,"We should not raise issues in this case, as we are not certain. As we are not (yet) doing cross-procedural analysis, doing the assumption that we may end up with a null value with necessarily raise à lot of FPs.","    private void checkReturnedValue(ReturnStatementTree tree, String nonNullAnnotation) {
      SymbolicValue returnedValue = programState.peekValue();
      Constraint constraint = programState.getConstraint(returnedValue);
      if (constraint == null) {
        reportIssue(tree, ""This method''s return value is marked \""{0}\"" but null may be returned."", nonNullAnnotation);
      } else if (constraint.isNull()) {
        reportIssue(tree, ""This method''s return value is marked \""{0}\"" but null is returned."", nonNullAnnotation);
      }
    }
","    private void checkReturnedValue(ReturnStatementTree tree, String nonNullAnnotation) {
      SymbolicValue returnedValue = programState.peekValue();
      Constraint constraint = programState.getConstraint(returnedValue);
      if (constraint == null) {
START         reportIssue(tree, ""This method''s return value is marked \""{0}\"" but null may be returned."", nonNullAnnotation); END 
      } else if (constraint.isNull()) {
        reportIssue(tree, ""This method''s return value is marked \""{0}\"" but null is returned."", nonNullAnnotation);
      }
    }
","    private void checkReturnedValue(ReturnStatementTree tree, String nonNullAnnotation) {
      SymbolicValue returnedValue = programState.peekValue();
      Constraint constraint = programState.getConstraint(returnedValue);
      if (constraint != null && constraint.isNull()) {
        reportIssue(tree, ""This method''s return value is marked \""{0}\"" but null is returned."", nonNullAnnotation);
      }
    }
"
1384,Minor: consider replacing equalTo with is from Hamcrest here and below.,"    private void verifyEditResultCode(EditingResult result) {
        assertThat(result.getResult(), equalTo(SUCCESS));
    }
","    private void verifyEditResultCode(EditingResult result) {
START         assertThat(result.getResult(), equalTo(SUCCESS)); END 
    }
","    private void verifyEditResultCode(EditingResult result) {
        assertThat(result.getResult(), is(SUCCESS));
    }
"
1385,should call super(); explicitly,"	public EnginesPreferencePage() {
	}
","START 	public EnginesPreferencePage() { END 
	}
","	public EnginesPreferencePage() {
		super();
	}
"
1386,Instead of copying the list and requiring a (potentially) unsafe cast. I think we could make more use of generics in `ClusterManagerCallback`.,"  public List<AmbryReplica> getReplicaIds() {
    return clusterManagerCallback.getReplicaIdsForPartition(this)
        .stream()
        .map(r -> (AmbryReplica) r)
        .collect(Collectors.toList());
  }
","  public List<AmbryReplica> getReplicaIds() {
START     return clusterManagerCallback.getReplicaIdsForPartition(this) END 
        .stream()
        .map(r -> (AmbryReplica) r)
        .collect(Collectors.toList());
  }
","  public List<AmbryReplica> getReplicaIds() {
    return clusterManagerCallback.getReplicaIdsForPartition(this);
  }
"
1387,remove?,"  private String blockingSSLConnect(int socketBufSize) throws IOException {
    String connectionId =
        selector.connect(new InetSocketAddress(""localhost"", server.port), socketBufSize, socketBufSize, PortType.SSL);
    while (!selector.connected().contains(connectionId)) {
      System.out.println(""here"");
      selector.poll(10000L);
    }
    return connectionId;
  }
","  private String blockingSSLConnect(int socketBufSize) throws IOException {
    String connectionId =
        selector.connect(new InetSocketAddress(""localhost"", server.port), socketBufSize, socketBufSize, PortType.SSL);
    while (!selector.connected().contains(connectionId)) {
START       System.out.println(""here""); END 
      selector.poll(10000L);
    }
    return connectionId;
  }
","  private String blockingSSLConnect(int socketBufSize) throws IOException {
    String connectionId =
        selector.connect(new InetSocketAddress(""localhost"", server.port), socketBufSize, socketBufSize, PortType.SSL);
    while (!selector.connected().contains(connectionId)) {
      selector.poll(10000L);
    }
    return connectionId;
  }
"
1388,Why does this constructor not simply call the other one?,"    public EDDifferentialPrivacy(double epsilon, double delta, 
                                 DataGeneralizationScheme generalization) {
        super(delta);
        this.epsilon = epsilon;
        this.generalization = generalization;
        this.beta = calculateBeta(epsilon);
        this.k = calculateK(getDelta(), epsilon, this.beta);
    }
","START     public EDDifferentialPrivacy(double epsilon, double delta,  END 
                                 DataGeneralizationScheme generalization) {
        super(delta);
        this.epsilon = epsilon;
        this.generalization = generalization;
        this.beta = calculateBeta(epsilon);
        this.k = calculateK(getDelta(), epsilon, this.beta);
    }
","    public EDDifferentialPrivacy(double epsilon, double delta, 
                                 DataGeneralizationScheme generalization) {
        this(epsilon, delta, generalization, false);
    }
"
1389,Can `statement` be null?,"    private final String getSessionIndex(Assertion subjectAssertion) {
        List<AuthnStatement> authnStatements = subjectAssertion.getAuthnStatements();
        if(authnStatements != null && authnStatements.size() > 0) {
        	AuthnStatement statement = authnStatements.get(0);
        	return statement.getSessionIndex();
        }
        return null;
    }
","    private final String getSessionIndex(Assertion subjectAssertion) {
        List<AuthnStatement> authnStatements = subjectAssertion.getAuthnStatements();
        if(authnStatements != null && authnStatements.size() > 0) {
        	AuthnStatement statement = authnStatements.get(0);
START         	return statement.getSessionIndex(); END 
        }
        return null;
    }
","    private final String getSessionIndex(Assertion subjectAssertion) {
        List<AuthnStatement> authnStatements = subjectAssertion.getAuthnStatements();
        if(authnStatements != null && authnStatements.size() > 0) {
        	AuthnStatement statement = authnStatements.get(0);
        	if(statement != null) {
        		return statement.getSessionIndex();
        	}
        }
        return null;
    }
"
1390,I would switch those two conditions.,"  public void visitNode(Tree tree) {
    if (!hasSemantic()) {
      return;
    }
    MethodTree method = (MethodTree) tree;
    if (!INPUT_STREAM_READ.matches(method) || method.block() == null) {
      return;
    }
    method.accept(new ReturnStatementVisitor());
  }
","  public void visitNode(Tree tree) {
    if (!hasSemantic()) {
      return;
    }
    MethodTree method = (MethodTree) tree;
START     if (!INPUT_STREAM_READ.matches(method) || method.block() == null) { END 
      return;
    }
    method.accept(new ReturnStatementVisitor());
  }
","  public void visitNode(Tree tree) {
    if (!hasSemantic()) {
      return;
    }
    MethodTree method = (MethodTree) tree;
    if (method.block() != null && INPUT_STREAM_READ.matches(method)) {
      method.accept(new ReturnStatementVisitor());
    }
  }
"
1391,Can't be set in xml ?,"    protected void onFinishInflate() {
        super.onFinishInflate();
        View.inflate(getContext(), R.layout.merge_login_view, this);
        loginButton = Views.findById(this, R.id.sign_in_button);
        loginButton.setSize(SignInButton.SIZE_WIDE);
    }
","    protected void onFinishInflate() {
        super.onFinishInflate();
        View.inflate(getContext(), R.layout.merge_login_view, this);
        loginButton = Views.findById(this, R.id.sign_in_button);
START         loginButton.setSize(SignInButton.SIZE_WIDE); END 
    }
","    protected void onFinishInflate() {
        super.onFinishInflate();
        View.inflate(getContext(), R.layout.merge_login_view, this);
        loginButton = Views.findById(this, R.id.sign_in_button);
    }
"
1392,static,"    private int encode(int bucketIndex, int value)
    {
        return (bucketIndex << VALUE_BITS) | value;
    }
","START     private int encode(int bucketIndex, int value) END 
    {
        return (bucketIndex << VALUE_BITS) | value;
    }
","    private static int encode(int bucketIndex, int value)
    {
        return (bucketIndex << VALUE_BITS) | value;
    }
"
1393,"Are you sure that `getTargetDock().getIdentifier()` is always not `null`? I suggest to rewrite the condition as
`!TestToolsPresenter.IDENTIFIER.equals(uberfireDocksInteractionEvent.getTargetDock().getIdentifier())`","    public void onUberfireDocksInteractionEvent(@Observes final UberfireDocksInteractionEvent uberfireDocksInteractionEvent) {
        if (isUberfireDocksInteractionEventToManage(uberfireDocksInteractionEvent) && !uberfireDocksInteractionEvent.getTargetDock().getIdentifier().equals(TestToolsPresenter.IDENTIFIER)) {
            populateRightDocks(uberfireDocksInteractionEvent.getTargetDock().getIdentifier());
        }
    }
","    public void onUberfireDocksInteractionEvent(@Observes final UberfireDocksInteractionEvent uberfireDocksInteractionEvent) {
START         if (isUberfireDocksInteractionEventToManage(uberfireDocksInteractionEvent) && !uberfireDocksInteractionEvent.getTargetDock().getIdentifier().equals(TestToolsPresenter.IDENTIFIER)) { END 
            populateRightDocks(uberfireDocksInteractionEvent.getTargetDock().getIdentifier());
        }
    }
","    public void onUberfireDocksInteractionEvent(@Observes final UberfireDocksInteractionEvent uberfireDocksInteractionEvent) {
        if (isUberfireDocksInteractionEventToManage(uberfireDocksInteractionEvent) && !TestToolsPresenter.IDENTIFIER.equals(uberfireDocksInteractionEvent.getTargetDock().getIdentifier())) {
            populateRightDocks(uberfireDocksInteractionEvent.getTargetDock().getIdentifier());
        }
    }
"
1394,"No, such a feature has not been requested so far.

The current state is that each division can be the type of root element. It was discussed that we might later add a possibility that these types can be restricted. In the context, one could also implement the selection of a standard type.","    public String getDocType() {
        if (Objects.isNull(docType)) {
            List<SelectItem> allDocTypes = getAllDoctypes();
            for (SelectItem item : allDocTypes) {
                if (""Monograph"".equals(item.getValue())) {
                    setDocType((String) item.getValue());
                    return docType;
                }
            }
            setDocType((String) allDocTypes.get(0).getValue());
        }
        return docType;
    }
","    public String getDocType() {
        if (Objects.isNull(docType)) {
            List<SelectItem> allDocTypes = getAllDoctypes();
            for (SelectItem item : allDocTypes) {
START                 if (""Monograph"".equals(item.getValue())) { END 
                    setDocType((String) item.getValue());
                    return docType;
                }
            }
            setDocType((String) allDocTypes.get(0).getValue());
        }
        return docType;
    }
","    public String getDocType() {
        if (Objects.isNull(docType) && !allDocTypes.isEmpty()) {
            setDocType((String) allDocTypes.get(0).getValue());
        }
        return docType;
    }
"
1395,why is this needed ?,"	public boolean shouldUseCommitTemplate() {
		return Activator.getDefault().getPreferenceStore()
				.getBoolean(UIPreferences.COMMIT_DIALOG_MESSAGE_TEMPLATE)
				&& getCommitMessage() == null
				&& getCommitTemplate().isPresent();
	}
","START 	public boolean shouldUseCommitTemplate() { END 
		return Activator.getDefault().getPreferenceStore()
				.getBoolean(UIPreferences.COMMIT_DIALOG_MESSAGE_TEMPLATE)
				&& getCommitMessage() == null
				&& getCommitTemplate().isPresent();
	}
","	public boolean shouldUseCommitTemplate() {
		return getCommitMessage() == null
				&& getCommitTemplate().isPresent();
	}
"
1396,"missing exception. either log, rethrow runtime or rename exception ignored. 
Expand Exception","    public void waitUntilAllBlocked()
    {
      try
      {
        _blockersDoneLatch.await();
      }
      catch (Exception ex)
      {

      }
    }
","    public void waitUntilAllBlocked()
    {
      try
      {
        _blockersDoneLatch.await();
      }
START       catch (Exception ex)
      {
 END 
      }
    }
","    public void waitUntilAllBlocked() throws InterruptedException
    {
      _blockersDoneLatch.await();
    }
"
1397,"Why not 

   if (matrixParams.containsKey(param) {
       ...
    }

?","    private static boolean hasMatrixParam(List<PathSegment> pathSegments, String param) {
        if (pathSegments != null)
            for (PathSegment segement : pathSegments) {
                MultivaluedMap<String, String> matrixParams = segement.getMatrixParameters();
                if (matrixParams != null && !matrixParams.isEmpty())
                    for (String key : matrixParams.keySet()) {
                        if (key.equals(param)) return true;
                    }
            }
        return false;
    }
","    private static boolean hasMatrixParam(List<PathSegment> pathSegments, String param) {
        if (pathSegments != null)
            for (PathSegment segement : pathSegments) {
                MultivaluedMap<String, String> matrixParams = segement.getMatrixParameters();
                if (matrixParams != null && !matrixParams.isEmpty())
                    for (String key : matrixParams.keySet()) {
                        if (key.equals(param)) return true;
START                     } END 
            }
        return false;
    }
","    private static boolean hasMatrixParam(List<PathSegment> pathSegments, String param) {
        if (pathSegments != null)
            for (PathSegment segement : pathSegments) {
                MultivaluedMap<String, String> matrixParams = segement.getMatrixParameters();
                if (matrixParams != null && !matrixParams.isEmpty() && matrixParams.containsKey(param))
                    return true;
            }
        return false;
    }
"
1398,"this is self assignment - please modify to:

this.attached = attached","    public void setAttached(boolean attached) {
        attached = attached;
    }
","    public void setAttached(boolean attached) {
START         attached = attached; END 
    }
","    public void setAttached(boolean attached) {
        this.attached = attached;
    }
"
1399,"Stupid question: why long/Long? walk.getTreeDepth() returns int, so why not use Integer (also in the Map, and intValue() above)?","		public void visited(RevObject o) {
			lowestDepthVisited.put(o, Long.valueOf(walk.getTreeDepth()));
		}
","		public void visited(RevObject o) {
START 			lowestDepthVisited.put(o, Long.valueOf(walk.getTreeDepth())); END 
		}
","		public void visited(RevObject o) {
			lowestDepthVisited.put(o, Integer.valueOf(walk.getTreeDepth()));
		}
"
1400,Is this superfluous casting?,"    private List<Object[]> convertIntegerToLong(List<Object[]> list, int index) {
        for (Object[] item : list) {
            item[index] = new Long((long) item[index]);
        }

        return list;
    }
","    private List<Object[]> convertIntegerToLong(List<Object[]> list, int index) {
        for (Object[] item : list) {
START             item[index] = new Long((long) item[index]); END 
        }

        return list;
    }
","    private List<Object[]> convertIntegerToLong(List<Object[]> list, int index) {
        for (Object[] item : list) {
            item[index] = (long) item[index];
        }

        return list;
    }
"
1401,"No new for constant object in loop. Either pass null, or construct the instance outside of the looop.","  private void flushAll() throws AuthException {
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
      CacheResource cacheResource =
          new CacheResource(e.getPluginName(), e.getExportName(),
              e.getProvider());
      if (FlushCache.WEB_SESSIONS.equals(cacheResource.getName())) {
        continue;
      }
      flushCache.get().apply(cacheResource, new FlushCache.Input());
    }
  }
","  private void flushAll() throws AuthException {
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
      CacheResource cacheResource =
          new CacheResource(e.getPluginName(), e.getExportName(),
              e.getProvider());
      if (FlushCache.WEB_SESSIONS.equals(cacheResource.getName())) {
        continue;
      }
      flushCache.get().apply(cacheResource, START  new FlushCache.Input()); END 
    }
  }
","  private void flushAll() throws AuthException {
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
      CacheResource cacheResource =
          new CacheResource(e.getPluginName(), e.getExportName(),
              e.getProvider());
      if (FlushCache.WEB_SESSIONS.equals(cacheResource.getName())) {
        continue;
      }
      flushCache.apply(cacheResource, null);
    }
  }
"
1402,"I'm not sure I like the fact we're creating 2-3 Lists and Maps everytime the ""get"" is called. Wouldn't there be a way to keep the fAnalsysiModules map always up-to-date as analyzes register, so that the get can simply return the map directly (wrapped into a Collections.unmodifiableMap of course) ?","    public static Map<String, IAnalysisModule> getAnalysisModules() {
        if (fAnalysisModules.isEmpty()) {
            TmfAnalysisType analysis = TmfAnalysisType.getInstance();
            List<IAnalysisModule> modules = analysis.getAnalysisModules();
            for (IAnalysisModule module : modules) {
                fAnalysisModules.add(module);
            }
        }
        return getExecutableModules();
    }
","START     public static Map<String, IAnalysisModule> getAnalysisModules() { END 
        if (fAnalysisModules.isEmpty()) {
            TmfAnalysisType analysis = TmfAnalysisType.getInstance();
            List<IAnalysisModule> modules = analysis.getAnalysisModules();
            for (IAnalysisModule module : modules) {
                fAnalysisModules.add(module);
            }
        }
        return getExecutableModules();
    }
","    public static Map<String, IAnalysisModule> getAnalysisModules() {
        synchronized (fAnalysisModules) {
            if (fAnalysisModules.isEmpty()) {
                TmfAnalysisType analysis = TmfAnalysisType.getInstance();
                List<IAnalysisModule> modules = analysis.getAnalysisModules();
                for (IAnalysisModule module : modules) {
                    fAnalysisModules.add(module);
                }
            }
        }
        return getExecutableModules();
    }
"
1403,Spaces.,"  void validateValueParameter(String name, Object value) {
    Class<? extends IValueValidator> validators[] = wrappedParameter.validateValueWith();
    if (validators != null && validators.length>0) {
      for(final Class<? extends IValueValidator> validator: validators) {
        validateValueParameter(validator, name, value);
      }
    }
  }
","  void validateValueParameter(String name, Object value) {
    Class<? extends IValueValidator> validators[] = wrappedParameter.validateValueWith();
START     if (validators != null && validators.length>0) { END 
      for(final Class<? extends IValueValidator> validator: validators) {
        validateValueParameter(validator, name, value);
      }
    }
  }
","  void validateValueParameter(String name, Object value) {
    final Class<? extends IValueValidator> validators[] = wrappedParameter.validateValueWith();
    if (validators != null && validators.length > 0) {
      for(final Class<? extends IValueValidator> validator: validators) {
        validateValueParameter(validator, name, value);
      }
    }
  }
"
1404,final?,"    public <C> Stream<Match> match(Object object, Captures captures, C context)
    {
        if (previous.isPresent()) {
            return previous.get().match(object, captures, context)
                    .flatMap(match -> accept(object, match.captures(), context));
        }
        else {
            return accept(object, captures, context);
        }
    }
","START     public <C> Stream<Match> match(Object object, Captures captures, C context) END 
    {
        if (previous.isPresent()) {
            return previous.get().match(object, captures, context)
                    .flatMap(match -> accept(object, match.captures(), context));
        }
        else {
            return accept(object, captures, context);
        }
    }
","    public final <C> Stream<Match> match(Object object, Captures captures, C context)
    {
        if (previous.isPresent()) {
            return previous.get().match(object, captures, context)
                    .flatMap(match -> accept(object, match.captures(), context));
        }
        else {
            return accept(object, captures, context);
        }
    }
"
1405,Global listener catch each click. You don't need to log it.,"  public ArticlePageObject savePage() {
    waitForElementInViewPort(editSummary);
    waitForElementInViewPort(reviewChangesButton);
    waitForElementVisibleByElement(savePanel);
    publishButton.click();
    PageObjectLogging.log(""savePage"", ""The 2nd Publish Button is clicked"", true);
    return new ArticlePageObject(driver);
  }
","  public ArticlePageObject savePage() {
    waitForElementInViewPort(editSummary);
    waitForElementInViewPort(reviewChangesButton);
    waitForElementVisibleByElement(savePanel);
    publishButton.click();
START     PageObjectLogging.log(""savePage"", ""The 2nd Publish Button is clicked"", true); END 
    return new ArticlePageObject(driver);
  }
","  public ArticlePageObject savePage() {
    waitForElementInViewPort(editSummary);
    waitForElementInViewPort(reviewChangesButton);
    waitForElementVisibleByElement(savePanel);
    publishButton.click();
    return new ArticlePageObject(driver);
  }
"
1406,"Please revert.
I know it's an IntelliJ warning but why should we tell Java to create an array generically by reflection when we literally know the size beforehand?","    public void executeCommand(CommandSender sender, List<String> arguments) {
        // Get the list of banned players
        Set<OfflinePlayer> bannedPlayers = bukkitService.getBannedPlayers();
        Set<String> namedBanned = new HashSet<>(bannedPlayers.size());
        for (OfflinePlayer offlinePlayer : bannedPlayers) {
            namedBanned.add(offlinePlayer.getName());
        }

        purgeService.purgePlayers(sender, namedBanned, bannedPlayers.toArray(new OfflinePlayer[0]));
    }
","    public void executeCommand(CommandSender sender, List<String> arguments) {
        // Get the list of banned players
        Set<OfflinePlayer> bannedPlayers = bukkitService.getBannedPlayers();
        Set<String> namedBanned = new HashSet<>(bannedPlayers.size());
        for (OfflinePlayer offlinePlayer : bannedPlayers) {
            namedBanned.add(offlinePlayer.getName());
        }

START         purgeService.purgePlayers(sender, namedBanned, bannedPlayers.toArray(new OfflinePlayer[0])); END 
    }
","    public void executeCommand(CommandSender sender, List<String> arguments) {
        // Get the list of banned players
        Set<OfflinePlayer> bannedPlayers = bukkitService.getBannedPlayers();
        Set<String> namedBanned = new HashSet<>(bannedPlayers.size());
        for (OfflinePlayer offlinePlayer : bannedPlayers) {
            namedBanned.add(offlinePlayer.getName());
        }

        purgeService.purgePlayers(sender, namedBanned, bannedPlayers.toArray(new OfflinePlayer[bannedPlayers.size()]));
    }
"
1407,"Why do we need to make this public? It should be package scoped, protected would work as well. All Astyanax classes in com.rackspace.blueflood.io.astyanax.\* should be able to call this method without it being public.","    public static Keyspace getKeyspace() {
        return keyspace;
    }
","START     public static Keyspace getKeyspace() { END 
        return keyspace;
    }
","    protected static Keyspace getKeyspace() {
        return keyspace;
    }
"
1408,"just for consistency, can we use `final int`?","    void setNewElementYPosition(final Element elementReference,
                                final Element newElement) {
        int referencePosition = getDndListComponent().getPositionY(elementReference);
        getDndListComponent().setPositionY(newElement, referencePosition);
    }
","    void setNewElementYPosition(final Element elementReference,
                                final Element newElement) {
START         int referencePosition = getDndListComponent().getPositionY(elementReference); END 
        getDndListComponent().setPositionY(newElement, referencePosition);
    }
","    void setNewElementYPosition(final Element elementReference,
                                final Element newElement) {
        final int referencePosition = getDndListComponent().getPositionY(elementReference);
        getDndListComponent().setPositionY(newElement, referencePosition);
    }
"
1409,"I'm not sure if we should fix it in this way. Removing the CTabFolder.layout invocation is a part of the optimization process that is needed to fix the issue exposed by the ""JRockit Mission Control "" application. It blocks the similar applications to be migrated to the E4 (poor GUI rendering performance)

Daniel","	public void layoutTopRight(CTabFolder ctf) {
		Composite trComp = getTRComposite(ctf);
		if (trComp.getChildren().length > 0) {
			trComp.setVisible(true);
			ctf.setTopRight(trComp, SWT.RIGHT | SWT.WRAP);
		} else {
			ctf.setTopRight(null);
			trComp.setVisible(false);
		}

		trComp.pack();
		ctf.layout(true, true);
	}
","	public void layoutTopRight(CTabFolder ctf) {
		Composite trComp = getTRComposite(ctf);
		if (trComp.getChildren().length > 0) {
			trComp.setVisible(true);
			ctf.setTopRight(trComp, SWT.RIGHT | SWT.WRAP);
		} else {
			ctf.setTopRight(null);
			trComp.setVisible(false);
		}

		trComp.pack();
START 		ctf.layout(true, true); END 
	}
","	public void layoutTopRight(CTabFolder ctf) {
		Composite trComp = getTRComposite(ctf);
		if (trComp.getChildren().length > 0) {
			trComp.setVisible(true);
			ctf.setTopRight(trComp, SWT.RIGHT | SWT.WRAP);
		} else {
			ctf.setTopRight(null);
			trComp.setVisible(false);
		}

		trComp.pack();
		trComp.layout(true, true);
	}
"
1410,Can we `assert context == null` here?,"        ByteBuf buffer() throws IOException {
            if (buf == null) {
                buf = Netty4Utils.toByteBuf(context.get());
                context = null;
            }
            return buf;
        }
","        ByteBuf buffer() throws IOException {
            if (buf == null) {
                buf = Netty4Utils.toByteBuf(context.get());
                context = null;
START             } END 
            return buf;
        }
","        ByteBuf buffer() throws IOException {
            if (buf == null) {
                buf = Netty4Utils.toByteBuf(context.get());
                context = null;
            }
            assert context == null;
            return buf;
        }
"
1411,Now we have `isEmpty` method for Strings in Utils. Is it good idea to use it here as well? https://github.com/kiegroup/kie-wb-common/blob/master/kie-wb-common-stunner/kie-wb-common-stunner-core/kie-wb-common-stunner-api/kie-wb-common-stunner-core-api/src/main/java/org/kie/workbench/common/stunner/core/util/StringUtils.java,"    public String getName() {
        String name = super.getName();
        if (name == null || name.isEmpty()) {
            return """";
        } else {
            return name;
        }
    }
","    public String getName() {
        String name = super.getName();
START         if (name == null || name.isEmpty()) { END 
            return """";
        } else {
            return name;
        }
    }
","    public String getName() {
        String name = super.getName();
        if (StringUtils.isEmpty(name)) {
            return """";
        } else {
            return name;
        }
    }
"
1412,minor: put _only_ the statement you expect to fail in `try`.,"  private void verifyInvalidValueSize(IndexValue value, String logSegmentName) {
    try {
      int capacity = TestUtils.RANDOM.nextInt(value.getBytes().capacity());
      ByteBuffer invalidValue = ByteBuffer.allocate(capacity);
      invalidValue.put(value.getBytes().array(), 0, capacity);
      new IndexValue(logSegmentName, invalidValue, version);
      fail(
          ""Contruction of IndexValue expected to fail with invalid byte buffer capacity of "" + invalidValue.capacity());
    } catch (IllegalArgumentException e) {
    }
  }
","  private void verifyInvalidValueSize(IndexValue value, String logSegmentName) {
    try {
      int capacity = TestUtils.RANDOM.nextInt(value.getBytes().capacity());
      ByteBuffer invalidValue = ByteBuffer.allocate(capacity);
      invalidValue.put(value.getBytes().array(), 0, capacity);
START       new IndexValue(logSegmentName, invalidValue, version); END 
      fail(
          ""Contruction of IndexValue expected to fail with invalid byte buffer capacity of "" + invalidValue.capacity());
    } catch (IllegalArgumentException e) {
    }
  }
","  private void verifyInvalidValueSize(IndexValue value, String logSegmentName) {
    int capacity = TestUtils.RANDOM.nextInt(value.getBytes().capacity());
    ByteBuffer invalidValue = ByteBuffer.allocate(capacity);
    invalidValue.put(value.getBytes().array(), 0, capacity);
    try {
      new IndexValue(logSegmentName, invalidValue, version);
      fail(
          ""Contruction of IndexValue expected to fail with invalid byte buffer capacity of "" + invalidValue.capacity());
    } catch (IllegalArgumentException e) {
    }
  }
"
1413,session could be set to null on dispose().,"    void dispose() {
        if (semanticResourcesUpdater != null) {
            semanticResourcesUpdater.dispose();
            semanticResourcesUpdater = null;
        }
    }
","    void dispose() {
        if (semanticResourcesUpdater != null) {
            semanticResourcesUpdater.dispose();
            semanticResourcesUpdater = null;
START         } END 
    }
","    void dispose() {
        session = null;
        if (semanticResourcesUpdater != null) {
            semanticResourcesUpdater.dispose();
            semanticResourcesUpdater = null;
        }
    }
"
1414,"you can do this things in one line such as
```
new DotConnect().setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE).addParam(type.id()).addParam(type.id()).loadResults();
```","	public void deleteByContentType(final ContentTypeIf type) throws DotDataException{
	    final DotConnect dc = new DotConnect();
	    dc.setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE);
	    dc.addParam(type.id());
	    dc.addParam(type.id());
	    dc.loadResults();
	}
","	public void deleteByContentType(final ContentTypeIf type) throws DotDataException{
START 	    final DotConnect dc = new DotConnect(); END 
	    dc.setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE);
	    dc.addParam(type.id());
	    dc.addParam(type.id());
	    dc.loadResults();
	}
","	public void deleteByContentType(final ContentTypeIf type) throws DotDataException{
	    new DotConnect()
                .setSQL(sql.DELETE_RELATIONSHIP_BY_PARENT_OR_CHILD_INODE)
                .addParam(type.id())
                .addParam(type.id())
                .loadResults();
	}
"
1415,Is the if block still needed?,"	public int getUniqueNotificationId() {
		if (uniqueNotificationIdCounter == null) {
			uniqueNotificationIdCounter = new AtomicInteger(0);
		}
		return uniqueNotificationIdCounter.incrementAndGet();
	}
","	public int getUniqueNotificationId() {
		if (uniqueNotificationIdCounter == null) {
			uniqueNotificationIdCounter = new AtomicInteger(0);
START 		} END 
		return uniqueNotificationIdCounter.incrementAndGet();
	}
","	public int getUniqueNotificationId() {
		return uniqueNotificationIdCounter.incrementAndGet();
	}
"
1416,How come not logger.error()?,"    public void run() {
      // Loops till QueueProcessorThread is shutdown
      while (!shutdown) {
        synchronized (this) {
          try {
            // start processing queue if active, other wait for sometime
            if (isActive) {
              processQueuedFlows(activeExecutorRefreshWindowInMilisec,
                activeExecutorRefreshWindowInFlows);
            }
            wait(QUEUE_PROCESSOR_WAIT_IN_MS);
          } catch (Exception e) {
            logger.info(
              ""QueueProcessorThread Interrupted. Probably to shut down."", e);
          }
        }
      }
    }
","    public void run() {
      // Loops till QueueProcessorThread is shutdown
      while (!shutdown) {
        synchronized (this) {
          try {
            // start processing queue if active, other wait for sometime
            if (isActive) {
              processQueuedFlows(activeExecutorRefreshWindowInMilisec,
                activeExecutorRefreshWindowInFlows);
            }
            wait(QUEUE_PROCESSOR_WAIT_IN_MS);
          } catch (Exception e) {
START             logger.info( END 
              ""QueueProcessorThread Interrupted. Probably to shut down."", e);
          }
        }
      }
    }
","    public void run() {
      // Loops till QueueProcessorThread is shutdown
      while (!shutdown) {
        synchronized (this) {
          try {
            // start processing queue if active, other wait for sometime
            if (isActive) {
              processQueuedFlows(activeExecutorRefreshWindowInMilisec,
                activeExecutorRefreshWindowInFlows);
            }
            wait(QUEUE_PROCESSOR_WAIT_IN_MS);
          } catch (Exception e) {
            logger.error(
              ""QueueProcessorThread Interrupted. Probably to shut down."", e);
          }
        }
      }
    }
"
1417,No need to force byte order when wrapping byte[],"  public HllSketchMergeBufferAggregator(
      final ColumnValueSelector<HllSketch> selector,
      final int lgK,
      final TgtHllType tgtHllType,
      final int size
  )
  {
    this.selector = selector;
    this.lgK = lgK;
    this.tgtHllType = tgtHllType;
    this.size = size;
    this.emptyUnion = new byte[size];

    //noinspection ResultOfObjectAllocationIgnored (Union writes to ""emptySketch"" as a side effect of construction)
    new Union(lgK, WritableMemory.wrap(emptyUnion, ByteOrder.LITTLE_ENDIAN));
  }
","  public HllSketchMergeBufferAggregator(
      final ColumnValueSelector<HllSketch> selector,
      final int lgK,
      final TgtHllType tgtHllType,
      final int size
  )
  {
    this.selector = selector;
    this.lgK = lgK;
    this.tgtHllType = tgtHllType;
    this.size = size;
    this.emptyUnion = new byte[size];

    //noinspection ResultOfObjectAllocationIgnored (Union writes to ""emptySketch"" as a side effect of construction)
START     new Union(lgK, WritableMemory.wrap(emptyUnion, ByteOrder.LITTLE_ENDIAN)); END 
  }
","  public HllSketchMergeBufferAggregator(
      final ColumnValueSelector<HllSketch> selector,
      final int lgK,
      final TgtHllType tgtHllType,
      final int size
  )
  {
    this.selector = selector;
    this.lgK = lgK;
    this.tgtHllType = tgtHllType;
    this.size = size;
    this.emptyUnion = new byte[size];

    //noinspection ResultOfObjectAllocationIgnored (Union writes to ""emptyUnion"" as a side effect of construction)
    new Union(lgK, WritableMemory.wrap(emptyUnion));
  }
"
1418,"The expected value should be 1st, it affects error messages by junit","    public void checkIPAdress() {
        Set<ConstraintViolation<IPAdress>> validate = validator.validate(new IPAdress(address));
        assertEquals(validate.isEmpty(), expectedResult);
    }
","    public void checkIPAdress() {
        Set<ConstraintViolation<IPAdress>> validate = validator.validate(new IPAdress(address));
START         assertEquals(validate.isEmpty(), expectedResult); END 
    }
","    public void checkIPAdress() {
        Set<ConstraintViolation<IPAdress>> validate = validator.validate(new IPAdress(address));
        assertEquals(expectedResult, validate.isEmpty());
    }
"
1419,No good idea. ;),"		public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
			try {
				// Ignore first call, which comes from onCreate()
				if (currentFormat != null)
					calc();
			} catch (GeopointException e) {
				context.showToast(e.getMessage());
				spinner.setSelection(currentFormat.ordinal());
				return;
			}

			currentFormat = coordInputFormatEnum.fromInt(pos);
			settings.setCoordInputFormat(currentFormat);
			updateGUI();
		}
","		public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
			try {
				// Ignore first call, which comes from onCreate()
				if (currentFormat != null)
					calc();
			} catch (GeopointException e) {
START 				context.showToast(e.getMessage()); END 
				spinner.setSelection(currentFormat.ordinal());
				return;
			}

			currentFormat = coordInputFormatEnum.fromInt(pos);
			settings.setCoordInputFormat(currentFormat);
			updateGUI();
		}
","		public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
			// Ignore first call, which comes from onCreate()
			if (currentFormat != null && !calc()) {
				// An error occurred, reset spinner to current format
				spinner.setSelection(currentFormat.ordinal());
				return;
			}

			currentFormat = coordInputFormatEnum.fromInt(pos);
			settings.setCoordInputFormat(currentFormat);
			updateGUI();
		}
"
1420,why return `false`?,"    public boolean visitTableWithType(String schemaName, String tableName, TableType type) {
      Preconditions
          .checkNotNull(type, ""Error. Type information for table %s.%s provided is null."", schemaName,
              tableName);
      records.add(new Records.Table(IS_CATALOG_NAME, schemaName, tableName, type.toString()));
      return false;
    }
","    public boolean visitTableWithType(String schemaName, String tableName, TableType type) {
      Preconditions
          .checkNotNull(type, ""Error. Type information for table %s.%s provided is null."", schemaName,
              tableName);
      records.add(new Records.Table(IS_CATALOG_NAME, schemaName, tableName, type.toString()));
START       return false; END 
    }
","    private void visitTableWithType(String schemaName, String tableName, TableType type) {
      Preconditions
          .checkNotNull(type, ""Error. Type information for table %s.%s provided is null."", schemaName,
              tableName);
      records.add(new Records.Table(IS_CATALOG_NAME, schemaName, tableName, type.toString()));
      return;
    }
"
1421,Comparing with null is not enough. You might replace an existing attachment with a different instance in which case you should return true. In short if the return is different from the input then something changed.,"    public boolean add(XWikiAttachment attachment)
    {
        return set(attachment) != null;
    }
","    public boolean add(XWikiAttachment attachment)
    {
START         return set(attachment) != null; END 
    }
","    public boolean add(XWikiAttachment attachment)
    {
        XWikiAttachment set = set(attachment);
        return set != attachment;
    }
"
1422,ditto: sort by name please,"  public String toString() {
    return Objects.toStringHelper(this).add(""liveWorkerNum"", mLiveWorkerNum)
        .add(""lostWorkerNum"", mLostWorkerNum).add(""capacityBytes"", mCapacityBytes)
        .add(""usedBytes"", mUsedBytes).add(""freeBytes"", mFreeBytes)
        .add(""capacityBytesOnTiers"", mCapacityBytesOnTiers)
        .add(""usedBytesOnTiers"", mUsedBytesOnTiers).toString();
  }
","  public String toString() {
START     return Objects.toStringHelper(this).add(""liveWorkerNum"", mLiveWorkerNum) END 
        .add(""lostWorkerNum"", mLostWorkerNum).add(""capacityBytes"", mCapacityBytes)
        .add(""usedBytes"", mUsedBytes).add(""freeBytes"", mFreeBytes)
        .add(""capacityBytesOnTiers"", mCapacityBytesOnTiers)
        .add(""usedBytesOnTiers"", mUsedBytesOnTiers).toString();
  }
","  public String toString() {
    return Objects.toStringHelper(this).add(""capacityBytes"", mCapacityBytes)
        .add(""capacityBytesOnTiers"", mCapacityBytesOnTiers)
        .add(""freeBytes"", mFreeBytes)
        .add(""liveWorkerNum"", mLiveWorkerNum)
        .add(""lostWorkerNum"", mLostWorkerNum)
        .add(""usedBytes"", mUsedBytes)
        .add(""usedBytesOnTiers"", mUsedBytesOnTiers).toString();
  }
"
1423,"```suggestion
                .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task));
```","    public static final void assertJenkinsNotInQuietMode(final JenkinsRule j) {
        await().pollInterval(250, TimeUnit.MILLISECONDS)
                .atMost(10, TimeUnit.SECONDS)
                .until(() -> !j.jenkins.get().getQueue().isBlockedByShutdown(task));
    }
","    public static final void assertJenkinsNotInQuietMode(final JenkinsRule j) {
        await().pollInterval(250, TimeUnit.MILLISECONDS)
                .atMost(10, TimeUnit.SECONDS)
START                 .until(() -> !j.jenkins.get().getQueue().isBlockedByShutdown(task)); END 
    }
","    public static final void assertJenkinsNotInQuietMode(final JenkinsRule j) {
        await().pollInterval(250, TimeUnit.MILLISECONDS)
                .atMost(10, TimeUnit.SECONDS)
                .until(() -> !j.jenkins.getQueue().isBlockedByShutdown(task));
    }
"
1424,The method signature doesn't specify the Exception which could be thrown.,"	private TreeLayer getTreeLayer() {
		NatTable natTable = (NatTable) getTableManager().getAdapter(NatTable.class);
		ILayer layer = natTable.getLayer();
		if (layer instanceof PapyrusGridLayer) {
			PapyrusGridLayer gridLayer = (PapyrusGridLayer) layer;
			ILayer rowLayer = gridLayer.getRowHeaderLayer();
			if (rowLayer instanceof RowHeaderHierarchicalLayerStack) {
				return ((RowHeaderHierarchicalLayerStack) rowLayer).getTreeLayer();
			}
		}
		throw new UnknownError(""TreeLayer has not been found""); //$NON-NLS-1$
	}
","	private TreeLayer START  getTreeLayer() END  {
		NatTable natTable = (NatTable) getTableManager().getAdapter(NatTable.class);
		ILayer layer = natTable.getLayer();
		if (layer instanceof PapyrusGridLayer) {
			PapyrusGridLayer gridLayer = (PapyrusGridLayer) layer;
			ILayer rowLayer = gridLayer.getRowHeaderLayer();
			if (rowLayer instanceof RowHeaderHierarchicalLayerStack) {
				return ((RowHeaderHierarchicalLayerStack) rowLayer).getTreeLayer();
			}
		}
		throw new UnknownError(""TreeLayer has not been found""); //$NON-NLS-1$
	}
","	private TreeLayer getTreeLayer() throws Exception {
		NatTable natTable = (NatTable) getTableManager().getAdapter(NatTable.class);
		ILayer layer = natTable.getLayer();
		if (layer instanceof PapyrusGridLayer) {
			PapyrusGridLayer gridLayer = (PapyrusGridLayer) layer;
			ILayer rowLayer = gridLayer.getRowHeaderLayer();
			if (rowLayer instanceof RowHeaderHierarchicalLayerStack) {
				return ((RowHeaderHierarchicalLayerStack) rowLayer).getTreeLayer();
			}
		}
		throw new UnknownError(""TreeLayer has not been found""); //$NON-NLS-1$
	}
"
1425,return directly,"    public boolean equals(@Nullable Object obj) {
        if (!(obj instanceof DataDrivenValueSelf)) {
            return false;
        }
        return true;
    }
","    public boolean equals(@Nullable Object obj) {
START         if (!(obj instanceof DataDrivenValueSelf)) { END 
            return false;
        }
        return true;
    }
","    public boolean equals(@Nullable Object obj) {
        if (!(obj instanceof DataDrivenValueSelf)) {
            return false;
        }
        return super.equals(obj);
    }
"
1426,"![MAJOR](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/severity-major.png) Remove this unused ""searchInput"" local variable. [![rule](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/rule.png)](http://sonar-s1/coding_rules#rule_key=squid%3AS1481)","    public void differentUrlForPostsAndVideo() {
        SearchInput searchInput = new SearchInput().searchInputValue();
        SearchInput searchInputSubmit = new SearchInput().searchInputSubmit();

        String URL = driver.getCurrentUrl();
        Assert.assertEquals(URL, ""http://qa.fandom.wikia.com/?s=TEST"");

        SearchInput postsResult = new SearchInput().searchResultsPosts();

        String postUrl = driver.getCurrentUrl();

        SearchInput videosResult = new SearchInput().searchResultsVideos();

        String videoUrl = driver.getCurrentUrl();

        Assert.assertNotEquals(postUrl, videoUrl);
    }
","    public void differentUrlForPostsAndVideo() {
START         SearchInput searchInput = new SearchInput().searchInputValue(); END 
        SearchInput searchInputSubmit = new SearchInput().searchInputSubmit();

        String URL = driver.getCurrentUrl();
        Assert.assertEquals(URL, ""http://qa.fandom.wikia.com/?s=TEST"");

        SearchInput postsResult = new SearchInput().searchResultsPosts();

        String postUrl = driver.getCurrentUrl();

        SearchInput videosResult = new SearchInput().searchResultsVideos();

        String videoUrl = driver.getCurrentUrl();

        Assert.assertNotEquals(postUrl, videoUrl);
    }
","    public void differentUrlForPostsAndVideo() {
        SearchInput searchInput = new SearchInput().searchInputValue();
        SearchInput searchInputSubmit = new SearchInput().searchInputSubmit();
        SearchInput postsResult = new SearchInput().searchResultsPosts();

        String postUrl = driver.getCurrentUrl();

        SearchInput videosResult = new SearchInput().searchResultsVideos();

        String videoUrl = driver.getCurrentUrl();

        Assert.assertNotEquals(postUrl, videoUrl);
    }
"
1427,I would deprecate it and add a new one.,"    String convert(Blob blob) {
        if (blob.getLength() == 0L) {
            return """";
        }
        try (InputStream stream = blob.getStream()) {
            Xml2TextHandler xml2text = new Xml2TextHandler();
            return xml2text.parse(stream);
        } catch (IOException | SAXException | ParserConfigurationException e) {
            throw new ConversionException(""Error during XML2Text conversion"", e);
        }
    }
","START     String convert(Blob blob) { END 
        if (blob.getLength() == 0L) {
            return """";
        }
        try (InputStream stream = blob.getStream()) {
            Xml2TextHandler xml2text = new Xml2TextHandler();
            return xml2text.parse(stream);
        } catch (IOException | SAXException | ParserConfigurationException e) {
            throw new ConversionException(""Error during XML2Text conversion"", e);
        }
    }
","    protected String convert(Blob blob) {
        if (blob.getLength() == 0L) {
            return """";
        }
        try (InputStream stream = blob.getStream()) {
            Xml2TextHandler xml2text = new Xml2TextHandler();
            return xml2text.parse(stream);
        } catch (IOException | SAXException | ParserConfigurationException e) {
            throw new ConversionException(""Error during XML2Text conversion"", blob, e);
        }
    }
"
1428,"This should be package-level protected:
```suggestion
    // Visible for testing
    static void validateHeaderConfigAction(String action) {
```","    public static void validateHeaderConfigAction(String action) {
        if (!HEADER_ACTIONS.stream().anyMatch(action::equalsIgnoreCase)) {
            throw new ConfigException(String.format(""Invalid header config action: '%s'. ""
                    + ""Expected one of %s"", action, HEADER_ACTIONS));
        }
    }
","START     public static void validateHeaderConfigAction(String action) { END 
        if (!HEADER_ACTIONS.stream().anyMatch(action::equalsIgnoreCase)) {
            throw new ConfigException(String.format(""Invalid header config action: '%s'. ""
                    + ""Expected one of %s"", action, HEADER_ACTIONS));
        }
    }
","    static void validateHeaderConfigAction(String action) {
        if (!HEADER_ACTIONS.stream().anyMatch(action::equalsIgnoreCase)) {
            throw new ConfigException(String.format(""Invalid header config action: '%s'. ""
                    + ""Expected one of %s"", action, HEADER_ACTIONS));
        }
    }
"
1429,`variableMetadata.getName().length()` invocation is redundant.,"    private String getVariableLabel(VariableMetadata variableMetadata) {
        if (variableMetadata.getName().startsWith(CASE_VARIABLE_PREFIX)) {
            return translationService.getValue(CASE_VARIABLE_LABEL_PREFIX) + "" "" +
                    variableMetadata.getName().substring(CASE_VARIABLE_PREFIX.length(), variableMetadata.getName().length());
        } else {
            return variableMetadata.getName();
        }
    }
","    private String getVariableLabel(VariableMetadata variableMetadata) {
        if (variableMetadata.getName().startsWith(CASE_VARIABLE_PREFIX)) {
            return translationService.getValue(CASE_VARIABLE_LABEL_PREFIX) + "" "" +
START                     variableMetadata.getName().substring(CASE_VARIABLE_PREFIX.length(), variableMetadata.getName().length()); END 
        } else {
            return variableMetadata.getName();
        }
    }
","    private String getVariableLabel(VariableMetadata variableMetadata) {
        if (variableMetadata.getName().startsWith(CASE_VARIABLE_PREFIX)) {
            return translationService.getValue(CASE_VARIABLE_LABEL_PREFIX) + "" "" +
                    variableMetadata.getName().substring(CASE_VARIABLE_PREFIX.length());
        } else {
            return variableMetadata.getName();
        }
    }
"
1430,[existsById(long id)](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html#existsById-ID-) 💯,"    private Long findFreeId(){
        while(personRepository.findOne(lastId) != null){ // New person
            lastId++;
        }
        return lastId;
    }
","    private Long findFreeId(){
START         while(personRepository.findOne(lastId) != null){ // New person END 
            lastId++;
        }
        return lastId;
    }
","    private Long findFreeId(){
        while(personRepository.exists(lastId)){ // New person
            lastId++;
        }
        return lastId;
    }
"
1431,Move to setUp(). You can make mCameraId a local variable again.,"    public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException {
        Assume.assumeTrue(mCameraId != null);
        mUseCase.addStateChangeListener(
                mCameraRepository.getCamera(
                        getCameraIdForLensFacingUnchecked(mConfig.getLensFacing())));
        mUseCase.doNotifyActive();
        mCameraRepository.onGroupActive(mUseCaseGroup);

        // Wait for the CameraDevice.onOpened callback.
        mUseCase.mDeviceStateCallback.waitForOnOpened(1);

        mCameraRepository.onGroupInactive(mUseCaseGroup);

        // Wait for the CameraDevice.onClosed callback.
        mUseCase.mDeviceStateCallback.waitForOnClosed(1);
    }
","    public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException {
        START  Assume.assumeTrue(mCameraId != null); END 
        mUseCase.addStateChangeListener(
                mCameraRepository.getCamera(
                        getCameraIdForLensFacingUnchecked(mConfig.getLensFacing())));
        mUseCase.doNotifyActive();
        mCameraRepository.onGroupActive(mUseCaseGroup);

        // Wait for the CameraDevice.onOpened callback.
        mUseCase.mDeviceStateCallback.waitForOnOpened(1);

        mCameraRepository.onGroupInactive(mUseCaseGroup);

        // Wait for the CameraDevice.onClosed callback.
        mUseCase.mDeviceStateCallback.waitForOnClosed(1);
    }
","    public void cameraDeviceCallsAreForwardedToCallback() throws InterruptedException {
        mUseCase.addStateChangeListener(
                mCameraRepository.getCamera(
                        getCameraIdForLensFacingUnchecked(mConfig.getLensFacing())));
        mUseCase.doNotifyActive();
        mCameraRepository.onGroupActive(mUseCaseGroup);

        // Wait for the CameraDevice.onOpened callback.
        mUseCase.mDeviceStateCallback.waitForOnOpened(1);

        mCameraRepository.onGroupInactive(mUseCaseGroup);

        // Wait for the CameraDevice.onClosed callback.
        mUseCase.mDeviceStateCallback.waitForOnClosed(1);
    }
"
1432,Beware that invoking [`getContent(I18N.getLocale())`](https://github.com/FenixEdu/fenixedu-commons/blob/v1.1.0/src/main/java/org/fenixedu/commons/i18n/LocalizedString.java#L461-L475) is different than just invoking [`getContent()`](https://github.com/FenixEdu/fenixedu-commons/blob/v1.1.0/src/main/java/org/fenixedu/commons/i18n/LocalizedString.java#L480-L496).,"    public String getDescription() {
        return getStatuteType().getName().getContent(I18N.getLocale())
                + (studentStatute instanceof SeniorStatute ? ("" (""
                        + ((SeniorStatute) studentStatute).getRegistration().getDegree().getPresentationName() + "") "") : """");
    }
","    public String getDescription() {
START         return getStatuteType().getName().getContent(I18N.getLocale()) END 
                + (studentStatute instanceof SeniorStatute ? ("" (""
                        + ((SeniorStatute) studentStatute).getRegistration().getDegree().getPresentationName() + "") "") : """");
    }
","    public String getDescription() {
        return getStatuteType().getName().getContent()
                + (studentStatute instanceof SeniorStatute ? ("" (""
                        + ((SeniorStatute) studentStatute).getRegistration().getDegree().getPresentationName() + "") "") : """");
    }
"
1433,Do this and the other method need to be public? Would `protected` suffice?,"    public boolean teleportToSpawn() {
        Location target = server.getWorlds().get(0).getSpawnLocation();

        EntityPortalEvent event = EventFactory.callEvent(new EntityPortalEvent(this, location.clone(), target, null));
        if (event.isCancelled()) {
            return false;
        }
        target = event.getTo();

        teleport(target);
        return true;
    }
","START     public boolean teleportToSpawn() { END 
        Location target = server.getWorlds().get(0).getSpawnLocation();

        EntityPortalEvent event = EventFactory.callEvent(new EntityPortalEvent(this, location.clone(), target, null));
        if (event.isCancelled()) {
            return false;
        }
        target = event.getTo();

        teleport(target);
        return true;
    }
","    protected boolean teleportToSpawn() {
        Location target = server.getWorlds().get(0).getSpawnLocation();

        EntityPortalEvent event = EventFactory.callEvent(new EntityPortalEvent(this, location.clone(), target, null));
        if (event.isCancelled()) {
            return false;
        }
        target = event.getTo();

        teleport(target);
        return true;
    }
"
1434,Can we please have this variable initialized to an empty array so that we can avoid a null check to be done ?,"  public String[] getGroupFilters() {
    String[] result = null;
    IAnnotation before = m_annotationFinder.findAnnotation(getConstructorOrMethod(), IBeforeMethod.class);
    if (before != null) {
      result = ((ConfigurationAnnotation) before).getGroupFilters();
    }
    return result;
  }
","  public String[] getGroupFilters() {
START     String[] result = null; END 
    IAnnotation before = m_annotationFinder.findAnnotation(getConstructorOrMethod(), IBeforeMethod.class);
    if (before != null) {
      result = ((ConfigurationAnnotation) before).getGroupFilters();
    }
    return result;
  }
","  public String[] getGroupFilters() {
    IBeforeMethod before = m_annotationFinder.findAnnotation(getConstructorOrMethod(), IBeforeMethod.class);
    if (before == null) {
      return new String[0];
    }
    return before.getGroupFilters();
  }
"
1435,some of the protected items here can be package private,"    protected PageCacheNumberArray( PagedFile pagedFile, int entrySize, long length,
                                 long defaultValue, long base ) throws IOException
    {
        this.pagedFile = pagedFile;
        this.entrySize = entrySize;
        this.entriesPerPage = pagedFile.pageSize() / entrySize;
        this.length = length;
        this.defaultValue = defaultValue;
        this.base = base;

        try ( PageCursor cursorToSetLength = pagedFile.io( 0, PF_SHARED_WRITE_LOCK ) )
        {
            setLength( cursorToSetLength, length );
        }

        if ( defaultValue != 0 )
        {
            setDefaultValue( defaultValue );
        }
    }
","START     protected PageCacheNumberArray( PagedFile pagedFile, int entrySize, long length, END 
                                 long defaultValue, long base ) throws IOException
    {
        this.pagedFile = pagedFile;
        this.entrySize = entrySize;
        this.entriesPerPage = pagedFile.pageSize() / entrySize;
        this.length = length;
        this.defaultValue = defaultValue;
        this.base = base;

        try ( PageCursor cursorToSetLength = pagedFile.io( 0, PF_SHARED_WRITE_LOCK ) )
        {
            setLength( cursorToSetLength, length );
        }

        if ( defaultValue != 0 )
        {
            setDefaultValue( defaultValue );
        }
    }
","    PageCacheNumberArray( PagedFile pagedFile, int entrySize, long length, long defaultValue, long base )
            throws IOException
    {
        this.pagedFile = pagedFile;
        this.entrySize = entrySize;
        this.entriesPerPage = pagedFile.pageSize() / entrySize;
        this.length = length;
        this.defaultValue = defaultValue;
        this.base = base;

        try ( PageCursor cursorToSetLength = pagedFile.io( 0, PF_SHARED_WRITE_LOCK ) )
        {
            setLength( cursorToSetLength, length );
        }

        if ( defaultValue != 0 )
        {
            setDefaultValue( defaultValue );
        }
    }
"
1436,Don't precompute `selectedPositions.getPositions`. It is unnecessary. And it makes the code harder to follow.,"        public InterpretedPageProjectionOutput(DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions)
        {
            this.yieldSignal = requireNonNull(yieldSignal, ""yieldSignal is null"");
            this.blocks = requireNonNull(page, ""page is null"").getBlocks();
            this.selectedPositions = requireNonNull(selectedPositions, ""selectedPositions is null"");
            this.nextIndexOrPosition = selectedPositions.getOffset();
            if (selectedPositions.isList()) {
                this.positions = selectedPositions.getPositions();
            }
            else {
                this.positions = null;
            }
        }
","        public InterpretedPageProjectionOutput(DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions)
        {
            this.yieldSignal = requireNonNull(yieldSignal, ""yieldSignal is null"");
            this.blocks = requireNonNull(page, ""page is null"").getBlocks();
            this.selectedPositions = requireNonNull(selectedPositions, ""selectedPositions is null"");
            this.nextIndexOrPosition = selectedPositions.getOffset();
            if (selectedPositions.isList()) {
                this.positions = selectedPositions.getPositions();
            }
            else {
                this.positions = null;
START             } END 
        }
","        public InterpretedPageProjectionOutput(DriverYieldSignal yieldSignal, Page page, SelectedPositions selectedPositions)
        {
            this.yieldSignal = requireNonNull(yieldSignal, ""yieldSignal is null"");
            this.blocks = requireNonNull(page, ""page is null"").getBlocks();
            this.selectedPositions = requireNonNull(selectedPositions, ""selectedPositions is null"");
            this.nextIndexOrPosition = selectedPositions.getOffset();
        }
"
1437,this ternary will not behave as stated in the 1. should annotation,"	public String getDicomViewerUrl(Study study) {
		if (study == null)
			throw new IllegalArgumentException(""study cannot be null"");
		else if (study.getStudyInstanceUid() == null)
			throw new IllegalArgumentException(""studyInstanceUid cannot be null"");
		
		return study.isCompleted() ? this.radiologyProperties.getDicomViewerUrl() + ""studyUID=""
		        + study.getStudyInstanceUid() : null;
		        
	}
","	public String getDicomViewerUrl(Study study) {
		if (study == null)
			throw new IllegalArgumentException(""study cannot be null"");
		else if (study.getStudyInstanceUid() == null)
			throw new IllegalArgumentException(""studyInstanceUid cannot be null"");
		
START 		return study.isCompleted() ? this.radiologyProperties.getDicomViewerUrl() + ""studyUID="" END 
		        + study.getStudyInstanceUid() : null;
		        
	}
","	public String getDicomViewerUrl(Study study) {
		if (study == null)
			throw new IllegalArgumentException(""study cannot be null"");
		else if (study.getStudyInstanceUid() == null)
			throw new IllegalArgumentException(""studyInstanceUid cannot be null"");
		return radiologyProperties.getDicomViewerUrl() + ""studyUID="" + study.getStudyInstanceUid();
	}
"
1438,..and change as well the variable name `declFromXpath` to `declCorrXpath` also here.,"    private Declaration getDeclarationCorrespondingToXpath( Pattern pattern, boolean isXPath, Constraint constraint ) {
        Declaration declFromXpath = null;
        if (!isXPath && pattern.hasXPath()) {
            Declaration xPathDecl = pattern.getXPathDeclaration();
            if (xPathDecl != null) {
                for ( Declaration decl : constraint.getRequiredDeclarations() ) {
                    if (xPathDecl.equals( decl )) {
                        declFromXpath = decl;
                        break;
                    }
                }
            }
        }
        return declFromXpath;
    }
","    private Declaration getDeclarationCorrespondingToXpath( Pattern pattern, boolean isXPath, Constraint constraint ) {
START         Declaration declFromXpath = null; END 
        if (!isXPath && pattern.hasXPath()) {
            Declaration xPathDecl = pattern.getXPathDeclaration();
            if (xPathDecl != null) {
                for ( Declaration decl : constraint.getRequiredDeclarations() ) {
                    if (xPathDecl.equals( decl )) {
                        declFromXpath = decl;
                        break;
                    }
                }
            }
        }
        return declFromXpath;
    }
","    private Declaration getDeclarationCorrespondingToXpath( Pattern pattern, boolean isXPath, Constraint constraint ) {
        if (!isXPath && pattern.hasXPath()) {
            Declaration xPathDecl = pattern.getXPathDeclaration();
            if (xPathDecl != null) {
                for ( Declaration decl : constraint.getRequiredDeclarations() ) {
                    if (xPathDecl.equals( decl )) {
                        return decl;
                    }
                }
            }
        }
        return null;
    }
"
1439,"the parent setQueryTimeout will throw a SQLException if the parameter is invalid, so this method now no longer throws an InvalidParameterSqlException","  public void setQueryTimeout( int seconds )
      throws AlreadyClosedSqlException,
             InvalidParameterSqlException,
             SQLException {
    throwIfClosed();
    super.setQueryTimeout(seconds);
  }
","  public void setQueryTimeout( int seconds )
      throws AlreadyClosedSqlException,
START              InvalidParameterSqlException, END 
             SQLException {
    throwIfClosed();
    super.setQueryTimeout(seconds);
  }
","  public void setQueryTimeout( int seconds )
      throws AlreadyClosedSqlException,
             SQLException {
    throwIfClosed();
    super.setQueryTimeout(seconds);
  }
"
1440,Please use Java conventions - param,"    private List<Disk> manualAggregateSnapshots() {
        List<Disk> Param = new ArrayList<>();
        DiskImage diskWithSnaps = diskWithSnapshots;
        diskWithSnaps.getSnapshots().addAll(snapshotsList);
        Param.add(diskWithSnapshots);
        Param.add(diskWithoutSnapshots);
        Param.add(ovfImage);
        Param.add(cinderDisk);
        return Param;
    }
","    private List<Disk> manualAggregateSnapshots() {
        List<Disk> START  Param = END  new ArrayList<>();
        DiskImage diskWithSnaps = diskWithSnapshots;
        diskWithSnaps.getSnapshots().addAll(snapshotsList);
        Param.add(diskWithSnapshots);
        Param.add(diskWithoutSnapshots);
        Param.add(ovfImage);
        Param.add(cinderDisk);
        return Param;
    }
","    private List<DiskImage> manualAggregateSnapshots() {
        DiskImage diskWithSnaps = diskWithSnapshots;
        diskWithSnaps.getSnapshots().addAll(snapshotsList);
        return Arrays.asList(diskWithSnapshots, diskWithoutSnapshots, ovfImage, cinderDisk);
    }
"
1441,Enabling indexing even if autoConfig == false? Maybe this auto-enabling should happen only if autoConfig==true?,"   public IndexingConfigurationBuilder autoConfig(boolean autoConfig) {
      enable();
      attributes.attribute(AUTO_CONFIG).set(autoConfig);
      return this;
   }
","   public IndexingConfigurationBuilder autoConfig(boolean autoConfig) {
START       enable(); END 
      attributes.attribute(AUTO_CONFIG).set(autoConfig);
      return this;
   }
","   public IndexingConfigurationBuilder autoConfig(boolean autoConfig) {
      if (autoConfig) enable();
      attributes.attribute(AUTO_CONFIG).set(autoConfig);
      return this;
   }
"
1442,"dao will return either an empty list or populated one, but never null.","    private boolean shouldBeDirectlyAttached(String vfName, Guid vmId) {
        return CollectionUtils
                .isNotEmpty(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.HOSTDEV, vfName));
    }
","    private boolean shouldBeDirectlyAttached(String vfName, Guid vmId) {
        return START  CollectionUtils
                .isNotEmpty(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, END  VmDeviceGeneralType.HOSTDEV, vfName));
    }
","    private boolean shouldBeDirectlyAttached(String vfName, Guid vmId) {
        return !vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.HOSTDEV, vfName).isEmpty();
    }
"
1443,static,"    private void safeCloseStream(Closeable stream) {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // swallow error in this case
                Logger.e(TAG, ""Failed to close the stream: "", """", ADALError.IO_EXCEPTION, e);
            }
        }
    }
","START     private void safeCloseStream(Closeable stream) { END 
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // swallow error in this case
                Logger.e(TAG, ""Failed to close the stream: "", """", ADALError.IO_EXCEPTION, e);
            }
        }
    }
","    private static void safeCloseStream(Closeable stream) {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // swallow error in this case
                Logger.e(TAG, ""Failed to close the stream: "", """", ADALError.IO_EXCEPTION, e);
            }
        }
    }
"
1444,"How about the following to simplify the string construction below:
```java
        String clientEnabled = System.getProperty(ZK_SASL_CLIENT, ""default:"" + DEFAULT_ZK_SASL_CLIENT);
        String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, ""default:"" + DEFAULT_ZK_LOGIN_CONTEXT_NAME);
```","    public static String zkSecuritySysConfigString() {
        String loginConfig = System.getProperty(JAVA_LOGIN_CONFIG_PARAM);
        String clientEnabled = System.getProperty(ZK_SASL_CLIENT);
        String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY);
        return ""["" +
                JAVA_LOGIN_CONFIG_PARAM + ""="" + loginConfig +
                "", "" +
                ZK_SASL_CLIENT + ""="" + (clientEnabled == null ? ""default:"" + DEFAULT_ZK_SASL_CLIENT : clientEnabled) +
                "", "" +
                ZK_LOGIN_CONTEXT_NAME_KEY + ""="" + (contextName == null ? ""default:"" + DEFAULT_ZK_LOGIN_CONTEXT_NAME : contextName) +
                ""]"";
    }
","    public static String zkSecuritySysConfigString() {
        String loginConfig = System.getProperty(JAVA_LOGIN_CONFIG_PARAM);
        String clientEnabled = System.getProperty(ZK_SASL_CLIENT);
START         String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY); END 
        return ""["" +
                JAVA_LOGIN_CONFIG_PARAM + ""="" + loginConfig +
                "", "" +
                ZK_SASL_CLIENT + ""="" + (clientEnabled == null ? ""default:"" + DEFAULT_ZK_SASL_CLIENT : clientEnabled) +
                "", "" +
                ZK_LOGIN_CONTEXT_NAME_KEY + ""="" + (contextName == null ? ""default:"" + DEFAULT_ZK_LOGIN_CONTEXT_NAME : contextName) +
                ""]"";
    }
","    public static String zkSecuritySysConfigString() {
        String loginConfig = System.getProperty(JAVA_LOGIN_CONFIG_PARAM);
        String clientEnabled = System.getProperty(ZK_SASL_CLIENT, ""default:"" + DEFAULT_ZK_SASL_CLIENT);
        String contextName = System.getProperty(ZK_LOGIN_CONTEXT_NAME_KEY, ""default:"" + DEFAULT_ZK_LOGIN_CONTEXT_NAME);
        return ""["" +
                JAVA_LOGIN_CONFIG_PARAM + ""="" + loginConfig +
                "", "" +
                ZK_SASL_CLIENT + ""="" + clientEnabled +
                "", "" +
                ZK_LOGIN_CONTEXT_NAME_KEY + ""="" + contextName +
                ""]"";
    }
"
1445,"I would recommend returning a boolean, `true` for a successful update and `false` for the ""no-op"" case","    public void updateNode(final @Nonnull Node node) throws IOException {
        if (node == nodes.get(node.getNodeName())) {
            Queue.withLock(new Runnable() {
                @Override
                public void run() {
                    jenkins.trimLabels();
                }
            });
            persistNode(node);
        }
    }
","START     public void updateNode(final @Nonnull Node node) throws IOException { END 
        if (node == nodes.get(node.getNodeName())) {
            Queue.withLock(new Runnable() {
                @Override
                public void run() {
                    jenkins.trimLabels();
                }
            });
            persistNode(node);
        }
    }
","    public boolean updateNode(final @Nonnull Node node) throws IOException {
        if (node == nodes.get(node.getNodeName())) {
            Queue.withLock(new Runnable() {
                @Override
                public void run() {
                    jenkins.trimLabels();
                }
            });
            persistNode(node);
            return true;
        }
        return false;
    }
"
1446,The rest of this class expects backStack to be nonnull. I recommend we initialize backStack to an empty mutable list and specify @NonNull in the setter.,"    public void onSaveInstanceState(Bundle outState) {
        if (backStack != null) {
            // update the topmost entry in the backstack
            updateCurrentBackStackItem();
            outState.putParcelableArrayList(""backStack"", backStack);
        }
    }
","    public void onSaveInstanceState(Bundle outState) {
START         if (backStack != null) { END 
            // update the topmost entry in the backstack
            updateCurrentBackStackItem();
            outState.putParcelableArrayList(""backStack"", backStack);
        }
    }
","    public void onSaveInstanceState(Bundle outState) {
        // update the topmost entry in the back stack
        updateCurrentBackStackItem();
        outState.putParcelableArrayList(""backStack"", backStack);
    }
"
1447,Is this necessary?,"	public Trader(String name, double cashInHand) {
		super();
		this.name = name;
		this.cashInHand = cashInHand;
		this.position = new ArrayList<Order>();
		this.ordersPlaced = new ArrayList<Order>();
	}
","	public Trader(String name, double cashInHand) {
START 		super(); END 
		this.name = name;
		this.cashInHand = cashInHand;
		this.position = new ArrayList<Order>();
		this.ordersPlaced = new ArrayList<Order>();
	}
","	public Trader(String name, double cashInHand) {
		//super();
		this.name = name;
		this.cashInHand = cashInHand;
		this.position = new ArrayList<Order>();
		this.ordersPlaced = new ArrayList<Order>();
	}
"
1448,There can only be one associated task.,"	private Iterable<ITask> getTasksAssosciatedWithReviewTask(ITask reviewTask) {
		String lookupUrl = reviewTask.getUrl();

		// TODO: Fetch from mapping with the lookupUrl
		String taskUrl = ""http://someurl"";

		AbstractRepositoryConnector repository = TasksUiPlugin.getRepositoryManager()
				.getConnectorForRepositoryTaskUrl(taskUrl);

		String taskId = repository.getTaskIdFromTaskUrl(taskUrl);
		String repositoryUrl = repository.getRepositoryUrlFromTaskUrl(taskUrl);

		ITask assosciatedTask = taskList.getTask(repositoryUrl, taskId);

		if (assosciatedTask == null) {
			return Collections.emptyList();
		}

		return ImmutableSet.of(assosciatedTask);
	}
","START 	private Iterable<ITask> getTasksAssosciatedWithReviewTask(ITask reviewTask) { END 
		String lookupUrl = reviewTask.getUrl();

		// TODO: Fetch from mapping with the lookupUrl
		String taskUrl = ""http://someurl"";

		AbstractRepositoryConnector repository = TasksUiPlugin.getRepositoryManager()
				.getConnectorForRepositoryTaskUrl(taskUrl);

		String taskId = repository.getTaskIdFromTaskUrl(taskUrl);
		String repositoryUrl = repository.getRepositoryUrlFromTaskUrl(taskUrl);

		ITask assosciatedTask = taskList.getTask(repositoryUrl, taskId);

		if (assosciatedTask == null) {
			return Collections.emptyList();
		}

		return ImmutableSet.of(assosciatedTask);
	}
","	private ITask getTasksAssosciatedWithReviewTask(ITask reviewTask) {
		String lookupUrl = reviewTask.getUrl();

		// TODO: Fetch from mapping with the lookupUrl
		String taskUrl = ""http://someurl"";

		AbstractRepositoryConnector repository = TasksUiPlugin.getRepositoryManager()
				.getConnectorForRepositoryTaskUrl(taskUrl);

		String taskId = repository.getTaskIdFromTaskUrl(taskUrl);
		String repositoryUrl = repository.getRepositoryUrlFromTaskUrl(taskUrl);

		ITask assosciatedTask = taskList.getTask(repositoryUrl, taskId);
		return assosciatedTask;
	}
"
1449,Override,"    protected void toLegacyText(StringBuilder builder)
    {
        builder.append(this.value);
    }
","START     protected void toLegacyText(StringBuilder builder) END 
    {
        builder.append(this.value);
    }
","    protected void toLegacyText(StringBuilder builder)
    {
        builder.append( this.value );
        super.toLegacyText( builder );
    }
"
1450,`public static boolean isRoute(final URL url)`,"    public static boolean isRoute(URL url) {
        return ROUTE_PROTOCOL.equals(url.getProtocol())
                || ROUTERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY));
    }
","START     public static boolean isRoute(URL url) { END 
        return ROUTE_PROTOCOL.equals(url.getProtocol())
                || ROUTERS_CATEGORY.equals(url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY));
    }
","    public static boolean isRoute(URL url) {
        return ROUTE_PROTOCOL.equals(url.getProtocol()) ||
                ROUTERS_CATEGORY.equals(url.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY));
    }
"
1451,"I would delete this synchronized block.  Values cannot be modified while we're reading it since we already saw state as 2.  It's also OK to move the prior accesses to values to before the synchronized blocks they are currently in, but it may be a better test without doing that.","  void thread2() {
    int[] vs1;
    synchronized (lock) {
      vs1 = values;
      state = 1;
    }

    int s;
    do {
      synchronized (lock) {
        s = state;
      }
    } while (s != 2);  // Busy loop.

    int[] vs2;
    synchronized (lock) {
      vs2 = values;
    }
    int v1 = vs1[0];
    int v2 = vs2[0];
    System.out.println(""b17689750TestMonitor failed: "" + v1 + "", "" + v2);
  }
","  void thread2() {
    int[] vs1;
    synchronized (lock) {
      vs1 = values;
      state = 1;
    }

    int s;
    do {
      synchronized (lock) {
        s = state;
      }
    } while (s != 2);  // Busy loop.

    int[] vs2;
    START  synchronized (lock) { END 
      vs2 = values;
    }
    int v1 = vs1[0];
    int v2 = vs2[0];
    System.out.println(""b17689750TestMonitor failed: "" + v1 + "", "" + v2);
  }
","  void thread2() {
    int[] vs1;
    synchronized (lock) {
      vs1 = values;
      state = 1;
    }

    int s;
    do {
      synchronized (lock) {
        s = state;
      }
    } while (s != 2);  // Busy loop.

    int[] vs2 = values;
    int v1 = vs1[0];
    int v2 = vs2[0];
    System.out.println(""b17689750TestMonitor failed: "" + v1 + "", "" + v2);
  }
"
1452,"Isn't it easier to have the serializationService as a field on this test? Are there any serializationServices created with different settings? Having it as field instead of local variable, will simplify the test methods.","    public void testWriteAndReadObject() throws Exception {
        InternalSerializationService serializationService = new DefaultSerializationServiceBuilder().build();

        String expected = ""test input"";
        String actual = (String) writeAndReadObject(serializationService, expected);

        assertNotNull(actual);
        assertEquals(expected, actual);
    }
","    public void testWriteAndReadObject() throws Exception {
START         InternalSerializationService serializationService = new DefaultSerializationServiceBuilder().build(); END 

        String expected = ""test input"";
        String actual = (String) writeAndReadObject(serializationService, expected);

        assertNotNull(actual);
        assertEquals(expected, actual);
    }
","    public void testWriteAndReadObject() throws Exception {
        String expected = ""test input"";
        String actual = (String) writeAndReadObject(expected);

        assertNotNull(actual);
        assertEquals(expected, actual);
    }
"
1453,please add braces for the else block.,"    public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final ArArchiveEntry other = (ArArchiveEntry) obj;
        if (name == null) {
            return other.name == null;
        } else return name.equals(other.name);
    }
","    public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final ArArchiveEntry other = (ArArchiveEntry) obj;
        if (name == null) {
            return other.name == null;
START         } else return name.equals(other.name); END 
    }
","    public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        final ArArchiveEntry other = (ArArchiveEntry) obj;
        if (name == null) {
            return other.name == null;
        } else {
            return name.equals(other.name);
        }
    }
"
1454,why do you need to wrap it in a new `ArrayList`? Seems wasteful.,"  public ByteBufferReadableStreamChannel(List<ByteBuffer> bufferList) {
    if (bufferList == null || bufferList.isEmpty()) {
      throw new IllegalArgumentException(""Input List of ByteBuffer cannot be null/empty for ByteBufferReadableStreamChannel"");
    }
    buffers = new ArrayList<>(bufferList);
    size = computeSize(bufferList);
  }
","  public ByteBufferReadableStreamChannel(List<ByteBuffer> bufferList) {
    if (bufferList == null || bufferList.isEmpty()) {
      throw new IllegalArgumentException(""Input List of ByteBuffer cannot be null/empty for ByteBufferReadableStreamChannel"");
    }
START     buffers = new ArrayList<>(bufferList); END 
    size = computeSize(bufferList);
  }
","  public ByteBufferReadableStreamChannel(List<ByteBuffer> bufferList) {
    if (bufferList == null || bufferList.isEmpty()) {
      throw new IllegalArgumentException(
          ""Input List of ByteBuffer cannot be null/empty for ByteBufferReadableStreamChannel"");
    }
    buffers = bufferList;
    size = computeSize(bufferList);
  }
"
1455,"I don't know if it's necessary to log this message for each host, since for other unmet conditions we don't log anything.

If it looks necessary to you then at least VDS ID would be helpful to know (assuming VM ID is already printed elsewehere).","    boolean areRequiredNetworksAvailable(final List<VmNetworkInterface> vmNetworkInterfaces,
            final List<VdsNetworkInterface> allInterfacesForVds) {
        for (final VmNetworkInterface vmIf : vmNetworkInterfaces) {
            boolean found = false;
            for (final VdsNetworkInterface vdsIf : allInterfacesForVds) {
                if (StringUtils.equals(vmIf.getNetworkName(), vdsIf.getNetworkName())) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                log.debug(""VDS is not ok for running the VM as network is missing"");
                return false;
            }
        }
        return true;
    }
","    boolean areRequiredNetworksAvailable(final List<VmNetworkInterface> vmNetworkInterfaces,
            final List<VdsNetworkInterface> allInterfacesForVds) {
        for (final VmNetworkInterface vmIf : vmNetworkInterfaces) {
            boolean found = false;
            for (final VdsNetworkInterface vdsIf : allInterfacesForVds) {
                if (StringUtils.equals(vmIf.getNetworkName(), vdsIf.getNetworkName())) {
                    found = true;
                    break;
                }
            }
            if (!found) {
START                 log.debug(""VDS is not ok for running the VM as network is missing""); END 
                return false;
            }
        }
        return true;
    }
","    boolean areRequiredNetworksAvailable(final List<VmNetworkInterface> vmNetworkInterfaces,
            final List<VdsNetworkInterface> allInterfacesForVds) {
        for (final VmNetworkInterface vmIf : vmNetworkInterfaces) {
            boolean found = false;
            for (final VdsNetworkInterface vdsIf : allInterfacesForVds) {
                if (StringUtils.equals(vmIf.getNetworkName(), vdsIf.getNetworkName())) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                return false;
            }
        }
        return true;
    }
"
1456,Never catch exceptions in test code unless you actually want to do something use. Just declare that this method throws Exception,"	public void testStash() {
		try {
			// 1) call stash create command
			git.stashCreate().call();
			readFile(""Stash Created"", git.getRepository().getWorkTree()
					+ ""/File1.txt"");

			// 2) call stash list
			git.stashList().call();
			// 3) apply stash
			git.stashApply().call();

			// 4) verify stash applied by outputting file
			readFile(""Stash Created"", git.getRepository().getWorkTree()
					+ ""/File1.txt"");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
","	public void testStash() {
		try {
			// 1) call stash create command
			git.stashCreate().call();
			readFile(""Stash Created"", git.getRepository().getWorkTree()
					+ ""/File1.txt"");

			// 2) call stash list
			git.stashList().call();
			// 3) apply stash
			git.stashApply().call();

			// 4) verify stash applied by outputting file
			readFile(""Stash Created"", git.getRepository().getWorkTree()
					+ ""/File1.txt"");
START 		} catch (Exception e) { END 
			e.printStackTrace();
		}
	}
","	public void testStash() throws Exception {
		// 1) call stash create command
		git.stashCreate().call();
		readFile(""Stash Created"", git.getRepository().getWorkTree()
				+ ""/File1.txt"");

		// 2) call stash list
		git.stashList().call();
		// 3) apply stash
		git.stashApply().call();

		// 4) verify stash applied by outputting file
		readFile(""Stash Created"", git.getRepository().getWorkTree()
				+ ""/File1.txt"");
	}
"
1457,Can we include the information from `e` in this exception message?,"  public List<WorkerInfo> getWorkerInfoList() throws UnavailableException {
    if (mSafeModeManager.isInSafeMode()) {
      throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage());
    }
    try {
      return mWorkerInfoCache.get(WORKER_INFO_CACHE_KEY);
    } catch (ExecutionException e) {
      throw new UnavailableException(""Unable to get worker info list from cache"");
    }
  }
","  public List<WorkerInfo> getWorkerInfoList() throws UnavailableException {
    if (mSafeModeManager.isInSafeMode()) {
      throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage());
    }
    try {
      return mWorkerInfoCache.get(WORKER_INFO_CACHE_KEY);
    } catch (ExecutionException e) {
START       throw new UnavailableException(""Unable to get worker info list from cache""); END 
    }
  }
","  public List<WorkerInfo> getWorkerInfoList() throws UnavailableException {
    if (mSafeModeManager.isInSafeMode()) {
      throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage());
    }
    try {
      return mWorkerInfoCache.get(WORKER_INFO_CACHE_KEY);
    } catch (ExecutionException e) {
      throw new UnavailableException(""Unable to get worker info list from cache"", e);
    }
  }
"
1458,"Rollback should be done after each test case (i.e., with an @After notation, not an @AfterClass notataion), and I think we should preserve the current behavior od tearDownTestCase().

I suggest creating a new tearDown() method for performing the rollback.","    public static void tearDownTestCase() throws Exception {
        if(dataSource != null) {
            Connection con = dataSource.getConnection();
            if(con != null) {
                // rollback any changes done to DB during the test case execution
                con.rollback();
            }
        }
    }
","    public static void tearDownTestCase() throws Exception {
        if(dataSource != null) {
            Connection con = dataSource.getConnection();
            if(con != null) {
                // rollback any changes done to DB during the test case execution
START                 con.rollback(); END 
            }
        }
    }
","    public static void tearDownTestCase() throws Exception {
    }
"
1459,Why do we have equality check here? it should have been done by the equals.,"    public void checkSelectFilter(final String label,
                                  final String value) {
        selectInputs.computeIfPresent(label,
                                      (key, values) -> {
                                          values.forEach(i -> {
                                              if ((i.getValue().equals(value) || i.getValue() == value) && i.getChecked() == false) {
                                                  i.setChecked(true);
                                              }
                                          });
                                          return values;
                                      });
    }
","    public void checkSelectFilter(final String label,
                                  final String value) {
        selectInputs.computeIfPresent(label,
                                      (key, values) -> {
                                          values.forEach(i -> {
START                                               if ((i.getValue().equals(value) || i.getValue() == value) && i.getChecked() == false) { END 
                                                  i.setChecked(true);
                                              }
                                          });
                                          return values;
                                      });
    }
","    public void checkSelectFilter(final String label,
                                  final String value) {
        selectInputs.computeIfPresent(label,
                                      (key, values) -> {
                                          values.forEach(i -> {
                                              if (i.getValue().equals(value) && i.getChecked() == false) {
                                                  i.setChecked(true);
                                              }
                                          });
                                          return values;
                                      });
    }
"
1460,needed?,"    public ColdMergeVDSCommandParameters(Guid storageJobId, SubchainInfo subchainInfo) {
        super();
        this.storageJobId = storageJobId;
        this.subchainInfo = subchainInfo;
    }
","    public ColdMergeVDSCommandParameters(Guid storageJobId, SubchainInfo subchainInfo) {
START         super(); END 
        this.storageJobId = storageJobId;
        this.subchainInfo = subchainInfo;
    }
","    public ColdMergeVDSCommandParameters(Guid storageJobId, SubchainInfo subchainInfo) {
        this.storageJobId = storageJobId;
        this.subchainInfo = subchainInfo;
    }
"
1461,"I think we don't need to check this, as we know that the resize will not result in the threshold being exceeded.","	private void putResize (K key, V value) {
		K[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		for (int i = place(key); ; i = (i + 1) & mask) {
			// space is available so we insert and break (resize is later)
			if (keyTable[i] == null) {
				keyTable[i] = key;
				valueTable[i] = value;
				break;
			}
		}
		if (++size >= threshold) {
			resize(keyTable.length << 1);
		}
	}
","	private void putResize (K key, V value) {
		K[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		for (int i = place(key); ; i = (i + 1) & mask) {
			// space is available so we insert and break (resize is later)
			if (keyTable[i] == null) {
				keyTable[i] = key;
				valueTable[i] = value;
				break;
			}
		}
START 		if (++size >= threshold) { END 
			resize(keyTable.length << 1);
		}
	}
","	private void putResize (K key, V value) {
		K[] keyTable = this.keyTable;
		V[] valueTable = this.valueTable;
		for (int i = place(key); ; i = (i + 1) & mask) {
			// space is available so we insert and break
			if (keyTable[i] == null) {
				keyTable[i] = key;
				valueTable[i] = value;
				break;
			}
		}
		++size;
	}
"
1462,"This isn't canModifyData.  I think you've overloaded the variable for too many meanings.  What we need is:

* canModifyDescription
* canModifyMergeType
* canModifyAgreements
* canModifyAccess

The first 3 are true only if projectControl.isOwner() is true.  The last one is true if projectControl.isOwnerAnyRef() is true, and is what you want to be using here for addPanel.","  protected void onLoad() {
    enableForm(false);
    super.onLoad();

    Util.PROJECT_SVC.projectDetail(projectName,
        new GerritCallback<ProjectDetail>() {
          public void onSuccess(final ProjectDetail result) {
            enableForm(true);
            display(result);

            addPanel.setVisible(result.canModifyData);
            delRight.setVisible(result.canModifyData);
            }
        });
  }
","  protected void onLoad() {
    enableForm(false);
    super.onLoad();

    Util.PROJECT_SVC.projectDetail(projectName,
        new GerritCallback<ProjectDetail>() {
          public void onSuccess(final ProjectDetail result) {
            enableForm(true);
            display(result);

START             addPanel.setVisible(result.canModifyData); END 
            delRight.setVisible(result.canModifyData);
            }
        });
  }
","  protected void onLoad() {
    enableForm(false);
    super.onLoad();

    Util.PROJECT_SVC.projectDetail(projectName,
        new GerritCallback<ProjectDetail>() {
          public void onSuccess(final ProjectDetail result) {
            enableForm(true);
            display(result);
          }
        });
  }
"
1463,Why not use `EncodeFormat.valueOf`,"    public static EncodeFormat checkedValueOf(String name) {
        try {
            return Enum.valueOf(EncodeFormat.class, name);
        }
        catch (Exception ex) {
            VoltDB.crashLocalVoltDB(""Illegal encoding format "" + name, true, ex);
        }
        return null;
    }
","    public static EncodeFormat checkedValueOf(String name) {
        try {
START             return Enum.valueOf(EncodeFormat.class, name); END 
        }
        catch (Exception ex) {
            VoltDB.crashLocalVoltDB(""Illegal encoding format "" + name, true, ex);
        }
        return null;
    }
","    public static EncodeFormat checkedValueOf(String name) {
        try {
            return valueOf(EncodeFormat.class, name);
        }
        catch (Exception ex) {
            VoltDB.crashLocalVoltDB(""Illegal encoding format "" + name, true, ex);
        }
        return null;
    }
"
1464,Minor: there is a shortcut `toObject()` method for doing the deserialization in this class and in `DefaultQueryCache`. Maybe that should be used to be consistent at all places.,"    public Set<K> keySet(Predicate predicate) {
        checkNotNull(predicate, ""Predicate cannot be null!"");

        Set<K> resultingSet = new HashSet<K>();

        Set<QueryableEntry> query = indexes.query(predicate);
        if (query != null) {
            for (QueryableEntry entry : query) {
                K key = (K) serializationService.toObject(entry.getKeyData());
                resultingSet.add(key);
            }
        } else {
            doFullKeyScan(predicate, resultingSet);
        }

        return resultingSet;
    }
","    public Set<K> keySet(Predicate predicate) {
        checkNotNull(predicate, ""Predicate cannot be null!"");

        Set<K> resultingSet = new HashSet<K>();

        Set<QueryableEntry> query = indexes.query(predicate);
        if (query != null) {
            for (QueryableEntry entry : query) {
START                 K key = (K) serializationService.toObject(entry.getKeyData()); END 
                resultingSet.add(key);
            }
        } else {
            doFullKeyScan(predicate, resultingSet);
        }

        return resultingSet;
    }
","    public Set<K> keySet(Predicate predicate) {
        checkNotNull(predicate, ""Predicate cannot be null!"");

        Set<K> resultingSet = new HashSet<K>();

        Set<QueryableEntry> query = indexes.query(predicate);
        if (query != null) {
            for (QueryableEntry entry : query) {
                K key = toObject(entry.getKeyData());
                resultingSet.add(key);
            }
        } else {
            doFullKeyScan(predicate, resultingSet);
        }

        return resultingSet;
    }
"
1465,"also a tiny thing, but sometimes you miss a whitespace after the `->`","	public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound() throws Exception {
		ClassWithBadGetter oo = new ClassWithBadGetter();
		oo.setMyLocations(new HashSet<>());
		Assertions.assertThrows(APIException.class,() ->RequiredDataAdvice.getChildCollection(oo, ClassWithBadGetter.class.getDeclaredField(""locations"")));
	}
","	public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound() throws Exception {
		ClassWithBadGetter oo = new ClassWithBadGetter();
		oo.setMyLocations(new HashSet<>());
START 		Assertions.assertThrows(APIException.class,() ->RequiredDataAdvice.getChildCollection(oo, ClassWithBadGetter.class.getDeclaredField(""locations""))); END 
	}
","	public void getChildCollection_shouldThrowAPIExceptionIfGetterMethodNotFound() throws Exception {
		ClassWithBadGetter oo = new ClassWithBadGetter();
		oo.setMyLocations(new HashSet<>());
		RequiredDataAdvice.getChildCollection(oo, ClassWithBadGetter.class.getDeclaredField(""locations""));
	}
"
1466,This should be declared in GerritGlobalModule.,"    protected void configure() {
      DynamicSet.setOf(binder(), CacheRemovalListener.class);

      install(new FactoryModule() {
        @Override
        protected void configure() {
          factory(ForwardingRemovalListener.Factory.class);
        }
      });

      bind(DefaultCacheFactory.class);
      bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class);
      bind(PersistentCacheFactory.class).to(H2CacheFactory.class);
      listener().to(H2CacheFactory.class);
    }
","    protected void configure() {
START       DynamicSet.setOf(binder(), CacheRemovalListener.class); END 

      install(new FactoryModule() {
        @Override
        protected void configure() {
          factory(ForwardingRemovalListener.Factory.class);
        }
      });

      bind(DefaultCacheFactory.class);
      bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class);
      bind(PersistentCacheFactory.class).to(H2CacheFactory.class);
      listener().to(H2CacheFactory.class);
    }
","    protected void configure() {
      install(new FactoryModule() {
        @Override
        protected void configure() {
          factory(ForwardingRemovalListener.Factory.class);
        }
      });

      bind(DefaultCacheFactory.class);
      bind(MemoryCacheFactory.class).to(DefaultCacheFactory.class);
      bind(PersistentCacheFactory.class).to(H2CacheFactory.class);
      listener().to(H2CacheFactory.class);
    }
"
1467,"This doesn't seem right: we're building `disabledImage` from `image`, so we need to check that `image` has not been disabled.  I think something like the following?

   if (this.image != null && !this.image.isDisposed()) {
      if (this.disabledImage != null && !this.disabledImage.isDisposed()) {
         this.disabledImage.dispose();
      }
      disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE);
   }","	private void createDisabledImage() {
		if (this.disabledImage != null && !this.disabledImage.isDisposed())
			disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE);
	}
","	private void createDisabledImage() {
START 		if (this.disabledImage != null && !this.disabledImage.isDisposed()) END 
			disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE);
	}
","	private void createDisabledImage() {
		// Only create a new disabledImage when the disabledImage==null or
		// disposed to avoid a GDI Handler leak See Bug 486531
		if (this.disabledImage == null || this.disabledImage.isDisposed())
			if (this.image != null && !this.image.isDisposed())
			disabledImage = new Image(this.image.getDevice(), this.image, SWT.IMAGE_DISABLE);
	}
"
1468,Should probably be sample.clear().,"    public synchronized void releaseSample(DecoderInputBuffer sample) {
        sample.data.clear();
        mSamplePool.offerLast(sample);
    }
","    public synchronized void releaseSample(DecoderInputBuffer sample) {
        START  sample.data.clear(); END 
        mSamplePool.offerLast(sample);
    }
","    public synchronized void releaseSample(DecoderInputBuffer sample) {
        sample.clear();
        mSamplePool.offerLast(sample);
    }
"
1469,"Looks like this builder just concatenate 3 strings without any loops. I guess, it is unnecessary here.","    private String buildClipboardMessage(Row row) {
        StringBuilder builder = new StringBuilder();
        builder.append(row.getLevel())
                .append("", "")
                .append(row.getMessage());
        return builder.toString();
    }
","    private String buildClipboardMessage(Row row) {
START         StringBuilder builder = new StringBuilder(); END 
        builder.append(row.getLevel())
                .append("", "")
                .append(row.getMessage());
        return builder.toString();
    }
","    private String buildClipboardMessage(Row row) {
        return row.getLevel() + "", "" + row.getMessage();
    }
"
1470,"Since a Tombstone is no longer in the hierarchy (result of removing the proxy), this method should probably either return a null or throw an exception","    public RepositoryObject getParent() {
        return driver.getParentObject(this);
    }
","START     public RepositoryObject getParent() { END 
        return driver.getParentObject(this);
    }
","    public RepositoryObject getParent() {
        // tombstone is not in the hierarchy, so doesn't have a parent
        return null;
    }
"
1471,"no braces here, more occurrences in this file","	private void setLastUsedBranch() {
		String lastBranch = settings.get(lastBranchKey);
		if (lastBranch != null) {
			branchText.setText(lastBranch);
		}
	}
","	private void setLastUsedBranch() {
		String lastBranch = settings.get(lastBranchKey);
START 		if (lastBranch != null) { END 
			branchText.setText(lastBranch);
		}
	}
","	private void setLastUsedBranch() {
		String lastBranch = settings.get(lastBranchKey);
		if (lastBranch != null)
			branchText.setText(lastBranch);
	}
"
1472,`this` is not needed?,"    public String toString()
    {
        return toStringHelper(this)
                .omitNullValues()
                .add(""equiCriteria"", this.equiCriteria)
                .add(""filter"", filter.orElse(null))
                .toString();
    }
","    public String toString()
    {
        return toStringHelper(this)
                .omitNullValues()
START                 .add(""equiCriteria"", this.equiCriteria) END 
                .add(""filter"", filter.orElse(null))
                .toString();
    }
","    public String toString()
    {
        return toStringHelper(this)
                .omitNullValues()
                .add(""equiCriteria"", equiCriteria)
                .add(""filter"", filter.orElse(null))
                .toString();
    }
"
1473,Seems more appropriately `logger.warn`.,"    private void validateKeyPatternsInConfig(Dictionary<String, ?> config) {

        Enumeration<String> keys = config.keys();
        while (keys.hasMoreElements()) {

            String key = keys.nextElement();

            // the config-key enumeration contains additional keys that we
            // don't want to process here ...
            if (""service.pid"".equals(key)) {
                continue;
            }

            Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN.matcher(key);
            if (!matcher.matches()) {
                logger.error(""Given plugwise-config-key '"" + key
                        + ""' does not follow the expected pattern '<PlugwiseId>.<mac|type|port|interval>'"");
                continue;
            }
        }

    }
","    private void validateKeyPatternsInConfig(Dictionary<String, ?> config) {

        Enumeration<String> keys = config.keys();
        while (keys.hasMoreElements()) {

            String key = keys.nextElement();

            // the config-key enumeration contains additional keys that we
            // don't want to process here ...
            if (""service.pid"".equals(key)) {
                continue;
            }

            Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN.matcher(key);
            if (!matcher.matches()) {
                logger.error(""Given plugwise-config-key '"" + key
START                         + ""' does not follow the expected pattern '<PlugwiseId>.<mac|type|port|interval>'""); END 
                continue;
            }
        }

    }
","    private void validateKeyPatternsInConfig(Dictionary<String, ?> config) {

        Enumeration<String> keys = config.keys();
        while (keys.hasMoreElements()) {

            String key = keys.nextElement();

            // the config-key enumeration contains additional keys that we
            // don't want to process here ...
            if (""service.pid"".equals(key)) {
                continue;
            }

            Matcher matcher = EXTRACT_PLUGWISE_CONFIG_PATTERN.matcher(key);
            if (!matcher.matches()) {
                logger.warn(""Given plugwise-config-key '"" + key
                        + ""' does not follow the expected pattern '<PlugwiseId>.<mac|type|port|interval>'"");
                continue;
            }
        }

    }
"
1474,"`GraphvizPrinter` (and all other plan printer) should not expect an `Expression`. Rather than having `isExpression` here, let's fix the tests if they are failing.","        public Void visitFilter(FilterNode node, Void context)
        {
            String expression = isExpression(node.getPredicate()) ? node.getPredicate().toString() : formatter.formatRowExpression(node.getPredicate());
            printNode(node, ""Filter"", expression, NODE_COLORS.get(NodeType.FILTER));
            return node.getSource().accept(this, context);
        }
","        public Void visitFilter(FilterNode node, Void context)
        {
START             String expression = isExpression(node.getPredicate()) ? node.getPredicate().toString() : formatter.formatRowExpression(node.getPredicate()); END 
            printNode(node, ""Filter"", expression, NODE_COLORS.get(NodeType.FILTER));
            return node.getSource().accept(this, context);
        }
","        public Void visitFilter(FilterNode node, Void context)
        {
            String expression = formatter.formatRowExpression(node.getPredicate());
            printNode(node, ""Filter"", expression, NODE_COLORS.get(NodeType.FILTER));
            return node.getSource().accept(this, context);
        }
"
1475,"Move this line after logging the error, so in any case the error get logged.","        public void run() {
            resetGlobalProgress();
            indexingAll = true;

            for (ObjectType objectType : ObjectType.values()) {
                startIndexing(objectType);
            }

            try {
                sleep(pause);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                logger.error(""Thread interrupted: "" + e.getMessage());
            }

            currentIndexState = ObjectType.NONE;
            indexingAll = false;

            pollingChannel.send(INDEXING_FINISHED_MESSAGE);
        }
","        public void run() {
            resetGlobalProgress();
            indexingAll = true;

            for (ObjectType objectType : ObjectType.values()) {
                startIndexing(objectType);
            }

            try {
                sleep(pause);
            } catch (InterruptedException e) {
START                 Thread.currentThread().interrupt(); END 
                logger.error(""Thread interrupted: "" + e.getMessage());
            }

            currentIndexState = ObjectType.NONE;
            indexingAll = false;

            pollingChannel.send(INDEXING_FINISHED_MESSAGE);
        }
","        public void run() {
            resetGlobalProgress();
            indexingAll = true;

            for (ObjectType objectType : ObjectType.values()) {
                startIndexing(objectType);
            }

            try {
                sleep(pause);
            } catch (InterruptedException e) {
                logger.error(""Thread interrupted: "" + e.getMessage());
                Thread.currentThread().interrupt();
            }

            currentIndexState = ObjectType.NONE;
            indexingAll = false;

            pollingChannel.send(INDEXING_FINISHED_MESSAGE);
        }
"
1476,"`return getCodecA() != null && (""ac3"".equals(getCodecA()) || ""a52"".contains(getCodecA()));`","	public boolean isAC3() {
		return getCodecA() != null && (""ac3"".equals(getCodecA()) || ""a52"".equals(getCodecA()) || ""liba52"".equals(getCodecA()));
	}
","	public boolean isAC3() {
START 		return getCodecA() != null && (""ac3"".equals(getCodecA()) || ""a52"".equals(getCodecA()) || ""liba52"".equals(getCodecA())); END 
	}
","	public boolean isAC3() {
		return getCodecA() != null && (""ac3"".equals(getCodecA()) || getCodecA().contains(""a52""));
	}
"
1477,redundant,"    ShardRewriter createShardRewriter(
            FileSystemContext fileSystemContext,
            FileSystem fileSystem,
            long transactionId,
            OptionalInt bucketNumber,
            UUID shardUuid,
            int shardRowCount,
            Optional<UUID> deltaShardUuid,
            boolean tableSupportsDeltaDelete,
            Map<String, Type> columns)
    {
        if (tableSupportsDeltaDelete) {
            return new DeltaShardRewriter(
                    shardUuid,
                    shardRowCount,
                    deltaShardUuid,
                    deletionExecutor,
                    transactionId,
                    bucketNumber,
                    this,
                    fileSystemContext,
                    fileSystem);
        }
        else {
            return new InplaceShardRewriter(
                    shardUuid,
                    columns,
                    deletionExecutor,
                    transactionId,
                    bucketNumber,
                    nodeId,
                    this,
                    fileSystem,
                    storageService,
                    shardRecorder,
                    backupManager);
        }
    }
","    ShardRewriter createShardRewriter(
            FileSystemContext fileSystemContext,
            FileSystem fileSystem,
            long transactionId,
            OptionalInt bucketNumber,
            UUID shardUuid,
            int shardRowCount,
            Optional<UUID> deltaShardUuid,
            boolean tableSupportsDeltaDelete,
            Map<String, Type> columns)
    {
        if (tableSupportsDeltaDelete) {
            return new DeltaShardRewriter(
                    shardUuid,
                    shardRowCount,
                    deltaShardUuid,
                    deletionExecutor,
                    transactionId,
                    bucketNumber,
                    this,
                    fileSystemContext,
                    fileSystem);
        }
START         else { END 
            return new InplaceShardRewriter(
                    shardUuid,
                    columns,
                    deletionExecutor,
                    transactionId,
                    bucketNumber,
                    nodeId,
                    this,
                    fileSystem,
                    storageService,
                    shardRecorder,
                    backupManager);
        }
    }
","    ShardRewriter createShardRewriter(
            FileSystemContext fileSystemContext,
            FileSystem fileSystem,
            long transactionId,
            OptionalInt bucketNumber,
            UUID shardUuid,
            int shardRowCount,
            Optional<UUID> deltaShardUuid,
            boolean tableSupportsDeltaDelete,
            Map<String, Type> columns)
    {
        if (tableSupportsDeltaDelete) {
            return new DeltaShardRewriter(
                    shardUuid,
                    shardRowCount,
                    deltaShardUuid,
                    deletionExecutor,
                    transactionId,
                    bucketNumber,
                    this,
                    fileSystemContext,
                    fileSystem);
        }
        return new InplaceShardRewriter(
                shardUuid,
                columns,
                deletionExecutor,
                transactionId,
                bucketNumber,
                nodeId,
                this,
                fileSystem,
                storageService,
                shardRecorder,
                backupManager);
    }
"
1478,TEXT datatype would be more appropriate.,"	public void init()
	{
		setLabel(""Plugin"");

		addAttribute(ID, ROLE_ID).setLabel(""Identifier"");
		addAttribute(LABEL, ROLE_LABEL, ROLE_LOOKUP).setNillable(false).setUnique(true).setLabel(""Label"");
		addAttribute(DESCRIPTION, ROLE_LOOKUP).setLabel(""Description"").setDataType(HTML);
	}
","	public void init()
	{
		setLabel(""Plugin"");

		addAttribute(ID, ROLE_ID).setLabel(""Identifier"");
		addAttribute(LABEL, ROLE_LABEL, ROLE_LOOKUP).setNillable(false).setUnique(true).setLabel(""Label"");
START 		addAttribute(DESCRIPTION, ROLE_LOOKUP).setLabel(""Description"").setDataType(HTML); END 
	}
","	public void init()
	{
		setLabel(""Plugin"");

		addAttribute(ID, ROLE_ID).setLabel(""Identifier"");
		addAttribute(LABEL, ROLE_LABEL, ROLE_LOOKUP).setNillable(false).setUnique(true).setLabel(""Label"");
		addAttribute(DESCRIPTION, ROLE_LOOKUP).setLabel(""Description"");
	}
"
1479,Space between IOException and {,"    @Override public Long call() throws IOException{

      String oldname = Thread.currentThread().getName();
      Thread.currentThread().setName(oldname+""Decode-""+this.parent.columnChunkMetaData.toString());

      this.parent.processPages(recordsToReadInThisPass);

      Thread.currentThread().setName(oldname);
      return recordsToReadInThisPass;
    }
","START     @Override public Long call() throws IOException{ END 

      String oldname = Thread.currentThread().getName();
      Thread.currentThread().setName(oldname+""Decode-""+this.parent.columnChunkMetaData.toString());

      this.parent.processPages(recordsToReadInThisPass);

      Thread.currentThread().setName(oldname);
      return recordsToReadInThisPass;
    }
","    @Override public Long call() throws IOException{

      String oldname = Thread.currentThread().getName();
      try {
        Thread.currentThread().setName(oldname + ""Decode-"" + this.parent.columnChunkMetaData.toString());

        this.parent.processPages(recordsToReadInThisPass);
        return recordsToReadInThisPass;

      } finally {
        Thread.currentThread().setName(oldname);
      }
    }
"
1480,"Does additional list creation (`new ArrayList<>()`) provide any benefits when compared with the following?
```java
this.collectors = asList(collectors);
```","    public CompositeMetricsCollector(MetricsCollector... collectors) {
        this.collectors = new ArrayList<>(asList(collectors));
    }
","    public CompositeMetricsCollector(MetricsCollector... collectors) {
START         this.collectors = new ArrayList<>(asList(collectors)); END 
    }
","    public CompositeMetricsCollector(MetricsCollector... collectors) {
        this.collectors = asList(collectors);
    }
"
1481,to nitpick: just use `this` instead of the application.,"  @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
      @NonNull int[] grantResults) {
    if (requestCode == REQUEST_READ_CONTACTS) {
      if (grantResults.length > 0
          && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
        loadContacts();
      } else {
        Toast.makeText(getApplicationContext(), ""Read contacts permission denied"",
            Toast.LENGTH_LONG).show();
        finish();
      }
    } else {
      super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    }
  }
","  @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
      @NonNull int[] grantResults) {
    if (requestCode == REQUEST_READ_CONTACTS) {
      if (grantResults.length > 0
          && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
        loadContacts();
      } else {
START         Toast.makeText(getApplicationContext(), ""Read contacts permission denied"", END 
            Toast.LENGTH_LONG).show();
        finish();
      }
    } else {
      super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    }
  }
","  @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,
      @NonNull int[] grantResults) {
    if (requestCode == REQUEST_READ_CONTACTS) {
      if (grantResults.length > 0
          && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
        loadContacts();
      } else {
        Toast.makeText(this, ""Read contacts permission denied"", Toast.LENGTH_LONG).show();
        finish();
      }
    } else {
      super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    }
  }
"
1482,"I must be missing something. Why not simply

  buffer.append(""body {color:"");
  appendColor(buffer, fgRGB);
  buffer.append(""; background-color:"");
  appendColor(buffer, bgRGB);
  buffer.append("";}"");

?","	private static void appendBodyColorsRule(StringBuilder buffer, RGB fgRGB, RGB bgRGB) {
		StringBuilder fg= new StringBuilder();
		appendColor(fg, fgRGB);
		StringBuilder bg= new StringBuilder();
		appendColor(bg, bgRGB);
		buffer.append(""body {color:"" + fg.toString() + ""; background-color:"" + bg.toString() + "";}""); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
	}
","	private static void appendBodyColorsRule(StringBuilder buffer, RGB fgRGB, RGB bgRGB) {
		StringBuilder fg= new StringBuilder();
		appendColor(fg, fgRGB);
		StringBuilder bg= new StringBuilder();
		appendColor(bg, bgRGB);
START 		buffer.append(""body {color:"" + fg.toString() + ""; background-color:"" + bg.toString() + "";}""); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ END 
	}
","	private static void appendBodyColorsRule(StringBuilder buffer, RGB fgRGB, RGB bgRGB) {
		StringBuilder fg= new StringBuilder();
		appendColor(fg, fgRGB);
		StringBuilder bg= new StringBuilder();
		appendColor(bg, bgRGB);

		buffer.append(""body {color:""); //$NON-NLS-1$
		appendColor(buffer, fgRGB);
		buffer.append(""; background-color:""); //$NON-NLS-1$
		appendColor(buffer, bgRGB);
		buffer.append("";}""); //$NON-NLS-1$
	}
"
1483,what .... synchronized access to the VoltDB instance not cool. it has transaction performance impact if you want to initialize without invoking the full thing we can do that without having to resource to this,"    public static synchronized VoltDBInterface instance() {
        if (singleton == null) {
            singleton = new RealVoltDB();
        }
        return singleton;
    }
","START     public static synchronized VoltDBInterface instance() { END 
        if (singleton == null) {
            singleton = new RealVoltDB();
        }
        return singleton;
    }
","    public static VoltDBInterface instance() {
        return singleton;
    }
"
1484,You can simplify this by reordering the states.,"    public int getRenderState() {
        int state = speed.ordinal();
        if (getReverse())
        	state = 14;
        if (isPowered()) {
            if (getReverse())
            	state += 1;
            else
            	state += 7;
    	}
        return state;
    }
","    public int getRenderState() {
        int state = speed.ordinal();
        if (getReverse())
        	state = 14;
        if (isPowered()) {
            if (getReverse())
            	state += 1;
            else
            	state += 7;
START     	} END 
        return state;
    }
","    public int getRenderState() {
        int state = speed.ordinal();
        if (getReverse())
        	state = 4;
        if (isPowered())
        	state += 5;
        return state;
    }
"
1485,Den cast auf (Errors) ist hier überflüssig.,"    public void ensureSettingsSavedShowsFormIfValidationFails() throws Exception {

        doAnswer(invocation -> {

            Errors errors = (Errors) invocation.getArgument(1);
            errors.rejectValue(""absenceSettings"", ""error"");
            return null;
        }).when(settingsValidator).validate(any(), any());

        perform(post(""/web/settings""))
            .andExpect(view().name(""settings/settings_form""));
    }
","    public void ensureSettingsSavedShowsFormIfValidationFails() throws Exception {

        doAnswer(invocation -> {

START             Errors errors = (Errors) invocation.getArgument(1); END 
            errors.rejectValue(""absenceSettings"", ""error"");
            return null;
        }).when(settingsValidator).validate(any(), any());

        perform(post(""/web/settings""))
            .andExpect(view().name(""settings/settings_form""));
    }
","    public void ensureSettingsSavedShowsFormIfValidationFails() throws Exception {

        doAnswer(invocation -> {

            Errors errors = invocation.getArgument(1);
            errors.rejectValue(""absenceSettings"", ""error"");
            return null;
        }).when(settingsValidator).validate(any(), any());

        perform(post(""/web/settings""))
            .andExpect(view().name(""settings/settings_form""));
    }
"
1486,"I know this is not directly part of this PR, but this could be changed to `new StringBuilder(iOSVariant.getVariantID())` to avoid one useless `append` (the `StringBuilder()` constructor create StringBuilder with capacity 16, that we immediately expand with the next append)","    private String extractConnectionKey(final iOSVariant iOSVariant) {
        final StringBuilder sb = new StringBuilder()
                .append(iOSVariant.getVariantID())
                .append(iOSVariant.isProduction() ? ""-prod"" : ""-dev"");

        return sb.toString();
    }
","    private String extractConnectionKey(final iOSVariant iOSVariant) {
        final StringBuilder sb = new StringBuilder()
START                 .append(iOSVariant.getVariantID()) END 
                .append(iOSVariant.isProduction() ? ""-prod"" : ""-dev"");

        return sb.toString();
    }
","    private String extractConnectionKey(final iOSVariant iOSVariant) {
        final StringBuilder sb = new StringBuilder(iOSVariant.getVariantID())
                .append(iOSVariant.isProduction() ? ""-prod"" : ""-dev"");

        return sb.toString();
    }
"
1487,Use logger instead for sysout for logging.,"	public void printCertificates() {
		DefaultTable table = new DefaultTable();
		for (int i = 0; i < table.rowCount(); i++) {
			System.out.println(""On index "" + i + "" is : "" + table.getItem(i).getText(1));
		}
	}
","	public void printCertificates() {
		DefaultTable table = new DefaultTable();
		for (int i = 0; i < table.rowCount(); i++) {
START 			System.out.println(""On index "" + i + "" is : "" + table.getItem(i).getText(1)); END 
		}
	}
","	public void printCertificates() {
		DefaultTable table = new DefaultTable();
		for (int i = 0; i < table.rowCount(); i++) {
			log.info(""On index "" + i + "" is : "" + table.getItem(i).getText(1));
		}
	}
"
1488,can we revert back to using `LockMode.X` instead of `LockResource.LockMode.X`?,"  public void lockEdge() throws Exception {
    edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.READ, true);
    edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.WRITE, true);
    edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.WRITE, true);
    edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.READ, false);
  }
","  public void lockEdge() throws Exception {
    edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.READ, true);
    edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.WRITE, true);
    edgeLockTest(LockResource.LockMode.WRITE, LockResource.LockMode.WRITE, true);
START     edgeLockTest(LockResource.LockMode.READ, LockResource.LockMode.READ, false); END 
  }
","  public void lockEdge() throws Exception {
    edgeLockTest(LockMode.WRITE, LockMode.READ, true);
    edgeLockTest(LockMode.READ, LockMode.WRITE, true);
    edgeLockTest(LockMode.WRITE, LockMode.WRITE, true);
    edgeLockTest(LockMode.READ, LockMode.READ, false);
  }
"
1489,"cast to busimpl should not be needed. getClientId is on the ClientMessageBus interface, no?","    private String getClientId() {
        return ( (ClientMessageBusImpl) clientMessageBus ).getClientId();
    }
","    private String getClientId() {
START         return ( (ClientMessageBusImpl) clientMessageBus ).getClientId(); END 
    }
","    String getClientId() {
        return clientMessageBus.getClientId();
    }
"
1490,Are you sure VdsInstallException is the right exception here?,"    private void configureManagementNetwork() {
        final NetworkConfigurator networkConfigurator = new NetworkConfigurator(getVds());
        if (networkConfigurator.awaitVdsmResponse()) {
            try {
                networkConfigurator.refreshNetworkConfiguration();
                networkConfigurator.createManagementNetworkIfRequired();
            } catch (VDSNetworkException e) {
                throw new VdsInstallException(VDSStatus.NonResponsive,
                        ""Network error during communication with the host"");
            } catch (VdsInstallException e) {
                throw new VdsInstallException(VDSStatus.NonOperational,
                        ""Failed to configure manamgent network on the host"");
            }
        } else {
            throw new VdsInstallException(VDSStatus.NonResponsive,
                    ""Network error during communication with the host"");
        }
    }
","    private void configureManagementNetwork() {
        final NetworkConfigurator networkConfigurator = new NetworkConfigurator(getVds());
        if (networkConfigurator.awaitVdsmResponse()) {
            try {
                networkConfigurator.refreshNetworkConfiguration();
                networkConfigurator.createManagementNetworkIfRequired();
            } catch (VDSNetworkException e) {
                throw new VdsInstallException(VDSStatus.NonResponsive,
                        ""Network error during communication with the host"");
START             } catch (VdsInstallException e) { END 
                throw new VdsInstallException(VDSStatus.NonOperational,
                        ""Failed to configure manamgent network on the host"");
            }
        } else {
            throw new VdsInstallException(VDSStatus.NonResponsive,
                    ""Network error during communication with the host"");
        }
    }
","    private void configureManagementNetwork() {
        final NetworkConfigurator networkConfigurator = new NetworkConfigurator(getVds());
        if (!networkConfigurator.awaitVdsmResponse()) {
            throw new VdsInstallException(VDSStatus.NonResponsive,
                    ""Network error during communication with the host"");
        }

        try {
            networkConfigurator.refreshNetworkConfiguration();
            networkConfigurator.createManagementNetworkIfRequired();
        } catch (VDSNetworkException e) {
            throw new VdsInstallException(VDSStatus.NonResponsive,
                    ""Network error during communication with the host"", e);
        } catch (Exception e) {
            throw new VdsInstallException(VDSStatus.NonOperational,
                    ""Failed to configure manamgent network on the host"", e);
        }
    }
"
1491,"I think you forgot to change this to -
`return newResetResponse(header, newNoServerError());`","    public static Response newResetResponse(Header header) {
        return newRestartResponse(header, newNoServerError());
    }
","START     public static Response newResetResponse(Header header) {
        return newRestartResponse(header, newNoServerError());
    } END 
","    public static Response newResetResponse(Header header) {
        return newResetResponse(header, newNoServerError());
    }
"
1492,Why does this need to be `static`?,"    private static Optional<TimeValue> getTimeValue(Optional<TimeValue> primaryValue, Optional<TimeValue> safetyValue) {
        if (!primaryValue.isPresent()) {
            return safetyValue;
        }
        return primaryValue;
    }
","START     private static Optional<TimeValue> getTimeValue(Optional<TimeValue> primaryValue, Optional<TimeValue> safetyValue) { END 
        if (!primaryValue.isPresent()) {
            return safetyValue;
        }
        return primaryValue;
    }
","    private Optional<TimeValue> getTimeValue(Optional<TimeValue> primaryValue, Optional<TimeValue> safetyValue) {
        if (!primaryValue.isPresent()) {
            return safetyValue;
        }
        return primaryValue;
    }
"
1493,"This should be a constant, not a magic string.","        public Uris(String scheme, String host) {
            this.scheme = scheme;
            this.host = host;
            this.port = 0;
            this.rcnamespace = ""0|120"";
        }
","        public Uris(String scheme, String host) {
            this.scheme = scheme;
            this.host = host;
            this.port = 0;
START             this.rcnamespace = ""0|120""; END 
        }
","        public Uris(String scheme, String host) {
            this.scheme = scheme;
            this.host = host;
            this.port = 0;
        }
"
1494,can change the order to save a temp variable s.,"	private void carryOntoHistory(RevCommit c, int carry) {
		stack = null;
		for (;;) {
			carryOntoHistoryInnerLoop(c, carry);
			CarryStack s = stack;
			if (s != null) {
				stack = s.prev;
				c = s.c;
				carry = s.carry;
				continue;
			}
			break;
		}
	}
","	private void carryOntoHistory(RevCommit c, int carry) {
		stack = null;
		for (;;) {
			carryOntoHistoryInnerLoop(c, carry);
			CarryStack s = stack;
			if (s != null) {
START 				stack = s.prev;
				c = s.c;
				carry = s.carry; END 
				continue;
			}
			break;
		}
	}
","	private void carryOntoHistory(RevCommit c, int carry) {
		stack = null;
		for (;;) {
			carryOntoHistoryInnerLoop(c, carry);
			if (stack != null) {
				c = stack.c;
				carry = stack.carry;
				stack = stack.prev;
				continue;
			}
			break;
		}
	}
"
1495,Could be just ksession.insert(String.valueOf(i));,"    private FactHandle[] insertFacts(KieSession ksession, int n) {
        FactHandle[] fhs = new FactHandle[n];
        for (int i = 0; i < n; i++) {
            fhs[i] = ksession.insert(i);
            ksession.insert("""" + String.valueOf(i));
        }

        return fhs;
    }
","    private FactHandle[] insertFacts(KieSession ksession, int n) {
        FactHandle[] fhs = new FactHandle[n];
        for (int i = 0; i < n; i++) {
            fhs[i] = ksession.insert(i);
START             ksession.insert("""" + String.valueOf(i)); END 
        }

        return fhs;
    }
","    private FactHandle[] insertFacts(KieSession ksession, int n) {
        FactHandle[] fhs = new FactHandle[n];
        for (int i = 0; i < n; i++) {
            fhs[i] = ksession.insert(i);
            ksession.insert(String.valueOf(i));
        }

        return fhs;
    }
"
1496,This will create a new instance every time. Cache the instance in a member variable?,"  public SecureStore get() {
    return injector.getInstance(getSecureStoreImpl());
  }
","  public SecureStore get() {
START     return injector.getInstance(getSecureStoreImpl()); END 
  }
","  public SecureStore get() {
    if (instance == null) {
      instance = injector.getInstance(getSecureStoreImpl());
    }
    return instance;
  }
"
1497,if (swingTransferable != null && getScoutObject() != null) {...},"  protected void handleSwingDropTargetChanged(TreePath path, Transferable swingTransferable) {
    if (getUpdateSwingFromScoutLock().isAcquired()) {
      return;
    }
    //
    if (swingTransferable != null) {
      if (getScoutObject() != null) {
        final ITreeNode scoutNode = treePathToScoutNode(path);
        // notify Scout (asynchronous !)
        Runnable t = new Runnable() {
          @Override
          public void run() {
            getScoutObject().getUIFacade().fireNodeDropTargetChangedFromUI(scoutNode);
          }
        };
        getSwingEnvironment().invokeScoutLater(t, 0);
        // end notify
      }
    }
  }
","  protected void handleSwingDropTargetChanged(TreePath path, Transferable swingTransferable) {
    if (getUpdateSwingFromScoutLock().isAcquired()) {
      return;
    }
    //
    if (swingTransferable != null) {
START       if (getScoutObject() != null) { END 
        final ITreeNode scoutNode = treePathToScoutNode(path);
        // notify Scout (asynchronous !)
        Runnable t = new Runnable() {
          @Override
          public void run() {
            getScoutObject().getUIFacade().fireNodeDropTargetChangedFromUI(scoutNode);
          }
        };
        getSwingEnvironment().invokeScoutLater(t, 0);
        // end notify
      }
    }
  }
","  protected void handleSwingDropTargetChanged(TreePath path, Transferable swingTransferable) {
    if (getUpdateSwingFromScoutLock().isAcquired()) {
      return;
    }
    //
    if (swingTransferable != null && getScoutObject() != null) {
      final ITreeNode scoutNode = treePathToScoutNode(path);
      // notify Scout (asynchronous !)
      Runnable t = new Runnable() {
        @Override
        public void run() {
          getScoutObject().getUIFacade().fireNodeDropTargetChangedFromUI(scoutNode);
        }
      };
      getSwingEnvironment().invokeScoutLater(t, 0);
      // end notify
    }
  }
"
1498,I don't see this called anywhere in the patch.  Is there a reason to make it public?,"    public void setDiskSpaceThreshold(float diskSpaceThreshold, float diskUsageWarnThreshold) {
        validateThreshold(diskSpaceThreshold, diskUsageWarnThreshold);
        this.diskUsageThreshold = diskSpaceThreshold;
        this.diskUsageWarnThreshold = diskUsageWarnThreshold;
    }
","START     public void setDiskSpaceThreshold(float diskSpaceThreshold, float diskUsageWarnThreshold) { END 
        validateThreshold(diskSpaceThreshold, diskUsageWarnThreshold);
        this.diskUsageThreshold = diskSpaceThreshold;
        this.diskUsageWarnThreshold = diskUsageWarnThreshold;
    }
","    void setDiskSpaceThreshold(float diskSpaceThreshold, float diskUsageWarnThreshold) {
        validateThreshold(diskSpaceThreshold, diskUsageWarnThreshold);
        this.diskUsageThreshold = diskSpaceThreshold;
        this.diskUsageWarnThreshold = diskUsageWarnThreshold;
    }
"
1499,not needed unboxing,"    public static void setInstance(Object source, @MappingTarget Object target) {
        Integer level = LEVEL.get();
        fireMethodCalled( level, ""setInstance"", source, target );
        if ( level == null ) {
            LEVEL.set( 1 );
            MAPPING.set( new IdentityHashMap<Object, Object>() );
        }
        else {
            LEVEL.set( level.intValue() + 1 );
        }
        MAPPING.get().put( source, target );
    }
","    public static void setInstance(Object source, @MappingTarget Object target) {
        Integer level = LEVEL.get();
        fireMethodCalled( level, ""setInstance"", source, target );
        if ( level == null ) {
            LEVEL.set( 1 );
            MAPPING.set( new IdentityHashMap<Object, Object>() );
        }
        else {
START             LEVEL.set( level.intValue() + 1 ); END 
        }
        MAPPING.get().put( source, target );
    }
","    public static void setInstance(Object source, @MappingTarget Object target) {
        Integer level = LEVEL.get();
        fireMethodCalled( level, ""setInstance"", source, target );
        if ( level == null ) {
            LEVEL.set( 1 );
            MAPPING.set( new IdentityHashMap<Object, Object>() );
        }
        else {
            LEVEL.set( level + 1 );
        }
        MAPPING.get().put( source, target );
    }
"
1500,Remove throws MiddlewareQueryException,"	public List<StandardPreset> getAllStandardPresets() throws MiddlewareQueryException {
		return this.workbenchDataManager.getStandardPresetDAO().getAll();
	}
","START 	public List<StandardPreset> getAllStandardPresets() throws MiddlewareQueryException { END 
		return this.workbenchDataManager.getStandardPresetDAO().getAll();
	}
","	public List<StandardPreset> getAllStandardPresets() {
		return this.workbenchDataManager.getStandardPresetDAO().getAll();
	}
"
1501,why did you change this?,"    protected void executeVDSCommand() {
        if (_vdsManager != null) {
            try {
                _vdsManager.getLockObj().lock();
                executeVdsIdCommand();
            } finally {
                _vdsManager.getLockObj().unlock();
            }
        } else {
            executeVdsIdCommand();
        }
    }
","    protected void executeVDSCommand() {
        if (_vdsManager != null) {
            try {
START                 _vdsManager.getLockObj().lock(); END 
                executeVdsIdCommand();
            } finally {
                _vdsManager.getLockObj().unlock();
            }
        } else {
            executeVdsIdCommand();
        }
    }
","    protected void executeVDSCommand() {
        if (_vdsManager != null) {
            synchronized (_vdsManager.getLockObj()) {
                executeVdsIdCommand();
            }
        } else {
            executeVdsIdCommand();
        }
    }
"
1502,Could you use `List#of` or `Collections#singletonList`?,"    public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt() throws IOException {
        TemplateSourceDocument templateSrc = createTemplateSourceDoc(""We are introducing ${myStringInCtxt} !"", WEBVIEW_RENDITION);
        TemplateBasedDocument templateBase = createTemplateBasedDoc(templateSrc.getAdaptedDoc());
        List<TemplateInput> params = Arrays.asList(
                factory(""myStringInCtxt"", StringValue, ""Beautiful String"")
        );
        templateBase.saveParams(TEMPLATE_NAME, params, true);

        Blob result = templateBase.renderWithTemplate(TEMPLATE_NAME);
        assertNotNull(result);
        assertEquals(""We are introducing Beautiful String !"", result.getString());
    }
","    public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt() throws IOException {
        TemplateSourceDocument templateSrc = createTemplateSourceDoc(""We are introducing ${myStringInCtxt} !"", WEBVIEW_RENDITION);
        TemplateBasedDocument templateBase = createTemplateBasedDoc(templateSrc.getAdaptedDoc());
START         List<TemplateInput> params = Arrays.asList( END 
                factory(""myStringInCtxt"", StringValue, ""Beautiful String"")
        );
        templateBase.saveParams(TEMPLATE_NAME, params, true);

        Blob result = templateBase.renderWithTemplate(TEMPLATE_NAME);
        assertNotNull(result);
        assertEquals(""We are introducing Beautiful String !"", result.getString());
    }
","    public void whenTemplateWithGivenInputTemplate_String_shouldRenderBlobAsIt() throws IOException {
        TemplateSourceDocument templateSrc = createTemplateSourceDoc(""We are introducing ${myStringInCtxt} !"", WEBVIEW_RENDITION);
        TemplateBasedDocument templateBase = createTemplateBasedDoc(templateSrc.getAdaptedDoc());
        List<TemplateInput> params = List.of(
                factory(""myStringInCtxt"", StringValue, ""Beautiful String"")
        );
        templateBase.saveParams(TEMPLATE_NAME, params, true);

        Blob result = templateBase.renderWithTemplate(TEMPLATE_NAME);
        assertNotNull(result);
        assertEquals(""We are introducing Beautiful String !"", result.getString());
    }
"
1503,Wonder if this would work/read better if PDPrintStyle had the default values itself and we could just return early instead of creating new objects to make the rest of the code work properly.,"    public static PDPrintStyle getLineStyle (JSONObject oskariStyle) {
        PDPrintStyle style = new PDPrintStyle();
        JSONObject stroke = JSONHelper.optJSONObject(oskariStyle, ""stroke"", () -> new JSONObject());
        setStrokeStyle(style, stroke);
        // polygon doesn't have cap style
        setLabelStyle(style, oskariStyle);
        style.setLineCap(LINE_CAP_STYLE.getOrDefault(JSONHelper.optString(stroke,""lineCap""), 0));

        return style;
    }
","    public static PDPrintStyle getLineStyle (JSONObject oskariStyle) {
        PDPrintStyle style = new PDPrintStyle();
START         JSONObject stroke = JSONHelper.optJSONObject(oskariStyle, ""stroke"", () -> new JSONObject()); END 
        setStrokeStyle(style, stroke);
        // polygon doesn't have cap style
        setLabelStyle(style, oskariStyle);
        style.setLineCap(LINE_CAP_STYLE.getOrDefault(JSONHelper.optString(stroke,""lineCap""), 0));

        return style;
    }
","    public static PDPrintStyle getLineStyle (JSONObject oskariStyle) {
        JSONObject stroke = oskariStyle.optJSONObject(""stroke"");

        PDPrintStyle style = new PDPrintStyle();
        setStrokeStyle(style, stroke);
        setLabelStyle(style, oskariStyle);
        return style;
    }
"
1504,All of the methods on this class should be `synchronized`. Otherwise this change looks good.,"  public static void init(Configuration conf) {
    if (!initDone) {
      DefaultConfiguration.conf = conf;
      DefaultConfiguration.initDone = true;
    }
  }
","  public static void init(Configuration conf) {
    if (!initDone) {
      DefaultConfiguration.conf = conf;
      DefaultConfiguration.initDone = true;
START     } END 
  }
","  public static synchronized void init(Configuration conf) {
    if (!initDone) {
      DefaultConfiguration.conf = conf;
      DefaultConfiguration.initDone = true;
    }
  }
"
1505,We return even if this is false. Should we do something in the else case?,"    private void rollBackToTimestamp(long timestamp) {
        if (getVersionUnsafe() > timestamp) {
            try {
                rollbackObjectUnsafe(timestamp);
                // Rollback successfully got us to the right
                // version, we're done.
                if (getVersionUnsafe() == timestamp) {
                    return;
                }
            } catch (NoRollbackException nre) {
                log.warn(""Rollback[{}] to {} failed {}"", this, timestamp, nre);
                resetUnsafe();
            }
        }
    }
","    private void rollBackToTimestamp(long timestamp) {
        if (getVersionUnsafe() > timestamp) {
            try {
                rollbackObjectUnsafe(timestamp);
                // Rollback successfully got us to the right
                // version, we're done.
START                 if (getVersionUnsafe() == timestamp) { END 
                    return;
                }
            } catch (NoRollbackException nre) {
                log.warn(""Rollback[{}] to {} failed {}"", this, timestamp, nre);
                resetUnsafe();
            }
        }
    }
","    private void rollBackToTimestamp(long timestamp) {
        if (getVersionUnsafe() > timestamp) {
            try {
                rollbackObjectUnsafe(timestamp);
            } catch (NoRollbackException nre) {
                log.warn(""Rollback[{}] to {} failed {}"", this, timestamp, nre);
                resetUnsafe();
            }
        }
    }
"
1506,Nit: I think `new KafkaProducer<>(options)` will work here,"    public void prepare(Properties options) {
        Objects.requireNonNull(mapper, ""mapper can not be null"");
        Objects.requireNonNull(topicSelector, ""topicSelector can not be null"");
        producer = new KafkaProducer<K, V>(options);
    }
","    public void prepare(Properties options) {
        Objects.requireNonNull(mapper, ""mapper can not be null"");
        Objects.requireNonNull(topicSelector, ""topicSelector can not be null"");
START         producer = new KafkaProducer<K, V>(options); END 
    }
","    public void prepare(Properties options) {
        Objects.requireNonNull(mapper, ""mapper can not be null"");
        Objects.requireNonNull(topicSelector, ""topicSelector can not be null"");
        producer = new KafkaProducer<>(options);
    }
"
1507,this must be disposed,"	protected Control createSWTControl(Composite parent) throws DatabindingFailedException {
		final Control control = super.createSWTControl(parent);

		final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] {
			new ReflectiveItemProviderAdapterFactory(),
			new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) });
		adapterFactoryItemDelegator = new AdapterFactoryItemDelegator(composedAdapterFactory);

		return control;
	}
","	protected Control createSWTControl(Composite parent) throws DatabindingFailedException {
		final Control control = super.createSWTControl(parent);

START 		final ComposedAdapterFactory composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] { END 
			new ReflectiveItemProviderAdapterFactory(),
			new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) });
		adapterFactoryItemDelegator = new AdapterFactoryItemDelegator(composedAdapterFactory);

		return control;
	}
","	protected Control createSWTControl(Composite parent) throws DatabindingFailedException {
		final Control control = super.createSWTControl(parent);

		composedAdapterFactory = new ComposedAdapterFactory(new AdapterFactory[] {
			new ReflectiveItemProviderAdapterFactory(),
			new ComposedAdapterFactory(ComposedAdapterFactory.Descriptor.Registry.INSTANCE) });
		adapterFactoryItemDelegator = new AdapterFactoryItemDelegator(composedAdapterFactory);

		return control;
	}
"
1508,`else` is redundant here.,"    public boolean isRegistered(VeluxProduct product) {
        logger.trace(""isRegistered(VeluxProduct {}) called."", product.toString());
        if (product.isV2()) {
            return isRegistered(product.getSerialNumber());
        } else {
            return isRegistered(product.getProductUniqueIndex());
        }
    }
","    public boolean isRegistered(VeluxProduct product) {
        logger.trace(""isRegistered(VeluxProduct {}) called."", product.toString());
        if (product.isV2()) {
            return isRegistered(product.getSerialNumber());
START         } else { END 
            return isRegistered(product.getProductUniqueIndex());
        }
    }
","    public boolean isRegistered(VeluxProduct product) {
        logger.trace(""isRegistered(VeluxProduct {}) called."", product.toString());
        if (product.isV2()) {
            return isRegistered(product.getSerialNumber());
        }
        return isRegistered(product.getProductUniqueIndex());
    }
"
1509,You can call the value just `value`,"    public void tearDown() throws Exception {
        FileUtils.deleteQuietly(nuxeoHome);

        // Restore or clear all the system properties manipulated by the current test
        originSystemProps.forEach((key, originValue) -> {
            if (originValue == null) {
                System.clearProperty(key);
            } else {
                System.setProperty(key, originValue);
            }
        });
        originSystemProps.clear();
    }
","    public void tearDown() throws Exception {
        FileUtils.deleteQuietly(nuxeoHome);

        // Restore or clear all the system properties manipulated by the current test
START         originSystemProps.forEach((key, originValue) -> { END 
            if (originValue == null) {
                System.clearProperty(key);
            } else {
                System.setProperty(key, originValue);
            }
        });
        originSystemProps.clear();
    }
","    public void tearDown() throws Exception {
        FileUtils.deleteQuietly(nuxeoHome);

        // Restore or clear all the system properties manipulated by the current test
        originSystemProps.forEach((key, value) -> {
            if (value == null) {
                System.clearProperty(key);
            } else {
                System.setProperty(key, value);
            }
        });
        originSystemProps.clear();
    }
"
1510,Are these two lines of definitions necessary? Isn't it shorter to just use module.getLabel().getState() in assert?,"	private void checkDeployedProject(String projectName) {
		ServersView2 serversView = new ServersView2();
		serversView.open();
		ServerModule module = serversView.getServer(FULL_SERVER_NAME)
				.getModule(new RegexMatcher("".*"" + projectName + "".*""));
		new WaitUntil(new ServerModuleHasState(module, ServerState.STARTED), TimePeriod.getCustom(30));
		ModuleLabel moduleLabel = module.getLabel();
		ServerState moduleState = moduleLabel.getState();
		assertTrue(""Module has not been started!"", moduleState == ServerState.STARTED);
	}
","	private void checkDeployedProject(String projectName) {
		ServersView2 serversView = new ServersView2();
		serversView.open();
		ServerModule module = serversView.getServer(FULL_SERVER_NAME)
				.getModule(new RegexMatcher("".*"" + projectName + "".*""));
		new WaitUntil(new ServerModuleHasState(module, ServerState.STARTED), TimePeriod.getCustom(30));
		ModuleLabel moduleLabel = module.getLabel();
		ServerState moduleState = moduleLabel.getState();
START 		assertTrue(""Module has not been started!"", moduleState == ServerState.STARTED); END 
	}
","	private void checkDeployedProject(String projectName) {
		ServersView2 serversView = new ServersView2();
		serversView.open();
		ServerModule module = serversView.getServer(FULL_SERVER_NAME)
				.getModule(new RegexMatcher("".*"" + projectName + "".*""));
		new WaitUntil(new ServerModuleHasState(module, ServerState.STARTED), TimePeriod.getCustom(30));
		ModuleLabel moduleLabel = module.getLabel();
		assertTrue(""Module has not been started!"", moduleLabel.getState() == ServerState.STARTED);
	}
"
1511,"Oh please, no! Don't ship a null object! :cry:","        SlackService getSlackService(final String baseUrl, final String teamDomain, final String authTokenCredentialId, final boolean botUser, final String room) {
            return new StandardSlackService(baseUrl, teamDomain, null, authTokenCredentialId, botUser, room);
        }
","        SlackService getSlackService(final String baseUrl, final String teamDomain, final String authTokenCredentialId, final boolean botUser, final String room) {
START             return new StandardSlackService(baseUrl, teamDomain, null, authTokenCredentialId, botUser, room); END 
        }
","        SlackService getSlackService(final String baseUrl, final String teamDomain, final String authTokenCredentialId, final boolean botUser, final String room) {
            return new StandardSlackService(baseUrl, teamDomain, authTokenCredentialId, botUser, room);
        }
"
1512,I would move this one first.,"	private boolean isAnnotationPresent(AnnotatedType annotatedType, Set<Annotation> processedAnnotations) {
		if ( annotatedType instanceof AnnotatedParameterizedType ) {
			for ( AnnotatedType type : ( (AnnotatedParameterizedType) annotatedType ).getAnnotatedActualTypeArguments() ) {
				if ( isAnnotationPresent( type, processedAnnotations ) ) {
					return true;
				}
			}
		}
		if ( isAnnotationPresentIn( annotatedType.getDeclaredAnnotations(), processedAnnotations ) ) {
			return true;
		}
		return false;
	}
","	private boolean isAnnotationPresent(AnnotatedType annotatedType, Set<Annotation> processedAnnotations) {
		if ( annotatedType instanceof AnnotatedParameterizedType ) {
			for ( AnnotatedType type : ( (AnnotatedParameterizedType) annotatedType ).getAnnotatedActualTypeArguments() ) {
				if ( isAnnotationPresent( type, processedAnnotations ) ) {
					return true;
				}
			}
		}
START 		if ( isAnnotationPresentIn( annotatedType.getDeclaredAnnotations(), processedAnnotations ) ) { END 
			return true;
		}
		return false;
	}
","	private boolean isAnnotationPresent(AnnotatedType annotatedType, Set<Annotation> processedAnnotations) {
		if ( isAnnotationPresentIn( annotatedType.getDeclaredAnnotations(), processedAnnotations ) ) {
			return true;
		}
		if ( annotatedType instanceof AnnotatedParameterizedType ) {
			for ( AnnotatedType type : ( (AnnotatedParameterizedType) annotatedType ).getAnnotatedActualTypeArguments() ) {
				if ( isAnnotationPresent( type, processedAnnotations ) ) {
					return true;
				}
			}
		}
		return false;
	}
"
1513,int func();,"    static int staticFunc() {
      InvokeStatic f = new InvokeStatic() {  // Noncompliant
        @Override
        public String func(int n) {
          unknown();
          staticFunc();
          return 0;
        }
      };
      return f.func();
    }
","    static int staticFunc() {
      InvokeStatic f = new InvokeStatic() {  // Noncompliant
        @Override
START         public String func(int n) { END 
          unknown();
          staticFunc();
          return 0;
        }
      };
      return f.func();
    }
","    static int staticFunc() {
      InvokeStatic f = new InvokeStatic() {  // Noncompliant
        @Override
        public int func() {
          unknown();
          staticFunc();
          return 0;
        }
      };
      return f.func();
    }
"
1514,"But we are moving to UNJOINED anyway, so it won't affect the result right?","    private synchronized void resetGeneration() {
        this.generation = Generation.NO_GENERATION;
        rejoinNeeded = true;

        // only reset the state to un-joined when it is not already in rebalancing
        if (state != MemberState.REBALANCING)
            state = MemberState.UNJOINED;
    }
","    private synchronized void resetGeneration() {
        this.generation = Generation.NO_GENERATION;
        rejoinNeeded = true;

        // only reset the state to un-joined when it is not already in rebalancing
START         if (state != MemberState.REBALANCING) END 
            state = MemberState.UNJOINED;
    }
","    private synchronized void resetGeneration() {
        this.rejoinNeeded = true;
        this.generation = Generation.NO_GENERATION;
    }
"
1515,why you need this here?,"    public Path generateArtifact(URI uri,
                                 int size)
            throws IOException
    {
        new NpmPackageGenerator(Paths.get(uri));

        buildPublishJson();

        return getPackagePath();
    }
","    public Path generateArtifact(URI uri,
                                 int size)
            throws IOException
    {
START         new NpmPackageGenerator(Paths.get(uri)); END 

        buildPublishJson();

        return getPackagePath();
    }
","    public Path generateArtifact(URI uri,
                                 int size)
            throws IOException
    {
        buildPublishJson();

        return getPackagePath();
    }
"
1516,"Minor nit, declaring a new Random each time is not really good practice.","        public void nextTuple() {
            Utils.sleep(100);
            Random rand = new Random();
            Integer value = rand.nextInt(1000);
            collector.emit(new Values(value));
        }
","        public void nextTuple() {
            Utils.sleep(100);
START             Random rand = new Random(); END 
            Integer value = rand.nextInt(1000);
            collector.emit(new Values(value));
        }
","        public void nextTuple() {
            Utils.sleep(100);
            collector.emit(new Values(rand.nextInt(1000)));
        }
"
1517,these 3 methods are `public` do you really need them?,"  public void register(final Class<?> clazz, final Object converter) {
    otherWord = """";
  }
","START   public void register(final Class<?> clazz, final Object converter) { END 
    otherWord = """";
  }
","  private void register(final Class<?> clazz, final Object converter) {
    otherWord = """";
  }
"
1518,Why are we setting it to true during indexing?,"	public void testMarkerOnLastLineNoNewline_495842() throws Exception {
		try(BufferedWriter writer = new BufferedWriter(new FileWriter(loadcode("""", false)))) {
			writer.write(getAboveComment().trim());
		}
		PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, true);
		indexFiles();
		PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false);
		String result = runQuickFixOneFile();
		assertContainedIn(""int func() { } // @suppress(\""No return\"")"", result);
	}
","	public void testMarkerOnLastLineNoNewline_495842() throws Exception {
		try(BufferedWriter writer = new BufferedWriter(new FileWriter(loadcode("""", false)))) {
			writer.write(getAboveComment().trim());
		}
START 		PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, true); END 
		indexFiles();
		PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false);
		String result = runQuickFixOneFile();
		assertContainedIn(""int func() { } // @suppress(\""No return\"")"", result);
	}
","	public void testMarkerOnLastLineNoNewline_495842() throws Exception {
		try(BufferedWriter writer = new BufferedWriter(new FileWriter(loadcode("""", false)))) {
			writer.write(getAboveComment().trim());
		}
		PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, false);
		indexFiles();
		String result = runQuickFixOneFile();
		PreferenceConstants.getPreferenceStore().setValue(PreferenceConstants.ENSURE_NEWLINE_AT_EOF, true);
		assertContainedIn(""int func() { } // @suppress(\""No return\"")"", result);
	}
"
1519,What is the Log.e for?,"    public void onLanguageTabSelected(String selectedLanguageCode) {
        Log.e(""####"", ""HERE"");
        searchLanguageCode = selectedLanguageCode;
        startSearch(query, query != null && query.length() > 1);
    }
","    public void onLanguageTabSelected(String selectedLanguageCode) {
        START  Log.e(""####"", ""HERE""); END 
        searchLanguageCode = selectedLanguageCode;
        startSearch(query, query != null && query.length() > 1);
    }
","    public void onLanguageTabSelected(String selectedLanguageCode) {
        searchLanguageCode = selectedLanguageCode;
        startSearch(query, query != null && query.length() > 1);
    }
"
1520,Move the tag to a constant?,"    public T insert(SQLiteDatabase db, T entityAdapter, boolean isSyncAdapter)
    {
        Log.d(""Logging EntityProcessor"", ""before insert"");
        T result = mDelegate.insert(db, entityAdapter, isSyncAdapter);
        Log.d(""Logging EntityProcessor"", ""after insert on "" + entityAdapter.id());
        return result;
    }
","    public T insert(SQLiteDatabase db, T entityAdapter, boolean isSyncAdapter)
    {
START         Log.d(""Logging EntityProcessor"", ""before insert""); END 
        T result = mDelegate.insert(db, entityAdapter, isSyncAdapter);
        Log.d(""Logging EntityProcessor"", ""after insert on "" + entityAdapter.id());
        return result;
    }
","    public T insert(SQLiteDatabase db, T entityAdapter, boolean isSyncAdapter)
    {
        Log.d(TAG, ""before insert"");
        T result = mDelegate.insert(db, entityAdapter, isSyncAdapter);
        Log.d(TAG, ""after insert on "" + entityAdapter.id());
        return result;
    }
"
1521,This won't copy the map?,"  protected UfsStatus(UfsStatus status) {
    mIsDirectory = status.mIsDirectory;
    mName = status.mName;
    mOwner = status.mOwner;
    mGroup = status.mGroup;
    mMode = status.mMode;
    mLastModifiedTimeMs = status.mLastModifiedTimeMs;
    mXAttr = status.mXAttr;
  }
","  protected UfsStatus(UfsStatus status) {
    mIsDirectory = status.mIsDirectory;
    mName = status.mName;
    mOwner = status.mOwner;
    mGroup = status.mGroup;
    mMode = status.mMode;
    mLastModifiedTimeMs = status.mLastModifiedTimeMs;
START     mXAttr = status.mXAttr; END 
  }
","  protected UfsStatus(UfsStatus status) {
    mIsDirectory = status.mIsDirectory;
    mName = status.mName;
    mOwner = status.mOwner;
    mGroup = status.mGroup;
    mMode = status.mMode;
    mLastModifiedTimeMs = status.mLastModifiedTimeMs;
    mXAttr = status.mXAttr == null ? null : new HashMap<>(status.mXAttr);
  }
"
1522,"if repository is null, this will throw an NPE.","  boolean isProjectStyle() {
    if (myIsFrameworkStyle) {
      return false;
    }
    ProjectResourceRepository repository = ProjectResourceRepository.getProjectResources(myConfiguration.getModule(), true);
    assert repository != null : repository.getDisplayName();
    return repository.hasResourceItem(ResourceType.STYLE, myStyleName);
  }
","  boolean isProjectStyle() {
    if (myIsFrameworkStyle) {
      return false;
    }
    ProjectResourceRepository repository = ProjectResourceRepository.getProjectResources(myConfiguration.getModule(), true);
    assert repository != null : START  repository.getDisplayName(); END 
    return repository.hasResourceItem(ResourceType.STYLE, myStyleName);
  }
","  boolean isProjectStyle() {
    if (myIsFrameworkStyle) {
      return false;
    }
    ProjectResourceRepository repository = ProjectResourceRepository.getProjectResources(myConfiguration.getModule(), true);
    assert repository != null : myConfiguration.getModule().getName();
    return repository.hasResourceItem(ResourceType.STYLE, myStyleName);
  }
"
1523,"Let's use @CacheEvict(value=""userSearchLocales"") public User saveUser(User user, String password) instead. We will get rid of CacheManager in Context as well. It would be better to evict just for the specified user, but our key consists of user and currentLocale. SaveUser is not called that often so invalidating all entries is no issue anyway.","	public void setUserProperty(String prop, String value) {
		getUserProperties().put(prop, value);
		Context.clearCacheForCurrentUser();
	}
","	public void setUserProperty(String prop, String value) {
		getUserProperties().put(prop, value);
START 		Context.clearCacheForCurrentUser(); END 
	}
","	public void setUserProperty(String prop, String value) {
		getUserProperties().put(prop, value);
	}
"
1524,You can revert this change because you don't need it in this specific class.,"    JarFileUtils(IPostProcessor processor, String xmlPathInJar, List<String> testNames) {
        this.processor = processor;
        this.xmlPathInJar = xmlPathInJar;
        //Ensure that dynamic list operations supported
        this.testNames = (testNames == null ? null : new ArrayList<>(testNames));
    }
","    JarFileUtils(IPostProcessor processor, String xmlPathInJar, List<String> testNames) {
        this.processor = processor;
        this.xmlPathInJar = xmlPathInJar;
        //Ensure that dynamic list operations supported
START         this.testNames = (testNames == null ? null : new ArrayList<>(testNames)); END 
    }
","    JarFileUtils(IPostProcessor processor, String xmlPathInJar, List<String> testNames) {
        this.processor = processor;
        this.xmlPathInJar = xmlPathInJar;
        this.testNames = testNames;
    }
"
1525,will properties provider return the defaultValue in case of no network or value not found ?,"		public String resolve(String variable, String defaultValue) {
			IVariableResolver delegate = new ExpressionResolver.SystemPropertiesVariableResolver();
			//ignoring argument here, as we want to fall back on the propertiesProvider.
			String result = delegate.resolve(variable, null);
			if (result == null) {
				try {
					result = propertiesProvider.getValue(variable, defaultValue, new NullProgressMonitor());
				} catch (CoreException e) {
					throw new ExpressionResolutionException(e);
				}
			}
			return result;
		}
","		public String resolve(String variable, String defaultValue) {
			IVariableResolver delegate = new ExpressionResolver.SystemPropertiesVariableResolver();
			//ignoring argument here, as we want to fall back on the propertiesProvider.
			String result = delegate.resolve(variable, null);
			if (result == null) {
				try {
START 					result = propertiesProvider.getValue(variable, defaultValue, new NullProgressMonitor()); END 
				} catch (CoreException e) {
					throw new ExpressionResolutionException(e);
				}
			}
			return result;
		}
","    public String resolve(String variable, String defaultValue) {
      IVariableResolver delegate = new ExpressionResolver.SystemPropertiesVariableResolver();
      // ignoring default value first, as we want to fall back on the
      // propertiesProvider later.
      String result = delegate.resolve(variable, null);
      if (result == null) {
        result = propertiesProvider.getValue(variable, defaultValue);
      }
      return result;
    }
"
1526,"you can simply return the result of anyMatch without the 'if' and 'return true/false' statements.
imo, it would also be nicer to extract the ""i -> i.getDiskVmElementForVm(vmBase.getId()).getDiskInterface() == DiskInterface.VirtIO_SCSI"" part to a separate method ""isVirtioScsiDisk"" to make it easier to read","    public static boolean isVirtIoScsiDiskInterfaceExists(VmBase vmBase) {
        if (vmBase.getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vmBase.getId())
                .getDiskInterface() == DiskInterface.VirtIO_SCSI)) {
            return true;
        }
        return false;
    }
","    public static boolean isVirtIoScsiDiskInterfaceExists(VmBase vmBase) {
        if (vmBase.getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vmBase.getId())
                .getDiskInterface() == DiskInterface.VirtIO_SCSI)) {
            return true;
        }
START         return false; END 
    }
","    public static boolean isVirtIoScsiDiskInterfaceExists(VmBase vmBase) {
        return vmBase.getImages().stream().anyMatch(i -> i.getDiskVmElementForVm(vmBase.getId())
                .getDiskInterface() == DiskInterface.VirtIO_SCSI);
    }
"
1527,"Is there a reason for using `Locale.FRENCH`? Also, why is it needed to remove all spaces? Are you just trying to do a `trim()`, or are you removing spaces between words?","    public void setContext(String context){
        typingRule.setContext(BloodTestContext.valueOf(context.replaceAll(""\\s"","""").toUpperCase(Locale.FRENCH)));
    }
","    public void setContext(String context){
START         typingRule.setContext(BloodTestContext.valueOf(context.replaceAll(""\\s"","""").toUpperCase(Locale.FRENCH))); END 
    }
","    public void setContext(String context){
        typingRule.setContext(BloodTestContext.valueOf(context.replaceAll(""\\s"","""").toUpperCase()));
    }
"
1528,close already done in Util.read(..),"    private String readClasspathResource(String c) throws IOException {
        InputStream is = getClass().getResourceAsStream(c);
        try {
            return Util.read(is);
        } finally {
            if (is != null) {
                is.close();
            }
        }
    }
","    private String readClasspathResource(String c) throws IOException {
        InputStream is = getClass().getResourceAsStream(c);
        try {
            return Util.read(is);
        } finally {
            if (is != null) {
START                 is.close(); END 
            }
        }
    }
","   private String readClasspathResource(String c) throws IOException {
      InputStream is = getClass().getResourceAsStream(c);
      return Util.read(is);
   }
"
1529,can be inlined,"    protected void build(UnitVmModel frontend, VM backend) {

        String name = (String) frontend.getName().getEntity();

        VmTemplate template = (VmTemplate) frontend.getTemplate().getSelectedItem();
        backend.setVmtGuid(template.getId());
        backend.setName(name);

        backend.setVmDescription((String) frontend.getDescription().getEntity());
        backend.setCustomProperties(frontend.getCustomPropertySheet().getEntity());

    }
","    protected void build(UnitVmModel frontend, VM backend) {

START         String name = (String) frontend.getName().getEntity(); END 

        VmTemplate template = (VmTemplate) frontend.getTemplate().getSelectedItem();
        backend.setVmtGuid(template.getId());
        backend.setName(name);

        backend.setVmDescription((String) frontend.getDescription().getEntity());
        backend.setCustomProperties(frontend.getCustomPropertySheet().getEntity());

    }
","    protected void build(UnitVmModel frontend, VM backend) {

        VmTemplate template = (VmTemplate) frontend.getTemplate().getSelectedItem();
        backend.setVmtGuid(template.getId());
        backend.setName((String) frontend.getName().getEntity());

        backend.setVmDescription((String) frontend.getDescription().getEntity());
        backend.setCustomProperties(frontend.getCustomPropertySheet().getEntity());

    }
"
1530,"@mavrk one test should only be for one method and one combination of parameters.
and the goal is that every public method in the service layer is tested.

so you should write tests for the methods

* getAllDrugs()
* getAllDrugs(includeRetired)

and for the latter you need one test passing true and one passing false.
another case is also what if there are no drugs will it return an empty list?

I know this is tedious but thats because when this was written [TDD|https://en.wikipedia.org/wiki/Test-driven_development] which would start with tests wasnt used.","	public void getAllDrugs_shouldReturnAListOfAllDrugs() throws Exception {
		int resultWhenTrue = 4;
		int resultWhenFalse = 2;
		List<Drug> allDrugs = conceptService.getAllDrugs();
		assertEquals(resultWhenTrue, allDrugs.size());
		allDrugs = conceptService.getAllDrugs(false);
		assertEquals(resultWhenFalse, allDrugs.size());
	}
","	public void getAllDrugs_shouldReturnAListOfAllDrugs() throws Exception {
		int resultWhenTrue = 4;
		int resultWhenFalse = 2;
		List<Drug> allDrugs = conceptService.getAllDrugs();
		assertEquals(resultWhenTrue, allDrugs.size());
START 		allDrugs = conceptService.getAllDrugs(false); END 
		assertEquals(resultWhenFalse, allDrugs.size());
	}
","	public void getAllDrugs_shouldReturnAListOfAllDrugs() throws Exception {
		int resultWhenTrue = 4;
		List<Drug> allDrugs = conceptService.getAllDrugs();
		assertEquals(resultWhenTrue, allDrugs.size());
	}
"
1531,those inner classes make reading all of this much worse,"  public List<BithumbTransactionHistoryResponse.BithumbTransactionHistory> getBithumbTrades(
      CurrencyPair currencyPair) throws IOException {
    final BithumbResponse<List<BithumbTransactionHistoryResponse.BithumbTransactionHistory>>
        transactionHistory = bithumb.transactionHistory(BithumbUtils.getBaseCurrency(currencyPair));
    return transactionHistory.getData();
  }
","  public List<BithumbTransactionHistoryResponse.BithumbTransactionHistory> getBithumbTrades(
      CurrencyPair currencyPair) throws IOException {
START     final BithumbResponse<List<BithumbTransactionHistoryResponse.BithumbTransactionHistory>> END 
        transactionHistory = bithumb.transactionHistory(BithumbUtils.getBaseCurrency(currencyPair));
    return transactionHistory.getData();
  }
","  public List<BithumbTransactionHistory> getBithumbTrades(CurrencyPair currencyPair)
      throws IOException {
    final BithumbResponse<List<BithumbTransactionHistory>> transactionHistory =
        bithumb.transactionHistory(BithumbUtils.getBaseCurrency(currencyPair));
    return transactionHistory.getData();
  }
"
1532,`mChildren` could be `null`,"      public void addChild(String name, Long id) {
        if (mChildren.put(name, id) == null) {
          mWeight.incrementAndGet();
        }
      }
","      public void addChild(String name, Long id) {
START         if (mChildren.put(name, id) == null) { END 
          mWeight.incrementAndGet();
        }
      }
","      public void addChild(String name, Long id) {
        if (mChildren != null && mChildren.put(name, id) == null) {
          mWeight.incrementAndGet();
        }
      }
"
1533,nit: This will result in double logging,"    static void reTryKerberos(boolean enabled)
    {
        if (enabled) {
            log.debug(""Try relogin kerberos at first!"");
            try {
                if (UserGroupInformation.isLoginKeytabBased()) {
                    UserGroupInformation.getLoginUser().reloginFromKeytab();
                }
                else if (UserGroupInformation.isLoginTicketBased()) {
                    UserGroupInformation.getLoginUser().reloginFromTicketCache();
                }
            }
            catch (IOException e) {
                log.error(""Try relogin kerberos failed!"");
                throw new RuntimeException(e);
            }
        }
    }
","    static void reTryKerberos(boolean enabled)
    {
        if (enabled) {
            log.debug(""Try relogin kerberos at first!"");
            try {
                if (UserGroupInformation.isLoginKeytabBased()) {
                    UserGroupInformation.getLoginUser().reloginFromKeytab();
                }
                else if (UserGroupInformation.isLoginTicketBased()) {
                    UserGroupInformation.getLoginUser().reloginFromTicketCache();
                }
            }
            catch (IOException e) {
START                 log.error(""Try relogin kerberos failed!""); END 
                throw new RuntimeException(e);
            }
        }
    }
","    static void reTryKerberos(boolean enabled)
    {
        if (enabled) {
            log.debug(""Try relogin kerberos at first!"");
            try {
                if (UserGroupInformation.isLoginKeytabBased()) {
                    UserGroupInformation.getLoginUser().reloginFromKeytab();
                }
                else if (UserGroupInformation.isLoginTicketBased()) {
                    UserGroupInformation.getLoginUser().reloginFromTicketCache();
                }
            }
            catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
"
1534,braces,"  void resetLogic() {
    for (int i = 0; i < fieldSize; i++)
      for (int j = 0; j < fieldSize; j++)
        fieldArray[i][j] = 0;
    playerMark = CROSS_MARK;
    aIMark = ZERO_MARK;
    turn = 0;   //first turn
    autoGameEnabled = false;
  }
","  void resetLogic() {
    for (int i = 0; i < fieldSize; i++)
START       for (int j = 0; j < fieldSize; j++)
        fieldArray[i][j] = 0; END 
    playerMark = CROSS_MARK;
    aIMark = ZERO_MARK;
    turn = 0;   //first turn
    autoGameEnabled = false;
  }
","  void resetLogic() {
    for (int i = 0; i < fieldSize; i++)
      for (int j = 0; j < fieldSize; j++) {
        fieldArray[i][j] = 0;
      }
    playerMark = CROSS_MARK;
    aIMark = ZERO_MARK;
    turn = 0;   //first turn
    autoGameEnabled = false;
  }
"
1535,Could you replace `Arrays#stream` by `Stream#of` for consistency ?,"    protected Stream<URL> listBundleComponents(Bundle bundle) {
        String list = OSGiRuntimeService.getComponentsList(bundle);
        String name = bundle.getSymbolicName();
        log.debug(""PartialBundle: "" + name + "" components: "" + list);
        if (list == null) {
            return Stream.empty();
        } else {
            return Arrays.stream(list.split(""[, \t\n\r\f]"")).map(bundle::getEntry).filter(Objects::nonNull);
        }
    }
","    protected Stream<URL> listBundleComponents(Bundle bundle) {
        String list = OSGiRuntimeService.getComponentsList(bundle);
        String name = bundle.getSymbolicName();
        log.debug(""PartialBundle: "" + name + "" components: "" + list);
        if (list == null) {
            return Stream.empty();
        } else {
START             return Arrays.stream(list.split(""[, \t\n\r\f]"")).map(bundle::getEntry).filter(Objects::nonNull); END 
        }
    }
","    protected Stream<URL> listBundleComponents(Bundle bundle) {
        String list = OSGiRuntimeService.getComponentsList(bundle);
        String name = bundle.getSymbolicName();
        log.debug(""PartialBundle: "" + name + "" components: "" + list);
        if (list == null) {
            return Stream.empty();
        } else {
            return Stream.of(list.split(""[, \t\n\r\f]"")).map(bundle::getEntry).filter(Objects::nonNull);
        }
    }
"
1536,"Please use assertj assertion. In case of fail it gives error message explaining different list sizes. Current implementation will just print assertion error, expected true but was false with no reference to list size.","    public void testLoadDataObjectsWithNonNullWorkspaceProject() {
        assertTrue(dataObjectsService.loadDataObjects(workspaceProject).isEmpty());
    }
","    public void testLoadDataObjectsWithNonNullWorkspaceProject() {
START         assertTrue(dataObjectsService.loadDataObjects(workspaceProject).isEmpty()); END 
    }
","    public void testLoadDataObjectsWithNonNullWorkspaceProject() {
        assertThat(dataObjectsService.loadDataObjects(workspaceProject)).isEmpty();
    }
"
1537,Why this function is public ? It will be used outside of this class ?,"    public Graphics2D prepareImageRenderer(MapTransform mt, BufferedImage img, ProgressMonitor pm) {
        Graphics2D g2 = img.createGraphics();
        if (backgroundColor != null) {
            g2.setBackground(backgroundColor);
            g2.clearRect(0, 0, width, height);
        }
        ImageRenderer renderer = new ImageRenderer();
        renderer.draw(mt, g2, width, height, rootLayer, pm);
        return g2;
    }
","START     public Graphics2D prepareImageRenderer(MapTransform mt, BufferedImage img, ProgressMonitor pm) { END 
        Graphics2D g2 = img.createGraphics();
        if (backgroundColor != null) {
            g2.setBackground(backgroundColor);
            g2.clearRect(0, 0, width, height);
        }
        ImageRenderer renderer = new ImageRenderer();
        renderer.draw(mt, g2, width, height, rootLayer, pm);
        return g2;
    }
","    private Graphics2D prepareImageRenderer(MapTransform mt, BufferedImage img, ProgressMonitor pm) {
        Graphics2D g2 = img.createGraphics();
        if (backgroundColor != null) {
            g2.setBackground(backgroundColor);
            g2.clearRect(0, 0, width, height);
        }
        ImageRenderer renderer = new ImageRenderer();
        renderer.draw(mt, g2, width, height, rootLayer, pm);
        return g2;
    }
"
1538,"Not needed, delete.","	public static void refreshResources(IResource[] resources,
			IProgressMonitor monitor) throws CoreException {
		try {
			SubMonitor progress = SubMonitor.convert(monitor,
					CoreText.ProjectUtil_refreshing, resources.length);
			for (IResource resource : resources) {
				if (progress.isCanceled())
					break;
				resource.refreshLocal(IResource.DEPTH_INFINITE,
						progress.newChild(1));
				progress.worked(1);
			}
		} finally {
			monitor.done();
		}
	}
","	public static void refreshResources(IResource[] resources,
			IProgressMonitor monitor) throws CoreException {
		try {
			SubMonitor progress = SubMonitor.convert(monitor,
					CoreText.ProjectUtil_refreshing, resources.length);
			for (IResource resource : resources) {
				if (progress.isCanceled())
					break;
				resource.refreshLocal(IResource.DEPTH_INFINITE,
						progress.newChild(1));
START 				progress.worked(1); END 
			}
		} finally {
			monitor.done();
		}
	}
","	public static void refreshResources(IResource[] resources,
			IProgressMonitor monitor) throws CoreException {
		try {
			SubMonitor progress = SubMonitor.convert(monitor,
					CoreText.ProjectUtil_refreshing, resources.length);
			for (IResource resource : resources) {
				if (progress.isCanceled())
					break;
				resource.refreshLocal(IResource.DEPTH_INFINITE,
						progress.newChild(1));
			}
		} finally {
			monitor.done();
		}
	}
"
1539,we can just use 'return false' instead of 'else return false',"private boolean isInSelection(Event event) {
	if (selection.x == selection.y) return false;
	int offset = getOffsetAtPoint(event.x, event.y, null, true);
	if (selection.x <= offset && offset < selection.y) return true;
	else return false;
}
","private boolean isInSelection(Event event) {
	if (selection.x == selection.y) return false;
	int offset = getOffsetAtPoint(event.x, event.y, null, true);
	if (selection.x <= offset && offset < selection.y) return true;
START 	else return false; END 
}
","private boolean isInSelection(Event event) {
	if (selection.x == selection.y) return false;
	int offset = getOffsetAtPoint(event.x, event.y, null, true);
	if (selection.x <= offset && offset < selection.y) return true;
	return false;
}
"
1540,Is the throws Exception needed here?,"    public void setUp() throws Exception {
        cuMarshalService = new CUMarshalServiceImpl();
        xmlFile = new File(EXAMPLE_FILE_NAME);
    }
","START     public void setUp() throws Exception {
        cuMarshalService = new CUMarshalServiceImpl();
        xmlFile = new File(EXAMPLE_FILE_NAME);
    } END 
","    public void setUp() {
        cuMarshalService = new CUMarshalServiceImpl();
        xmlFile = new File(EXAMPLE_FILE_NAME);
    }
"
1541,System.out? Booh!,"	public void actionPerformed(ActionEvent e) {
		if(e.getSource() == okButton){
			//controller should be passed to this class only if there is need to modification content of Keystore.
			System.out.println(certControll);
			if (certControll != null) {
				certControll.setAddToKeystore(true);
			}
			this.dispose();
		}else if(e.getSource() == cancelButton){
			if (certControll != null) {
				certControll.setAddToKeystore(false);
			}
			this.dispose();
		}
	}
","	public void actionPerformed(ActionEvent e) {
		if(e.getSource() == okButton){
			//controller should be passed to this class only if there is need to modification content of Keystore.
START 			System.out.println(certControll); END 
			if (certControll != null) {
				certControll.setAddToKeystore(true);
			}
			this.dispose();
		}else if(e.getSource() == cancelButton){
			if (certControll != null) {
				certControll.setAddToKeystore(false);
			}
			this.dispose();
		}
	}
","	public void actionPerformed(ActionEvent e) {
		if(e.getSource() == okButton){
			//controller should be passed to this class only if there is need to modification content of Keystore.
			if (certControll != null) {
				certControll.setAddToKeystore(true);
			}
			this.dispose();
		}else if(e.getSource() == cancelButton){
			if (certControll != null) {
				certControll.setAddToKeystore(false);
			}
			this.dispose();
		}
	}
"
1542,"instead of initializing `filterSteps` in `initFilterSteps` could you do the following?

```
filterSteps = createFilterSteps(buildTarget, goToolchain, platform, fileTypes);
```","  public FilteredSourceFiles(
      List<Path> rawSrcFiles,
      BuildTarget buildTarget,
      GoToolchain goToolchain,
      GoPlatform platform,
      List<FileType> fileTypes) {
    this.rawSrcFiles = rawSrcFiles;
    this.extraSrcFiles = new ArrayList<>();
    initFilterSteps(buildTarget, goToolchain, platform, fileTypes);
  }
","  public FilteredSourceFiles(
      List<Path> rawSrcFiles,
      BuildTarget buildTarget,
      GoToolchain goToolchain,
      GoPlatform platform,
      List<FileType> fileTypes) {
    this.rawSrcFiles = rawSrcFiles;
    this.extraSrcFiles = new ArrayList<>();
START     initFilterSteps(buildTarget, goToolchain, platform, fileTypes); END 
  }
","  public FilteredSourceFiles(
      List<Path> rawSrcFiles,
      BuildTarget buildTarget,
      GoToolchain goToolchain,
      GoPlatform platform,
      List<FileType> fileTypes) {
    this(rawSrcFiles, ImmutableList.of(), buildTarget, goToolchain, platform, fileTypes);
  }
"
1543,Isn't this already present elsewhere in biojava?,"    public static char complementBase(char base, boolean RNA) {
        if (base == 'A' && RNA) return 'U';
        if (base == 'A') return 'T';
        if (base == 'T' && !RNA) return 'A';
        if (base == 'U' && RNA) return 'A';
        if (base == 'C') return 'G';
        if (base == 'G') return 'C';
        return ' ';
    }
","START     public static char complementBase(char base, boolean RNA) { END 
        if (base == 'A' && RNA) return 'U';
        if (base == 'A') return 'T';
        if (base == 'T' && !RNA) return 'A';
        if (base == 'U' && RNA) return 'A';
        if (base == 'C') return 'G';
        if (base == 'G') return 'C';
        return ' ';
    }
","    protected static char complementBase(char base, boolean RNA) {
        if (base == 'A' && RNA) return 'U';
        if (base == 'A') return 'T';
        if (base == 'T' && !RNA) return 'A';
        if (base == 'U' && RNA) return 'A';
        if (base == 'C') return 'G';
        if (base == 'G') return 'C';
        return ' ';
    }
"
1544,"Replace with `this(in, null)`","        public TCCLObjectInputStream(InputStream in) throws IOException {
            super(in);
            this.classLoader = Thread.currentThread().getContextClassLoader();
        }
","        public TCCLObjectInputStream(InputStream in) throws IOException {
            super(in);
START             this.classLoader = Thread.currentThread().getContextClassLoader(); END 
        }
","        public TCCLObjectInputStream(InputStream in) throws IOException {
            this(in, null);
        }
"
1545,Add the cause to the log.,"    private void run() {
        try {
            boolean valid = connectionSanityCheck.isValid();
            if (!valid) {
                onInvalidConnection.run();
            }
        } catch (Exception e) {
            logger.warn(""Impossible to correctly monitor the Axon Server connection state."");
        }
    }
","    private void run() {
        try {
            boolean valid = connectionSanityCheck.isValid();
            if (!valid) {
                onInvalidConnection.run();
            }
        } catch (Exception e) {
START             logger.warn(""Impossible to correctly monitor the Axon Server connection state.""); END 
        }
    }
","    private void run() {
        try {
            boolean valid = connectionSanityCheck.isValid();
            if (!valid) {
                onInvalidConnection.run();
            }
        } catch (Exception e) {
            logger.warn(""Impossible to correctly monitor the Axon Server connection state."", e);
        }
    }
"
1546,Why did you remove the `stateData`?,"    protected String getStateParameter(final WebContext context) {
        final String stateParameter;
        final String stateData = getState();
        if (CommonHelper.isNotBlank(stateData)) {
            stateParameter = stateData;
        } else {
            stateParameter = CommonHelper.randomString(10);
        }
        return stateParameter;
    }
","    protected String getStateParameter(final WebContext context) {
START         final String stateParameter; END 
        final String stateData = getState();
        if (CommonHelper.isNotBlank(stateData)) {
            stateParameter = stateData;
        } else {
            stateParameter = CommonHelper.randomString(10);
        }
        return stateParameter;
    }
","    protected String getStateParameter(final WebContext context) {
        final String stateParameter;
        if (CommonHelper.isNotBlank(stateData)) {
            stateParameter = stateData;
        } else {
            stateParameter = CommonHelper.randomString(10);
        }
        return stateParameter;
    }
"
1547,"This logic seems potentially fragile.  What if someone accidentally types in *two spaces*, e.g. `-c[space][space]test`.

Also, have you investigated whether there is a way to potentially use the tools/API in Apache Commons CLI to do this parameter parsing for us (instead of doing string parsing)?  If we could just use that CLI API directly, it'd be better than rewriting it ourselves.","    public DSpaceCommandLineParameter(String parameter) {
        this(StringUtils.substringBefore(parameter, "" ""), StringUtils.substringAfter(parameter, "" ""));
    }
","    public DSpaceCommandLineParameter(String parameter) {
START         this(StringUtils.substringBefore(parameter, "" ""), StringUtils.substringAfter(parameter, "" "")); END 
    }
","    protected DSpaceCommandLineParameter(String parameter) {
        this(StringUtils.substringBefore(parameter, "" ""), StringUtils.substringAfter(parameter, "" ""));
    }
"
1548,Does this have to be after the above line? Seems like it may as well be right before. Or you could just check that the returned list is empty. Or you can do both.,"	protected Transferable createTransferable(JComponent c)
		{
		indices = list.getSelectedIndices();
		if (list.isSelectionEmpty()) return null;
		return new ActionTransferable((ArrayList<Action>) list.getSelectedValuesList());
		}
","	protected Transferable createTransferable(JComponent c)
		{
		indices = list.getSelectedIndices();
START 		if (list.isSelectionEmpty()) return null; END 
		return new ActionTransferable((ArrayList<Action>) list.getSelectedValuesList());
		}
","	protected Transferable createTransferable(JComponent c)
		{
		if (list.isSelectionEmpty()) return null;
		indices = list.getSelectedIndices();
		return new ActionTransferable((ArrayList<Action>) list.getSelectedValuesList());
		}
"
1549,"Again don't eat the exception throw it, and wrap it if you cannot update the interface.","    public List<NimbusInfo> getAllNimbuses() {
        List<NimbusInfo> nimbusInfos = new ArrayList<>();
        try {
            Collection<Participant> participants = leaderLatch.get().getParticipants();
            for (Participant participant : participants) {
                nimbusInfos.add(Zookeeper.toNimbusInfo(participant));
            }
        } catch (Exception e) {
            LOG.warn(""failed to get nimbuses"", e);
        }
        return nimbusInfos;
    }
","    public List<NimbusInfo> getAllNimbuses() {
        List<NimbusInfo> nimbusInfos = new ArrayList<>();
        try {
            Collection<Participant> participants = leaderLatch.get().getParticipants();
            for (Participant participant : participants) {
                nimbusInfos.add(Zookeeper.toNimbusInfo(participant));
            }
        } catch (Exception e) {
            LOG.warn(""failed to get nimbuses"", e);
START         } END 
        return nimbusInfos;
    }
","    public List<NimbusInfo> getAllNimbuses() throws Exception {
        List<NimbusInfo> nimbusInfos = new ArrayList<>();
        Collection<Participant> participants = leaderLatch.get().getParticipants();
        for (Participant participant : participants) {
            nimbusInfos.add(Zookeeper.toNimbusInfo(participant));
        }
        return nimbusInfos;
    }
"
1550,deprecate this,"  protected void doBegin() throws TransactionException {
    if (txManager == null) {
      throw new IllegalStateException(CoreMessages
          .objectNotRegistered(""javax.transaction.TransactionManager"", ""Transaction Manager"").getMessage());
    }

    try {
      txManager.setTransactionTimeout(getTimeoutInSeconds());
      txManager.begin();
      synchronized (this) {
        transaction = txManager.getTransaction();
      }
    } catch (Exception e) {
      throw new TransactionException(cannotStartTransaction(""XA""), e);
    }
  }
","START   protected void doBegin() throws TransactionException { END 
    if (txManager == null) {
      throw new IllegalStateException(CoreMessages
          .objectNotRegistered(""javax.transaction.TransactionManager"", ""Transaction Manager"").getMessage());
    }

    try {
      txManager.setTransactionTimeout(getTimeoutInSeconds());
      txManager.begin();
      synchronized (this) {
        transaction = txManager.getTransaction();
      }
    } catch (Exception e) {
      throw new TransactionException(cannotStartTransaction(""XA""), e);
    }
  }
","  protected void doBegin() throws TransactionException {
    if (txManager == null) {
      throw new IllegalStateException(objectNotRegistered(""javax.transaction.TransactionManager"", ""Transaction Manager"")
          .getMessage());
    }

    try {
      txManager.setTransactionTimeout(getTimeoutInSeconds());
      txManager.begin();
      synchronized (this) {
        transaction = txManager.getTransaction();
      }
    } catch (Exception e) {
      throw new TransactionException(cannotStartTransaction(""XA""), e);
    }
  }
"
1551,"Why not use `org.modeshape.common.util.HashCode.compute(...)` instead of this? Or better yet, why not just return `name.hashCode()`? (When can `name` be null?)","    public int hashCode() {
        int hash = 7;
        hash = 89 * hash + (this.name != null ? this.name.hashCode() : 0);
        return hash;
    }
","    public int hashCode() {
        int hash = 7;
        hash = 89 * hash + (this.name != null ? this.name.hashCode() : 0);
START         return hash; END 
    }
","    public int hashCode() {
        return name.hashCode();
    }
"
1552,this should be before the callback I think,"  public void postProcessRequest(RestRequest restRequest, Callback<Void> callback) {
    Exception exception = null;
    frontendMetrics.securityServicePostProcessRequestRate.mark();
    long startTimeMs = System.currentTimeMillis();
    if (!isOpen) {
      exception = new RestServiceException(""SecurityService is closed"", RestServiceErrorCode.ServiceUnavailable);
    } else if (restRequest == null || callback == null) {
      throw new IllegalArgumentException(""RestRequest or Callback is null"");
    }
    callback.onCompletion(null, exception);
    frontendMetrics.securityServicePostProcessRequestTimeInMs.update(System.currentTimeMillis() - startTimeMs);
  }
","  public void postProcessRequest(RestRequest restRequest, Callback<Void> callback) {
    Exception exception = null;
    frontendMetrics.securityServicePostProcessRequestRate.mark();
    long startTimeMs = System.currentTimeMillis();
    if (!isOpen) {
      exception = new RestServiceException(""SecurityService is closed"", RestServiceErrorCode.ServiceUnavailable);
    } else if (restRequest == null || callback == null) {
      throw new IllegalArgumentException(""RestRequest or Callback is null"");
    }
START     callback.onCompletion(null, exception); END 
    frontendMetrics.securityServicePostProcessRequestTimeInMs.update(System.currentTimeMillis() - startTimeMs);
  }
","  public void postProcessRequest(RestRequest restRequest, Callback<Void> callback) {
    Exception exception = null;
    frontendMetrics.securityServicePostProcessRequestRate.mark();
    long startTimeMs = System.currentTimeMillis();
    if (!isOpen) {
      exception = new RestServiceException(""SecurityService is closed"", RestServiceErrorCode.ServiceUnavailable);
    } else if (restRequest == null || callback == null) {
      throw new IllegalArgumentException(""RestRequest or Callback is null"");
    }
    frontendMetrics.securityServicePostProcessRequestTimeInMs.update(System.currentTimeMillis() - startTimeMs);
    callback.onCompletion(null, exception);
  }
"
1553,static,"	private IMethod[] toArray(List<IMethod> methods) {
		return methods.toArray(new IMethod[methods.size()]);
	}
","START 	private IMethod[] END  toArray(List<IMethod> methods) {
		return methods.toArray(new IMethod[methods.size()]);
	}
","	private static IMethod[] toArray(List<IMethod> methods) {
		return methods.toArray(new IMethod[methods.size()]);
	}
"
1554,"update wouldn't work if the id is always a new id
setting a new id is the job of add command","    public UserProfileParameters() {
        profile.setId(Guid.newGuid());
    }
","    public UserProfileParameters() {
START         profile.setId(Guid.newGuid()); END 
    }
","    public UserProfileParameters() {
    }
"
1555,"It is safe to call dismiss multiple times, in the source for dismiss(), there's a nice global if check along the lines of (mView != null && isVisible()) or something.","    public void onActivityPaused(Activity activity) {
        if (null != mCurInAppNotification) {
            mCurInAppNotification.dismiss();
        }
    }
","    public void onActivityPaused(Activity activity) {
        if (null != mCurInAppNotification) {
START             mCurInAppNotification.dismiss(); END 
        }
    }
","    public void onActivityPaused(Activity activity) {}
"
1556,Done,"	public void createReplyReplyDone() {
		createButton(buttonparent, buttonReply_ID, buttonReply_caption, true);

		createButton(buttonparent, buttonReplyDone_ID, buttonReplyDone_caption, true);

		buttonBar.pack();

	}
","START 	public void createReplyReplyDone() { END 
		createButton(buttonparent, buttonReply_ID, buttonReply_caption, true);

		createButton(buttonparent, buttonReplyDone_ID, buttonReplyDone_caption, true);

		buttonBar.pack();

	}
","	private void createReplyReplyDone() {
		createButton(buttonparent, buttonReply_ID, buttonReply_caption, true);

		createButton(buttonparent, buttonReplyDone_ID, buttonReplyDone_caption, true);

		buttonBar.pack();

	}
"
1557,"`SECONDS.toMillis(5)` -> `5`. Timeout parameter of `assertTrueEventually(..)` is in seconds, not milliseconds.","    public void noMoreBubble() {
        config.setProperty(PARTITION_OPERATION_THREAD_COUNT.getName(), ""1"");
        initExecutor();

        final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory();
        taskFactory.delayMs = 1000;
        executor.executeOnPartitions(taskFactory, newPartitions());

        final DummyOperation op = new DummyOperation();
        executor.execute(op);
        assertTrueEventually(new AssertTask() {
            @Override
            public void run() {
                assertTrue(op.completed);
            }
        }, SECONDS.toMillis(5));
    }
","    public void noMoreBubble() {
        config.setProperty(PARTITION_OPERATION_THREAD_COUNT.getName(), ""1"");
        initExecutor();

        final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory();
        taskFactory.delayMs = 1000;
        executor.executeOnPartitions(taskFactory, newPartitions());

        final DummyOperation op = new DummyOperation();
        executor.execute(op);
        assertTrueEventually(new AssertTask() {
            @Override
            public void run() {
                assertTrue(op.completed);
            }
START         }, SECONDS.toMillis(5)); END 
    }
","    public void noMoreBubble() {
        config.setProperty(PARTITION_OPERATION_THREAD_COUNT.getName(), ""1"");
        initExecutor();

        final DummyPartitionTaskFactory taskFactory = new DummyPartitionTaskFactory();
        taskFactory.delayMs = 1000;
        executor.executeOnPartitions(taskFactory, newPartitions());

        final DummyOperation op = new DummyOperation();
        executor.execute(op);
        assertTrueEventually(new AssertTask() {
            @Override
            public void run() {
                assertTrue(op.completed);
            }
        }, 5);
    }
"
1558,I guess we could just assert without the temporary variable.,"	public void equal_shouldReturnTrueIfObjectReferenceAreTheSame() {
		CohortMembership cohortMembership = new CohortMembership(12);
		
		boolean result = cohortMembership.equals(cohortMembership);
		
		assertTrue(result);
	}
","	public void equal_shouldReturnTrueIfObjectReferenceAreTheSame() {
		CohortMembership cohortMembership = new CohortMembership(12);
		
START 		boolean result = cohortMembership.equals(cohortMembership); END 
		
		assertTrue(result);
	}
","	public void equal_shouldReturnTrueIfObjectReferenceAreTheSame() {
		CohortMembership cohortMembership = new CohortMembership(12);
		
		assertTrue(cohortMembership.equals(cohortMembership));
	
	}
"
1559,"nit, could return: withPendingLocalization(this.pendingLocalization, pendingDownload);","        public DynamicState withPendingLocalization(Future<Void> pendingDownload) {
            return new DynamicState(this.state, this.newAssignment,
                    this.container, this.currentAssignment,
                    this.pendingLocalization, this.startTime,
                    pendingDownload, this.profileActions,
                    this.pendingStopProfileActions);
        }
","START         public DynamicState withPendingLocalization(Future<Void> pendingDownload) { END 
            return new DynamicState(this.state, this.newAssignment,
                    this.container, this.currentAssignment,
                    this.pendingLocalization, this.startTime,
                    pendingDownload, this.profileActions,
                    this.pendingStopProfileActions);
        }
","        public DynamicState withPendingLocalization(Future<Void> pendingDownload) {
            return withPendingLocalization(this.pendingLocalization, pendingDownload);
        }
"
1560,"We could also return true here, which seems to be more obvious to me","	public boolean verifyUser(String username, String password, ESClientVersionInfo clientVersionInfo) {
		try {
			final Optional<ESAuthenticationInformation> information = doVerifyUser(username, password,
				clientVersionInfo);
			if (!information.isPresent()) {
				/* to many bad attempts, otherwise we get an exception */
				ModelUtil.logWarning(
					MessageFormat.format(Messages.LoginService_VerifyUserTooManyFailedRequests, username, delay));
			}
			return information.isPresent();
		} catch (final AccessControlException ex) {
			/* regular bad attempt */
			return false;
		}
	}
","	public boolean verifyUser(String username, String password, ESClientVersionInfo clientVersionInfo) {
		try {
			final Optional<ESAuthenticationInformation> information = doVerifyUser(username, password,
				clientVersionInfo);
			if (!information.isPresent()) {
				/* to many bad attempts, otherwise we get an exception */
				ModelUtil.logWarning(
					MessageFormat.format(Messages.LoginService_VerifyUserTooManyFailedRequests, username, delay));
			}
			return START  information.isPresent(); END 
		} catch (final AccessControlException ex) {
			/* regular bad attempt */
			return false;
		}
	}
","	public boolean verifyUser(String username, String password, ESClientVersionInfo clientVersionInfo) {
		try {
			final Optional<ESAuthenticationInformation> information = doVerifyUser(username, password,
				clientVersionInfo);
			if (!information.isPresent()) {
				/* too many bad attempts, otherwise we get an exception */
				ModelUtil.logWarning(
					MessageFormat.format(Messages.LoginService_VerifyUserTooManyFailedRequests, username, delay));
			}
			return true;
		} catch (final AccessControlException ex) {
			/* regular bad attempt */
			return false;
		}
	}
"
1561,duplicate assert,"    public void test() throws Exception {
        ExternalBuildReport report = new ExternalBuildReport(""http://some.url.com"");

        assertEquals(""View External Report"", report.getDisplayName());
        assertEquals(""graph.gif"", report.getIconFileName());
        assertEquals(""graph.gif"", report.getIconFileName());
        assertEquals(""http://some.url.com"", report.getUrlName());
        assertEquals(null, report.getTarget());
    }
","    public void test() throws Exception {
        ExternalBuildReport report = new ExternalBuildReport(""http://some.url.com"");

        assertEquals(""View External Report"", report.getDisplayName());
        assertEquals(""graph.gif"", report.getIconFileName());
START         assertEquals(""graph.gif"", report.getIconFileName()); END 
        assertEquals(""http://some.url.com"", report.getUrlName());
        assertEquals(null, report.getTarget());
    }
","    public void test() throws Exception {
        ExternalBuildReport report = new ExternalBuildReport(""http://some.url.com"");

        assertEquals(""View External Report"", report.getDisplayName());
        assertEquals(""graph.gif"", report.getIconFileName());
        assertEquals(""http://some.url.com"", report.getUrlName());
        assertEquals(null, report.getTarget());
    }
"
1562,The null `source` looks odd.,"      public void publishEvent(Object event) {
         publishEvent(new PayloadApplicationEvent<Object>(null, event));
      }
","      public void publishEvent(Object event) {
START          publishEvent(new PayloadApplicationEvent<Object>(null, event)); END 
      }
","      public void publishEvent(Object event) {
         publishEvent(new PayloadApplicationEvent<>(this, event));
      }
"
1563,"Personally for all these simple things, I would simple it down to a ternary operation for code simplicity. Always keep in mind code size.","    public boolean isList()
    {
        if (isProperty)
            return prop.isList();
        else
            return false;
    }
","    public boolean isList()
    {
START         if (isProperty) END 
            return prop.isList();
        else
            return false;
    }
","    public boolean isList()
    {
        return isProperty && prop.isList();
    }
"
1564,"I don't think we need this check nor this method.
simply call
   geoRepDao.getById(getParameters().getGeoRepSessionId()) when needed, if getParameters().getGeoRepSessionId() we will simply won't get any result","    private GlusterGeoRepSession getGeoRepSession() {
        if (getParameters().getGeoRepSessionId() != null) {
            return geoRepDao.getById(getParameters().getGeoRepSessionId());
        }
        return null;
    }
","    private GlusterGeoRepSession getGeoRepSession() {
        if (getParameters().getGeoRepSessionId() != null) {
            return geoRepDao.getById(getParameters().getGeoRepSessionId());
        }
START         return null; END 
    }
","    private GlusterGeoRepSession getGeoRepSession() {
        return geoRepDao.getById(getParameters().getGeoRepSessionId());
    }
"
1565,"Unfortunately this method is protected. Changing the signature may break someone. @junit-team/junit-committers how should we handle this? We could not add the new feature without breaking the extension point.

I'm in favour of modifying the methods signature and making it private. Users should create a new rule instead of extending Timeout. They could use the builder for creating the statement.","    protected Statement createFailOnTimeoutStatement(
            Statement statement, Description description) throws Exception {
        return FailOnTimeout.builder()
            .withTimeout(timeout, timeUnit)
            .withLookingForStuckThread(lookForStuckThread)
            .withDescription(description)
            .build(statement);
    }
","    protected Statement createFailOnTimeoutStatement(
START             Statement statement, Description description) throws Exception { END 
        return FailOnTimeout.builder()
            .withTimeout(timeout, timeUnit)
            .withLookingForStuckThread(lookForStuckThread)
            .withDescription(description)
            .build(statement);
    }
","    private Statement createFailOnTimeoutStatement(
            Statement statement, Description description) throws Exception {
        return FailOnTimeout.builder()
            .withDescription(description)
            .build(createFailOnTimeoutStatement(statement));
    }
"
1566,"The loop fails if `stops` contains _the first_ stop (`0`). The method should be:
```
        Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>();
        while (stops.hasNext()) {
            activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stops.next()));
        }
        return activeTripPatternsForGivenStops.iterator();
```","    @Override public Iterator<? extends TripPatternInfo<TripSchedule>> patternIterator(
            IntIterator stops
    ) {
        Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>();
        int stopIndex = stops.next();
        while (stopIndex > 0) {
            activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stopIndex));
            stopIndex = stops.next();
        }
        return activeTripPatternsForGivenStops.iterator();
    }
","    @Override public Iterator<? extends TripPatternInfo<TripSchedule>> patternIterator(
            IntIterator stops
    ) {
        Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>();
        int stopIndex = stops.next();
        while (stopIndex > 0) {
            activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stopIndex));
            stopIndex = stops.next();
        }
START         return activeTripPatternsForGivenStops.iterator(); END 
    }
","    @Override public Iterator<? extends TripPatternInfo<TripSchedule>> patternIterator(
            IntIterator stops
    ) {
        Set<TripPatternInfo<TripSchedule>> activeTripPatternsForGivenStops = new HashSet<>();
        while (stops.hasNext()) {
            activeTripPatternsForGivenStops.addAll(activeTripPatternsPerStop.get(stops.next()));
        }
        return activeTripPatternsForGivenStops.iterator();
    }
"
1567,This is likely unnecessary. The set of qualifiers is expected to contain all elements. See also `org.jboss.weld.bootstrap.WeldStartup.createContexts(ServiceRegistry)` and other places where this constructor is used.,"    public ContextHolder(T context, Class<T> type, Set<Annotation> qualifiers) {
        this.context = context;
        this.type = type;
        this.qualifiers = asSet(DefaultLiteral.INSTANCE, AnyLiteral.INSTANCE);
        this.qualifiers.addAll(qualifiers);
    }
","    public ContextHolder(T context, Class<T> type, Set<Annotation> qualifiers) {
        this.context = context;
        this.type = type;
START         this.qualifiers = asSet(DefaultLiteral.INSTANCE, AnyLiteral.INSTANCE); END 
        this.qualifiers.addAll(qualifiers);
    }
","    public ContextHolder(T context, Class<T> type, Set<Annotation> qualifiers) {
        this.context = context;
        this.type = type;
        this.qualifiers = qualifiers;
    }
"
1568,"Unnecessary; it is still enabled by default in core, disabled in wizard.","    public void setUp() {
        jenkins.CLI.get().setEnabled(true);
        Set<String> agentProtocols = new HashSet<>(j.jenkins.getAgentProtocols());
        agentProtocols.add(ExtensionList.lookupSingleton(CliProtocol2.class).getName());
        j.jenkins.setAgentProtocols(agentProtocols);
    }
","    public void setUp() {
START         jenkins.CLI.get().setEnabled(true); END 
        Set<String> agentProtocols = new HashSet<>(j.jenkins.getAgentProtocols());
        agentProtocols.add(ExtensionList.lookupSingleton(CliProtocol2.class).getName());
        j.jenkins.setAgentProtocols(agentProtocols);
    }
","    public void setUp() {
        Set<String> agentProtocols = new HashSet<>(j.jenkins.getAgentProtocols());
        agentProtocols.add(ExtensionList.lookupSingleton(CliProtocol2.class).getName());
        j.jenkins.setAgentProtocols(agentProtocols);
    }
"
1569,There is a lack of symmetry here. `positionGap` should be initialized in both ctors.,"    public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context,
            BasicQueryWeigher weigher) {
        this.executionContext = executionContext;
        this.context = context;
        this.weigher = weigher;
        this.positionGap = 1;
    }
","    public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context,
            BasicQueryWeigher weigher) {
        this.executionContext = executionContext;
        this.context = context;
        this.weigher = weigher;
        this.positionGap = START  1; END 
    }
","    public FieldWrapper(HighlightExecutionContext executionContext, HighlighterContext context,
            BasicQueryWeigher weigher) {
        this.executionContext = executionContext;
        this.context = context;
        this.weigher = weigher;
    }
"
1570,`ImmutableList.copyOf`,"    public StripeFooter(List<Stream> streams, List<ColumnEncoding> columnEncodings, List<Slice> stripeEncryptionGroups)
    {
        this.streams = ImmutableList.copyOf(requireNonNull(streams, ""streams is null""));
        this.columnEncodings = ImmutableList.copyOf(requireNonNull(columnEncodings, ""columnEncodings is null""));
        this.stripeEncryptionGroups = requireNonNull(stripeEncryptionGroups, ""stripeEncryptionGroups is null"");
    }
","    public StripeFooter(List<Stream> streams, List<ColumnEncoding> columnEncodings, List<Slice> stripeEncryptionGroups)
    {
        this.streams = ImmutableList.copyOf(requireNonNull(streams, ""streams is null""));
        this.columnEncodings = ImmutableList.copyOf(requireNonNull(columnEncodings, ""columnEncodings is null""));
START         this.stripeEncryptionGroups = requireNonNull(stripeEncryptionGroups, ""stripeEncryptionGroups is null""); END 
    }
","    public StripeFooter(List<Stream> streams, List<ColumnEncoding> columnEncodings, List<Slice> stripeEncryptionGroups)
    {
        this.streams = ImmutableList.copyOf(requireNonNull(streams, ""streams is null""));
        this.columnEncodings = ImmutableList.copyOf(requireNonNull(columnEncodings, ""columnEncodings is null""));
        this.stripeEncryptionGroups = ImmutableList.copyOf(requireNonNull(stripeEncryptionGroups, ""stripeEncryptionGroups is null""));
    }
"
1571,"i'm not sure how getValue() is supposed to be called, but I would make it work correctly even if it is called twice.  that is, set cx back to zero after you accumulate.","  public Double getValue()
  {
    //do not miss the last tuple
    try {
        estimator.accumulate(cx);
    } catch (ExecException ex) {
        throw new RuntimeException(""Error while accumulating sample frequency: "" + ex);
    }
    
    return estimator.getEntropy();
  }
","  public Double getValue()
  {
    //do not miss the last tuple
    try {
START         estimator.accumulate(cx); END 
    } catch (ExecException ex) {
        throw new RuntimeException(""Error while accumulating sample frequency: "" + ex);
    }
    
    return estimator.getEntropy();
  }
","  public Double getValue()
  {
    //do not miss the last tuple
    try {
        this.estimator.accumulate(this.cx);
    } catch (ExecException ex) {
        throw new RuntimeException(""Error while accumulating sample frequency: "" + ex);
    }

    return this.estimator.getEntropy();
  }
"
1572,Hmm I think we should remove this line. Seems like it's not needed since `close(null)` will just do nothing. Maybe it's a left-over line from some previous version of the file where the result set got closed properly or something :-),"    private boolean usesCatalogsAsSchemas(DatabaseMetaData metaData) {
        boolean result = true;
        ResultSet rs = null;
        try {
            rs = metaData.getSchemas();
            while (rs.next() && result) {
                result = false;
            }
        } catch (SQLException e) {
            throw JdbcUtils.wrapException(e, ""retrieve schema and catalog metadata"", JdbcActionType.METADATA);
        } finally {
            FileHelper.safeClose(rs);
            close(null);
        }
        return result;
    }
","    private boolean usesCatalogsAsSchemas(DatabaseMetaData metaData) {
        boolean result = true;
        ResultSet rs = null;
        try {
            rs = metaData.getSchemas();
            while (rs.next() && result) {
                result = false;
            }
        } catch (SQLException e) {
            throw JdbcUtils.wrapException(e, ""retrieve schema and catalog metadata"", JdbcActionType.METADATA);
        } finally {
            FileHelper.safeClose(rs);
START             close(null); END 
        }
        return result;
    }
","    private boolean usesCatalogsAsSchemas(DatabaseMetaData metaData) {
        boolean result = true;
        ResultSet rs = null;
        try {
            rs = metaData.getSchemas();
            while (rs.next() && result) {
                result = false;
            }
        } catch (SQLException e) {
            throw JdbcUtils.wrapException(e, ""retrieve schema and catalog metadata"", JdbcActionType.METADATA);
        } finally {
            FileHelper.safeClose(rs);
        }
        return result;
    }
"
1573,those `if (!event.isPre())` can be avoided by adding `@Listener(observation = Observation.POST)` at class level,"   public void processCacheEntryDestroyed(CacheEntryRemovedEvent event) {
      if (!event.isPre()) {
         emitSessionDestroyedEvent((String) event.getKey());
      }
   }
","   public void processCacheEntryDestroyed(CacheEntryRemovedEvent event) {
      if (!event.isPre()) {
         emitSessionDestroyedEvent((String) event.getKey());
      }
START    } END 
","   public void processCacheEntryDestroyed(CacheEntryRemovedEvent event) {
      emitSessionDestroyedEvent((String) event.getKey());
   }
"
1574,Flip the `if` and move the invalidate call up inside,"  public void invalidate(@Nullable String path) {
    if (path == null) {
      return;
    }
    invalidate(Uri.parse(path));
  }
","  public void invalidate(@Nullable String path) {
    if (path == null) {
START       return; END 
    }
    invalidate(Uri.parse(path));
  }
","  public void invalidate(@Nullable String path) {
    if (path != null) {
      invalidate(Uri.parse(path));
    }
  }
"
1575,"could this block be simplified?

``` java
public MerlinBuilder withRxCallbacks() {
    rxCallbacksManager = new RxCallbacksManager();
    if (connectableRegisterer == null) {
        withConnectableCallbacks();
    }
    if (disconnectableRegisterer == null) {
        withDisconnectableCallbacks();
    }
    return this;
}
```","    public MerlinBuilder withRxCallbacks() {
        rxCallbacksManager = new RxCallbacksManager();
        if (connectableRegisterer == null && disconnectableRegisterer == null) {
            return this.withConnectableCallbacks().withDisconnectableCallbacks();
        } else if (connectableRegisterer == null) {
            return this.withConnectableCallbacks();
        } else if (disconnectableRegisterer == null) {
            return this.withDisconnectableCallbacks();
        }
        return this;
    }
","    public MerlinBuilder withRxCallbacks() {
        rxCallbacksManager = new RxCallbacksManager();
        if (connectableRegisterer == null && disconnectableRegisterer == null) {
            return this.withConnectableCallbacks().withDisconnectableCallbacks();
        } else if (connectableRegisterer == null) {
            return this.withConnectableCallbacks();
        } else if (disconnectableRegisterer == null) {
            return this.withDisconnectableCallbacks();
        }
START         return this; END 
    }
","    public MerlinBuilder withRxCallbacks() {
        rxCallbacksManager = new RxCallbacksManager();
        if (connectableRegisterer == null) {
            withConnectableCallbacks();
        }
        if (disconnectableRegisterer == null) {
            withDisconnectableCallbacks();
        }
        return this;
    }
"
1576,"I don't like this code duplication. How about

  if (name != null) {
    switch (name) {
    ...
    }
  }
  Assert.isTrue(false);
  return null;","	public static String localizeProvider(String name) {
		if (name==null) {
			Assert.isTrue(false);
			return null;
		}

		switch (name) {
		case DIRECT_PROVIDER:
			return Messages.ProxySelector_0;
		case ECLIPSE_PROVIDER:
			return Messages.ProxySelector_1;
		case NATIVE_PROVIDER:
			return Messages.ProxySelector_2;
		default:
			break;
		}
		Assert.isTrue(false);
		return null;
	}
","	public static String localizeProvider(String name) {
		if (name==null) {
			Assert.isTrue(false);
			return null;
START 		} END 

		switch (name) {
		case DIRECT_PROVIDER:
			return Messages.ProxySelector_0;
		case ECLIPSE_PROVIDER:
			return Messages.ProxySelector_1;
		case NATIVE_PROVIDER:
			return Messages.ProxySelector_2;
		default:
			break;
		}
		Assert.isTrue(false);
		return null;
	}
","	public static String localizeProvider(String name) {
		if (name != null) {
			switch (name) {
			case DIRECT_PROVIDER:
				return Messages.ProxySelector_0;
			case ECLIPSE_PROVIDER:
				return Messages.ProxySelector_1;
			case NATIVE_PROVIDER:
				return Messages.ProxySelector_2;
			default:
				break;
			}
		}
		Assert.isTrue(false);
		return null;
	}
"
1577,Does this need to be public?,"  public String removeSuffix(String loaderFileName, char suffixTerm) {
    return loaderFileName.substring(0, loaderFileName.lastIndexOf(suffixTerm));
  }
","START   public String removeSuffix(String loaderFileName, char suffixTerm) { END 
    return loaderFileName.substring(0, loaderFileName.lastIndexOf(suffixTerm));
  }
","  private String removeSuffix(String loaderFileName, char suffixTerm) {
    return loaderFileName.substring(0, loaderFileName.lastIndexOf(suffixTerm));
  }
"
1578,Very minor but maybe let's make it consistent and initialize the set and map below in the same way? I had to check if there was a specific reason to initialize it this way compared to the others.,"	private BootstrapConfigurationImpl() {
		this.defaultProviderClassName = null;
		this.constraintValidatorFactoryClassName = null;
		this.messageInterpolatorClassName = null;
		this.traversableResolverClassName = null;
		this.parameterNameProviderClassName = null;
		this.clockProviderClassName = null;
		this.valueExtractorClassNames = new HashSet<>( 0 );
		this.validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES;
		this.isExecutableValidationEnabled = true;
		this.constraintMappingResourcePaths = newHashSet();
		this.properties = newHashMap();
	}
","	private BootstrapConfigurationImpl() {
		this.defaultProviderClassName = null;
		this.constraintValidatorFactoryClassName = null;
		this.messageInterpolatorClassName = null;
		this.traversableResolverClassName = null;
		this.parameterNameProviderClassName = null;
		this.clockProviderClassName = null;
START 		this.valueExtractorClassNames = new HashSet<>( 0 ); END 
		this.validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES;
		this.isExecutableValidationEnabled = true;
		this.constraintMappingResourcePaths = newHashSet();
		this.properties = newHashMap();
	}
","	private BootstrapConfigurationImpl() {
		this.defaultProviderClassName = null;
		this.constraintValidatorFactoryClassName = null;
		this.messageInterpolatorClassName = null;
		this.traversableResolverClassName = null;
		this.parameterNameProviderClassName = null;
		this.clockProviderClassName = null;
		this.valueExtractorClassNames = new HashSet<>();
		this.validatedExecutableTypes = DEFAULT_VALIDATED_EXECUTABLE_TYPES;
		this.isExecutableValidationEnabled = true;
		this.constraintMappingResourcePaths = new HashSet<>();
		this.properties = new HashMap<>();
	}
"
1579,"I am concerned about the addition of buildResult here, since this will cause every single copy to read the data twice for the copy and for the checksum, instead of once as before, which could be expensive when dealing with large files and cause performance regressions.","  public static FileUtils.FileCopyResult copyToFileAndClose(InputStream is, File file) throws IOException
  {
    file.getParentFile().mkdirs();
    try (OutputStream os = new BufferedOutputStream(new FileOutputStream(file))) {
      ByteStreams.copy(is, os);
    }
    finally {
      CloseQuietly.close(is);
    }
    return FileUtils.FileCopyResult.buildResult(file.toPath());
  }
","  public static FileUtils.FileCopyResult copyToFileAndClose(InputStream is, File file) throws IOException
  {
    file.getParentFile().mkdirs();
    try (OutputStream os = new BufferedOutputStream(new FileOutputStream(file))) {
      ByteStreams.copy(is, os);
    }
    finally {
      CloseQuietly.close(is);
    }
START     return FileUtils.FileCopyResult.buildResult(file.toPath()); END 
  }
","  public static long copyToFileAndClose(InputStream is, File file) throws IOException
  {
    file.getParentFile().mkdirs();
    try (OutputStream os = new BufferedOutputStream(new FileOutputStream(file))) {
      return ByteStreams.copy(is, os);
    }
    finally {
      CloseQuietly.close(is);
    }
  }
"
1580,"If you are using an AtomicBoolean (and dont do anything else), you no longer need the synchronized keyword here.","  @Override public synchronized boolean cancel( final boolean mayInterruptIfRunning ) {
    return canceled.compareAndSet( false, true );
  }
","START   @Override public synchronized boolean cancel( final boolean mayInterruptIfRunning ) { END 
    return canceled.compareAndSet( false, true );
  }
","  @Override public boolean cancel( final boolean mayInterruptIfRunning ) {
    return canceled.compareAndSet( false, true );
  }
"
1581,"hey @manstis , quick looking at this seems that a potential NPE can be produced here? I mean for `orElse(null).getValue()`?","    protected AbstractToolbarItem<S> getItem(final ToolbarCommand<?> command) {
        return items
                .entrySet()
                .stream()
                .filter(e -> e.getKey().equals(command))
                .findFirst()
                .orElse(null)
                .getValue();
    }
","    protected AbstractToolbarItem<S> getItem(final ToolbarCommand<?> command) {
        return items
                .entrySet()
                .stream()
                .filter(e -> e.getKey().equals(command))
                .findFirst()
                .orElse(null)
START                 .getValue(); END 
    }
","    protected AbstractToolbarItem<S> getItem(final ToolbarCommand<?> command) {
        return items
                .entrySet()
                .stream()
                .filter(e -> e.getKey().equals(command))
                .findFirst()
                .map(Map.Entry::getValue)
                .orElse(null);
    }
"
1582,TAG,"    public CellIdentityCdma() {
        super(CellIdentityCdma.class.getSimpleName(), TYPE_CDMA, null, null);
        mNetworkId = Integer.MAX_VALUE;
        mSystemId = Integer.MAX_VALUE;
        mBasestationId = Integer.MAX_VALUE;
        mLongitude = Integer.MAX_VALUE;
        mLatitude = Integer.MAX_VALUE;
        mAlphaLong = null;
        mAlphaShort = null;
    }
","    public CellIdentityCdma() {
        START super(CellIdentityCdma.class.getSimpleName(), TYPE_CDMA, END  null, null);
        mNetworkId = Integer.MAX_VALUE;
        mSystemId = Integer.MAX_VALUE;
        mBasestationId = Integer.MAX_VALUE;
        mLongitude = Integer.MAX_VALUE;
        mLatitude = Integer.MAX_VALUE;
        mAlphaLong = null;
        mAlphaShort = null;
    }
","    public CellIdentityCdma() {
        super(TAG, TYPE_CDMA, null, null);
        mNetworkId = Integer.MAX_VALUE;
        mSystemId = Integer.MAX_VALUE;
        mBasestationId = Integer.MAX_VALUE;
        mLongitude = Integer.MAX_VALUE;
        mLatitude = Integer.MAX_VALUE;
        mAlphaLong = null;
        mAlphaShort = null;
    }
"
1583,"Would encapsulating the underlying implementation of BecauseYouReadCard be better or do we need the PageTitle elsewhere? I'm thinking of my recent PageTitle.getText() bug where I meant to call getDisplayText(). At least the bug could only live in one place. If we expose a large object like PageTitle, we have lots of flexibility to do things beyond what a Card is really meant for. There's some notes on some of the tradeoffs here: https://en.wikipedia.org/wiki/Law_of_Demeter.","    private void header(@NonNull final BecauseYouReadCard card) {
        CardLargeHeaderView header = new CardLargeHeaderView(getContext())
                .setTitle(card.title())
                .setSubtitle(card.subtitle())
                .setPageTitle(card.pageTitle().getDisplayText())
                .setImage(card.image());
        header(header);
    }
","    private void header(@NonNull final BecauseYouReadCard card) {
        CardLargeHeaderView header = new CardLargeHeaderView(getContext())
                .setTitle(card.title())
                .setSubtitle(card.subtitle())
START                 .setPageTitle(card.pageTitle().getDisplayText()) END 
                .setImage(card.image());
        header(header);
    }
","    private void header(@NonNull final BecauseYouReadCard card) {
        CardLargeHeaderView header = new CardLargeHeaderView(getContext())
                .setTitle(card.title())
                .setSubtitle(card.subtitle())
                .setPageTitle(card.pageTitle())
                .setImage(card.image());
        header(header);
    }
"
1584,`DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString()` -> `String.valueOf(DEFAULT_CHECK_TIMEOUT_IN_SECONDS)` now that it's an `int`,"    private int getCheckTimeoutInSeconds(ConfigurationGenerator cg) {
        int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS;
        try {
            checkTimeout = Integer.parseInt(cg.getUserConfig().getProperty(PARAM_MONGODB_CHECK_TIMEOUT, DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString()));
        } catch (NumberFormatException e) {
            log.warn(String.format(""Invalid format for %s parameter, using default value instead"", PARAM_MONGODB_CHECK_TIMEOUT), e);
        }
        return checkTimeout;
    }
","    private int getCheckTimeoutInSeconds(ConfigurationGenerator cg) {
        int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS;
        try {
START             checkTimeout = Integer.parseInt(cg.getUserConfig().getProperty(PARAM_MONGODB_CHECK_TIMEOUT, DEFAULT_CHECK_TIMEOUT_IN_SECONDS.toString())); END 
        } catch (NumberFormatException e) {
            log.warn(String.format(""Invalid format for %s parameter, using default value instead"", PARAM_MONGODB_CHECK_TIMEOUT), e);
        }
        return checkTimeout;
    }
","    private int getCheckTimeoutInSeconds(ConfigurationGenerator cg) {
        int checkTimeout = DEFAULT_CHECK_TIMEOUT_IN_SECONDS;
        try {
            checkTimeout = Integer.parseInt(cg.getUserConfig().getProperty(PARAM_MONGODB_CHECK_TIMEOUT, String.valueOf(DEFAULT_CHECK_TIMEOUT_IN_SECONDS)));
        } catch (NumberFormatException e) {
            log.warn(String.format(""Invalid format for %s parameter, using default value instead"", PARAM_MONGODB_CHECK_TIMEOUT), e);
        }
        return checkTimeout;
    }
"
1585,This should be a WARN instead of an ERROR.,"    private void closeConnection(String deviceId) {
        DeviceConfig device = deviceConfigCache.get(deviceId);

        if (device == null) {
            logger.error(""Could not find device '{}'"", deviceId);
            return;
        }

        EpsonProjectorDevice remoteController = device.getConnection();

        if (remoteController != null) {
            try {
                logger.debug(""Closing connection to device '{}' "", deviceId);
                remoteController.disconnect();
            } catch (EpsonProjectorException e) {
                logger.debug(""Error occurred when closing connection to device '{}'"", deviceId);
            }
        }
    }
","    private void closeConnection(String deviceId) {
        DeviceConfig device = deviceConfigCache.get(deviceId);

        if (device == null) {
START             logger.error(""Could not find device '{}'"", deviceId); END 
            return;
        }

        EpsonProjectorDevice remoteController = device.getConnection();

        if (remoteController != null) {
            try {
                logger.debug(""Closing connection to device '{}' "", deviceId);
                remoteController.disconnect();
            } catch (EpsonProjectorException e) {
                logger.debug(""Error occurred when closing connection to device '{}'"", deviceId);
            }
        }
    }
","    private void closeConnection(String deviceId) {
        DeviceConfig device = deviceConfigCache.get(deviceId);

        if (device == null) {
            logger.warn(""Could not find device '{}'"", deviceId);
            return;
        }

        EpsonProjectorDevice remoteController = device.getConnection();

        if (remoteController != null) {
            try {
                logger.debug(""Closing connection to device '{}' "", deviceId);
                remoteController.disconnect();
            } catch (EpsonProjectorException e) {
                logger.debug(""Error occurred when closing connection to device '{}'"", deviceId);
            }
        }
    }
"
1586,I'd prefer ImmutableList.of throughout.,"  public void testSimpleAnnotation() {
    assertGeneratedMatches(
        Lists.newArrayList(""import javax.annotation.Nullable;""),
        Lists.newArrayList(""@Nullable""),
        Lists.newArrayList(""@javax.annotation.Nullable""));
  }
","  public void testSimpleAnnotation() {
    assertGeneratedMatches(
START         Lists.newArrayList(""import javax.annotation.Nullable;""), END 
        Lists.newArrayList(""@Nullable""),
        Lists.newArrayList(""@javax.annotation.Nullable""));
  }
","  public void testSimpleAnnotation() {
    assertGeneratedMatches(
        ImmutableList.of(""import javax.annotation.Nullable;""),
        ImmutableList.of(""@Nullable""),
        ImmutableList.of(""@javax.annotation.Nullable""));
  }
"
1587,"I'd expect the union of `POINT (1, 2)` and `LINESTRING EMPTY` to be `POINT (1, 2)`, but this test asserts the result to be `GEOMETRYCOLLECTION (POINT (1 2))`.","	public void testUnionPointWithEmptyLineString() {
		assertUnion(""POINT (1 2)"", ""LINESTRING EMPTY"", ""GEOMETRYCOLLECTION (POINT (1 2))"");
	}
","	public void testUnionPointWithEmptyLineString() {
START 		assertUnion(""POINT (1 2)"", ""LINESTRING EMPTY"", ""GEOMETRYCOLLECTION (POINT (1 2))""); END 
	}
","	public void testUnionPointWithEmptyLineString() {
		assertUnion(""POINT (1 2)"", ""LINESTRING EMPTY"", ""POINT (1 2)"");
	}
"
1588,protected?,"        public Layers(EntityLivingBase entity, RenderLivingBase<T> entityRenderer, LayerRenderer<T> layerRenderer, double x, double y, double z)
        {
            super(entity, entityRenderer, x, y, z);
            this.layerRenderer = layerRenderer;
        }
","START         public Layers(EntityLivingBase entity, RenderLivingBase<T> entityRenderer, LayerRenderer<T> layerRenderer, double x, double y, double z) END 
        {
            super(entity, entityRenderer, x, y, z);
            this.layerRenderer = layerRenderer;
        }
","        protected Layers(EntityLivingBase entity, RenderLivingBase<T> entityRenderer, LayerRenderer<T> layerRenderer, double x, double y, double z)
        {
            super(entity, entityRenderer, x, y, z);
            this.layerRenderer = layerRenderer;
        }
"
1589,"Seems the output name cache should be reset here, not below.","	public void deleteOldDeployments(final IServer server) throws CoreException {
		File deploymentsRootFolder = getDeploymentsRootFolder();
		Arrays.stream(server.getModules())
			.forEach(module -> deleteOldDeployment(module, deploymentsRootFolder));
	}
","	public void deleteOldDeployments(final IServer server) throws CoreException {
		File deploymentsRootFolder = getDeploymentsRootFolder();
		Arrays.stream(server.getModules())
START 			.forEach(module -> deleteOldDeployment(module, deploymentsRootFolder)); END 
	}
","	public void deleteOldDeployments(final IServer server) throws CoreException {
		File deploymentsRootFolder = getDeploymentsRootFolder();
		Arrays.stream(server.getModules())
			.forEach(module -> deleteOldDeployment(module, deploymentsRootFolder, server));
	}
"
1590,I would recommend to use <code>this()</code> in this constructor,"    public CronTab(String format, int line, Hash hash) throws ANTLRException {
        set(format, line, hash);
    }
","    public CronTab(String format, int line, Hash hash) throws ANTLRException {
START         set(format, line, hash); END 
    }
","    public CronTab(String format, int line, Hash hash) throws ANTLRException {
        this(format, line, hash, null);
    }
"
1591,"@mdaneshi, do you think it would make sense to have something like this in every static methods that you wrote?

```
if (buf == null ||  Math.min(buf.length, len) < off + 1 /* required array length for this method to work correctly */)
{
    return false;
}
```

I know this is not a common practice currently in libjitsi and we sometimes are a little sloppy when we access arrays, but I believe we should change this and write more defensive code whenever possible.","    public boolean isKeyFrame(byte[] buff, int off, int len)
    {
      if (buff == null || len < 1 || buff.length < len)
      {
          return false;
      }

      int nalType =  buff[off] & kTypeMask;
      // Single NAL Unit Packet
      if (nalType == kFuA)
      {
          // Fragmented NAL units (FU-A).
          if (parseFuaNaluForKeyFrame(buff, off, len))
          {
              return true;
          }
      }
      else
      {
          if (parseSingleNaluForKeyFrame(buff, off, len))
          {
              return true;
          }
      }

      return false;
    }
","    public boolean isKeyFrame(byte[] buff, int off, int len)
    {
START       if (buff == null || len < 1 || buff.length < len) END 
      {
          return false;
      }

      int nalType =  buff[off] & kTypeMask;
      // Single NAL Unit Packet
      if (nalType == kFuA)
      {
          // Fragmented NAL units (FU-A).
          if (parseFuaNaluForKeyFrame(buff, off, len))
          {
              return true;
          }
      }
      else
      {
          if (parseSingleNaluForKeyFrame(buff, off, len))
          {
              return true;
          }
      }

      return false;
    }
","    public static boolean isKeyFrame(byte[] buff, int off, int len)
    {
      if (buff == null || buff.length < off + Math.max(len, 1))
      {
          return false;
      }

      int nalType =  buff[off] & kTypeMask;
      // Single NAL Unit Packet
      if (nalType == kFuA)
      {
          // Fragmented NAL units (FU-A).
          if (parseFuaNaluForKeyFrame(buff, off, len))
          {
              return true;
          }
      }
      else
      {
          if (parseSingleNaluForKeyFrame(buff, off, len))
          {
              return true;
          }
      }

      return false;
    }
"
1592,"`@ResponseStatus(HttpStatus.NO_RESPONSE)`

Then you can change return type to void and remove the return statement","  public ResponseEntity<?> delete(@RequestBody List<Long> printerIds) throws IOException {
    for (long id : printerIds) {
      Printer printer = printerService.get(id);
      if (printer != null) {
        printerService.remove(printer);
      }
    }
    return new ResponseEntity<>(HttpStatus.OK);
  }
","START   public ResponseEntity<?> delete(@RequestBody List<Long> printerIds) throws IOException { END 
    for (long id : printerIds) {
      Printer printer = printerService.get(id);
      if (printer != null) {
        printerService.remove(printer);
      }
    }
    return new ResponseEntity<>(HttpStatus.OK);
  }
","  public void delete(@RequestBody List<Long> printerIds) throws IOException {
    for (long id : printerIds) {
      Printer printer = printerService.get(id);
      if (printer != null) {
        printerService.remove(printer);
      }
    }
  }
"
1593,"Use k, like you did in the other files","    public DiskWriteModel getDisk(int deviceId) {

        return fDisks.computeIfAbsent(deviceId, k -> new DiskWriteModel(deviceId, checkNotNull(getStateSystemBuilder())));
    }
","    public DiskWriteModel getDisk(int deviceId) {

        return fDisks.computeIfAbsent(deviceId, k -> new START DiskWriteModel(deviceId, checkNotNull(getStateSystemBuilder()))); END 
    }
","    public DiskWriteModel getDisk(int deviceId) {
        return fDisks.computeIfAbsent(deviceId, k -> new DiskWriteModel(k, checkNotNull(getStateSystemBuilder())));
    }
"
1594,"In the context of GUVNOR-2821 I would expect `assertTrue` here, can you please update the `fakeConditionCol52` method to achieve this? Let me know if you don't see my point.","    public void testIsConditionValidWhenHeaderIsValid() throws Exception {
        final ConditionCol52 conditionCol1 = fakeConditionCol52(""header1"");
        final ConditionCol52 conditionCol2 = fakeConditionCol52(""header2"");
        final Validator validator = new Validator(fakeCompositeColumn(conditionCol1,
                                                                      conditionCol2));

        assertFalse(validator.isConditionValid(conditionCol2));
    }
","    public void testIsConditionValidWhenHeaderIsValid() throws Exception {
        final ConditionCol52 conditionCol1 = fakeConditionCol52(""header1"");
        final ConditionCol52 conditionCol2 = fakeConditionCol52(""header2"");
        final Validator validator = new Validator(fakeCompositeColumn(conditionCol1,
                                                                      conditionCol2));

START         assertFalse(validator.isConditionValid(conditionCol2)); END 
    }
","    public void testIsConditionValidWhenHeaderIsValid() throws Exception {
        final ConditionCol52 conditionCol1 = fakeConditionCol52(""header1"");
        final ConditionCol52 conditionCol2 = fakeConditionCol52(""header2"");
        final Validator validator = new Validator(fakeCompositeColumn(conditionCol1,
                                                                      conditionCol2));

        assertTrue(validator.isConditionValid(conditionCol2));
    }
"
1595,does this need to be a class member?,"  public StatsManagerMetrics(MetricRegistry registry) {
    this.registry = registry;
    statsPublishFailureCount = registry.counter(MetricRegistry.name(StatsManager.class, ""StatsPublishFailureCount""));
    totalFetchAndAggregateTime =
        registry.histogram(MetricRegistry.name(StatsManager.class, ""TotalFetchAndAggregateTime""));
    fetchAndAggregateTimePerStore =
        registry.histogram(MetricRegistry.name(StatsManager.class, ""FetchAndAggregateTimePerStore""));
  }
","  public StatsManagerMetrics(MetricRegistry registry) {
START     this.registry = registry; END 
    statsPublishFailureCount = registry.counter(MetricRegistry.name(StatsManager.class, ""StatsPublishFailureCount""));
    totalFetchAndAggregateTime =
        registry.histogram(MetricRegistry.name(StatsManager.class, ""TotalFetchAndAggregateTime""));
    fetchAndAggregateTimePerStore =
        registry.histogram(MetricRegistry.name(StatsManager.class, ""FetchAndAggregateTimePerStore""));
  }
","  public StatsManagerMetrics(MetricRegistry registry) {
    statsPublishFailureCount = registry.counter(MetricRegistry.name(StatsManager.class, ""StatsPublishFailureCount""));
    totalFetchAndAggregateTime =
        registry.histogram(MetricRegistry.name(StatsManager.class, ""TotalFetchAndAggregateTime""));
    fetchAndAggregateTimePerStore =
        registry.histogram(MetricRegistry.name(StatsManager.class, ""FetchAndAggregateTimePerStore""));
  }
"
1596,minor: the `replicaList.size() > 0` check isn't really needed,"  BlobStatus(List<String> replicaList) {
    if (replicaList != null && replicaList.size() > 0) {
      unavailable.addAll(replicaList);
    }
  }
","  BlobStatus(List<String> replicaList) {
    if (replicaList != null && replicaList.size() > 0) {
      unavailable.addAll(replicaList);
    }
START   } END 
","  BlobStatus(List<String> replicaList) {
    if (replicaList != null) {
      unavailable.addAll(replicaList);
    }
  }
"
1597,MemcachedClientCallback should be renamed to StorageClientCallback,"	protected MemcachedClientCallback createMemcachedClientCallback() {
		return new MemcachedClientCallback() {
			@Override
			public byte[] get(final String key) throws IOException {
				return _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key ));
			}
		};
	}
","START 	protected MemcachedClientCallback createMemcachedClientCallback() { END 
		return new MemcachedClientCallback() {
			@Override
			public byte[] get(final String key) throws IOException {
				return _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key ));
			}
		};
	}
","	protected MemcachedClientCallback createMemcachedClientCallback() {
		return new MemcachedClientCallback() {
			@Override
			public byte[] get(final String key) {
				return _memcached.get(_memcachedNodesManager.getStorageKeyFormat().format( key ));
			}
		};
	}
"
1598,"Your tests don't rely on `Stripe.clientId` at all, so you should remove this line, rename the method, and get rid of `tearDownMockAndClientId()` entirely.","	public void clientId() throws IOException {
		Stripe.clientId = ""ca_test"";
		chargeBody = resource(""charge.json"");
	}
","	public void clientId() throws IOException {
START 		Stripe.clientId = ""ca_test""; END 
		chargeBody = resource(""charge.json"");
	}
","	public void clientId() throws IOException {
		chargeBody = resource(""charge.json"");
	}
"
1599,Maybe it would be good to include the causing exception so user knows why it couldn't be created.,"    private XADataSource createXaDataSourceInstance(String className) {
        try {
            Class<?> dataSourceClass = ClassUtils.forName(className, this.getClass().getClassLoader());
            Object instance = BeanUtils.instantiate(dataSourceClass);
            Assert.isInstanceOf(XADataSource.class, instance);
            return (XADataSource) instance;
        }
        catch (Exception ex) {
            throw new IllegalStateException(
                    ""Unable to create XADataSource instance from '"" + className + ""'"");
        }
    }
","    private XADataSource createXaDataSourceInstance(String className) {
        try {
            Class<?> dataSourceClass = ClassUtils.forName(className, this.getClass().getClassLoader());
            Object instance = BeanUtils.instantiate(dataSourceClass);
            Assert.isInstanceOf(XADataSource.class, instance);
            return (XADataSource) instance;
        }
        catch (Exception ex) {
            throw new IllegalStateException(
START                     ""Unable to create XADataSource instance from '"" + className + ""'""); END 
        }
    }
","    private XADataSource createXaDataSourceInstance(String className) {
        try {
            Class<?> dataSourceClass = ClassUtils.forName(className, this.getClass().getClassLoader());
            Object instance = BeanUtils.instantiate(dataSourceClass);
            Assert.isInstanceOf(XADataSource.class, instance);
            return (XADataSource) instance;
        }
        catch (Exception ex) {
            throw new IllegalStateException(
                    ""Unable to create XADataSource instance from '"" + className + ""'"", ex);
        }
    }
"
1600,"You need to swap the order of nullcheck / isEmpty, otherwise it will lead to NPE (if getModules returns null, not sure that's possible) and this validator will fail.","    protected Optional<ExampleProjectError> getError(Path projectPath) {

        POM pom = this.getPom(pomService,
                              projectPath);

        if (pom.getModules().isEmpty() || pom.getModules() == null) {
            return Optional.empty();
        } else {
            return Optional.of(new ExampleProjectError(CheckModulesValidator.class.getCanonicalName(),
                                                       """"));
        }
    }
","    protected Optional<ExampleProjectError> getError(Path projectPath) {

        POM pom = this.getPom(pomService,
                              projectPath);

START         if (pom.getModules().isEmpty() || pom.getModules() == null) { END 
            return Optional.empty();
        } else {
            return Optional.of(new ExampleProjectError(CheckModulesValidator.class.getCanonicalName(),
                                                       """"));
        }
    }
","    protected Optional<ExampleProjectError> getError(Path projectPath) {

        POM pom = this.getPom(pomService,
                              projectPath);

        if (pom.getModules() == null || pom.getModules().isEmpty()) {
            return Optional.empty();
        } else {
            return Optional.of(new ExampleProjectError(CheckModulesValidator.class.getCanonicalName(),
                                                       """"));
        }
    }
"
1601,"When is `mTransport == null`? Isn't it always set to something in `open()`? Also, why do you need to check `mBaseTransport`?","  public boolean isOpen() {
    return mBaseTransport.isOpen() && mTransport != null && mTransport.isOpen();
  }
","  public boolean isOpen() {
START     return mBaseTransport.isOpen() && mTransport != null && mTransport.isOpen(); END 
  }
","  public boolean isOpen() {
    return mTransport != null && mTransport.isOpen();
  }
"
1602,why enabled? why restore those?,"    public static void restoreSystemProperties() {
        System.clearProperty(""org.uberfire.nio.git.daemon.enabled"");
        System.clearProperty(""org.uberfire.nio.git.ssh.enabled"");
        System.clearProperty(""org.uberfire.sys.repo.monitor.disabled"");
    }
","    public static void restoreSystemProperties() {
        System.clearProperty(""org.uberfire.nio.git.daemon.enabled"");
START         System.clearProperty(""org.uberfire.nio.git.ssh.enabled""); END 
        System.clearProperty(""org.uberfire.sys.repo.monitor.disabled"");
    }
","    public static void restoreSystemProperties() {
        System.clearProperty(""org.uberfire.sys.repo.monitor.disabled"");
        System.clearProperty(""org.uberfire.nio.git.daemon.enabled"");
        System.clearProperty(""org.uberfire.nio.git.ssh.enabled"");
        System.clearProperty(""org.uberfire.sys.repo.monitor.disabled"");
    }
"
1603,"I'd rather see more specific error messages here, as there's a few different scenarios here we should be aware of:
* A permanent group's name can *never* be patched.  But, its description can be updated.
* Same with a Community/Collection group's name (not editable) & description (editable), unless it's detached. In which case it can be patched. 

So, at a minimum, it seems like we need different errors & checks here.  Permanent groups can *never* have name updates, but can have description updates.  Community/Collection groups can be updated if the Community/Collection is deleted, but are otherwise considered ""permanent"".","    protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID id,
                         Patch patch) throws AuthorizeException, SQLException {
        final Group group = dsoService.find(context, id);
        if (group != null && isPatchUnprocessable(context, group)) {
            throw new UnprocessableEntityException(""This group cannot be patched."");
        }
        patchDSpaceObject(apiCategory, model, id, patch);
    }
","    protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID id,
                         Patch patch) throws AuthorizeException, SQLException {
        final Group group = dsoService.find(context, id);
        if (group != null && isPatchUnprocessable(context, group)) {
START             throw new UnprocessableEntityException(""This group cannot be patched.""); END 
        }
        patchDSpaceObject(apiCategory, model, id, patch);
    }
","    protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID id,
                         Patch patch) throws AuthorizeException, SQLException {
        patchDSpaceObject(apiCategory, model, id, patch);
    }
"
1604,"no need to assign to counterName just to return on next line. However, we probably should add a null check for the evaluationContext.","	protected String computeMetricName(Message<?> message) {
		String counterName = nameExpression.getValue(evaluationContext, message, CharSequence.class).toString();
		return counterName;
	}
","	protected String computeMetricName(Message<?> message) {
START 		String counterName = nameExpression.getValue(evaluationContext, message, CharSequence.class).toString(); END 
		return counterName;
	}
","	protected String computeMetricName(Message<?> message) {
		return nameExpression.getValue(evaluationContext, message, CharSequence.class).toString();
	}
"
1605,Could you break this statement into multiple for readability?,"  public boolean supportsBitmapIndex(final BitmapIndexSelector selector)
  {
    // We can operate on bitmap indexes if this is a constant expression, or if it reads one column that has
    // an index and does not have multiple values. The lack of multiple values is important because expression
    // filters treat multi-value arrays as nulls, which doesn't permit index based filtering.
    return requiredBindings.isEmpty()
           || (requiredBindings.size() == 1
               && selector.getBitmapIndex(Iterables.getOnlyElement(requiredBindings)) != null
               && !selector.hasMultipleValues(Iterables.getOnlyElement(requiredBindings)));
  }
","  public boolean supportsBitmapIndex(final BitmapIndexSelector selector)
  {
    // We can operate on bitmap indexes if this is a constant expression, or if it reads one column that has
    // an index and does not have multiple values. The lack of multiple values is important because expression
    // filters treat multi-value arrays as nulls, which doesn't permit index based filtering.
START     return requiredBindings.isEmpty() END 
           || (requiredBindings.size() == 1
               && selector.getBitmapIndex(Iterables.getOnlyElement(requiredBindings)) != null
               && !selector.hasMultipleValues(Iterables.getOnlyElement(requiredBindings)));
  }
","  public boolean supportsBitmapIndex(final BitmapIndexSelector selector)
  {
    if (requiredBindings.isEmpty()) {
      // Constant expression.
      return true;
    } else if (requiredBindings.size() == 1) {
      // Single-column expression. We can use bitmap indexes if this column has an index and does not have
      // multiple values. The lack of multiple values is important because expression filters treat multi-value
      // arrays as nulls, which doesn't permit index based filtering.
      final String column = Iterables.getOnlyElement(requiredBindings);
      return selector.getBitmapIndex(column) != null && !selector.hasMultipleValues(column);
    } else {
      // Multi-column expression.
      return false;
    }
  }
"
1606,this method should be changed to private,"	public void setM(Market currentMarket) {
		this.currentMarket = currentMarket;
	}
","START 	public END  void setM(Market currentMarket) {
		this.currentMarket = currentMarket;
	}
","	private void setM(Market currentMarket) {
		this.currentMarket = currentMarket;
	}
"
1607,Please write it as `!config.getQueryCacheConfigs().isEmpty()` instead of checking the size.,"    private long countMapWithAtleastOneQueryCache(Node node) {
        return maps.stream().filter(distributedObject -> {
            MapConfig config = node.getConfig().getMapConfig(distributedObject.getName());
            if (config != null) {
                return config.getQueryCacheConfigs().size() >= 1;
            }
            return false;
        }).count();

    }
","    private long countMapWithAtleastOneQueryCache(Node node) {
        return maps.stream().filter(distributedObject -> {
            MapConfig config = node.getConfig().getMapConfig(distributedObject.getName());
            if (config != null) {
START                 return config.getQueryCacheConfigs().size() >= 1; END 
            }
            return false;
        }).count();

    }
","    private long countMapWithAtleastOneQueryCache(Node node) {
        return maps.stream().filter(distributedObject -> {
            MapConfig config = node.getConfig().getMapConfig(distributedObject.getName());
            if (config != null) {
                return !config.getQueryCacheConfigs().isEmpty();
            }
            return false;
        }).count();

    }
"
1608,"probably it is better to change it to

```
String columnName;
if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) {
	columnName = propertyAuditingData.getExplicitModifiedFlagName();
}
else {
	columnName = propertyAuditingData.getModifiedFlagName();
}
```","	public void addModifiedColumns(
			GlobalConfiguration globalCfg,
			Value value,
			Element parent,
			PropertyAuditingData propertyAuditingData) {
		String columnName = propertyAuditingData.getModifiedFlagName();
		if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) {
			columnName = propertyAuditingData.getExplicitModifiedFlagName();
		}
		MetadataTools.addModifiedFlagProperty(
				parent,
				propertyAuditingData.getName(),
				globalCfg.getModifiedFlagSuffix(),
				columnName
		);
	}
","	public void addModifiedColumns(
			GlobalConfiguration globalCfg,
			Value value,
			Element parent,
			PropertyAuditingData propertyAuditingData) {
		String columnName = propertyAuditingData.getModifiedFlagName();
		if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) {
			columnName = propertyAuditingData.getExplicitModifiedFlagName();
START 		} END 
		MetadataTools.addModifiedFlagProperty(
				parent,
				propertyAuditingData.getName(),
				globalCfg.getModifiedFlagSuffix(),
				columnName
		);
	}
","	public void addModifiedColumns(
			GlobalConfiguration globalCfg,
			Value value,
			Element parent,
			PropertyAuditingData propertyAuditingData) {
		final String columnName;
		if ( propertyAuditingData.isModifiedFlagNameExplicitlySpecified() ) {
			columnName = propertyAuditingData.getExplicitModifiedFlagName();
		}
		else {
			columnName = propertyAuditingData.getModifiedFlagName();
		}
		MetadataTools.addModifiedFlagProperty(
				parent,
				propertyAuditingData.getName(),
				globalCfg.getModifiedFlagSuffix(),
				columnName
		);
	}
"
1609,"Why is this final and condition not? Same issue on line 130. Since final is normally not used for local variables in spock, I'd remove it.","  private boolean isFailedEqualityComparison(Throwable exception) {
    if (!(exception instanceof ConditionNotSatisfiedError)) return false;

    final ConditionNotSatisfiedError conditionNotSatisfiedError = (ConditionNotSatisfiedError) exception;
    Condition condition = conditionNotSatisfiedError.getCondition();
    ExpressionInfo expr = condition.getExpression();
    return expr != null && expr.isEqualityComparison() && // it is equality
        conditionNotSatisfiedError.getCause() == null;    // and it is not failed because of exception
  }
","  private boolean isFailedEqualityComparison(Throwable exception) {
    if (!(exception instanceof ConditionNotSatisfiedError)) return false;

START     final ConditionNotSatisfiedError conditionNotSatisfiedError = (ConditionNotSatisfiedError) exception; END 
    Condition condition = conditionNotSatisfiedError.getCondition();
    ExpressionInfo expr = condition.getExpression();
    return expr != null && expr.isEqualityComparison() && // it is equality
        conditionNotSatisfiedError.getCause() == null;    // and it is not failed because of exception
  }
","  private boolean isFailedEqualityComparison(Throwable exception) {
    if (!(exception instanceof ConditionNotSatisfiedError)) return false;

    ConditionNotSatisfiedError conditionNotSatisfiedError = (ConditionNotSatisfiedError) exception;
    Condition condition = conditionNotSatisfiedError.getCondition();
    ExpressionInfo expr = condition.getExpression();
    return expr != null && expr.isEqualityComparison() && // it is equality
        conditionNotSatisfiedError.getCause() == null;    // and it is not failed because of exception
  }
"
1610,These checks are not necessary for logout.,"    public final RedirectAction getLogoutRedirectAction(final WebContext context) {
        // it's an AJAX request -> unauthorized (instead of a redirection)
        if (ajaxRequestResolver.isAjax(context)) {
            logger.info(""AJAX request detected -> returning 401"");
            cleanRequestedUrl(context);
            return null;
        }
        // authentication has already been tried -> unauthorized
        final String attemptedAuth = (String) context.getSessionAttribute(getName() + ATTEMPTED_AUTHENTICATION_SUFFIX);
        if (CommonHelper.isNotBlank(attemptedAuth)) {
        	return null;
        }

        init(context);
        return retrieveLogoutRedirectAction(context);
    }
","    public final RedirectAction getLogoutRedirectAction(final WebContext context) {
        // it's an AJAX request -> unauthorized (instead of a redirection)
START         if (ajaxRequestResolver.isAjax(context)) { END 
            logger.info(""AJAX request detected -> returning 401"");
            cleanRequestedUrl(context);
            return null;
        }
        // authentication has already been tried -> unauthorized
        final String attemptedAuth = (String) context.getSessionAttribute(getName() + ATTEMPTED_AUTHENTICATION_SUFFIX);
        if (CommonHelper.isNotBlank(attemptedAuth)) {
        	return null;
        }

        init(context);
        return retrieveLogoutRedirectAction(context);
    }
","    public final RedirectAction getLogoutRedirectAction(final WebContext context) {
        init(context);
        return retrieveLogoutRedirectAction(context);
    }
"
1611,debug/trace/remove?,"    public void setMainTabSelectedItem(Erratum selectedItem) {
        logger.info(""setMainTabSelectedItem""); //$NON-NLS-1$
        updateErrataDetailFormPanel(selectedItem);
    }
","    public void setMainTabSelectedItem(Erratum selectedItem) {
START         logger.info(""setMainTabSelectedItem""); //$NON-NLS-1$ END 
        updateErrataDetailFormPanel(selectedItem);
    }
","    public void setMainTabSelectedItem(Erratum selectedItem) {
        updateErrataDetailFormPanel(selectedItem);
    }
"
1612,"If we need to do this, I feel like we can at least do this somewhere else. A binding for something like DiscoveryManagerInitializer with dependencies on these Config classes might work.","    public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) {
        this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION);
        
        this.namespace = namespace;
        this.config = config.getPrefixedView(namespace);
        this.dcInfo = dcInfo;

        // TODO: Remove this when DiscoveryManager is finally no longer used
        DiscoveryManager.getInstance().setEurekaInstanceConfig(this);
    }
","    public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) {
        this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION);
        
        this.namespace = namespace;
        this.config = config.getPrefixedView(namespace);
        this.dcInfo = dcInfo;

        // TODO: Remove this when DiscoveryManager is finally no longer used
START         DiscoveryManager.getInstance().setEurekaInstanceConfig(this); END 
    }
","    public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) {
        this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION);
        this.namespace = namespace;
        this.config = config.getPrefixedView(namespace);
        this.dcInfo = dcInfo;
    }
"
1613,"Right here (and in the equivalent 3.0 class) is the only place you're using ""this"" where a field isn't shadowed, is this intentional?","    public AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest body, WebServiceContext context) {
        AssertionType assertion = getAssertion(context, null);
        if (assertion != null) {
            assertion.setImplementsSpecVersion(UDDI_SPEC_VERSION.SPEC_2_0.toString());
        }

        return inboundDocQuery.respondingGatewayCrossGatewayQuery(body, assertion, this.getWebContextProperties(context));
    }
","    public AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest body, WebServiceContext context) {
        AssertionType assertion = getAssertion(context, null);
        if (assertion != null) {
            assertion.setImplementsSpecVersion(UDDI_SPEC_VERSION.SPEC_2_0.toString());
        }

START         return inboundDocQuery.respondingGatewayCrossGatewayQuery(body, assertion, this.getWebContextProperties(context)); END 
    }
","    public AdhocQueryResponse respondingGatewayCrossGatewayQuery(AdhocQueryRequest body, WebServiceContext context) {
        AssertionType assertion = getAssertion(context, null);
        if (assertion != null) {
            assertion.setImplementsSpecVersion(UDDI_SPEC_VERSION.SPEC_2_0.toString());
        }

        return inboundDocQuery.respondingGatewayCrossGatewayQuery(body, assertion, getWebContextProperties(context));
    }
"
1614,Drop this empty block.,"    public void allBindingsChanged(BindingProvider provider) {
        logger.trace(""allBindingsChanged() called."");
        if (provider instanceof VeluxBindingProvider) {
        }
        super.allBindingsChanged(provider);
    }
","    public void allBindingsChanged(BindingProvider provider) {
        logger.trace(""allBindingsChanged() called."");
START         if (provider instanceof VeluxBindingProvider) { END 
        }
        super.allBindingsChanged(provider);
    }
","    public void allBindingsChanged(BindingProvider provider) {
        logger.trace(""allBindingsChanged() called."");
        super.allBindingsChanged(provider);
    }
"
1615,"Please, remove `final` modifiers as they seem to be redundant.","    private Map<String, String> makeParserFields() {
      final Map<String, String> fieldMapping = Maps.newHashMap();
      for (final SchemaPath sp : getColumns()) {
        final String drillField = sp.getRootSegment().getPath();
        try {
          final String parserField = HttpdParser.parserFormattedFieldName(drillField);
          fieldMapping.put(drillField, parserField);
        } catch (Exception e) {
          LOG.info(""Putting field: "" + drillField + "" into map"", e);
        }
      }
      return fieldMapping;
    }
","    private Map<String, String> makeParserFields() {
      final Map<String, String> fieldMapping = Maps.newHashMap();
      for (final SchemaPath sp : getColumns()) {
        final String drillField = sp.getRootSegment().getPath();
        try {
START           final String parserField = HttpdParser.parserFormattedFieldName(drillField); END 
          fieldMapping.put(drillField, parserField);
        } catch (Exception e) {
          LOG.info(""Putting field: "" + drillField + "" into map"", e);
        }
      }
      return fieldMapping;
    }
","    private Map<String, String> makeParserFields() {
      Map<String, String> fieldMapping = new HashMap<>();
      for (final SchemaPath sp : getColumns()) {
        String drillField = sp.getRootSegment().getPath();
        try {
          String parserField = HttpdParser.parserFormattedFieldName(drillField);
          fieldMapping.put(drillField, parserField);
        } catch (Exception e) {
          LOG.info(""Putting field: "" + drillField + "" into map"", e);
        }
      }
      return fieldMapping;
    }
"
1616,"Message needs changed. What does Retrofit do? Do we care if people overwrite this? I don't, and it breaks your `newBuilder()` desire.","    public Builder client(@NonNull OkHttpClient client) {
      if (client == null) {
        throw new NullPointerException(""client == null"");
      }
      if (downloader != null) {
        throw new IllegalArgumentException(""Downloader already set."");
      }
      downloader = new OkHttp3Downloader(client, client.cache(), true);
      return this;
    }
","    public Builder client(@NonNull OkHttpClient client) {
      if (client == null) {
        throw new NullPointerException(""client == null"");
      }
      if (downloader != null) {
        throw new IllegalArgumentException(""Downloader already set."");
      }
      downloader = new OkHttp3Downloader(client, client.cache(), true);
      return this;
START     } END 
","    public Builder client(@NonNull OkHttpClient client) {
      if (client == null) {
        throw new NullPointerException(""client == null"");
      }
      downloader = new OkHttp3Downloader(client, client.cache(), true);
      return this;
    }
"
1617,"Just a small remark feel free to skip it.
It would have a nicer look if you keep if else logic direct like
 if (activity == null) {
           return Optional.empty();
        } else {
            final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity;
            return Optional.of((CoverageReportView) coverageActivity.getWidget());
        }","    protected Optional<CoverageReportView> getCoverageReportView(PlaceRequest placeRequest) {
        final Activity activity = placeManager.getActivity(placeRequest);
        if (activity != null) {
            final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity;
            return Optional.of((CoverageReportView) coverageActivity.getWidget());
        } else {
            return Optional.empty();
        }
    }
","    protected Optional<CoverageReportView> getCoverageReportView(PlaceRequest placeRequest) {
        final Activity activity = placeManager.getActivity(placeRequest);
START         if (activity != null) { END 
            final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity;
            return Optional.of((CoverageReportView) coverageActivity.getWidget());
        } else {
            return Optional.empty();
        }
    }
","    protected Optional<CoverageReportView> getCoverageReportView(PlaceRequest placeRequest) {
        final Activity activity = placeManager.getActivity(placeRequest);
        if (activity == null) {
            return Optional.empty();
        } else {
            final AbstractWorkbenchActivity coverageActivity = (AbstractWorkbenchActivity) activity;
            return Optional.of((CoverageReportView) coverageActivity.getWidget());
        }
    }
"
1618,"Generally you don't sort the VMs, and in the one case where you do - you don't really sort them either, but just move one to the top of the list. So firstly, consider dropping this method, making edit() protected and add the logic only in VmAffinityGroupListModel. Secondly, you could drop the comparator there and just iterate over the items to find the specific ID and move it to the top of the list, the comparator thing isn't necessary.","    private void edit() {
        if (getWindow() != null) {
            return;
        }
        AffinityGroup affinityGroup = getSelectedItem();
        if (affinityGroup == null) {
            return;
        }
        sortVms(affinityGroup);
        AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver());
        model.init();
        setWindow(model);
    }
","    private void edit() {
        if (getWindow() != null) {
            return;
        }
        AffinityGroup affinityGroup = getSelectedItem();
        if (affinityGroup == null) {
            return;
        }
START         sortVms(affinityGroup); END 
        AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver());
        model.init();
        setWindow(model);
    }
","    private void edit() {
        if (getWindow() != null) {
            return;
        }
        AffinityGroup affinityGroup = getSelectedItem();
        if (affinityGroup == null) {
            return;
        }
        AffinityGroupModel model = new EditAffinityGroupModel(affinityGroup, this, getClusterResolver());
        model.init();
        setWindow(model);
    }
"
1619,"Considering the expected exception for this test, it seems like the `assertThat` is superfluous, and all we really want is `itty.hasNext();`","    public void testIteratorCloses() throws Exception
    {
        Kabob bob = db.getJdbi().onDemand(Kabob.class);

        Iterator<Something> itty = bob.iterateAll();
        assertThat(itty.hasNext()).isFalse();
    }
","    public void testIteratorCloses() throws Exception
    {
        Kabob bob = db.getJdbi().onDemand(Kabob.class);

        Iterator<Something> itty = bob.iterateAll();
START         assertThat(itty.hasNext()).isFalse(); END 
    }
","    public void testIteratorCloses() throws Exception
    {
        Kabob bob = db.getJdbi().onDemand(Kabob.class);

        Iterator<Something> itty = bob.iterateAll();
        itty.hasNext();
    }
"
1620,Cant the class name be included here so we know where this method is being called from.,"	public static void assertSwappedIngredientsMatch(ObjectInstance ing, State s, List<String> ings) {
		Set<String> swappedIngredients = IngredientFactory.getRecursiveContentsAndSwapped(s, ing);
		Boolean match = true;
		assertEquals(swappedIngredients.size(), ings.size());
		for (String i : ings) {
			if (!swappedIngredients.contains(i)) {
				match = false;
				break;
			}
		}
		assertTrue(match);
	}
","	public static void assertSwappedIngredientsMatch(ObjectInstance ing, State s, List<String> ings) {
		Set<String> swappedIngredients = IngredientFactory.getRecursiveContentsAndSwapped(s, ing);
		Boolean match = true;
START 		assertEquals(swappedIngredients.size(), ings.size()); END 
		for (String i : ings) {
			if (!swappedIngredients.contains(i)) {
				match = false;
				break;
			}
		}
		assertTrue(match);
	}
","	public static void assertSwappedIngredientsMatch(ObjectInstance ing, State s, List<String> ings) {
		Set<String> swappedIngredients = IngredientFactory.getRecursiveContentsAndSwapped(s, ing);
		Boolean match = true;
		Assert.assertEquals(swappedIngredients.size(), ings.size());
		for (String i : ings) {
			if (!swappedIngredients.contains(i)) {
				match = false;
				break;
			}
		}
		Assert.assertTrue(match);
	}
"
1621,Edge case of duplicate code ;) It could be extracted to a common private method with two params for id and type. Up to you if you want to change it or not ;),"	public List<Document> getClientDocuments(String clientId) throws MambuApiException {

		if (clientId == null || clientId.trim().isEmpty()) {
			throw new IllegalArgumentException(""ClientId ID must not be null or empty"");
		}

		return DocumentsService.getDocuments(mambuAPIService, CLIENTS, clientId);
	}
","	public List<Document> getClientDocuments(String clientId) throws MambuApiException {

START 		if (clientId == null || clientId.trim().isEmpty()) { END 
			throw new IllegalArgumentException(""ClientId ID must not be null or empty"");
		}

		return DocumentsService.getDocuments(mambuAPIService, CLIENTS, clientId);
	}
","	public List<Document> getClientDocuments(String clientId) throws MambuApiException {

		if (clientId == null || clientId.trim().isEmpty()) {
			throw new IllegalArgumentException(""ClientId ID must not be null or empty"");
		}

		return new DocumentsService(mambuAPIService).getDocuments(CLIENTS, clientId);
	}
"
1622,"Now this should return true, since there are disks on the storage domain (Remember that you don't check the validate only the method checkDisksInBackupStorage)
Change to assertTrue","    public void testFailForCheckDisksNotInBackupStorage() {
        final VM vm = new VM();
        command.setVm(vm);
        when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
        command.setCluster(new Cluster());
        Guid storageDomainId = initDiskImage(vm);
        when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true));
        assertFalse(""checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain"",
                command.checkDisksInBackupStorage());
    }
","    public void testFailForCheckDisksNotInBackupStorage() {
        final VM vm = new VM();
        command.setVm(vm);
        when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
        command.setCluster(new Cluster());
        Guid storageDomainId = initDiskImage(vm);
        when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true));
START         assertFalse(""checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain"", END 
                command.checkDisksInBackupStorage());
    }
","    public void testFailForCheckDisksNotInBackupStorage() {
        final VM vm = new VM();
        command.setVm(vm);
        when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
        command.setCluster(new Cluster());
        Guid storageDomainId = initDiskImage(vm);
        when(storageDomainStaticDao.get(storageDomainId)).thenReturn(backupStorageDomain(true));
        assertTrue(""checkDisksNotInBackupStorage() fails to run because one or more disk is in backup domain"",
                command.checkDisksInBackupStorage());
    }
"
1623,shouldn't be the ```max()``` between ```offset``` and ```skip``` to avoid the ```pos``` to be previous than ```offset```?,"   public long skip(long n) {
      if (n > 0) {
         long skip = bytes.length - pos;
         if (skip > n)
            skip = n;

         pos += skip;
         return skip;
      } else {
         int idx = Math.min(bytes.length, pos);
         long skip = idx + n;
         pos = (int) skip;
         return skip;
      }
   }
","   public long skip(long n) {
      if (n > 0) {
         long skip = bytes.length - pos;
         if (skip > n)
            skip = n;

         pos += skip;
         return skip;
      } else {
         int idx = Math.min(bytes.length, pos);
         long skip = idx + n;
START          pos = (int) skip; END 
         return skip;
      }
   }
","   public long skip(long n) {
      if (n > 0) {
         long skip = bytes.length - pos;
         if (skip > n)
            skip = n;

         pos += skip;
         return skip;
      } else {
         int idx = Math.min(bytes.length, pos);
         long skip = idx + n;
         // Calculate max to avoid skipping before offset
         pos = (int) Math.max(skip, offset);
         return skip;
      }
   }
"
1624,You may want to put this into a try/finally block.,"  public void actionPerformed(AnActionEvent e) {
    BaseAction.State s = setupAction(e);
    List<String> lastTask = Collections.singletonList(s.getLastRanTask());
    s.performTasks(lastTask);
    s.cleanup();
  }
","  public void actionPerformed(AnActionEvent e) {
    BaseAction.State s = setupAction(e);
    List<String> lastTask = Collections.singletonList(s.getLastRanTask());
    s.performTasks(lastTask);
    START s.cleanup(); END 
  }
","  public void actionPerformed(AnActionEvent e) {
    BaseAction.State s = setupAction(e);
    try {
      List<String> lastTask = Collections.singletonList(s.getLastRanTask());
      s.performTasks(lastTask);
    }
    finally {
      s.cleanup();
    }
  }
"
1625,rename to s,"	public void addAll(SerializableStatus status) {
		Assert.isLegal(status != null);
		SerializableStatus[] statuses = (SerializableStatus[]) status.getChildren();
		for (SerializableStatus statuse : statuses) {
			add(statuse);
		}
	}
","	public void addAll(SerializableStatus status) {
		Assert.isLegal(status != null);
		SerializableStatus[] statuses = (SerializableStatus[]) status.getChildren();
		for (SerializableStatus START  statuse : END  statuses) {
			add(statuse);
		}
	}
","	public void addAll(SerializableStatus status) {
		Assert.isLegal(status != null);
		SerializableStatus[] statuses = (SerializableStatus[]) status.getChildren();
		for (SerializableStatus s : statuses) {
			add(s);
		}
	}
"
1626,"how about moving logicalNetworkExists() after changesAreClusterCompatible() ?

in case changesAreClusterCompatible() returns false, it will save one DB call :)","    protected boolean canDoAction() {
        return super.canDoAction() && VdsGroupExists() && logicalNetworkExists() && changesAreClusterCompatible();
    }
","    protected boolean canDoAction() {
START         return super.canDoAction() && VdsGroupExists() && logicalNetworkExists() && changesAreClusterCompatible(); END 
    }
","    protected boolean canDoAction() {
        return super.canDoAction() && VdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists();
    }
"
1627,"any reason you can't just iterate through the values?

    schemaTableMapping.values().foreach(v -> v.invalidateAll());
    schemaTableMapping.clear();","    protected void reloadCache()
    {
        schemaMappingCache.invalidateAll();

        // this preloads the list of schema names
        Set<String> schemas = getSchemaNames();

        // invalidate and remove from the schema table mapping all records, start from scratch
        for (String key : schemaTableMapping.keySet()) {
            schemaTableMapping.get(key).invalidateAll();
            schemaTableMapping.remove(key);
        }

        for (final String schema : schemas) {
            // this preloads the list of table names for each schema
            getTableNames(schema);
        }
    }
","    protected void reloadCache()
    {
        schemaMappingCache.invalidateAll();

        // this preloads the list of schema names
        Set<String> schemas = getSchemaNames();

        // invalidate and remove from the schema table mapping all records, start from scratch
        for (String key : schemaTableMapping.keySet()) {
            schemaTableMapping.get(key).invalidateAll();
            schemaTableMapping.remove(key);
START         } END 

        for (final String schema : schemas) {
            // this preloads the list of table names for each schema
            getTableNames(schema);
        }
    }
","    protected void reloadCache()
    {
        schemaMappingCache.invalidateAll();

        // this preloads the list of schema names
        Set<String> schemas = getSchemaNames();

        // invalidate and remove from the schema table mapping all records, start from scratch
        schemaTableMapping.keySet().forEach(key -> {
            schemaTableMapping.get(key).invalidateAll();
        });
        schemaTableMapping.clear();

        for (final String schema : schemas) {
            // this preloads the list of table names for each schema
            getTableNames(schema);
        }
    }
"
1628,This assertion could be removed as it seems to test the Java type system rather than our code,"    public void testSetUser() {
        Configuration configuration = generateConfiguration();
        configuration.setUser(""24601"", ""m@rp.fr"", ""MM"");
        assertEquals(User.class, configuration.getUser().getClass());
        assertEquals(""24601"", configuration.getUser().getId());
        assertEquals(""m@rp.fr"", configuration.getUser().getEmail());
        assertEquals(""MM"", configuration.getUser().getName());
    }
","    public void testSetUser() {
        Configuration configuration = generateConfiguration();
        configuration.setUser(""24601"", ""m@rp.fr"", ""MM"");
START         assertEquals(User.class, configuration.getUser().getClass()); END 
        assertEquals(""24601"", configuration.getUser().getId());
        assertEquals(""m@rp.fr"", configuration.getUser().getEmail());
        assertEquals(""MM"", configuration.getUser().getName());
    }
","    public void testSetUser() {
        Configuration configuration = generateConfiguration();
        configuration.setUser(""24601"", ""m@rp.fr"", ""MM"");
        assertEquals(""24601"", configuration.getUser().getId());
        assertEquals(""m@rp.fr"", configuration.getUser().getEmail());
        assertEquals(""MM"", configuration.getUser().getName());
    }
"
1629,No need to call `file.toString()` -> `FileWriter` can take `File` in the constructor as well.,"    private void writeStringToFile(File file, String str) throws IOException {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.toString()))) {
            bw.write(str);
        }
    }
","    private void writeStringToFile(File file, String str) throws IOException {
START         try (BufferedWriter bw = new BufferedWriter(new FileWriter(file.toString()))) { END 
            bw.write(str);
        }
    }
","    private void writeStringToFile(File file, String str) throws IOException {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {
            bw.write(str);
        }
    }
"
1630,"Minor: the two calls could be collapsed, since `DimensionHandlerUtils.convertObjectToLong` handles nulls just fine.","  private RelNode possiblyWrapRootWithOuterLimitFromContext(
      RelRoot root
  )
  {
    Object outerLimitObj = plannerContext.getQueryContext().get(PlannerContext.CTX_SQL_OUTER_LIMIT);
    if (outerLimitObj == null) {
      return root.rel;
    }
    Long outerLimit = DimensionHandlerUtils.convertObjectToLong(outerLimitObj, true);
    if (outerLimit == null) {
      return root.rel;
    }

    return LogicalSort.create(
        root.rel,
        root.collation,
        makeBigIntLiteral(0),
        makeBigIntLiteral(outerLimit)
    );
  }
","  private RelNode possiblyWrapRootWithOuterLimitFromContext(
      RelRoot root
  )
  {
    Object outerLimitObj = plannerContext.getQueryContext().get(PlannerContext.CTX_SQL_OUTER_LIMIT);
    if (outerLimitObj == null) {
      return root.rel;
    }
START     Long outerLimit = DimensionHandlerUtils.convertObjectToLong(outerLimitObj, true); END 
    if (outerLimit == null) {
      return root.rel;
    }

    return LogicalSort.create(
        root.rel,
        root.collation,
        makeBigIntLiteral(0),
        makeBigIntLiteral(outerLimit)
    );
  }
","  private RelNode possiblyWrapRootWithOuterLimitFromContext(
      RelRoot root
  )
  {
    Object outerLimitObj = plannerContext.getQueryContext().get(PlannerContext.CTX_SQL_OUTER_LIMIT);
    Long outerLimit = DimensionHandlerUtils.convertObjectToLong(outerLimitObj, true);
    if (outerLimit == null) {
      return root.rel;
    }

    return LogicalSort.create(
        root.rel,
        root.collation,
        makeBigIntLiteral(0),
        makeBigIntLiteral(outerLimit)
    );
  }
"
1631,nit - ConfigException is unused,"    public void testSamePortConfiguredForClientAndElection() throws IOException, ConfigException {
        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();
        try {
            Properties zkProp = getDefaultZKProperties();
            zkProp.setProperty(""server.1"", ""localhost:2888:2888"");
            quorumPeerConfig.parseProperties(zkProp);
            fail(""ConfigException is expected"");
        } catch (ConfigException ce) {
            String expectedMessage = ""Client and election port must be different! Please update the configuration file on server.1"";
            assertEquals(expectedMessage, ce.getMessage());
        }
    }
","START     public void testSamePortConfiguredForClientAndElection() throws IOException, ConfigException { END 
        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();
        try {
            Properties zkProp = getDefaultZKProperties();
            zkProp.setProperty(""server.1"", ""localhost:2888:2888"");
            quorumPeerConfig.parseProperties(zkProp);
            fail(""ConfigException is expected"");
        } catch (ConfigException ce) {
            String expectedMessage = ""Client and election port must be different! Please update the configuration file on server.1"";
            assertEquals(expectedMessage, ce.getMessage());
        }
    }
","    public void testSamePortConfiguredForClientAndElection() throws IOException, ConfigException {
        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();
        Properties zkProp = getDefaultZKProperties();
        zkProp.setProperty(""server.1"", ""localhost:2888:2888"");
        quorumPeerConfig.parseProperties(zkProp);
    }
"
1632,ConnectException is not actually thrown by anything... it shouldn't be declared in the `throws`,"	public static URLConnection openURLConnection(URL url)
			throws IOException, ConnectException {

		return openURLConnection(url,DEFAULT_CONNECTION_TIMEOUT);

	}
","	public static URLConnection openURLConnection(URL url)
START 			throws IOException, ConnectException { END 

		return openURLConnection(url,DEFAULT_CONNECTION_TIMEOUT);

	}
","	public static URLConnection openURLConnection(URL url) throws IOException {
		return openURLConnection(url,DEFAULT_CONNECTION_TIMEOUT);
	}
"
1633,"1. let's replace with params.forEach

2. it makes more sense that this method will reside in HostSetupNetworksParametersBuilder - I don't see how its related to ""ReportFailedChildHostOperationsUtil""","    public void updateParentCommandId(ArrayList<VdcActionParametersBase> parameters, CommandBase command) {
        for (VdcActionParametersBase param : parameters) {
            param.setParentCommand(command.getActionType());
            param.setParentParameters(command.getParameters());
        }
    }
","    public void updateParentCommandId(ArrayList<VdcActionParametersBase> parameters, CommandBase command) {
START         for (VdcActionParametersBase param : parameters) { END 
            param.setParentCommand(command.getActionType());
            param.setParentParameters(command.getParameters());
        }
    }
","    public void updateParentCommandId(ArrayList<VdcActionParametersBase> parameters, CommandBase command) {
        parameters.forEach(param -> {
            param.setParentCommand(command.getActionType());
            param.setParentParameters(command.getParameters());
        });
    }
"
1634,nm.  I misread the diff. I thought ```getDatapointsForRange()``` only called ```getNumericMetricDataForRange()```,"    public MetricData getDatapointsForRange(Locator locator, Range range, Granularity gran) {
        RollupType rollupType = null;
        String rollupTypeStr = metaCache.safeGet(locator, rollupTypeCacheKey);
        if ( rollupTypeStr != null ) {
            rollupType = RollupType.fromString(rollupTypeStr);
        }
        if ( rollupType == null ) {
            rollupType = RollupType.BF_BASIC;
        }

        return getNumericMetricDataForRange(locator, range, gran, rollupType);
    }
","    public MetricData getDatapointsForRange(Locator locator, Range range, Granularity gran) {
        RollupType rollupType = null;
        String rollupTypeStr = metaCache.safeGet(locator, rollupTypeCacheKey);
        if ( rollupTypeStr != null ) {
            rollupType = RollupType.fromString(rollupTypeStr);
        }
        if ( rollupType == null ) {
            rollupType = RollupType.BF_BASIC;
        }

START         return getNumericMetricDataForRange(locator, range, gran, rollupType); END 
    }
","    public MetricData getDatapointsForRange(Locator locator, Range range, Granularity gran) {
        RollupType rollupType = RollupType.BF_BASIC;
        String rollupTypeStr = metaCache.safeGet(locator, rollupTypeCacheKey);
        if ( rollupTypeStr != null ) {
            rollupType = RollupType.fromString(rollupTypeStr);
        }

        return getNumericMetricDataForRange(locator, range, gran, rollupType);
    }
"
1635,"to be null safe on here, I would suggest using stringutils.equalsignorecase or start the expression with the constant","    public boolean shouldProcessRequestedCashAdvancesFromSaeData() {
        return (getConcurParameterValue(ConcurParameterConstants.CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND).equalsIgnoreCase(KFSConstants.ParameterValues.YES));
    }
","    public boolean shouldProcessRequestedCashAdvancesFromSaeData() {
START         return (getConcurParameterValue(ConcurParameterConstants.CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND).equalsIgnoreCase(KFSConstants.ParameterValues.YES)); END 
    }
","    public boolean shouldProcessRequestedCashAdvancesFromSaeData() {
        return (StringUtils.equalsIgnoreCase(getConcurParameterValue(ConcurParameterConstants.CONCUR_PROCESS_CASH_ADVANCES_FROM_SAE_DATA_IND), KFSConstants.ParameterValues.YES));
    }
"
1636,"Looks that works OK, but for me it's hard to read. I would rather see better readable return.","    static Path resolvePath(Path file,
                            String workingDirectory) {
        return file == null ? null : (file.isAbsolute() ? file : (file.getFileName().startsWith(File.separator) ? file.toAbsolutePath() : (Paths.get(workingDirectory,
                                                                                                                                                     file.getFileName().toString()))));
    }
","    static Path resolvePath(Path file,
                            String workingDirectory) {
START         return file == null ? null : (file.isAbsolute() ? file : (file.getFileName().startsWith(File.separator) ? file.toAbsolutePath() : (Paths.get(workingDirectory, END 
                                                                                                                                                     file.getFileName().toString()))));
    }
","    static Path resolvePath(Path file, String workingDirectory) {
        if(file == null){
            return null;
        }else if(file.isAbsolute()){
            return file;
        }else if(file.getFileName().startsWith(File.separator)){
            return file.toAbsolutePath();
        }else{
            return Paths.get(workingDirectory, file.getFileName().toString());
        }
    }
"
1637,Let's only use DsfDebugOptions.DEBUG_SESSION_LISTENERS here but have it include the others directly in DsfDebugOptions.,"    public void removeServiceEventListener(Object listener) {
        assert getExecutor().isInExecutorThread();

        ListenerEntry entry = new ListenerEntry(listener, null);
        if (DsfDebugOptions.DEBUG && DsfDebugOptions.DEBUG_SESSION && DsfDebugOptions.DEBUG_SESSION_LISTENERS) {
        	String msg = new Formatter().format(
        			""%s %s removed as a service listener to %s (id=%s)"", //$NON-NLS-1$
        			DsfPlugin.getDebugTime(),
        			LoggingUtils.toString(listener),
        			LoggingUtils.toString(this),
        			getId()
        			).toString();
        	DsfDebugOptions.trace(msg);
        }
        fListeners.remove(entry);
    }
","    public void removeServiceEventListener(Object listener) {
        assert getExecutor().isInExecutorThread();

        ListenerEntry entry = new ListenerEntry(listener, null);
START         if (DsfDebugOptions.DEBUG && DsfDebugOptions.DEBUG_SESSION && DsfDebugOptions.DEBUG_SESSION_LISTENERS) { END 
        	String msg = new Formatter().format(
        			""%s %s removed as a service listener to %s (id=%s)"", //$NON-NLS-1$
        			DsfPlugin.getDebugTime(),
        			LoggingUtils.toString(listener),
        			LoggingUtils.toString(this),
        			getId()
        			).toString();
        	DsfDebugOptions.trace(msg);
        }
        fListeners.remove(entry);
    }
","    public void removeServiceEventListener(Object listener) {
        assert getExecutor().isInExecutorThread();

        ListenerEntry entry = new ListenerEntry(listener, null);
        if (DsfDebugOptions.DEBUG_SESSION_LISTENERS) {
        	String msg = new Formatter().format(
        			""%s %s removed as a service listener to %s (id=%s)"", //$NON-NLS-1$
        			DsfPlugin.getDebugTime(),
        			LoggingUtils.toString(listener),
        			LoggingUtils.toString(this),
        			getId()
        			).toString();
        	DsfDebugOptions.trace(msg);
        }
        fListeners.remove(entry);
    }
"
1638,I smell an incoming NPE here...,"	private static void validateEntityLabel(EntityType entityType)
	{
		String label = entityType.getLabel();
		if (label.isEmpty())
		{
			throw new MolgenisValidationException(
					new ConstraintViolation(format(""Label of EntityType [%s] is empty"", entityType.getId())));
		}
		else if (label.trim().equals(""""))
		{
			throw new MolgenisValidationException(new ConstraintViolation(
					format(""Label of EntityType [%s] contains only white space"", entityType.getId())));
		}
	}
","	private static void validateEntityLabel(EntityType entityType)
	{
		String label = entityType.getLabel();
START 		if (label.isEmpty()) END 
		{
			throw new MolgenisValidationException(
					new ConstraintViolation(format(""Label of EntityType [%s] is empty"", entityType.getId())));
		}
		else if (label.trim().equals(""""))
		{
			throw new MolgenisValidationException(new ConstraintViolation(
					format(""Label of EntityType [%s] contains only white space"", entityType.getId())));
		}
	}
","	private static void validateEntityLabel(EntityType entityType)
	{
		String label = entityType.getLabel();
		if (label != null)
		{
			if (label.isEmpty())
			{
				throw new MolgenisValidationException(
						new ConstraintViolation(format(""Label of EntityType [%s] is empty"", entityType.getId())));
			}
			else if (label.trim().equals(""""))
			{
				throw new MolgenisValidationException(new ConstraintViolation(
						format(""Label of EntityType [%s] contains only white space"", entityType.getId())));
			}
		}
	}
"
1639,We could just call deleteIfExists(path) since it's same.,"    public void deleteIfExists(File path, String user, String logPrefix) throws IOException {
        LOG.info(""Deleting path {}"", path);
        Path p = path.toPath();
        if (Files.exists(p)) {
            try {
                FileUtils.forceDelete(path);
            } catch (FileNotFoundException ignored) {}
        }
    }
","    public void deleteIfExists(File path, String user, String logPrefix) throws IOException {
START         LOG.info(""Deleting path {}"", path); END 
        Path p = path.toPath();
        if (Files.exists(p)) {
            try {
                FileUtils.forceDelete(path);
            } catch (FileNotFoundException ignored) {}
        }
    }
","    public void deleteIfExists(File path, String user, String logPrefix) throws IOException {
        //by default no need to do this as a different user
        deleteIfExists(path);
    }
"
1640,This could be even `if (dedicatedTransport != transport)`,"   protected void releaseTransport(Transport transport) {
      if (dedicatedTransport == null) {
         //we aren't using this transport. we can release it
         super.releaseTransport(transport);
      }
   }
","   protected void releaseTransport(Transport transport) {
START       if (dedicatedTransport == null) { END 
         //we aren't using this transport. we can release it
         super.releaseTransport(transport);
      }
   }
","   protected void releaseTransport(Transport transport) {
      if (dedicatedTransport != transport) {
         //we aren't using this transport. we can release it
         super.releaseTransport(transport);
      }
   }
"
1641,You probably made it a couple of thousand times slower :-) Keys rarely overlap in this domain creating a StringBuilder has an initialization cost that is not amortized.,"	String prepare(String name, Map<String, Map<String, String>> domain) {
		StringBuilder builder = new StringBuilder(name);
		while (domain.containsKey(name)) {
			builder.append(""~"");
		}
		domain.put(builder.toString(), new LinkedHashMap<>());
		return builder.toString();
	}
","	String prepare(String name, Map<String, Map<String, String>> domain) {
		StringBuilder builder = new StringBuilder(name);
		while (domain.containsKey(name)) {
START 			builder.append(""~""); END 
		}
		domain.put(builder.toString(), new LinkedHashMap<>());
		return builder.toString();
	}
","	String prepare(String name, Map<String, Map<String, String>> domain) {
		StringBuilder builder = new StringBuilder(name);
		while (domain.containsKey(name)) {
			builder.append(""~"");
		}
		String val = builder.toString();
		domain.put(val, new LinkedHashMap<>());
		return val;
	}
"
1642,is this a RuntimeException? In which case you probably don't want to catch it.,"    public synchronized void deleteFile() {
        closeFile();

        File historyTreeFile = fConfig.getStateFile();
        try {
            if (!historyTreeFile.delete()) {
                /* We didn't succeed in deleting the file */
                Activator.getDefault().logError(""Failed to delete"" + historyTreeFile.getName()); //$NON-NLS-1$
            }
        } catch (SecurityException e) {
            Activator.getDefault().logError(e.getMessage(), e);
        }
    }
","    public synchronized void deleteFile() {
        closeFile();

        File historyTreeFile = fConfig.getStateFile();
        try {
            if (!historyTreeFile.delete()) {
                /* We didn't succeed in deleting the file */
                Activator.getDefault().logError(""Failed to delete"" + historyTreeFile.getName()); //$NON-NLS-1$
            }
START         } catch (SecurityException e) { END 
            Activator.getDefault().logError(e.getMessage(), e);
        }
    }
","    public synchronized void deleteFile() {
        closeFile();

        File historyTreeFile = fConfig.getStateFile();
        if (!historyTreeFile.delete()) {
            /* We didn't succeed in deleting the file */
            Activator.getDefault().logError(""Failed to delete"" + historyTreeFile.getName()); //$NON-NLS-1$
        }
    }
"
1643,"Replace method content with...

super.delete(userEntityFile);

...as the underlying code will not only delete the entity but also fire an event about it.","  public void delete(UserEntityFile userEntityFile) {
    getEntityManager().remove(userEntityFile);
  }
","  public void delete(UserEntityFile userEntityFile) {
START     getEntityManager().remove(userEntityFile); END 
  }
","  public void delete(UserEntityFile userEntityFile) {
    super.delete(userEntityFile);
  }
"
1644,If we allow to create sub class of this **DubboConfigBindingBeanPostProcessor ** and some **init method** get override then it might cause issue. So better to make init final or provide. What do you say?,"    public void init() {

        if (dubboConfigBinder == null) {
            try {
                dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class);
            } catch (BeansException ignored) {
                if (log.isDebugEnabled()) {
                    log.debug(""DubboConfigBinder Bean can't be found in ApplicationContext."");
                }
                // Use Default implementation
                dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());
            }
        }

        dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);
        dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);

    }
","START     public void init() { END 

        if (dubboConfigBinder == null) {
            try {
                dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class);
            } catch (BeansException ignored) {
                if (log.isDebugEnabled()) {
                    log.debug(""DubboConfigBinder Bean can't be found in ApplicationContext."");
                }
                // Use Default implementation
                dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());
            }
        }

        dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);
        dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);

    }
","    private void init() {

        if (dubboConfigBinder == null) {
            try {
                dubboConfigBinder = applicationContext.getBean(DubboConfigBinder.class);
            } catch (BeansException ignored) {
                if (log.isDebugEnabled()) {
                    log.debug(""DubboConfigBinder Bean can't be found in ApplicationContext."");
                }
                // Use Default implementation
                dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());
            }
        }

        dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);
        dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);

    }
"
1645,I find it even easier to read without the `(...)`,"    public static void removeDuplicateImages(Feed feed) {
        Set<String> known = new HashSet<String>();
        for (FeedItem item : feed.getItems()) {
            String url = (item.hasItemImage()) ? item.getImage().getDownload_url() : null;
            if (url != null) {
                if (known.contains(url)) {
                    item.setImage(null);
                } else {
                    known.add(url);
                }
            }
        }
    }
","    public static void removeDuplicateImages(Feed feed) {
        Set<String> known = new HashSet<String>();
        for (FeedItem item : feed.getItems()) {
START             String url = (item.hasItemImage()) ? item.getImage().getDownload_url() : null; END 
            if (url != null) {
                if (known.contains(url)) {
                    item.setImage(null);
                } else {
                    known.add(url);
                }
            }
        }
    }
","    public static void removeDuplicateImages(Feed feed) {
        Set<String> known = new HashSet<String>();
        for (FeedItem item : feed.getItems()) {
            String url = item.hasItemImage() ? item.getImage().getDownload_url() : null;
            if (url != null) {
                if (known.contains(url)) {
                    item.setImage(null);
                } else {
                    known.add(url);
                }
            }
        }
    }
"
1646,Shouldn't this also be changed to super.selectedItemsChanged()?,"    protected void selectedItemsChanged() {
        super.onSelectedItemChanged();
        updateActionAvailability();
    }
","    protected void selectedItemsChanged() {
START         super.onSelectedItemChanged(); END 
        updateActionAvailability();
    }
","    protected void selectedItemsChanged() {
        super.selectedItemsChanged();
        updateActionAvailability();
    }
"
1647,"Shouldn't this loop release memory of ""discarded"" arrays? E.g. intArrays[intArraysTop] = null?","    public int[] borrowIntArray(int positionCount)
    {
        int[] array;
        while (intArraysTop >= 0 && intArrays[intArraysTop].length < positionCount) {
            estimatedSizeInBytes -= sizeOfIntArray(intArrays[intArraysTop].length);
            --intArraysTop;
        }

        if (intArraysTop < 0) {
            array = new int[positionCount];
            estimatedSizeInBytes += sizeOfIntArray(positionCount);
        }
        else {
            array = intArrays[intArraysTop];
            --intArraysTop;
        }

        ++borrowedIntArrays;

        return array;
    }
","    public int[] borrowIntArray(int positionCount)
    {
        int[] array;
START         while (intArraysTop >= 0 && intArrays[intArraysTop].length < positionCount) { END 
            estimatedSizeInBytes -= sizeOfIntArray(intArrays[intArraysTop].length);
            --intArraysTop;
        }

        if (intArraysTop < 0) {
            array = new int[positionCount];
            estimatedSizeInBytes += sizeOfIntArray(positionCount);
        }
        else {
            array = intArrays[intArraysTop];
            --intArraysTop;
        }

        ++borrowedIntArrays;

        return array;
    }
","    public int[] borrowIntArray(int positionCount)
    {
        int[] array;
        while (intArraysTop >= 0 && intArrays[intArraysTop].length < positionCount) {
            estimatedSizeInBytes -= sizeOfIntArray(intArrays[intArraysTop].length);
            intArrays[intArraysTop] = null;
            --intArraysTop;
        }

        if (intArraysTop < 0) {
            array = new int[positionCount];
            estimatedSizeInBytes += sizeOfIntArray(positionCount);
        }
        else {
            array = intArrays[intArraysTop];
            --intArraysTop;
        }

        ++borrowedIntArrays;

        return array;
    }
"
1648,I suspect that you want to preserve order here and return a List?,"  public Collection<MergeStrategySection> getAllMergeStrategySections() {
    List<MergeStrategySection> all = new ArrayList<MergeStrategySection>();
    all.addAll(getLocalMergeStrategySections());
    all.addAll(getInheritedMergeStrategySections());
    return all;
  }
","START   public Collection<MergeStrategySection> getAllMergeStrategySections() { END 
    List<MergeStrategySection> all = new ArrayList<MergeStrategySection>();
    all.addAll(getLocalMergeStrategySections());
    all.addAll(getInheritedMergeStrategySections());
    return all;
  }
","  public List<MergeStrategySection> getAllMergeStrategySections() {
    List<MergeStrategySection> all = new ArrayList<MergeStrategySection>();
    all.addAll(getLocalMergeStrategySections());
    all.addAll(getInheritedMergeStrategySections());
    return all;
  }
"
1649,Alias should never be null.,"  public String getDeleteDescription() {
    return getName() + (getAlias() == null ? """" : "" ("" + getAlias() + "")"");
  }
","  public String getDeleteDescription() {
START     return getName() + (getAlias() == null ? """" : "" ("" + getAlias() + "")""); END 
  }
","  public String getDeleteDescription() {
    return getName() + "" ("" + getAlias() + "")"";
  }
"
1650,"Is CouchbaseLiteException thrown from anything in this method? 
Or it should return void but throw CouchbaseLiteException instead?","    boolean selectCommonAncestor(ReadOnlyDocument doc1, ReadOnlyDocument doc2)
            throws CouchbaseLiteException {
        if (!c4doc.getRawDoc().selectCommonAncestorRevision(doc1.getRevID(), doc2.getRevID()))
            return false;
        setC4Doc(c4doc); // self.c4Doc = _c4Doc; // This will update to the selected revision
        return true;
    }
","    boolean selectCommonAncestor(ReadOnlyDocument doc1, ReadOnlyDocument doc2)
START             throws CouchbaseLiteException { END 
        if (!c4doc.getRawDoc().selectCommonAncestorRevision(doc1.getRevID(), doc2.getRevID()))
            return false;
        setC4Doc(c4doc); // self.c4Doc = _c4Doc; // This will update to the selected revision
        return true;
    }
","    boolean selectCommonAncestor(ReadOnlyDocument doc1, ReadOnlyDocument doc2) {
        if (!c4doc.getRawDoc().selectCommonAncestorRevision(doc1.getRevID(), doc2.getRevID()))
            return false;
        setC4Doc(c4doc); // self.c4Doc = _c4Doc; // This will update to the selected revision
        return true;
    }
"
1651,`protected`. It would be bad to allow end-user to mutate on this local property.,"	public void setHazelcastRegisteredEventListenerId(String hazelcastRegisteredEventListenerId) {
		this.hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId;
	}
","START 	public void setHazelcastRegisteredEventListenerId(String hazelcastRegisteredEventListenerId) { END 
		this.hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId;
	}
","	protected void setHazelcastRegisteredEventListenerId(String hazelcastRegisteredEventListenerId) {
		this.hazelcastRegisteredEventListenerId = hazelcastRegisteredEventListenerId;
	}
"
1652,"In what case can the file exist but be too long? If we are on a system with a longer filename limit, we should just use the existing file and not worry about the length, I think.","	protected String getFileName(ITask task, Predicate<String> fileExists) {
		String encodedFileName = CoreUtil.asFileName(task.getTaskId());

		// for backwards-compatibility with versions that always encoded file names,
		// we will use an encoded name if the file with an encoded name already exists
		if (encodedFileName.length() <= FILENAME_MAX_LEN && fileExists.test(encodedFileName)) {
			return encodedFileName;
		}

		// if file with encoded name does not exist, we will only encode file name if it is required
		String fileName;
		if (requiresEncoding(task.getTaskId())) {
			fileName = encodedFileName;
		} else {
			fileName = task.getTaskId();
		}

		// trim the file name if it is too long
		return trimFilenameIfRequired(fileName);
	}
","	protected String getFileName(ITask task, Predicate<String> fileExists) {
		String encodedFileName = CoreUtil.asFileName(task.getTaskId());

		// for backwards-compatibility with versions that always encoded file names,
		// we will use an encoded name if the file with an encoded name already exists
START 		if (encodedFileName.length() <= FILENAME_MAX_LEN && fileExists.test(encodedFileName)) { END 
			return encodedFileName;
		}

		// if file with encoded name does not exist, we will only encode file name if it is required
		String fileName;
		if (requiresEncoding(task.getTaskId())) {
			fileName = encodedFileName;
		} else {
			fileName = task.getTaskId();
		}

		// trim the file name if it is too long
		return trimFilenameIfRequired(fileName);
	}
","	protected String getFileName(ITask task, Predicate<String> fileExists) {
		String encodedFileName = CoreUtil.asFileName(task.getTaskId());

		// for backwards-compatibility with versions that always encoded file names,
		// we will use an encoded name if the file with an encoded name already exists
		if (fileExists.test(encodedFileName)) {
			return encodedFileName;
		}

		// if file with encoded name does not exist, we will only encode file name if it is required
		String fileName;
		if (requiresEncoding(task.getTaskId())) {
			fileName = encodedFileName;
		} else {
			fileName = task.getTaskId();
		}

		// trim the file name if it is too long
		return trimFilenameIfRequired(fileName);
	}
"
1653,"why the extraction to a variable? I would keep it inlined:
```
return client.indices().create(createIndexRequest(indexName), RequestOptions.DEFAULT).isAcknowledged();
```","	public boolean createIndex(String indexName) {
		Assert.notNull(indexName, ""No index defined for Query"");
		try {
			CreateIndexRequest indexRequest = createIndexRequest(indexName);
			return client.indices().create(indexRequest, RequestOptions.DEFAULT).isAcknowledged();
		} catch (Exception e) {
			throw new ElasticsearchException(""Failed to create index "" + indexName, e);
		}
	}
","	public boolean createIndex(String indexName) {
		Assert.notNull(indexName, ""No index defined for Query"");
		try {
			CreateIndexRequest indexRequest = createIndexRequest(indexName);
START 			return client.indices().create(indexRequest, RequestOptions.DEFAULT).isAcknowledged(); END 
		} catch (Exception e) {
			throw new ElasticsearchException(""Failed to create index "" + indexName, e);
		}
	}
","	public boolean createIndex(String indexName) {
		Assert.notNull(indexName, ""No index defined for Query"");
		try {
			return client.indices().create(createIndexRequest(indexName), RequestOptions.DEFAULT).isAcknowledged();
		} catch (Exception e) {
			throw new ElasticsearchException(""Failed to create index "" + indexName, e);
		}
	}
"
1654,What is this property used for?,"   public static Properties defaultProperties() {
      Properties properties = BaseHttpApiMetadata.defaultProperties();
      properties.setProperty(ShipyardProperties.SHIPYARD_CREDENTIAL, ""<remote-service-key-given-by-shipyard-cli>"");
      return properties;
   }
","   public static Properties defaultProperties() {
      Properties properties = BaseHttpApiMetadata.defaultProperties();
START       properties.setProperty(ShipyardProperties.SHIPYARD_CREDENTIAL, ""<remote-service-key-given-by-shipyard-cli>""); END 
      return properties;
   }
","   public static Properties defaultProperties() {
      return BaseHttpApiMetadata.defaultProperties();
   }
"
1655,It seems this could be changed to `return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP))`,"   protected boolean writeNeedsRemoteValue(InvocationContext ctx, WriteCommand command, Object key) {
      if (command.hasFlag(Flag.CACHE_MODE_LOCAL)) {
         return false;
      }
      if (ctx.isOriginLocal()) {
         // The return value only matters on the originator.
         // Conditional commands also check the previous value only on the originator.
         if (!command.readsExistingValues()) {
            return false;
         }
         // TODO Could make DELTA_WRITE/ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to
         // return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.alwaysReadsExistingValues();
         if (command.hasFlag(Flag.SKIP_REMOTE_LOOKUP)) {
            return false;
         }
      } else {
         // Ignore SKIP_REMOTE_LOOKUP on remote nodes
         // TODO Can we ignore the CACHE_MODE_LOCAL flag as well?
         if (!command.alwaysReadsExistingValues()) {
            return false;
         }
      }
      return true;
   }
","   protected boolean writeNeedsRemoteValue(InvocationContext ctx, WriteCommand command, Object key) {
      if (command.hasFlag(Flag.CACHE_MODE_LOCAL)) {
         return false;
      }
      if (ctx.isOriginLocal()) {
         // The return value only matters on the originator.
         // Conditional commands also check the previous value only on the originator.
         if (!command.readsExistingValues()) {
            return false;
         }
         // TODO Could make DELTA_WRITE/ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to
         // return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.alwaysReadsExistingValues();
START          if (command.hasFlag(Flag.SKIP_REMOTE_LOOKUP)) { END 
            return false;
         }
      } else {
         // Ignore SKIP_REMOTE_LOOKUP on remote nodes
         // TODO Can we ignore the CACHE_MODE_LOCAL flag as well?
         if (!command.alwaysReadsExistingValues()) {
            return false;
         }
      }
      return true;
   }
","   protected boolean writeNeedsRemoteValue(InvocationContext ctx, WriteCommand command, Object key) {
      if (command.hasFlag(Flag.CACHE_MODE_LOCAL)) {
         return false;
      }
      if (ctx.isOriginLocal()) {
         // The return value only matters on the originator.
         // Conditional commands also check the previous value only on the originator.
         if (!command.readsExistingValues()) {
            return false;
         }
         // TODO Could make DELTA_WRITE/ApplyDeltaCommand override SKIP_REMOTE_LOOKUP by changing next line to
         // return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP) || command.alwaysReadsExistingValues();
         return !command.hasFlag(Flag.SKIP_REMOTE_LOOKUP);
      } else {
         // Ignore SKIP_REMOTE_LOOKUP on remote nodes
         // TODO Can we ignore the CACHE_MODE_LOCAL flag as well?
         return command.alwaysReadsExistingValues();
      }
   }
"
1656,"![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove the declaration of thrown exception 'java.io.IOException', as it cannot be thrown from constructor's body. [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ARedundantThrowsDeclarationCheck)","    public BulkReceiveLibraryBackend(LibraryDto dto, Integer quantity, Project project, SampleClass aliquotClass, String defaultSciName,
        LibraryTemplateService libraryTemplateService) throws IOException {
      super(""libraryReceipt"", LibraryDto.class, ""Libraries"", dto, quantity);
      if (isDetailedSampleEnabled() && aliquotClass == null) throw new InvalidParameterException(""Aliquot class cannot be null"");
      this.project = project;
      this.aliquotClass = aliquotClass;
      this.defaultSciName = defaultSciName;
      this.libraryTemplateService = libraryTemplateService;
      newBox = dto.getBox();
    }
","    public BulkReceiveLibraryBackend(LibraryDto dto, Integer quantity, Project project, SampleClass aliquotClass, String defaultSciName,
START         LibraryTemplateService libraryTemplateService) throws IOException { END 
      super(""libraryReceipt"", LibraryDto.class, ""Libraries"", dto, quantity);
      if (isDetailedSampleEnabled() && aliquotClass == null) throw new InvalidParameterException(""Aliquot class cannot be null"");
      this.project = project;
      this.aliquotClass = aliquotClass;
      this.defaultSciName = defaultSciName;
      this.libraryTemplateService = libraryTemplateService;
      newBox = dto.getBox();
    }
","    public BulkReceiveLibraryBackend(LibraryDto dto, Integer quantity, Project project, SampleClass aliquotClass, String defaultSciName,
        LibraryTemplateService libraryTemplateService) {
      super(""libraryReceipt"", LibraryDto.class, ""Libraries"", dto, quantity);
      if (isDetailedSampleEnabled() && aliquotClass == null) throw new InvalidParameterException(""Aliquot class cannot be null"");
      this.project = project;
      this.aliquotClass = aliquotClass;
      this.defaultSciName = defaultSciName;
      this.libraryTemplateService = libraryTemplateService;
      newBox = dto.getBox();
    }
"
1657,getEmailAddress can return null.,"  public void evict(AccountExternalId id) {
    byKey.remove(id.getKey());
    byAccountId.remove(id.getAccountId());
    byEmail.remove(new EmailWrapper(id.getEmailAddress()));
  }
","  public void evict(AccountExternalId id) {
    byKey.remove(id.getKey());
    byAccountId.remove(id.getAccountId());
START     byEmail.remove(new EmailWrapper(id.getEmailAddress())); END 
  }
","  public void evict(AccountExternalId id) {
    byKey.remove(id.getKey());
    byAccountId.remove(id.getAccountId());
    if (id.getEmailAddress() != null) {
      byEmail.remove(new EmailWrapper(id.getEmailAddress()));
    }
  }
"
1658,create a `vparameter.getName()` that delegates to `Parameter`,"	public void outjectRequestMap() {
		for (ValuedParameter vparameter : methodInfo.getValuedParameters()) {
			result.include(vparameter.getParameter().getName(), vparameter.getValue());
		}
	}
","	public void outjectRequestMap() {
		for (ValuedParameter vparameter : methodInfo.getValuedParameters()) {
START 			result.include(vparameter.getParameter().getName(), vparameter.getValue()); END 
		}
	}
","	public void outjectRequestMap() {
		for (ValuedParameter vparameter : methodInfo.getValuedParameters()) {
			result.include(vparameter.getName(), vparameter.getValue());
		}
	}
"
1659,seems like these constructors should set `protected` properties on the base class. They're called via `super` below.,"    public AbstractBlockFamily(BlockFamilyDefinition definition, BlockShape shape, BlockBuilderHelper blockBuilder) {
    }
","START     public AbstractBlockFamily(BlockFamilyDefinition definition, BlockShape shape, BlockBuilderHelper blockBuilder) { END 
    }
","    protected AbstractBlockFamily(BlockFamilyDefinition definition, BlockShape shape, BlockBuilderHelper blockBuilder) {
    }
"
1660,Maybe we can move the null check on `mGoogleApiClient` a level above so to protect also the access to `stopAutoManage`. wdyt?,"    public void onStop() {
        super.onStop();
        mGoogleApiClient.stopAutoManage(getActivity());
        if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) {
            mGoogleApiClient.disconnect();
        }
    }
","    public void onStop() {
        super.onStop();
        mGoogleApiClient.stopAutoManage(getActivity());
START         if (mGoogleApiClient != null && mGoogleApiClient.isConnected()) { END 
            mGoogleApiClient.disconnect();
        }
    }
","    public void onStop() {
        super.onStop();
        if (mGoogleApiClient != null) {
            mGoogleApiClient.stopAutoManage(getActivity());
            if (mGoogleApiClient.isConnected()) {
                mGoogleApiClient.disconnect();
            }
        }
    }
"
1661,please remove redundant brackets (isInter...),"    protected Guid getQuotaId() {
        if (getNewDisk() != null && (isInternalManagedDisk())) {
            return ((DiskImage) getNewDisk()).getQuotaId();
        }
        return null;
    }
","    protected Guid getQuotaId() {
START         if (getNewDisk() != null && (isInternalManagedDisk())) { END 
            return ((DiskImage) getNewDisk()).getQuotaId();
        }
        return null;
    }
","    protected Guid getQuotaId() {
        if (getNewDisk() != null && isInternalManagedDisk()) {
            return ((DiskImage) getNewDisk()).getQuotaId();
        }
        return null;
    }
"
1662,One of these two trace lines should be removed.,"    public JClogin() {
		logger.trace(""JClogin(constructor) called."");
		logger.trace(""JClogin(this={}) called."",this);
    }
","    public JClogin() {
START 		logger.trace(""JClogin(constructor) called.""); END 
		logger.trace(""JClogin(this={}) called."",this);
    }
","    public JClogin() {
        logger.trace(""JClogin(constructor) called."");
    }
"
1663,I think using this util obfuscates the code,"    public ScriptingJobs(ScriptingAdaptor adaptor, XenonEngine xenonEngine, SchedulerConnectionFactory connectionFactory) {
        this.adaptor = adaptor;
        this.xenonEngine = xenonEngine;
        this.adaptorName = adaptor.getName();
        this.connectionFactory = connectionFactory;

        connections = Utils.emptyMap(1);
    }
","    public ScriptingJobs(ScriptingAdaptor adaptor, XenonEngine xenonEngine, SchedulerConnectionFactory connectionFactory) {
        this.adaptor = adaptor;
        this.xenonEngine = xenonEngine;
        this.adaptorName = adaptor.getName();
        this.connectionFactory = connectionFactory;

START         connections = Utils.emptyMap(1); END 
    }
","    public ScriptingJobs(ScriptingAdaptor adaptor, XenonEngine xenonEngine, SchedulerConnectionFactory connectionFactory) {
        this.adaptor = adaptor;
        this.xenonEngine = xenonEngine;
        this.adaptorName = adaptor.getName();
        this.connectionFactory = connectionFactory;

        connections = new HashMap<>();
    }
"
1664,"I really dislike how this confuses things.  Most of the `/`s are in the templates, but then this one special slash is being added here.  This is a really good opportunity for future mistakes.

Maybe this is a case for changing from using `String.format()` with templates that all do essentially the same thing for varying numbers of parameters to say just using `String.join()`.","    public TMSKeyBuilder(final String prefix, TileLayerDispatcher layers) {
        this.prefix = Strings.isNullOrEmpty(prefix) ? """" : prefix + ""/"";
        this.layers = layers;
    }
","    public TMSKeyBuilder(final String prefix, TileLayerDispatcher layers) {
START         this.prefix = Strings.isNullOrEmpty(prefix) ? """" : prefix + ""/""; END 
        this.layers = layers;
    }
","    public TMSKeyBuilder(final String prefix, TileLayerDispatcher layers) {
        this.prefix = prefix;
        this.layers = layers;
    }
"
1665,"nit: I somehow liked the old, more concise `UNKNOWN_STATS`","    public void testLeftJoinMissingStats()
    {
        PlanNodeStatsEstimate leftStats = planNodeStats(
                0,
                new SymbolStatistics(LEFT_JOIN_COLUMN, SymbolStatsEstimate.unknown()),
                new SymbolStatistics(LEFT_OTHER_COLUMN, SymbolStatsEstimate.unknown()));
        PlanNodeStatsEstimate rightStats = planNodeStats(
                0,
                new SymbolStatistics(RIGHT_JOIN_COLUMN, SymbolStatsEstimate.unknown()),
                new SymbolStatistics(RIGHT_OTHER_COLUMN, SymbolStatsEstimate.unknown()));
        assertJoinStats(LEFT, leftStats, rightStats, leftStats);
    }
","    public void testLeftJoinMissingStats()
    {
        PlanNodeStatsEstimate leftStats = planNodeStats(
                0,
START                 new SymbolStatistics(LEFT_JOIN_COLUMN, SymbolStatsEstimate.unknown()), END 
                new SymbolStatistics(LEFT_OTHER_COLUMN, SymbolStatsEstimate.unknown()));
        PlanNodeStatsEstimate rightStats = planNodeStats(
                0,
                new SymbolStatistics(RIGHT_JOIN_COLUMN, SymbolStatsEstimate.unknown()),
                new SymbolStatistics(RIGHT_OTHER_COLUMN, SymbolStatsEstimate.unknown()));
        assertJoinStats(LEFT, leftStats, rightStats, leftStats);
    }
","    public void testLeftJoinMissingStats()
    {
        PlanNodeStatsEstimate leftStats = planNodeStats(
                0,
                new SymbolStatistics(LEFT_JOIN_COLUMN, SymbolStatsEstimate.unknown()),
                new SymbolStatistics(LEFT_OTHER_COLUMN, SymbolStatsEstimate.unknown()));
        PlanNodeStatsEstimate rightStats = planNodeStats(
                0,
                new SymbolStatistics(RIGHT_JOIN_COLUMN, SymbolStatsEstimate.unknown()),
                new SymbolStatistics(RIGHT_OTHER_COLUMN, SymbolStatsEstimate.unknown()));
        assertJoinStats(LEFT, leftStats, rightStats, PlanNodeStatsEstimate.unknown());
    }
"
1666,Didn't you remove guava from GWTP?,"    public Collection<ClassDefinition> generate(ExtensionContext input) throws UnableToCompleteException {
        PrintWriter printWriter = tryCreate();

        if (printWriter != null) {
            mergeTemplate(printWriter);
            commit(printWriter);
            registerGinBinding();
        } else {
            getLogger().debug(""Jackson Mapper Provider already generated. Returning."");
        }

        return Lists.newArrayList(getClassDefinition());
    }
","    public Collection<ClassDefinition> generate(ExtensionContext input) throws UnableToCompleteException {
        PrintWriter printWriter = tryCreate();

        if (printWriter != null) {
            mergeTemplate(printWriter);
            commit(printWriter);
            registerGinBinding();
        } else {
            getLogger().debug(""Jackson Mapper Provider already generated. Returning."");
        }

START         return Lists.newArrayList(getClassDefinition()); END 
    }
","    public Collection<ClassDefinition> generate(ExtensionContext input) throws UnableToCompleteException {
        PrintWriter printWriter = tryCreate();

        if (printWriter != null) {
            mergeTemplate(printWriter);
            commit(printWriter);
            registerGinBinding();
        } else {
            getLogger().debug(""Jackson Mapper Provider already generated. Returning."");
        }

        return Arrays.asList(getClassDefinition());
    }
"
1667,"👍
ah. a good reason to make `picasso3` the package name, so long as it has common names like `Request` in the API.","  @Test public void shouldHandleSchemeInsensitiveCase() {
    String[] schemes = {
            ""http"",
            ""https"",
            ""HTTP"",
            ""HTTPS"",
            ""HTtP"",
    };

    for (String scheme : schemes) {
      final Uri uri = URI_1.buildUpon().scheme(scheme).build();
      final Boolean shouldHandle = networkHandler.canHandleRequest(
              TestUtils.mockRequest(uri)
      );

      assertThat(shouldHandle).isTrue();
    }
  }
","  @Test public void shouldHandleSchemeInsensitiveCase() {
    String[] schemes = {
            ""http"",
            ""https"",
            ""HTTP"",
            ""HTTPS"",
            ""HTtP"",
    };

    for (String scheme : schemes) {
      final Uri uri = URI_1.buildUpon().scheme(scheme).build();
      final Boolean shouldHandle = networkHandler.canHandleRequest(
START               TestUtils.mockRequest(uri) END 
      );

      assertThat(shouldHandle).isTrue();
    }
  }
","  @Test public void shouldHandleSchemeInsensitiveCase() {
    String[] schemes = {
            ""http"",
            ""https"",
            ""HTTP"",
            ""HTTPS"",
            ""HTtP"",
    };

    for (String scheme : schemes) {
      Uri uri = URI_1.buildUpon().scheme(scheme).build();
      assertThat(networkHandler.canHandleRequest(TestUtils.mockRequest(uri))).isTrue();
    }
  }
"
1668,"if (um != null) {
        Framework.doPrivileged(() -> createUsersAndGroups(um));
    }","    public void populate(CoreSession session) throws ClientException {

        UserManager um = Framework.getLocalService(UserManager.class);
        Framework.doPrivileged(() -> {
            // Create some users
            if (um != null) {
                createUsersAndGroups(um);
            }
        });
    }
","    public void populate(CoreSession session) throws ClientException {

        UserManager um = Framework.getLocalService(UserManager.class);
        Framework.doPrivileged(() -> {
            // Create some users
            if (um != null) {
                createUsersAndGroups(um);
            }
START         }); END 
    }
","    public void populate(CoreSession session) throws ClientException {

        UserManager um = Framework.getLocalService(UserManager.class);
        // Create some users
        if (um != null) {
            Framework.doPrivileged(() -> createUsersAndGroups(um));
        }
    }
"
1669,Might be also in finally?,"	public void stop(BundleContext context) throws Exception {
		try {
			Job.getJobManager().join(LUCENE_JOB_FAMILY, null);
			plugin = null;
		} finally {
			super.stop(context);
		}
	}
","	public void stop(BundleContext context) throws Exception {
		try {
			Job.getJobManager().join(LUCENE_JOB_FAMILY, null);
START 			plugin = null; END 
		} finally {
			super.stop(context);
		}
	}
","	public void stop(BundleContext context) throws Exception {
		try {
			Job.getJobManager().join(LUCENE_JOB_FAMILY, null);
		} finally {
			plugin = null;
			super.stop(context);
		}
	}
"
1670,move null check back as first action to not change behaviour.,"    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        ObjectUtil.checkNotNull(unit, ""unit"");
        if (delay < 0) {
            delay = 0;
        }
        validateScheduled0(delay, unit);

        return schedule(new ScheduledFutureTask<Void>(
                this,
                ObjectUtil.checkNotNull(command, ""command""),
                deadlineNanos(unit.toNanos(delay))));
    }
","    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        ObjectUtil.checkNotNull(unit, ""unit"");
        if (delay < 0) {
            delay = 0;
        }
        validateScheduled0(delay, unit);

        return schedule(new ScheduledFutureTask<Void>(
                this,
START                 ObjectUtil.checkNotNull(command, ""command""), END 
                deadlineNanos(unit.toNanos(delay))));
    }
","    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        ObjectUtil.checkNotNull(command, ""command"");
        ObjectUtil.checkNotNull(unit, ""unit"");
        if (delay < 0) {
            delay = 0;
        }
        validateScheduled0(delay, unit);

        return schedule(new ScheduledFutureTask<Void>(
                this,
                command,
                deadlineNanos(unit.toNanos(delay))));
    }
"
1671,I think that `if (in == null) return null` is a slightly better way to deal with this...,"      public Integer invoke() {
         Integer result = 0;
         try (InputStream in = cache.getViaStream(key)) {
            int read = 0;
            while ((read = in.read(buffer)) != -1)
               result = result + read;
            return value = result;
         } catch (IOException e) {
            throw new RuntimeException(e);
         } catch (NullPointerException e) {
            return null;
         }
      }
","      public Integer invoke() {
         Integer result = 0;
         try (InputStream in = cache.getViaStream(key)) {
            int read = 0;
            while ((read = in.read(buffer)) != -1)
               result = result + read;
            return value = result;
         } catch (IOException e) {
            throw new RuntimeException(e);
START          } catch (NullPointerException e) { END 
            return null;
         }
      }
","      public Integer invoke() {
         Integer result = 0;
         try (InputStream in = cache.getViaStream(key)) {
            if (in == null)
               return null;
            int read = 0;
            while ((read = in.read(buffer)) != -1)
               result = result + read;
            return value = result;
         } catch (IOException e) {
            throw new RuntimeException(e);
         }
      }
"
1672,check for `cause != null`,"  public CoreEvent process(CoreEvent event) throws MuleException {
    try {
      return processToApply(event, this);
    } catch (Exception error) {
      Throwable cause = error.getCause();
      if (cause instanceof RetryContextInitializationException &&
          cause.getCause() instanceof ExpressionRuntimeException) {
        // Runtime exception caused by Retry Ctx initialization, propagating
        throw ((ExpressionRuntimeException) cause.getCause());
      } else {
        // Not caused by context initialization. Throwing as raised.
        throw error;
      }
    }
  }
","  public CoreEvent process(CoreEvent event) throws MuleException {
    try {
      return processToApply(event, this);
    } catch (Exception error) {
      Throwable cause = error.getCause();
START       if (cause instanceof RetryContextInitializationException && END 
          cause.getCause() instanceof ExpressionRuntimeException) {
        // Runtime exception caused by Retry Ctx initialization, propagating
        throw ((ExpressionRuntimeException) cause.getCause());
      } else {
        // Not caused by context initialization. Throwing as raised.
        throw error;
      }
    }
  }
","  public CoreEvent process(CoreEvent event) throws MuleException {
    try {
      return processToApply(event, this);
    } catch (Exception error) {
      Throwable cause = error.getCause();
      if (cause != null && cause instanceof RetryContextInitializationException &&
          cause.getCause() instanceof ExpressionRuntimeException) {
        // Runtime exception caused by Retry Ctx initialization, propagating
        throw ((ExpressionRuntimeException) cause.getCause());
      } else {
        // Not caused by context initialization. Throwing as raised.
        throw error;
      }
    }
  }
"
1673,"Missing a .get() here after .getKey() as the UUID is the key in the map, not the PatchLineComment.Key object instance.","  private static void addChildren(Map<String, List<PatchLineComment>> parentMap,
      List<PatchLineComment> children, List<PatchLineComment> outResult) {
    if (children != null) {
      for (PatchLineComment c : children) {
        outResult.add(c);
        addChildren(parentMap, parentMap.get(c.getKey()), outResult);
      }
    }
  }
","  private static void addChildren(Map<String, List<PatchLineComment>> parentMap,
      List<PatchLineComment> children, List<PatchLineComment> outResult) {
    if (children != null) {
      for (PatchLineComment c : children) {
        outResult.add(c);
START         addChildren(parentMap, parentMap.get(c.getKey()), outResult); END 
      }
    }
  }
","  private static void addChildren(Map<String, List<PatchLineComment>> parentMap,
      List<PatchLineComment> children, List<PatchLineComment> outResult) {
    if (children != null) {
      for (PatchLineComment c : children) {
        outResult.add(c);
        addChildren(parentMap, parentMap.get(c.getKey().get()), outResult);
      }
    }
  }
"
1674,What is this logging buying us ? Do we really need so much of it?,"	public void dispose() {
		LogManager.logInfo(""Disposing"", this); //$NON-NLS-1$
		fWindow= null;
	}
","	public void dispose() {
START 		LogManager.logInfo(""Disposing"", this); //$NON-NLS-1$ END 
		fWindow= null;
	}
","	public void dispose() {
		fWindow= null;
	}
"
1675,the second part of the OR is redundant: byte[].class != obj.getClass(),"   public boolean equals(byte[] obj, Object otherObj) {
      if (obj == otherObj) return true;
      if (obj == null || byte[].class != obj.getClass()) return false;
      if (otherObj == null || byte[].class != otherObj.getClass()) return false;
      byte[] byteArray = obj;
      byte[] otherByteArray = (byte[]) otherObj;
      return Arrays.equals(byteArray, otherByteArray);
   }
","   public boolean equals(byte[] obj, Object otherObj) {
      if (obj == otherObj) return true;
START       if (obj == null || byte[].class != obj.getClass()) return false; END 
      if (otherObj == null || byte[].class != otherObj.getClass()) return false;
      byte[] byteArray = obj;
      byte[] otherByteArray = (byte[]) otherObj;
      return Arrays.equals(byteArray, otherByteArray);
   }
","   public boolean equals(byte[] obj, Object otherObj) {
      if (obj == otherObj) return true;
      if (obj == null) return false;
      if (otherObj == null || byte[].class != otherObj.getClass()) return false;
      byte[] otherByteArray = (byte[]) otherObj;
      return Arrays.equals(obj, otherByteArray);
   }
"
1676,can be private,"    public EngineSearcherTotalHitsMatcher(Query query, int totalHits) {
        this.query = query;
        this.totalHits = totalHits;
    }
","START     public EngineSearcherTotalHitsMatcher(Query query, int totalHits) { END 
        this.query = query;
        this.totalHits = totalHits;
    }
","    private EngineSearcherTotalHitsMatcher(Query query, int totalHits) {
        this.query = query;
        this.totalHits = totalHits;
    }
"
1677,Why don't you push this down to `LogData::getPayload` ? (since that's when deserialize is actually invoked),"    protected boolean processEntryForContext(final ILogData data) {
        if (data != null) {
            try {
                final Object payload = data.getPayload(runtime);
            } catch (Throwable e) {
                log.error(""Exception caught at address {}, {}, {}"",
                        data.getGlobalAddress(), data.getStreams(), data.getType());
                throw e;
            }
        }
        return false;
    }
","    protected boolean processEntryForContext(final ILogData data) {
        if (data != null) {
            try {
START                 final Object payload = data.getPayload(runtime); END 
            } catch (Throwable e) {
                log.error(""Exception caught at address {}, {}, {}"",
                        data.getGlobalAddress(), data.getStreams(), data.getType());
                throw e;
            }
        }
        return false;
    }
","    protected boolean processEntryForContext(final ILogData data) {
        if (data != null) {
            final Object payload = data.getPayload(runtime);
        }
        return false;
    }
"
1678,any reason for disabling cache for descending order queries ?,"  public boolean isQueryCacheable(Query query)
  {
    // O(n) impl, but I don't think we'll ever have a million query types here
    return !query.isDescending() && !unCacheable.contains(query.getType());
  }
","  public boolean isQueryCacheable(Query query)
  {
    // O(n) impl, but I don't think we'll ever have a million query types here
START     return !query.isDescending() && !unCacheable.contains(query.getType()); END 
  }
","  public boolean isQueryCacheable(Query query)
  {
    // O(n) impl, but I don't think we'll ever have a million query types here
    return !unCacheable.contains(query.getType());
  }
"
1679,Just replace all this new code with MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension()).,"	public static boolean isMoeFile(IResource resource) {
		if(resource instanceof IFile ) {
			String fileExtension = resource.getFileExtension();
			return fileExtension != null && resource.getFileExtension().equals(MODEL_OBJECT_ELEMENTFILE_EXTENSION);
		}
		return false;
	}
","	public static boolean isMoeFile(IResource resource) {
		if(resource instanceof IFile ) {
START 			String fileExtension = resource.getFileExtension();
			return fileExtension != null && resource.getFileExtension().equals(MODEL_OBJECT_ELEMENTFILE_EXTENSION); END 
		}
		return false;
	}
","	public static boolean isMoeFile(IResource resource) {
		return resource instanceof IFile && MODEL_OBJECT_ELEMENTFILE_EXTENSION.equals(resource.getFileExtension());
	}
"
1680,could we change to List<Properties> or is this API fixed?,"  public Property[] getProperties() {
    return m_properties.toArray(new Property[m_properties.size()]);
  }
","START   public Property[] getProperties() { END 
    return m_properties.toArray(new Property[m_properties.size()]);
  }
","  public List<Property> getProperties() {
    return m_properties;
  }
"
1681,"No need for this. The tests must be independent, hence the instance count here should be zero.","    public void setup() throws NoSuchFieldException, IllegalAccessException {
        // Before ""onCreate"", we need to record the instance count for the test
        instanceCountField = OpenHelperManager.class.getDeclaredField(""instanceCount"");
        instanceCountField.setAccessible(true);
        instanceCount = instanceCountField.getInt(null);

        activity = Robolectric.buildActivity(OrmLiteActivity_.class).create().get();
    }
","    public void setup() throws NoSuchFieldException, IllegalAccessException {
        // Before ""onCreate"", we need to record the instance count for the test
START         instanceCountField = OpenHelperManager.class.getDeclaredField(""instanceCount""); END 
        instanceCountField.setAccessible(true);
        instanceCount = instanceCountField.getInt(null);

        activity = Robolectric.buildActivity(OrmLiteActivity_.class).create().get();
    }
","	public void setup() {
		activity = Robolectric.buildActivity(OrmLiteActivity_.class).create().get();
	}
"
1682,"Do we need to do this here?  This seems like it's creating a circular dependency of the EMF into Guice, but the EMF depends on Guice.","    public static Injector getInjector() {
        if ( injector == null ) {
            injector = Guice.createInjector( new GuiceModule( emf ) ); 
        }
        return injector;
    }
","    public static Injector getInjector() {
        if ( injector == null ) {
START             injector = Guice.createInjector( new GuiceModule( emf ) );  END 
        }
        return injector;
    }
","    public static Injector getInjector() {
        if ( injector == null ) {
            injector = Guice.createInjector( new GuiceModule() ); 
        }
        return injector;
    }
"
1683,We don't like System.out :),"	public void serialize() throws Exception {
		String xml = serializer.serialize(header);
		System.out.println(xml);
		XMLAssert.assertXpathExists(""/subscriptionHeader/contentUri"", xml);
		XMLAssert.assertXpathExists(""/subscriptionHeader/packageHeader"", xml);
		XMLAssert.assertXpathExists(""/subscriptionHeader/packageHeader/name"", xml);
	}
","	public void serialize() throws Exception {
		String xml = serializer.serialize(header);
START 		System.out.println(xml); END 
		XMLAssert.assertXpathExists(""/subscriptionHeader/contentUri"", xml);
		XMLAssert.assertXpathExists(""/subscriptionHeader/packageHeader"", xml);
		XMLAssert.assertXpathExists(""/subscriptionHeader/packageHeader/name"", xml);
	}
","	public void serialize() throws Exception {
		String xml = serializer.serialize(header);
		XMLAssert.assertXpathExists(""/subscriptionHeader/contentUri"", xml);
		XMLAssert.assertXpathExists(""/subscriptionHeader/packageHeader"", xml);
		XMLAssert.assertXpathExists(""/subscriptionHeader/packageHeader/name"", xml);
	}
"
1684,Instanceof nightmare?,"    protected IMicroblockContainerTile getMicroblockTile(IBlockAccess world, BlockPos pos)
    {
        TileEntity tile = world.getTileEntity(pos);
        return tile instanceof IMicroblockContainerTile ? (IMicroblockContainerTile) tile : null;
    }
","    protected IMicroblockContainerTile getMicroblockTile(IBlockAccess world, BlockPos pos)
START     { END 
        TileEntity tile = world.getTileEntity(pos);
        return tile instanceof IMicroblockContainerTile ? (IMicroblockContainerTile) tile : null;
    }
","    protected IMicroblockContainerTile getMicroblockTile(IBlockAccess world, BlockPos pos)
    {
        TileEntity tile = world.getTileEntity(pos);
        if (tile == null)
        {
            return null;
        }
        return getMicroblockTile(tile);
    }
"
1685,should be a protected method,"    public void setMethod(final ZonemasterRequest.Method method) {
        this.method = method.getMethod();
        this.id = method.getId();
    }
","START     public void setMethod(final ZonemasterRequest.Method method) { END 
        this.method = method.getMethod();
        this.id = method.getId();
    }
","    protected void setMethod(final ZonemasterRequest.Method method) {
        this.method = method.getMethod();
        this.id = method.getId();
    }
"
1686,Multi return is forbidden.,"	public Dimension getFloatingItemOffset() {
		if (editPart instanceof FloatingLabelEditPart) {
			return ((FloatingLabelEditPart) editPart).getFloatingItemOffset();
		}
		return new Dimension();
	}
","START 	public Dimension getFloatingItemOffset() { END 
		if (editPart instanceof FloatingLabelEditPart) {
			return ((FloatingLabelEditPart) editPart).getFloatingItemOffset();
		}
		return new Dimension();
	}
","	public Dimension getFloatingItemOffset() {
		Dimension offset = null;
		if (editPart instanceof FloatingLabelEditPart) {
			offset = ((FloatingLabelEditPart) editPart).getFloatingItemOffset();
		}
		return offset != null ? offset : new Dimension();
	}
"
1687,irc is not open if con is null initially. The logic here is a bit muddled.,"	private static synchronized ITerminalConnector getConnector(IRemoteConnection irc) throws RemoteConnectionException {
		ITerminalConnector con = cons.get(irc.getAddress());
		if(con == null) {
			con = TerminalConnectorExtension.makeTerminalConnector(
					""org.eclipse.ptp.remote.internal.terminal.RemoteToolsConnector""); //$NON-NLS-1$
			cons.put(irc.getAddress(),con);
		} else if(irc.isOpen()) {
			return null;
		} else {
			irc.open(new NullProgressMonitor());
			return null;
		}
		return con;
	}
","	private static synchronized ITerminalConnector getConnector(IRemoteConnection irc) throws RemoteConnectionException {
		ITerminalConnector con = cons.get(irc.getAddress());
		if(con == null) {
			con = TerminalConnectorExtension.makeTerminalConnector(
					""org.eclipse.ptp.remote.internal.terminal.RemoteToolsConnector""); //$NON-NLS-1$
			cons.put(irc.getAddress(),con);
START 		} else if(irc.isOpen()) { END 
			return null;
		} else {
			irc.open(new NullProgressMonitor());
			return null;
		}
		return con;
	}
","	private static synchronized ITerminalConnector getConnector(IRemoteConnection irc) throws RemoteConnectionException {
		ITerminalConnector con = cons.get(irc.getAddress());
		if(con == null) {
			con = TerminalConnectorExtension.makeTerminalConnector(
					""org.eclipse.ptp.remote.internal.terminal.RemoteToolsConnector""); //$NON-NLS-1$
			cons.put(irc.getAddress(),con);
		}
		return con;
	}
"
1688,Why not declare GLOBAL_ID as a long?,"    public long getGlobalClassLoaderId() {
        return (long) ClassLoaderIdentifier.GLOBAL_ID;
    }
","    public long getGlobalClassLoaderId() {
START         return (long) ClassLoaderIdentifier.GLOBAL_ID; END 
    }
","    public long getGlobalClassLoaderId() {
        return ClassLoaderIdentifier.GLOBAL_ID;
    }
"
1689,"Even though these two are ""CMAS Severe Alerts"", shouldn't getCmasSeverity() still return CMAS_SEVERITY_EXTREME? Spec says ""Severity of Extreme, Urgency of Expected...""","    private int getCmasSeverity() {
        switch (messageIdentifier) {
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_LIKELY:
                return SmsCbCmasInfo.CMAS_SEVERITY_EXTREME;

            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_LIKELY:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_LIKELY:
                return SmsCbCmasInfo.CMAS_SEVERITY_SEVERE;

            default:
                return SmsCbCmasInfo.CMAS_SEVERITY_UNKNOWN;
        }
    }
","    private int getCmasSeverity() {
        switch (messageIdentifier) {
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_LIKELY:
                return SmsCbCmasInfo.CMAS_SEVERITY_EXTREME;

            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_OBSERVED:
START             case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY: END 
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_LIKELY:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_LIKELY:
                return SmsCbCmasInfo.CMAS_SEVERITY_SEVERE;

            default:
                return SmsCbCmasInfo.CMAS_SEVERITY_UNKNOWN;
        }
    }
","    private int getCmasSeverity() {
        switch (messageIdentifier) {
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_IMMEDIATE_LIKELY:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_EXTREME_EXPECTED_LIKELY:
                return SmsCbCmasInfo.CMAS_SEVERITY_EXTREME;

            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_IMMEDIATE_LIKELY:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_OBSERVED:
            case SmsCbConstants.MESSAGE_ID_CMAS_ALERT_SEVERE_EXPECTED_LIKELY:
                return SmsCbCmasInfo.CMAS_SEVERITY_SEVERE;

            default:
                return SmsCbCmasInfo.CMAS_SEVERITY_UNKNOWN;
        }
    }
"
1690,instead of thowing we could return an empty list,"	public Collection<String> getAliases(final KeyStore keyStore) throws ScriptSignatureException {
		try {
			if (keyStore != null)
				return Collections.list(keyStore.aliases());

		} catch (KeyStoreException e) {
			throw new ScriptSignatureException(""Keystore not initialized properly. Try again."", e);
		}
		throw new ScriptSignatureException(""Keystore not initialized properly. Try again."", null);
	}
","	public Collection<String> getAliases(final KeyStore keyStore) throws ScriptSignatureException {
		try {
			if (keyStore != null)
				return Collections.list(keyStore.aliases());

		} catch (KeyStoreException e) {
			throw new ScriptSignatureException(""Keystore not initialized properly. Try again."", e);
		}
START 		throw new ScriptSignatureException(""Keystore not initialized properly. Try again."", null); END 
	}
","	public Collection<String> getAliases(final KeyStore keyStore) {
		try {
			if (keyStore != null)
				return Collections.list(keyStore.aliases());

		} catch (KeyStoreException e) {
			return null;
		}
		return null;
	}
"
1691,Type argument Expression is not need.,"    public List<Expression> getExpressions() {
        List<Expression> result = new ArrayList<Expression>(groupByAttributes);
        result.add(expression);
        return result;
    }
","    public List<Expression> getExpressions() {
START         List<Expression> result = new ArrayList<Expression>(groupByAttributes); END 
        result.add(expression);
        return result;
    }
","    public List<Expression> getExpressions() {
        List<Expression> result = new ArrayList<>(groupByAttributes);
        result.add(expression);
        return result;
    }
"
1692,Could we keep this API private?,"    public boolean isIdentityProvider() {
        try {
            PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES);
            for (ActivityInfo activityInfo : packageInfo.activities) {
                if (activityInfo.name.equals(IDPAccountPickerActivity.class.getName())) {
                    return true;
                }
            }


        } catch (NameNotFoundException e) {
            SalesforceSDKLogger.e(TAG, ""Exception occurred while examining application info"", e);
        }

        return false;
    }
","START     public boolean isIdentityProvider() { END 
        try {
            PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES);
            for (ActivityInfo activityInfo : packageInfo.activities) {
                if (activityInfo.name.equals(IDPAccountPickerActivity.class.getName())) {
                    return true;
                }
            }


        } catch (NameNotFoundException e) {
            SalesforceSDKLogger.e(TAG, ""Exception occurred while examining application info"", e);
        }

        return false;
    }
","    private boolean isIdentityProvider() {
        try {
            PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES);
            for (ActivityInfo activityInfo : packageInfo.activities) {
                if (activityInfo.name.equals(IDPAccountPickerActivity.class.getName())) {
                    return true;
                }
            }


        } catch (NameNotFoundException e) {
            SalesforceSDKLogger.e(TAG, ""Exception occurred while examining application info"", e);
        }

        return false;
    }
"
1693,@olivergondza noted in the commit that this should not be public as it is for testing only,"    public List<BlockedItem> getBlockedItems() {
        return new ArrayList<BlockedItem>(snapshot.blockedProjects);
    }
","START     public List<BlockedItem> getBlockedItems() { END 
        return new ArrayList<BlockedItem>(snapshot.blockedProjects);
    }
","    protected List<BlockedItem> getBlockedItems() {
        return new ArrayList<BlockedItem>(snapshot.blockedProjects);
    }
"
1694,I don't think it makes sense for the trace to be null here. We shouldn't have to create a new Message file for this case...,"    public IStatus validate(String path) {
        if (fTrace == null) {
            return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.TraceTypeHelper_ValidateNoTrace);
        }
        return fTrace.validate(null, path);
    }
","    public IStatus validate(String path) {
        if (fTrace == null) {
START             return new Status(IStatus.ERROR, Activator.PLUGIN_ID, Messages.TraceTypeHelper_ValidateNoTrace); END 
        }
        return fTrace.validate(null, path);
    }
","    public IStatus validate(String path) {
        return fTrace.validate(null, path);
    }
"
1695,just wondering...is it worth putting the `rc == FMT` check first for a short-circuiting efficiency improvement?,"    public static boolean isTCCPacket(ByteArrayBuffer baf)
    {
        int rc = RTCPHeaderUtils.getReportCount(baf);
        return isRTPFBPacket(baf) && rc == FMT;
    }
","    public static boolean isTCCPacket(ByteArrayBuffer baf)
    {
        int rc = RTCPHeaderUtils.getReportCount(baf);
START         return isRTPFBPacket(baf) && rc == FMT; END 
    }
","    public static boolean isTCCPacket(ByteArrayBuffer baf)
    {
        int rc = RTCPHeaderUtils.getReportCount(baf);
        return rc == FMT && isRTPFBPacket(baf);
    }
"
1696,"@bkmeneguello 
Are you sure that <code>!=</code> is correct?","        private Result waitForCompletion() throws InterruptedException, IOException {
            // wait for the completion
            Result result;
            while((result = checkForCompletion()) != null) {
                Thread.sleep(1000);
            }
            return result;
        }
","        private Result waitForCompletion() throws InterruptedException, IOException {
            // wait for the completion
            Result result;
START             while((result = checkForCompletion()) != null) { END 
                Thread.sleep(1000);
            }
            return result;
        }
","        private Result waitForCompletion() throws InterruptedException, IOException {
            // wait for the completion
            Result result;
            while((result = checkForCompletion()) == null) {
                Thread.sleep(1000);
            }
            return result;
        }
"
1697,Missing fs.close(),"  public void testUnderlyingReaders() throws IOException, FormatException {
    FakeReader reader = new FakeReader();
    FileStitcher fs = new FileStitcher(reader);
    assertNotNull(fs.getUnderlyingReaders());
    fs.setId(""test_z<0-2>.fake"");
    assertNotNull(fs.getUnderlyingReaders());
  }
","  public void testUnderlyingReaders() throws IOException, FormatException {
    FakeReader reader = new FakeReader();
    FileStitcher fs = new FileStitcher(reader);
    assertNotNull(fs.getUnderlyingReaders());
    fs.setId(""test_z<0-2>.fake"");
    assertNotNull(fs.getUnderlyingReaders());
START   } END 
","  public void testUnderlyingReaders() throws IOException, FormatException {
    FakeReader reader = new FakeReader();
    FileStitcher fs = new FileStitcher(reader);
    assertNotNull(fs.getUnderlyingReaders());
    fs.setId(""test_z<0-2>.fake"");
    assertNotNull(fs.getUnderlyingReaders());
    fs.close();
  }
"
1698,We can get rid of these variables if they are being used in one place.,"	public void shouldGetDiagnosisByUuid() {
		String uuid = ""4e663d66-6b78-11e0-93c3-18a905e044dc"";
		int diagnosisId = 1;

		Diagnosis diagnosis = diagnosisDAO.getDiagnosisByUuid(uuid);
		assertEquals(diagnosisId, (int) diagnosis.getId());
	}
","	public void shouldGetDiagnosisByUuid() {
START 		String uuid = ""4e663d66-6b78-11e0-93c3-18a905e044dc""; END 
		int diagnosisId = 1;

		Diagnosis diagnosis = diagnosisDAO.getDiagnosisByUuid(uuid);
		assertEquals(diagnosisId, (int) diagnosis.getId());
	}
","	public void shouldGetDiagnosisByUuid() {
		Diagnosis diagnosis = diagnosisDAO.getDiagnosisByUuid(""4e663d66-6b78-11e0-93c3-18a905e044dc"");
		assertEquals(1, (int) diagnosis.getId());
	}
"
1699,I don't think the logic is necessary. We can have the default visibility as `GONE`.,"    public void setUpCallToAction(String callToActionText) {
        if (callToActionText == null) {
            callToActionContainer.setVisibility(GONE);
        } else {
            callToActionContainer.setVisibility(VISIBLE);
            callToActionTextView.setText(callToActionText);
        }
    }
","    public void setUpCallToAction(String callToActionText) {
        if (callToActionText == null) {
            callToActionContainer.setVisibility(GONE);
        } else {
            callToActionContainer.setVisibility(VISIBLE);
START             callToActionTextView.setText(callToActionText); END 
        }
    }
","    public void setUpCallToAction(String callToActionText) {
        if (callToActionText != null) {
            callToActionContainer.setVisibility(VISIBLE);
            callToActionTextView.setText(callToActionText);
        } else {
            callToActionContainer.setVisibility(GONE);
        }
    }
"
1700,Could this be protected as well?,"	public AbstractTableViewer getTableViewer() {
		return actionContext.getViewer();
	}
","START 	public AbstractTableViewer END  getTableViewer() {
		return actionContext.getViewer();
	}
","	protected AbstractTableViewer getTableViewer() {
		return actionContext.getViewer();
	}
"
1701,"This probably should be public, and in the interface.","    void start() {
        if (!started) {
            log.info(""Starting prefetching thread."");
            executorService.execute(new DefaultGetRecordsCacheDaemon());
        }
        started = true;
    }
","START     void start() { END 
        if (!started) {
            log.info(""Starting prefetching thread."");
            executorService.execute(new DefaultGetRecordsCacheDaemon());
        }
        started = true;
    }
","    public void start() {
        if (!started) {
            log.info(""Starting prefetching thread."");
            executorService.execute(new DefaultGetRecordsCacheDaemon());
        }
        started = true;
    }
"
1702,Why `new ArrayList<>(`?,"  public SymbolTableBuilder(String fullyQualifiedModuleName) {
    this.fullyQualifiedModuleName = new ArrayList<>(Arrays.asList(fullyQualifiedModuleName.split(""\\."")));
  }
","  public SymbolTableBuilder(String fullyQualifiedModuleName) {
START     this.fullyQualifiedModuleName = new ArrayList<>(Arrays.asList(fullyQualifiedModuleName.split(""\\.""))); END 
  }
","  public SymbolTableBuilder(String fullyQualifiedModuleName) {
    this.fullyQualifiedModuleName = Arrays.asList(fullyQualifiedModuleName.split(""\\.""));
  }
"
1703,Double volatile read is gone. Can get rid of maxTS.,"    public long getNextTimestamp() throws TimestampIOException {
        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);
        long maxTS = _maxReservedTimestamp; // avoid the double volatile read
        if (nextTS > maxTS) {
            reserveNextBlock(nextTS);
        }
        _numTimestampsCreated.incrementAndGet(); // JMX metric
        return nextTS;
    }
","    public long getNextTimestamp() throws TimestampIOException {
        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);
START         long maxTS = _maxReservedTimestamp; // avoid the double volatile read END 
        if (nextTS > maxTS) {
            reserveNextBlock(nextTS);
        }
        _numTimestampsCreated.incrementAndGet(); // JMX metric
        return nextTS;
    }
","    public long getNextTimestamp() throws TimestampIOException {
        long nextTS = _timestampCounter.addAndGet(TIMESTAMP_INCREMENT);
        if (nextTS > _maxReservedTimestamp) {
            reserveNextBlock(nextTS);
        }
        _numTimestampsCreated.incrementAndGet(); // JMX metric
        return nextTS;
    }
"
1704,please remove `this.` on this line and the next,"    public TileRenderRunnable( TileCanvasViewGroup viewGroup, Tile tile) {
      this.mTileCanvasViewGroup = new WeakReference<>( viewGroup );
      this.mTile = new WeakReference<>( tile );
    }
","    public TileRenderRunnable( TileCanvasViewGroup viewGroup, Tile tile) {
START       this.mTileCanvasViewGroup = new WeakReference<>( viewGroup ); END 
      this.mTile = new WeakReference<>( tile );
    }
","    public TileRenderRunnable( TileCanvasViewGroup viewGroup, Tile tile) {
      mTileCanvasViewGroup = new WeakReference<>( viewGroup );
      mTile = new WeakReference<>( tile );
    }
"
1705,@matthew-a-dunlap please update the docs on `:ExcludeEmailFromExport`. Thanks!,"    public Response viewDataverse(@PathParam(""identifier"") String idtf) {
        return allowCors(response(req -> ok(
            json(execCommand(new GetDataverseCommand(req, findDataverseOrDie(idtf))),
                false,
                settingsService.isTrueForKey(SettingsServiceBean.Key.ExcludeEmailFromExport, false)
            ))));
    }
","    public Response viewDataverse(@PathParam(""identifier"") String idtf) {
        return allowCors(response(req -> ok(
            json(execCommand(new GetDataverseCommand(req, findDataverseOrDie(idtf))),
                false,
START                 settingsService.isTrueForKey(SettingsServiceBean.Key.ExcludeEmailFromExport, false) END 
            ))));
    }
","    public Response viewDataverse(@PathParam(""identifier"") String idtf) {
        return allowCors(response(req -> ok(
            json(execCommand(new GetDataverseCommand(req, findDataverseOrDie(idtf))),
                settingsService.isTrueForKey(SettingsServiceBean.Key.ExcludeEmailFromExport, false)
            ))));
    }
"
1706,"Should this better be:
  super(id.get())
?

At least in some other places [1] we provide the decoded id to ResourceNotFoundException(String). Shouldn't it be the same in all places, either always the decoded id or always the encoded id?

[1] https://gerrit-review.googlesource.com/#/c/41733/1/gerrit-server/src/main/java/com/google/gerrit/server/group/GroupsCollection.java","  public ResourceNotFoundException(IdString id) {
    super(id.encoded());
  }
","  public ResourceNotFoundException(IdString id) {
START     super(id.encoded()); END 
  }
","  public ResourceNotFoundException(IdString id) {
    super(id.get());
  }
"
1707,"if you use AppiumDriver<?> driver = (AppiumDriver<?>) getDriverSafe();
then there is no sense in if (driver instanceof AppiumDriver)","    private AppiumDriver getDriverSafe() {
        WebDriver driver = getDriver();
        if (driver instanceof EventFiringWebDriver) {
            driver = ((EventFiringWebDriver) driver).getWrappedDriver();
            if (driver instanceof AppiumDriver) {
                return (AppiumDriver) driver;
            }
        }
        throw new ClassCastException(""Appium Driver can not be casted from the actual driver."");
    }
","    private AppiumDriver getDriverSafe() {
        WebDriver driver = getDriver();
        if (driver instanceof EventFiringWebDriver) {
            driver = ((EventFiringWebDriver) driver).getWrappedDriver();
START             if (driver instanceof AppiumDriver) { END 
                return (AppiumDriver) driver;
            }
        }
        throw new ClassCastException(""Appium Driver can not be casted from the actual driver."");
    }
","    private WebDriver getDriverSafe() {
        WebDriver driver = getDriver();
        if (driver instanceof EventFiringWebDriver) {
            driver = ((EventFiringWebDriver) driver).getWrappedDriver();
        }
        return driver;
    }
"
1708,You forgot to revert that,"    public void assertSimilarity(final File actualFile, final double maxDistance) throws IOException {
        BufferedImage tempImg = ImageIO.read(actualFile);
        File tempFile = File.createTempFile(""print-test"", "".png"");
        ImageIO.write(tempImg, ""png"", tempFile);
        assertSimilarity(ImageIO.read(tempFile), maxDistance);
    }
","    public void assertSimilarity(final File actualFile, final double maxDistance) throws IOException {
        BufferedImage tempImg = ImageIO.read(actualFile);
        File tempFile = File.createTempFile(""print-test"", "".png"");
        ImageIO.write(tempImg, ""png"", tempFile);
START         assertSimilarity(ImageIO.read(tempFile), maxDistance); END 
    }
","    public void assertSimilarity(final File actualFile, final double maxDistance) throws IOException {
        assertSimilarity(ImageIO.read(actualFile), maxDistance);
    }
"
1709,Good catch. I also just spotted that a few other log messages in tryDoEnd are attribued to this. It will be clearer to just remove the LRARecord.doEnd prefix I think.,"    public URI getLocationHeaderAsURI() {
        try {
            return locationHeader != null ? new URI(locationHeader) : null;
        } catch (URISyntaxException e) {
            if (LRALogger.logger.isInfoEnabled()) {
                LRALogger.logger.infof(""LRARecord.doEnd missing Location header on ACCEPTED response %s failed: %s"",
                        getRequestURI(), e.getMessage());
            }

            return null;
        }
    }
","    public URI getLocationHeaderAsURI() {
        try {
            return locationHeader != null ? new URI(locationHeader) : null;
        } catch (URISyntaxException e) {
            if (LRALogger.logger.isInfoEnabled()) {
START                 LRALogger.logger.infof(""LRARecord.doEnd missing Location header on ACCEPTED response %s failed: %s"", END 
                        getRequestURI(), e.getMessage());
            }

            return null;
        }
    }
","    public URI getLocationHeaderAsURI() throws URISyntaxException {
        return locationHeader != null ? new URI(locationHeader) : null;
    }
"
1710,This seems redundant to me as we are logging in as the current user in the base class.,"    public void setup(Method method) throws Exception {
        logger.info(""test name: "" + method.getName());
        KerberosHelper.loginFromKeytab(MerlinConstants.CURRENT_USER_NAME);
        bundles[0] = Util.readELBundles()[0][0];
        bundles[0] = new Bundle(bundles[0], cluster.getEnvFileName(), cluster.getPrefix());
        bundles[0].generateUniqueBundle();
        bundles[0].setProcessWorkflow(aggregateWorkflowDir);
    }
","    public void setup(Method method) throws Exception {
        logger.info(""test name: "" + method.getName());
START         KerberosHelper.loginFromKeytab(MerlinConstants.CURRENT_USER_NAME); END 
        bundles[0] = Util.readELBundles()[0][0];
        bundles[0] = new Bundle(bundles[0], cluster.getEnvFileName(), cluster.getPrefix());
        bundles[0].generateUniqueBundle();
        bundles[0].setProcessWorkflow(aggregateWorkflowDir);
    }
","    public void setup(Method method) throws Exception {
        logger.info(""test name: "" + method.getName());
        bundles[0] = Util.readELBundles()[0][0];
        bundles[0] = new Bundle(bundles[0], cluster.getEnvFileName(), cluster.getPrefix());
        bundles[0].generateUniqueBundle();
        bundles[0].setProcessWorkflow(aggregateWorkflowDir);
    }
"
1711,Any reason not to check value of the view?,"    public View getOverflowMenuAnchor() {
        View view = getToolbar().findViewById(R.id.menu_overflow_button);
        return getToolbar();
    }
","    public View getOverflowMenuAnchor() {
        View view = getToolbar().findViewById(R.id.menu_overflow_button);
        START  return getToolbar(); END 
    }
","    public View getOverflowMenuAnchor() {
        View view = getToolbar().findViewById(R.id.menu_overflow_button);
        return view == null ? getToolbar() : view;
    }
"
1712,I thought we will catch the exception and call close() here and then rethrow,"  public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestInfos)
      throws IOException {
    if (closed) {
      throw new IllegalStateException(""The NetworkClient is closed."");
    }
    List<ResponseInfo> responseInfoList = new ArrayList<ResponseInfo>();
    for (RequestInfo requestInfo : requestInfos) {
      pendingRequests.add(new RequestMetadata(time.milliseconds(), requestInfo, null));
    }
    List<NetworkSend> sends = prepareSends(responseInfoList);
    selector.poll(POLL_TIMEOUT_MS, sends);
    handleSelectorEvents(responseInfoList);
    return responseInfoList;
  }
","  public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestInfos)
      throws IOException {
    if (closed) {
      throw new IllegalStateException(""The NetworkClient is closed."");
    }
    List<ResponseInfo> responseInfoList = new ArrayList<ResponseInfo>();
    for (RequestInfo requestInfo : requestInfos) {
      pendingRequests.add(new RequestMetadata(time.milliseconds(), requestInfo, null));
    }
    List<NetworkSend> sends = prepareSends(responseInfoList);
    selector.poll(POLL_TIMEOUT_MS, sends);
    handleSelectorEvents(responseInfoList);
START     return responseInfoList; END 
  }
","  public List<ResponseInfo> sendAndPoll(List<RequestInfo> requestInfos)
      throws IOException {
    if (closed) {
      throw new IllegalStateException(""The NetworkClient is closed."");
    }
    List<ResponseInfo> responseInfoList = new ArrayList<ResponseInfo>();
    for (RequestInfo requestInfo : requestInfos) {
      pendingRequests.add(new RequestMetadata(time.milliseconds(), requestInfo));
    }
    List<NetworkSend> sends = prepareSends(responseInfoList);
    selector.poll(POLL_TIMEOUT_MS, sends);
    handleSelectorEvents(responseInfoList);
    return responseInfoList;
  }
"
1713,"As far as I know, enums can be used with the ==/!= operators. It's a matter of style, but I prefer them (since an instance of an enum is really the same referenced entity as the enum constant). However, you can do whatever you like, either is fine by me.","    public void handleQuotaColumnVisibility() {
        isQuotaVisible = false;
        SystemTreeItemModel treeItem =
                (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem();
        if (treeItem != null
                && SystemTreeItemType.DataCenter.equals(treeItem.getType())) {
            StoragePool storagePool = (StoragePool) treeItem.getEntity();
            if (!QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
                isQuotaVisible = true;
            }
        }
        onDiskViewTypeChanged();
    }
","    public void handleQuotaColumnVisibility() {
        isQuotaVisible = false;
        SystemTreeItemModel treeItem =
                (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem();
        if (treeItem != null
START                 && SystemTreeItemType.DataCenter.equals(treeItem.getType())) { END 
            StoragePool storagePool = (StoragePool) treeItem.getEntity();
            if (!QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
                isQuotaVisible = true;
            }
        }
        onDiskViewTypeChanged();
    }
","    public void handleQuotaColumnVisibility() {
        isQuotaVisible = false;
        SystemTreeItemModel treeItem =
                (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem();
        if (treeItem != null
                && SystemTreeItemType.DataCenter == treeItem.getType()) {
            StoragePool storagePool = (StoragePool) treeItem.getEntity();
            if (QuotaEnforcementTypeEnum.DISABLED != storagePool.getQuotaEnforcementType()) {
                isQuotaVisible = true;
            }
        }
        onDiskViewTypeChanged();
    }
"
1714,"shouldn't you force the put?  Otherwise, what is returned might be different than what's in the cache, it's also possible that doesn't matter.","    public CompletableFuture<StaticResource> getResource(String name) {
        StaticResource template = templates.get(name);
        if (template != null) {
            return CompletableFuture.completedFuture(template);
        }
        
        return delegate
                .getResource(name)
                .exceptionally((th)   -> { templates.putIfAbsent(name, null); return null; } )
                .thenApply(    (file) -> { templates.putIfAbsent(name, file); return file; });
    }
","    public CompletableFuture<StaticResource> getResource(String name) {
        StaticResource template = templates.get(name);
        if (template != null) {
            return CompletableFuture.completedFuture(template);
        }
        
        return delegate
                .getResource(name)
                .exceptionally((th)   -> { templates.putIfAbsent(name, null); return null; } )
START                 .thenApply(    (file) -> { templates.putIfAbsent(name, file); return file; }); END 
    }
","    public CompletableFuture<Optional<StaticResource>> getResource(String name) {
        Optional<StaticResource> template = templates.get(name);
        if (template != null) {
            return CompletableFuture.completedFuture(template);
        }
        
        return delegate
                .getResource(name)
                .exceptionally((th)   -> { return Optional.empty(); } )
                .thenApply(    (file) -> { templates.put(name, file); return file; });
    }
"
1715,OpenSSL also supports it in a similar way on the server-side. See SSL_OP_NO_TICKET on this page: https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_options.html.,"    public void testSessionTicketsWithTLSv13AndNoKey() throws Throwable {
        assumeTrue(OpenSsl.isTlsv13Supported());
        assumeTrue(OpenSsl.isBoringSSL());
        testSessionTickets(SslUtils.PROTOCOL_TLS_V1_3, false);
    }
","    public void testSessionTicketsWithTLSv13AndNoKey() throws Throwable {
        assumeTrue(OpenSsl.isTlsv13Supported());
START         assumeTrue(OpenSsl.isBoringSSL()); END 
        testSessionTickets(SslUtils.PROTOCOL_TLS_V1_3, false);
    }
","    public void testSessionTicketsWithTLSv13AndNoKey() throws Throwable {
        assumeTrue(OpenSsl.isTlsv13Supported());
        testSessionTickets(SslUtils.PROTOCOL_TLS_V1_3, false);
    }
"
1716,"a BeforeClass has to be static (it doesn't tell you until you actually try to run it)

I was wondering why this passed Hudson, but then remembered the perf tests don't run, yet...","    public void setUp() {
        TmfEventMatching.registerMatchObject(new TcpEventMatching());
        TmfEventMatching.registerMatchObject(new TcpLttngEventMatching());
    }
","START     public void setUp() { END 
        TmfEventMatching.registerMatchObject(new TcpEventMatching());
        TmfEventMatching.registerMatchObject(new TcpLttngEventMatching());
    }
","    public static void setUp() {
        TmfEventMatching.registerMatchObject(new TcpEventMatching());
        TmfEventMatching.registerMatchObject(new TcpLttngEventMatching());
    }
"
1717,Would it make more sense to mark the brand parameter of setBrand as @NonNull instead of checking it here?,"	protected void updateTitle(String brand) {
		if (brand != null) {
			IBrandManager brandManager = TasksUiPlugin.getDefault().getBrandManager();
			setTitle(brandManager.getConnectorLabel(getConnector(), brand));
		}
	}
","	protected void updateTitle(String brand) {
START 		if (brand != null) { END 
			IBrandManager brandManager = TasksUiPlugin.getDefault().getBrandManager();
			setTitle(brandManager.getConnectorLabel(getConnector(), brand));
		}
	}
","	protected void updateTitle(String brand) {
		IBrandManager brandManager = TasksUiPlugin.getDefault().getBrandManager();
		setTitle(brandManager.getConnectorLabel(getConnector(), brand));
	}
"
1718,I'd rather throw an exception,"   public static int getSegmentForKey(Object key, Cache cache) {
      KeyPartitioner keyPartitioner = extractComponent(cache, KeyPartitioner.class);
      if (keyPartitioner != null) {
         return keyPartitioner.getSegment(key);
      }
      return SegmentSpecificCommand.UNKNOWN_SEGMENT;
   }
","   public static int getSegmentForKey(Object key, Cache cache) {
      KeyPartitioner keyPartitioner = extractComponent(cache, KeyPartitioner.class);
      if (keyPartitioner != null) {
         return keyPartitioner.getSegment(key);
      }
START       return SegmentSpecificCommand.UNKNOWN_SEGMENT; END 
   }
","   public static int getSegmentForKey(Object key, Cache cache) {
      KeyPartitioner keyPartitioner = extractComponent(cache, KeyPartitioner.class);
      return keyPartitioner.getSegment(key);
   }
"
