,comment,before,before_marked,after
0,"Setting the alias and temp directory can be quite important. Perhaps make this an optional argument? So you can overwrite the alias when needed (i.e. to improve performance).
Right now all instances will be cached under the same name.","	public void startRuntime() {
		String tempDir = AppConstants.getInstance().getString(""log.dir"", null);
		v8 = V8.createV8Runtime(""J2V8Javascript"", tempDir);
	}
","	public void startRuntime() {
		String tempDir = AppConstants.getInstance().getString(""log.dir"", null);
START 		v8 = V8.createV8Runtime(""J2V8Javascript"", tempDir); END 
	}
","	public void startRuntime() {
		v8 = V8.createV8Runtime();
	}
"
1,"This bloc of code is repeated many times, should be centralized in a single method.","    public GWCConfig getConfig() {
        if (gsEnvironment != null && gsEnvironment.isStale()) {
            syncEnvironment();
        }
        return gwcConfigPersister.getConfig();
    }
","    public GWCConfig getConfig() {
START         if (gsEnvironment != null && gsEnvironment.isStale()) { END 
            syncEnvironment();
        }
        return gwcConfigPersister.getConfig();
    }
","    public GWCConfig getConfig() {
        return gwcConfigPersister.getConfig();
    }
"
2,"again, maybe StringUtils.defaultString()","    private BlackboardArtifact createDownloadArtifact(AbstractFile zoneFile, ZoneIdentifierInfo zoneInfo) {

        Collection<BlackboardAttribute> bbattributes = createDownloadAttributes(
                null, null,
                zoneInfo.getURL(), null,
                (zoneInfo.getURL() != null ? NetworkUtils.extractDomain(zoneInfo.getURL()) : """"),
                null);
        return addArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD, zoneFile, bbattributes);
    }
","    private BlackboardArtifact createDownloadArtifact(AbstractFile zoneFile, ZoneIdentifierInfo zoneInfo) {

        Collection<BlackboardAttribute> bbattributes = createDownloadAttributes(
                null, null,
                zoneInfo.getURL(), null,
START                 (zoneInfo.getURL() != null ? NetworkUtils.extractDomain(zoneInfo.getURL()) : """"), END 
                null);
        return addArtifact(BlackboardArtifact.ARTIFACT_TYPE.TSK_WEB_DOWNLOAD, zoneFile, bbattributes);
    }
","    private BlackboardArtifact createDownloadArtifact(AbstractFile zoneFile, ZoneIdentifierInfo zoneInfo) {

        Collection<BlackboardAttribute> bbattributes = createDownloadAttributes(
                null, null,
                zoneInfo.getURL(), null,
                (zoneInfo.getURL() != null ? NetworkUtils.extractDomain(zoneInfo.getURL()) : """"),
                null);
        return addArtifact(TSK_WEB_DOWNLOAD, zoneFile, bbattributes);
    }
"
3,I fear we won't be able to add this fail fast (although I always like any proposal to add more fail fasts :)). The other fail fasts added in the PR are fine.,"    public IncrementalScoreDirector(IncrementalScoreDirectorFactory scoreDirectorFactory,
                                    boolean constraintMatchEnabledPreference,
                                    IncrementalScoreCalculator<Solution_> incrementalScoreCalculator) {
        super(scoreDirectorFactory, constraintMatchEnabledPreference);
        if (constraintMatchEnabledPreference
                && !(incrementalScoreCalculator instanceof ConstraintMatchAwareIncrementalScoreCalculator)) {
            throw new IllegalStateException(""The score calculator "" + incrementalScoreCalculator + "" must implement ""
                    + ConstraintMatchAwareIncrementalScoreCalculator.class.getSimpleName()
                    + "" when constraintMatchEnabledPreference is true."");
        }
        this.incrementalScoreCalculator = incrementalScoreCalculator;
    }
","    public IncrementalScoreDirector(IncrementalScoreDirectorFactory scoreDirectorFactory,
                                    boolean constraintMatchEnabledPreference,
                                    IncrementalScoreCalculator<Solution_> incrementalScoreCalculator) {
        super(scoreDirectorFactory, constraintMatchEnabledPreference);
        if (constraintMatchEnabledPreference
                && !(incrementalScoreCalculator instanceof ConstraintMatchAwareIncrementalScoreCalculator)) {
            throw new IllegalStateException(""The score calculator "" + incrementalScoreCalculator + "" must implement ""
                    + ConstraintMatchAwareIncrementalScoreCalculator.class.getSimpleName()
                    + "" when constraintMatchEnabledPreference is true."");
START         } END 
        this.incrementalScoreCalculator = incrementalScoreCalculator;
    }
","    public IncrementalScoreDirector(IncrementalScoreDirectorFactory scoreDirectorFactory,
                                    boolean constraintMatchEnabledPreference,
                                    IncrementalScoreCalculator<Solution_> incrementalScoreCalculator) {
        super(scoreDirectorFactory, constraintMatchEnabledPreference);
        this.incrementalScoreCalculator = incrementalScoreCalculator;
    }
"
4,no need for the return statement.,"	public static void copyFile(InputStream inputStream, OutputStream outputStream) throws IOException {
		if (inputStream == null || outputStream == null) {
			if (outputStream != null) {
				IOUtils.closeQuietly(outputStream);
			}
			return;
		}

		try {
			IOUtils.copy(inputStream, outputStream);
		} finally {
			IOUtils.closeQuietly(outputStream);
			return;
		}

	}
","	public static void copyFile(InputStream inputStream, OutputStream outputStream) throws IOException {
		if (inputStream == null || outputStream == null) {
			if (outputStream != null) {
				IOUtils.closeQuietly(outputStream);
			}
			return;
		}

		try {
			IOUtils.copy(inputStream, outputStream);
		} finally {
			IOUtils.closeQuietly(outputStream);
START 			return; END 
		}

	}
","	public static void copyFile(InputStream inputStream, OutputStream outputStream) throws IOException {

		if (inputStream == null || outputStream == null) {
			if (outputStream != null) {
				IOUtils.closeQuietly(outputStream);
			}
			return;
		}

		try {
			IOUtils.copy(inputStream, outputStream);
		} finally {
			IOUtils.closeQuietly(outputStream);
		}

	}
"
5,"Change to `Assert.state(session != null, ""Session was not initialized"");`","	protected void before() throws Throwable {

		if (session == null) {
			throw new IllegalStateException(""Session was not initialized"");
		}

		session.execute(String.format(""CREATE KEYSPACE %s WITH durable_writes = false AND ""
				+ ""replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};"", keyspaceName));
		session.execute(String.format(""USE %s;"", keyspaceName));
	}
","	protected void before() throws Throwable {

START 		if (session == null) { END 
			throw new IllegalStateException(""Session was not initialized"");
		}

		session.execute(String.format(""CREATE KEYSPACE %s WITH durable_writes = false AND ""
				+ ""replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};"", keyspaceName));
		session.execute(String.format(""USE %s;"", keyspaceName));
	}
","	protected void before() throws Throwable {

		Assert.state(session != null, ""Session was not initialized"");

		session.execute(String.format(""CREATE KEYSPACE %s WITH durable_writes = false AND ""
				+ ""replication = {'class': 'SimpleStrategy', 'replication_factor' : 1};"", keyspaceName));
		session.execute(String.format(""USE %s;"", keyspaceName));
	}
"
6,"Not needed, the next statement handles it in the DB, do we really care if we have the status changed in the instance?","    private void lockImageInDb() {
        final DiskImage diskImage = getDiskImage();

        TransactionSupport.executeInNewTransaction(() -> {
            getCompensationContext().snapshotEntityStatus(diskImage.getImage());
            diskImage.setImageStatus(ImageStatus.LOCKED);
            ImagesHandler.updateImageStatus(diskImage.getImageId(), ImageStatus.LOCKED);
            getCompensationContext().stateChanged();
            return null;
        });
    }
","    private void lockImageInDb() {
        final DiskImage diskImage = getDiskImage();

        TransactionSupport.executeInNewTransaction(() -> {
            getCompensationContext().snapshotEntityStatus(diskImage.getImage());
START             diskImage.setImageStatus(ImageStatus.LOCKED); END 
            ImagesHandler.updateImageStatus(diskImage.getImageId(), ImageStatus.LOCKED);
            getCompensationContext().stateChanged();
            return null;
        });
    }
","    private void lockImageInDb() {
        final DiskImage diskImage = getDiskImage();

        TransactionSupport.executeInNewTransaction(() -> {
            getCompensationContext().snapshotEntityStatus(diskImage.getImage());
            ImagesHandler.updateImageStatus(diskImage.getImageId(), ImageStatus.LOCKED);
            getCompensationContext().stateChanged();
            return null;
        });
    }
"
7,"What's the motivation for swallowing this exception, and is it really only a warning? Also, could we use `closeQuietly` (or an improved version if we want the logging)?","  public synchronized void close() {
    try {
      Closer closer = Closer.create();
      if (mJournalOutputStream != null) {
        closer.register(mJournalOutputStream);
      }
      closer.register(mGarbageCollector);
      closer.close();
    } catch (IOException e) {
      LOG.warn(""Failed to close UfsJournalLogWriter with error: {}."", e.getMessage());
    }
    mClosed = true;
  }
","  public synchronized void close() {
    try {
      Closer closer = Closer.create();
      if (mJournalOutputStream != null) {
        closer.register(mJournalOutputStream);
      }
      closer.register(mGarbageCollector);
      closer.close();
    } catch (IOException e) {
START       LOG.warn(""Failed to close UfsJournalLogWriter with error: {}."", e.getMessage()); END 
    }
    mClosed = true;
  }
","  public synchronized void close() throws IOException {
    Closer closer = Closer.create();
    if (mJournalOutputStream != null) {
      closer.register(mJournalOutputStream);
    }
    closer.register(mGarbageCollector);
    closer.close();
    mClosed = true;
  }
"
8,"The logging actually happens on the ""client"" side. So we'll need to setup the log level there, maybe using `@BeforeClass` and `@AfterClass`? I tried to move this code to the `AbstractShutdownHookTest.deploy()` method and it seemed to work.","    public void testFooPing() {
        // change logging level, does NOT work
        Logger logger = Logger.getLogger(JMXMethodExecutor.class.getName());
        Level originalLevel = logger.getLevel();
        logger.setLevel(Level.OFF);
        // Initialize weld, Foo bean is used in observer
        new Weld().initialize();
        logger.setLevel(originalLevel);
    }
","    public void testFooPing() {
        // change logging level, does NOT work
START         Logger logger = Logger.getLogger(JMXMethodExecutor.class.getName()); END 
        Level originalLevel = logger.getLevel();
        logger.setLevel(Level.OFF);
        // Initialize weld, Foo bean is used in observer
        new Weld().initialize();
        logger.setLevel(originalLevel);
    }
","    public void testFooPing() {
        // Initialize weld, Foo bean is used in observer
        new Weld().initialize();
    }
"
9,One empty line too much.,"    public void searchForProcesses() throws Exception {
        desktopPage.searchInSearchField(""process"");
        int numberOfResults = searchResultPage.getNumberOfResults();
        assertEquals(""There should be two processes found"",2,numberOfResults);

        searchResultPage.searchInSearchField(""proc"");
        numberOfResults = searchResultPage.getNumberOfResults();
        assertEquals(""There should be two processes found"",2,numberOfResults);


        searchResultPage.searchInSearchField(""möhö"");
        numberOfResults = searchResultPage.getNumberOfResults();
        assertEquals(""There should be no process found"",0,numberOfResults);

    }
","    public void searchForProcesses() throws Exception {
        desktopPage.searchInSearchField(""process"");
        int numberOfResults = searchResultPage.getNumberOfResults();
        assertEquals(""There should be two processes found"",2,numberOfResults);

        searchResultPage.searchInSearchField(""proc"");
        numberOfResults = searchResultPage.getNumberOfResults();
        assertEquals(""There should be two processes found"",2,numberOfResults);


        searchResultPage.searchInSearchField(""möhö"");
        numberOfResults = searchResultPage.getNumberOfResults();
        assertEquals(""There should be no process found"",0,numberOfResults);
START  END 
    }
","    public void searchForProcesses() throws Exception {
        desktopPage.searchInSearchField(""process"");
        int numberOfResults = searchResultPage.getNumberOfResults();
        assertEquals(""There should be two processes found"",2,numberOfResults);

        searchResultPage.searchInSearchField(""proc"");
        numberOfResults = searchResultPage.getNumberOfResults();
        assertEquals(""There should be two processes found"",2,numberOfResults);

        //TODO: selenium is too fast here and counts results from previous search
        searchResultPage.searchInSearchField(""möhö"");
        numberOfResults = searchResultPage.getNumberOfResults();
        //assertEquals(""There should be no process found"",0,numberOfResults);

    }
"
10,"new HashMap<String,Object>(0) or Collections.<String, Object>emptyMap() if immutable","	public AS7ManagementDetails(IServer server) {
		this(server, new HashMap<String,Object>());
	}
","	public AS7ManagementDetails(IServer server) {
START 		this(server, new HashMap<String,Object>()); END 
	}
","	public AS7ManagementDetails(IServer server) {
		this(server, new HashMap<String,Object>(0));
	}
"
11,Do we need FQCN?,"    public CommandResult<RuleViolation> execute(final GraphCommandExecutionContext context) {
        final CommandResult<RuleViolation> results = allow(context);
        if (!results.getType().equals(CommandResult.Type.ERROR)) {
            final org.kie.workbench.common.stunner.core.graph.Graph graph = getGraph(context);
            graph.addNode(candidate);
            getMutableIndex(context).addNode(candidate);
        }
        return results;
    }
","    public CommandResult<RuleViolation> execute(final GraphCommandExecutionContext context) {
        final CommandResult<RuleViolation> results = allow(context);
        if (!results.getType().equals(CommandResult.Type.ERROR)) {
START             final org.kie.workbench.common.stunner.core.graph.Graph graph = getGraph(context); END 
            graph.addNode(candidate);
            getMutableIndex(context).addNode(candidate);
        }
        return results;
    }
","    public CommandResult<RuleViolation> execute(final GraphCommandExecutionContext context) {
        final CommandResult<RuleViolation> results = allow(context);
        if (!results.getType().equals(CommandResult.Type.ERROR)) {
            final Graph graph = getGraph(context);
            graph.addNode(candidate);
            getMutableIndex(context).addNode(candidate);
        }
        return results;
    }
"
12,"might be better to return the exception so that you can directly see that it exits in the code

`throw dataTableHeaderMayOnlyContainVariableNames(column.get(0));`","  private static void dataTableHeaderMayOnlyContainVariableNames(ASTNode stat) throws InvalidSpecCompileException {
    throw new InvalidSpecCompileException(stat, ""Header of data table may only contain variable names"");
  }
","START   private static void dataTableHeaderMayOnlyContainVariableNames(ASTNode stat) throws InvalidSpecCompileException { END 
    throw new InvalidSpecCompileException(stat, ""Header of data table may only contain variable names"");
  }
","  private static InvalidSpecCompileException dataTableHeaderMayOnlyContainVariableNames(ASTNode stat) {
    return new InvalidSpecCompileException(stat, ""Header of data table may only contain variable names"");
  }
"
13,"If we move the logic to the builder factories, this would not be needed.","	public static <T> MutableMessageBuilder<T> fromMessage(Message<T> message) {
		Assert.notNull(message, ""message must not be null"");
		if (message instanceof CloneableMessage) {
			logger.warn(""For CloneableMessages consider to use regular MessageBuilder. "" +
					""Otherwise custom Message context may be lost."");
		}
		return new MutableMessageBuilder<T>(message);
	}
","	public static <T> MutableMessageBuilder<T> fromMessage(Message<T> message) {
		Assert.notNull(message, ""message must not be null"");
		if (message instanceof CloneableMessage) {
			logger.warn(""For CloneableMessages consider to use regular MessageBuilder. "" +
					""Otherwise custom Message context may be lost."");
START 		} END 
		return new MutableMessageBuilder<T>(message);
	}
","	public static <T> MutableMessageBuilder<T> fromMessage(Message<T> message) {
		Assert.notNull(message, ""message must not be null"");
		return new MutableMessageBuilder<T>(message);
	}
"
14,"This implies you're expecting that ""Code Review"" and ""Verified"" below to always be integers (otherwise, you break silently so you must be.)

I think this seems to have an underlying implication that the data type for both getters really should be ""Integer"". You can always convert an integer to a string safely but this isn't true for parsing some arbitrary string IMO.

Thoughts?","	public Image getColumnImage(Object element, int columnIndex) {
		TaskReview reviewContainer = (TaskReview) element;

		switch (columnIndex) {
		case 0:
			return getIncomingChangesImage();
		case 1:
			try {
				return getReviewStateImage(Integer.parseInt(reviewContainer.getCr()));
			} catch (Exception e) {
				break;
			}
		case 2:
			try {
				return getVerifiedStateImage(Integer.parseInt(reviewContainer.getV()));
			} catch (Exception e) {
				break;
			}
		}

		return null;
	}
","	public Image getColumnImage(Object element, int columnIndex) {
		TaskReview reviewContainer = (TaskReview) element;

		switch (columnIndex) {
		case 0:
			return getIncomingChangesImage();
		case 1:
			try {
START 				return getReviewStateImage(Integer.parseInt(reviewContainer.getCr())); END 
			} catch (Exception e) {
				break;
			}
		case 2:
			try {
				return getVerifiedStateImage(Integer.parseInt(reviewContainer.getV()));
			} catch (Exception e) {
				break;
			}
		}

		return null;
	}
","	public Image getColumnImage(Object element, int columnIndex) {
		TaskReview reviewContainer = (TaskReview) element;

		switch (columnIndex) {
		case 0:
			return getIncomingChangesImage();
		case 1:
			return getReviewStateImage(reviewContainer.getCr());
		case 2:
			return getVerifiedStateImage(reviewContainer.getV());
		}

		return null;
	}
"
15,let's add `protected` here to be symmetric to what other fields that are accessed by the context have as scope,"    WorkerErrantRecordReporter workerErrantRecordReporter() {
        return workerErrantRecordReporter;
    }
","START     WorkerErrantRecordReporter workerErrantRecordReporter() { END 
        return workerErrantRecordReporter;
    }
","    protected WorkerErrantRecordReporter workerErrantRecordReporter() {
        return workerErrantRecordReporter;
    }
"
16,"According to logic in BaseEditVmInterfaceModel:

nicTypes = nicTypes == null ? new ArrayList<VmInterfaceType>() : nicTypes;

the items are expected to be an empty ArrayList. In that case the items.iterator().next() would fail on NoSuchElementException.","    public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items)
    {
        return items.contains(VmInterfaceType.pv) ? VmInterfaceType.pv : items.iterator().next();
    }
","    public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items)
    {
START         return items.contains(VmInterfaceType.pv) ? VmInterfaceType.pv : items.iterator().next(); END 
    }
","    public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items)
    {
        if (items == null || items.isEmpty()) {
            return null;
        } else if (items.contains(VmInterfaceType.pv)) {
            return VmInterfaceType.pv;
        } else {
            return items.iterator().next();
        }
    }
"
17,"Don't need to wait for the tx completion responses before removing the local info here either, although since removing the local info is expensive you could still send the command first.","   public CompletionStage<Void> removeRecoveryInformationFromCluster(Collection<Address> where, long internalId) {
      if (rpcManager != null) {
         TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(internalId);
         CompletionStage<Void> stage = sendTxCompletionNotification(where, ftc);
         return stage.thenRun(() -> removeRecoveryInformation(internalId));
      } else {
         removeRecoveryInformation(internalId);
         return CompletableFutures.completedNull();
      }
   }
","   public CompletionStage<Void> removeRecoveryInformationFromCluster(Collection<Address> where, long internalId) {
      if (rpcManager != null) {
         TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(internalId);
         CompletionStage<Void> stage = sendTxCompletionNotification(where, ftc);
START          return stage.thenRun(() -> removeRecoveryInformation(internalId)); END 
      } else {
         removeRecoveryInformation(internalId);
         return CompletableFutures.completedNull();
      }
   }
","   public CompletionStage<Void> removeRecoveryInformationFromCluster(Collection<Address> where, long internalId) {
      if (rpcManager != null) {
         TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(internalId);
         CompletionStage<Void> stage = sendTxCompletionNotification(where, ftc);
         removeRecoveryInformation(internalId);
         return stage;
      } else {
         removeRecoveryInformation(internalId);
         return CompletableFutures.completedNull();
      }
   }
"
18,Could be extracted to a `private static final` constant.,"    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)
    {
      if (args.size() >= 1) {
        throw new IAE(""Function[%s] needs 0 argument"", name());
      }

      return ExprEval.of(Math.PI);
    }
","    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)
    {
      if (args.size() >= 1) {
        throw new IAE(""Function[%s] needs 0 argument"", name());
      }

START       return ExprEval.of(Math.PI); END 
    }
","    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)
    {
      if (args.size() >= 1) {
        throw new IAE(""Function[%s] needs 0 argument"", name());
      }

      return ExprEval.of(PI);
    }
"
19,rename to entry,"	public static List<CPListElement> getExistingEntries(IJavaProject project) throws JavaModelException {
		ArrayList<CPListElement> newClassPath= new ArrayList<>();
		for (IClasspathEntry curr : project.getRawClasspath()) {
			newClassPath.add(CPListElement.createFromExisting(curr, project));
		}
		return newClassPath;
	}
","	public static List<CPListElement> getExistingEntries(IJavaProject project) throws JavaModelException {
		ArrayList<CPListElement> newClassPath= new ArrayList<>();
		for (IClasspathEntry START  curr : END  project.getRawClasspath()) {
			newClassPath.add(CPListElement.createFromExisting(curr, project));
		}
		return newClassPath;
	}
","	public static List<CPListElement> getExistingEntries(IJavaProject project) throws JavaModelException {
		ArrayList<CPListElement> newClassPath= new ArrayList<>();
		for (IClasspathEntry entry : project.getRawClasspath()) {
			newClassPath.add(CPListElement.createFromExisting(entry, project));
		}
		return newClassPath;
	}
"
20,"Hmm, I am suprised this is the case.  I am using Intellij 14.0.2.  Yourself?","  public final List<A> minus(final Equal<A> eq, final List<A> xs) {
    return this.removeAll(compose(Monoid.disjunctionMonoid.sumLeft(), xs.mapM(Function.<A, A, Boolean>curry(eq.eq()))));
  }
","  public final List<A> minus(final Equal<A> eq, final List<A> xs) {
    return this.removeAll(compose(Monoid.disjunctionMonoid.sumLeft(), xs.mapM(Function.<A, A, Boolean>curry(eq.eq()))));
START   } END 
","  public final List<A> minus(final Equal<A> eq, final List<A> xs) {
    return removeAll(compose(Monoid.disjunctionMonoid.sumLeft(), xs.mapM(curry(eq.eq()))));
  }
"
21,"This is not a good way to set up things. If both defaultHint and defaultBackend is set, the end result depends on the order...

Either some checking (and possibly logging) is required here, or we should define a clear priority between the settings, and the build method should ensure that.","        public Builder withDefaultHint(QueryEvaluationHint engineDefaultHints) {
            this.engineDefaultHints = engineDefaultHints;
            this.defaultBackendFactory = engineDefaultHints.getQueryBackendFactory();
            return this;
        }
","        public Builder withDefaultHint(QueryEvaluationHint engineDefaultHints) {
            this.engineDefaultHints = engineDefaultHints;
START             this.defaultBackendFactory = engineDefaultHints.getQueryBackendFactory(); END 
            return this;
        }
","        public Builder withDefaultHint(QueryEvaluationHint engineDefaultHints) {
            this.engineDefaultHints = engineDefaultHints;
            return this;
        }
"
22,I don't think calling super is what I'd do here,"	public Integer getIdle() {
		HikariPool pool = getHikariPool();
		if (Objects.nonNull(pool)) {
			return pool.getIdleConnections();
		}

		return super.getIdle();
	}
","	public Integer getIdle() {
		HikariPool pool = getHikariPool();
		if (Objects.nonNull(pool)) {
			return pool.getIdleConnections();
		}

START 		return super.getIdle(); END 
	}
","	public Integer getIdle() {
		HikariPool pool = getHikariPool();
		if (Objects.nonNull(pool)) {
			return pool.getIdleConnections();
		}

		return null;
	}
"
23,Let's remove these `checkArgument`s as these are not critical checks & we will probably forget to remove these when `MinDuration` gets fixed.,"    ElasticsearchTableDescriptionProvider(ElasticsearchConnectorConfig config, JsonCodec<ElasticsearchTableDescription> codec)
    {
        requireNonNull(config, ""config is null"");
        requireNonNull(codec, ""codec is null"");
        checkArgument(config.getScrollTimeout().toMillis() >= 10, ""scrollTimeout must be at least 10 ms"");
        checkArgument(config.getRequestTimeout().toMillis() >= 10, ""requestTimeout must be at least 10 ms"");
        tableDefinitions = createTableDescriptions(config, codec);
    }
","    ElasticsearchTableDescriptionProvider(ElasticsearchConnectorConfig config, JsonCodec<ElasticsearchTableDescription> codec)
    {
        requireNonNull(config, ""config is null"");
        requireNonNull(codec, ""codec is null"");
START         checkArgument(config.getScrollTimeout().toMillis() >= 10, ""scrollTimeout must be at least 10 ms""); END 
        checkArgument(config.getRequestTimeout().toMillis() >= 10, ""requestTimeout must be at least 10 ms"");
        tableDefinitions = createTableDescriptions(config, codec);
    }
","    ElasticsearchTableDescriptionProvider(ElasticsearchConnectorConfig config, JsonCodec<ElasticsearchTableDescription> codec)
    {
        requireNonNull(config, ""config is null"");
        requireNonNull(codec, ""codec is null"");
        tableDefinitions = createTableDescriptions(config, codec);
    }
"
24,What if fSelectionProvider is null? NPE will be thrown.,"	public void dispose() {
		if (fRegisterInProvider) {
			unregisterActions();
		}
		fSelectionProvider = null;
		fFindDeclarationsAction = null;
		fFindDeclarationsInProjectAction = null;
		fFindDeclarationsInHierarchyAction = null;
		fFindDeclarationsInWorkingSetAction = null;
		updateGlobalActionHandlers();
		super.dispose();
	}
","	public void dispose() {
START 		if (fRegisterInProvider) {
			unregisterActions();
		} END 
		fSelectionProvider = null;
		fFindDeclarationsAction = null;
		fFindDeclarationsInProjectAction = null;
		fFindDeclarationsInHierarchyAction = null;
		fFindDeclarationsInWorkingSetAction = null;
		updateGlobalActionHandlers();
		super.dispose();
	}
","	public void dispose() {
		unregisterActions();

		fSelectionProvider = null;
		fFindDeclarationsAction = null;
		fFindDeclarationsInProjectAction = null;
		fFindDeclarationsInHierarchyAction = null;
		fFindDeclarationsInWorkingSetAction = null;
		updateGlobalActionHandlers();
		super.dispose();
	}
"
25,Minor thing: I'm generally not happy with reassigning method parameters.,"    public void addError(Throwable error) {
        if (error == null) {
            throw new NullPointerException(""Error cannot be null"");
        }
        if (error instanceof AssumptionViolatedException) {
            AssertionError e = new AssertionError(error.getMessage());
            e.initCause(error);
            error = e;
        }
        errors.add(error);
    }
","    public void addError(Throwable error) {
        if (error == null) {
            throw new NullPointerException(""Error cannot be null"");
        }
        if (error instanceof AssumptionViolatedException) {
            AssertionError e = new AssertionError(error.getMessage());
            e.initCause(error);
START             error = e; END 
        }
        errors.add(error);
    }
","    public void addError(Throwable error) {
        if (error == null) {
            throw new NullPointerException(""Error cannot be null"");
        }
        if (error instanceof AssumptionViolatedException) {
            AssertionError e = new AssertionError(error.getMessage());
            e.initCause(error);
            errors.add(e);
        } else {
            errors.add(error);
        }
    }
"
26,Shouldn't the test be synchronized as in `Http1xClientConnection.java`?,"  protected void handleIdle() {
    if (streams.isEmpty()) {
      return;
    }
    super.handleIdle();
  }
","  protected void handleIdle() {
START     if (streams.isEmpty()) { END 
      return;
    }
    super.handleIdle();
  }
","  protected void handleIdle() {
    synchronized (this) {
      if (streams.isEmpty()) {
        return;
      }
    }
    super.handleIdle();
  }
"
27,"I know this was pre-existing, but the variable is capitalized Map, but should be just map.","  public String get(String key) {
    Map<String, String> Map = inheritableThreadLocal.get();
    if ((Map != null) && (key != null)) {
      return Map.get(key);
    } else {
      return null;
    }
  }
","  public String get(String key) {
START     Map<String, String> Map = inheritableThreadLocal.get(); END 
    if ((Map != null) && (key != null)) {
      return Map.get(key);
    } else {
      return null;
    }
  }
","    public String get(String key) {
        Map<String, String> map = inheritableThreadLocal.get();
        if ((map != null) && (key != null)) {
            return map.get(key);
        } else {
            return null;
        }
    }
"
28,@marko-bekhta Is this still a left-over? I.e. are you planning to revert this change as per our discussion above? Same question for some more places where `Locale.getDefault()` is used now.,"		public void containsConversion(Class<?> from, Class<?> to) {
			isNotNull();

			boolean foundMatchingConversion = false;

			for ( GroupConversionDescriptor groupConversionDescriptor : actual ) {
				if ( groupConversionDescriptor.getFrom().equals( from ) &&
						groupConversionDescriptor.getTo().equals( to ) ) {
					foundMatchingConversion = true;
					break;
				}
			}

			if ( !foundMatchingConversion ) {
				fail( String.format( Locale.getDefault(), ""<%s> does not contain a conversion from <%s> to <%s>."", actual, from, to ) );
			}
		}
","		public void containsConversion(Class<?> from, Class<?> to) {
			isNotNull();

			boolean foundMatchingConversion = false;

			for ( GroupConversionDescriptor groupConversionDescriptor : actual ) {
				if ( groupConversionDescriptor.getFrom().equals( from ) &&
						groupConversionDescriptor.getTo().equals( to ) ) {
					foundMatchingConversion = true;
					break;
				}
			}

			if ( !foundMatchingConversion ) {
START 				fail( String.format( Locale.getDefault(), ""<%s> does not contain a conversion from <%s> to <%s>."", actual, from, to ) ); END 
			}
		}
","		public void containsConversion(Class<?> from, Class<?> to) {
			isNotNull();

			boolean foundMatchingConversion = false;

			for ( GroupConversionDescriptor groupConversionDescriptor : actual ) {
				if ( groupConversionDescriptor.getFrom().equals( from ) &&
						groupConversionDescriptor.getTo().equals( to ) ) {
					foundMatchingConversion = true;
					break;
				}
			}

			if ( !foundMatchingConversion ) {
				fail( String.format( ""<%s> does not contain a conversion from <%s> to <%s>."", actual, from, to ) );
			}
		}
"
29,Copy paste error ?,"    public synchronized void setTailSegment(long tailSegment) {
        dataStore.put(Long.class, PREFIX_TAIL_SEGMENT, KEY_TAIL_SEGMENT, tailSegment);
        // Set the epoch in the router as well.
        //TODO need to figure out if we can remove this redundancy
        serverRouter.setServerEpoch(tailSegment);
    }
","    public synchronized void setTailSegment(long tailSegment) {
        dataStore.put(Long.class, PREFIX_TAIL_SEGMENT, KEY_TAIL_SEGMENT, tailSegment);
        // Set the epoch in the router as well.
        //TODO need to figure out if we can remove this redundancy
START         serverRouter.setServerEpoch(tailSegment); END 
    }
","    public void setTailSegment(long tailSegment) {
        dataStore.put(Long.class, PREFIX_TAIL_SEGMENT, KEY_TAIL_SEGMENT, tailSegment);
    }
"
30,"FYI, `TimeUnit.SECONDS.sleep(seconds.longValue())`","	public void sleep(IInteger seconds) {
	    try {
            Thread.sleep(TimeUnit.SECONDS.toMillis(seconds.longValue()));
        }
        catch (InterruptedException e) {
        }
	}
","	public void sleep(IInteger seconds) {
	    try {
START             Thread.sleep(TimeUnit.SECONDS.toMillis(seconds.longValue())); END 
        }
        catch (InterruptedException e) {
        }
	}
","	public void sleep(IInteger seconds) {
	    try {
            TimeUnit.SECONDS.sleep(seconds.longValue());
        }
        catch (InterruptedException e) {
        }
	}
"
31,I see that `connectionAccessProvidedConnection` isn't used. Is the check on `connectionAccess` and the cast there just to make sure that the connection was provided?,"	public void release() {
		JdbcConnectionAccess connectionAccess = jdbcContext.getJdbcConnectionAccess();
		if( !( connectionAccess instanceof JdbcConnectionAccessProvidedConnectionImpl ) ) {
			throw new IllegalStateException( ""DdlTransactionIsolatorProvidedConnectionImpl should always use a JdbcConnectionAccessProvidedConnectionImpl"" );
		}
		JdbcConnectionAccessProvidedConnectionImpl connectionAccessProvidedConnection =
			(JdbcConnectionAccessProvidedConnectionImpl) connectionAccess;
		try {
			connectionAccess.releaseConnection( null );
		}
		catch (SQLException ignore) {
			LOG.unableToReleaseIsolatedConnection( ignore );
		}
	}
","	public void release() {
START 		JdbcConnectionAccess connectionAccess = jdbcContext.getJdbcConnectionAccess(); END 
		if( !( connectionAccess instanceof JdbcConnectionAccessProvidedConnectionImpl ) ) {
			throw new IllegalStateException( ""DdlTransactionIsolatorProvidedConnectionImpl should always use a JdbcConnectionAccessProvidedConnectionImpl"" );
		}
		JdbcConnectionAccessProvidedConnectionImpl connectionAccessProvidedConnection =
			(JdbcConnectionAccessProvidedConnectionImpl) connectionAccess;
		try {
			connectionAccess.releaseConnection( null );
		}
		catch (SQLException ignore) {
			LOG.unableToReleaseIsolatedConnection( ignore );
		}
	}
","	public void release() {
		JdbcConnectionAccess connectionAccess = jdbcContext.getJdbcConnectionAccess();
		if( !( connectionAccess instanceof JdbcConnectionAccessProvidedConnectionImpl ) ) {
			throw new IllegalStateException(
				""DdlTransactionIsolatorProvidedConnectionImpl should always use a JdbcConnectionAccessProvidedConnectionImpl""
			);
		}
		try {
			// While passing the connection to the releaseConnection method might be suitable for other `JdbcConnectionAccess` implementations,
			// it has no meaning for JdbcConnectionAccessProvidedConnectionImpl because, in this case, the connection is wrapped
			// and we don't have access to it upon releasing via the DdlTransactionIsolatorProvidedConnectionImpl.
			connectionAccess.releaseConnection( null );
		}
		catch (SQLException ignore) {
			LOG.unableToReleaseIsolatedConnection( ignore );
		}
	}
"
32,Integer.valueOf(...) instead.,"	public boolean isRead(Tip tip) {
		return fReadList.contains(new Integer(tip.hashCode()));
	}
","	public boolean isRead(Tip tip) {
START 		return fReadList.contains(new Integer(tip.hashCode())); END 
	}
","	public boolean isRead(Tip tip) {
		return fReadList.contains(Integer.valueOf(tip.hashCode()));
	}
"
33,"Please use brackets, even for one-line blocks","	public IContentProvider getContentProvider() {
		if (useDynamic)
			return dynamicProvider;
		return super.getContentProvider();
	}
","	public IContentProvider getContentProvider() {
START 		if (useDynamic) END 
			return dynamicProvider;
		return super.getContentProvider();
	}
","	public IContentProvider getContentProvider() {
		if (useDynamic) {
			return dynamicProvider;
		}
		return super.getContentProvider();
	}
"
34,Why are we swallowing the exception? Isn't this something the caller should know?,"    public BlobStore getById(Function<String, InputStream> configGetter, String storeId) {
        logger.debug(""Looking blob store with id {}"", storeId);
        try {
            HierarchicalConfiguration config = getConfiguration(configGetter);
            if (config != null) {
                return findStore(config, store ->
                        StringUtils.equals(storeId, store.getString(CONFIG_KEY_ID)));
            }
        } catch (ConfigurationException e) {
            logger.error(""Error reading blob store configuration"", e);
        }
        return null;
    }
","    public BlobStore getById(Function<String, InputStream> configGetter, String storeId) {
        logger.debug(""Looking blob store with id {}"", storeId);
        try {
            HierarchicalConfiguration config = getConfiguration(configGetter);
            if (config != null) {
                return findStore(config, store ->
                        StringUtils.equals(storeId, store.getString(CONFIG_KEY_ID)));
            }
        } catch (ConfigurationException e) {
START             logger.error(""Error reading blob store configuration"", e); END 
        }
        return null;
    }
","    public BlobStore getById(Function<String, InputStream> configGetter, String storeId)
            throws ConfigurationException, IOException {
        logger.debug(""Looking blob store with id {}"", storeId);
        HierarchicalConfiguration config = getConfiguration(configGetter);
        if (config != null) {
            return findStore(config, store ->
                    StringUtils.equals(storeId, store.getString(CONFIG_KEY_ID)));
        }
        return null;
    }
"
35,"Add a null check, as the class may not be initialized just yet.","	public void disconnect() {
		// Set the terminal control state to CLOSED.
		fControl.setState(TerminalState.CLOSED);
    }
","	public void disconnect() {
		// Set the terminal control state to CLOSED.
START 		fControl.setState(TerminalState.CLOSED); END 
    }
","	public void disconnect() {
		// Set the terminal control state to CLOSED.
    	if (fControl != null) {
    		fControl.setState(TerminalState.CLOSED);
    	}
    }
"
36,If this setter is only called here then it should be moved into the constructor.,"  public SymmetricHashJoin construct(final ConstructArgs args) {
    SymmetricHashJoin join =
        new SymmetricHashJoin(
            null,
            null,
            argColumns1,
            argColumns2,
            argSelect1,
            argSelect2,
            argSetSemanticsLeft,
            argSetSemanticsRight,
            argColumnNames);
    join.setPullOrder(argOrder);
    return join;
  }
","  public SymmetricHashJoin construct(final ConstructArgs args) {
    SymmetricHashJoin join =
        new SymmetricHashJoin(
            null,
            null,
            argColumns1,
            argColumns2,
            argSelect1,
            argSelect2,
            argSetSemanticsLeft,
            argSetSemanticsRight,
            argColumnNames);
START     join.setPullOrder(argOrder); END 
    return join;
  }
","  public SymmetricHashJoin construct(final ConstructArgs args) {
    return new SymmetricHashJoin(
        null,
        null,
        argColumns1,
        argColumns2,
        argSelect1,
        argSelect2,
        argSetSemanticsLeft,
        argSetSemanticsRight,
        argColumnNames,
        argOrder);
  }
"
37,you can use getName() instead of vmStatic.getvm_name(),"    public String toString() {
        return ""VM ["" + vmStatic.getvm_name() + ""]"";
    }
","    public String toString() {
START         return ""VM ["" + vmStatic.getvm_name() + ""]""; END 
    }
","    public String toString() {
        return ""VM ["" + getName() + ""]"";
    }
"
38,"public, protected, private?","    DropDownMenu updateContextMenu(DropDownMenu menuBar, List<ActionButtonDefinition<T>> actions) {
        return updateContextMenu(menuBar, actions, true);
    }
","START     DropDownMenu updateContextMenu(DropDownMenu menuBar, List<ActionButtonDefinition<T>> actions) { END 
        return updateContextMenu(menuBar, actions, true);
    }
","    private DropDownMenu updateContextMenu(DropDownMenu menuBar, List<ActionButtonDefinition<T>> actions) {
        return updateContextMenu(menuBar, actions, true);
    }
"
39,Don't spam final keywords in code that is not part of your changeset,"    private static synchronized Session session() {
        final Properties properties = new Properties();
        final ConfigurationProperties conf = EmailDispatchConfiguration.getConfiguration();
        properties.put(""mail.smtp.host"", conf.mailSmtpHost());
        properties.put(""mail.smtp.name"", conf.mailSmtpName());
        properties.put(""mail.smtp.port"", conf.mailSmtpPort());
        properties.put(""mailSender.max.recipients"", conf.mailSenderMaxRecipients());
        SESSION = Session.getDefaultInstance(properties, null);
        return SESSION;
    }
","    private static synchronized Session session() {
        final Properties properties = new Properties();
START         final ConfigurationProperties conf = EmailDispatchConfiguration.getConfiguration(); END 
        properties.put(""mail.smtp.host"", conf.mailSmtpHost());
        properties.put(""mail.smtp.name"", conf.mailSmtpName());
        properties.put(""mail.smtp.port"", conf.mailSmtpPort());
        properties.put(""mailSender.max.recipients"", conf.mailSenderMaxRecipients());
        SESSION = Session.getDefaultInstance(properties, null);
        return SESSION;
    }
","    private static synchronized Session session() {
        final Properties properties = new Properties();
        ConfigurationProperties conf = EmailDispatchConfiguration.getConfiguration();
        properties.put(""mail.smtp.host"", conf.mailSmtpHost());
        properties.put(""mail.smtp.name"", conf.mailSmtpName());
        properties.put(""mail.smtp.port"", conf.mailSmtpPort());
        properties.put(""mailSender.max.recipients"", conf.mailSenderMaxRecipients());
        SESSION = Session.getDefaultInstance(properties, null);
        return SESSION;
    }
"
40,You need to mark the pipelining as `final` as the code needs to be JDK6 compatible.,"    public void testInterrupt() throws Exception {
        Pipelining<String> pipelining = new Pipelining<String>(1);
        pipelining.add(mock(ICompletableFuture.class));

        TestThread t = new TestThread() {
            @Override
            public void doRun() throws Throwable {
                pipelining.add(mock(ICompletableFuture.class));
            }
        };
        t.start();
        t.interrupt();
        t.assertFailsEventually(InterruptedException.class);
    }
","    public void testInterrupt() throws Exception {
        Pipelining<String> pipelining = new Pipelining<String>(1);
        pipelining.add(mock(ICompletableFuture.class));

        TestThread t = new TestThread() {
            @Override
            public void doRun() throws Throwable {
START                 pipelining.add(mock(ICompletableFuture.class)); END 
            }
        };
        t.start();
        t.interrupt();
        t.assertFailsEventually(InterruptedException.class);
    }
","    public void testInterrupt() throws Exception {
        final Pipelining<String> pipelining = new Pipelining<String>(1);
        pipelining.add(mock(ICompletableFuture.class));

        TestThread t = new TestThread() {
            @Override
            public void doRun() throws Throwable {
                pipelining.add(mock(ICompletableFuture.class));
            }
        };
        t.start();
        t.interrupt();
        t.assertFailsEventually(InterruptedException.class);
    }
"
41,"If the trace is an experiment, it has already been disposed and its UUID has changed (experiment no longer has any children, its UUID computed from an empty string).","    public void traceClosed(@Nullable TmfTraceClosedSignal signal) {
        cancelUpdate();
        super.traceClosed(signal);
        setDataProvider(null);
        if (signal != null) {
            fXYPresentationProvider.remove(signal.getTrace().getUUID());
        }
    }
","    public void traceClosed(@Nullable TmfTraceClosedSignal signal) {
        cancelUpdate();
        super.traceClosed(signal);
        setDataProvider(null);
        if (signal != null) {
START             fXYPresentationProvider.remove(signal.getTrace().getUUID()); END 
        }
    }
","    public void traceClosed(@Nullable TmfTraceClosedSignal signal) {
        cancelUpdate();
        super.traceClosed(signal);
        setDataProvider(null);
        if (signal != null) {
            fXYPresentationProvider.remove(signal.getTrace());
        }
    }
"
42,the other option is to do it on the commands exposing this information to the user only. I think internally we should stick to the original author/committer/tagger,"	private String author(int line) {
		PersonIdent author = db.getMailmap().map(blame.getSourceAuthor(line));
		if (author == null)
			return """"; //$NON-NLS-1$
		String name = showAuthorEmail ? author.getEmailAddress() : author
				.getName();
		return name != null ? name : """"; //$NON-NLS-1$
	}
","	private String author(int line) {
		PersonIdent author = START  db.getMailmap().map(blame.getSourceAuthor(line)); END 
		if (author == null)
			return """"; //$NON-NLS-1$
		String name = showAuthorEmail ? author.getEmailAddress() : author
				.getName();
		return name != null ? name : """"; //$NON-NLS-1$
	}
","	private String author(int line) {
		PersonIdent author = blame.getSourceAuthor(line);
		if (author == null)
			return """"; //$NON-NLS-1$
		String name = showAuthorEmail ? author.getEmailAddress() : author
				.getName();
		return name != null ? name : """"; //$NON-NLS-1$
	}
"
43,Avoid multiple returns.,"	public void deactivate() {
		// retrieve the view and the element managed by the edit part
		View view = getView();
		if (view == null) {
			return;
		}
		getDiagramEventBroker().removeNotificationListener(view, this);
		if (hostSemanticElement == null) {
			return;
		}
		// remove listeners to applied stereotyped
		for (EObject stereotypeApplication : hostSemanticElement.getStereotypeApplications()) {
			getDiagramEventBroker().removeNotificationListener(stereotypeApplication, this);
		}
		// remove notification on element
		getDiagramEventBroker().removeNotificationListener(hostSemanticElement, this);
		// removes the reference to the semantic element
		hostSemanticElement = null;
	}
","START 	public void deactivate() { END 
		// retrieve the view and the element managed by the edit part
		View view = getView();
		if (view == null) {
			return;
		}
		getDiagramEventBroker().removeNotificationListener(view, this);
		if (hostSemanticElement == null) {
			return;
		}
		// remove listeners to applied stereotyped
		for (EObject stereotypeApplication : hostSemanticElement.getStereotypeApplications()) {
			getDiagramEventBroker().removeNotificationListener(stereotypeApplication, this);
		}
		// remove notification on element
		getDiagramEventBroker().removeNotificationListener(hostSemanticElement, this);
		// removes the reference to the semantic element
		hostSemanticElement = null;
	}
","	public void deactivate() {
		// retrieve the view and the element managed by the edit part
		View view = getView();
		if (view != null) {
			getDiagramEventBroker().removeNotificationListener(view, this);
			if (hostSemanticElement != null) {

				// remove listeners to applied stereotyped
				for (EObject stereotypeApplication : hostSemanticElement.getStereotypeApplications()) {
					getDiagramEventBroker().removeNotificationListener(stereotypeApplication, this);
				}
				// remove notification on element
				getDiagramEventBroker().removeNotificationListener(hostSemanticElement, this);
				// removes the reference to the semantic element
				hostSemanticElement = null;
			}
		}
	}
"
44,isn't this the exact same notification that the FlowProcessMediator is already sending?,"  public DefaultSchedulerMessageSource(MuleContext muleContext, PeriodicScheduler scheduler,
                                       boolean disallowConcurrentExecution) {
    this.muleContext = muleContext;
    this.scheduler = scheduler;
    this.disallowConcurrentExecution = disallowConcurrentExecution;

    notificationFunctions = new LinkedList<>();
    // Add message received notification
    notificationFunctions
        .add((event, component) -> createConnectorMessageNotification(this, event, component.getLocation(), MESSAGE_RECEIVED));
  }
","  public DefaultSchedulerMessageSource(MuleContext muleContext, PeriodicScheduler scheduler,
                                       boolean disallowConcurrentExecution) {
    this.muleContext = muleContext;
    this.scheduler = scheduler;
    this.disallowConcurrentExecution = disallowConcurrentExecution;

    notificationFunctions = new LinkedList<>();
    // Add message received notification
    notificationFunctions
START         .add((event, component) -> createConnectorMessageNotification(this, event, component.getLocation(), MESSAGE_RECEIVED)); END 
  }
","  public DefaultSchedulerMessageSource(MuleContext muleContext, PeriodicScheduler scheduler,
                                       boolean disallowConcurrentExecution) {
    this.muleContext = muleContext;
    this.scheduler = scheduler;
    this.disallowConcurrentExecution = disallowConcurrentExecution;
  }
"
45,Don't understand this. Why aren't you doing `MockBlobStorageService.ECHO_REST_METHOD` for everything?,"  public void requestHandleWithNonHealthCheckRequestTest()
      throws IOException {
    testNonHealthCheckRequest(HttpMethod.POST, ""POST"");
    testNonHealthCheckRequest(HttpMethod.GET, ""GET"");
    testNonHealthCheckRequest(HttpMethod.GET, MockBlobStorageService.ECHO_REST_METHOD);
    testNonHealthCheckRequest(HttpMethod.DELETE, ""DELETE"");
  }
","  public void requestHandleWithNonHealthCheckRequestTest()
      throws IOException {
START     testNonHealthCheckRequest(HttpMethod.POST, ""POST""); END 
    testNonHealthCheckRequest(HttpMethod.GET, ""GET"");
    testNonHealthCheckRequest(HttpMethod.GET, MockBlobStorageService.ECHO_REST_METHOD);
    testNonHealthCheckRequest(HttpMethod.DELETE, ""DELETE"");
  }
","  public void requestHandleWithNonHealthCheckRequestTest()
      throws IOException {
    testNonHealthCheckRequest(HttpMethod.POST, ""POST"");
    testNonHealthCheckRequest(HttpMethod.GET, ""GET"");
    testNonHealthCheckRequest(HttpMethod.DELETE, ""DELETE"");
  }
"
46,"In general for the whole PR, are these checks really needed? Guava's immutable collections don't allow null values so checking the null input in the map and list options here looks redundant?","   public DockerTemplateOptions volumes(Map<String, String> volumes) {
      for (Map.Entry<String, String> entry : checkNotNull(volumes, ""volumes"").entrySet()) {
         checkNotNull(entry.getKey(), ""host paths must not be null"");
         checkNotNull(entry.getValue(), ""container paths must not be null"");
      }
      this.volumes = Optional.<Map<String, String>>of(ImmutableMap.copyOf(volumes));
      return this;
   }
","   public DockerTemplateOptions volumes(Map<String, String> volumes) {
      for (Map.Entry<String, String> entry : checkNotNull(volumes, ""volumes"").entrySet()) {
         checkNotNull(entry.getKey(), ""host paths must not be null"");
         checkNotNull(entry.getValue(), ""container paths must not be null"");
START       } END 
      this.volumes = Optional.<Map<String, String>>of(ImmutableMap.copyOf(volumes));
      return this;
   }
","   public DockerTemplateOptions volumes(Map<String, String> volumes) {
      this.volumes = Optional.<Map<String, String>>of(ImmutableMap.copyOf(checkNotNull(volumes, ""volumes"")));
      return this;
   }
"
47,"Correct me if it's wrong, but I think the first block with ""if (isVoidMethod(method)) {"" is not needed anymore","    private String getMethodCallback(JMethod method) {
        if (isVoidMethod(method)) {
            return ""org.fusesource.restygwt.client.MethodCallback<java.lang.Void> callback"";
        } else if (method.getReturnType().isPrimitive() != null) {
        	JPrimitiveType primitiveType = method.getReturnType().isPrimitive();
        	return ""org.fusesource.restygwt.client.MethodCallback<"" + primitiveType.getQualifiedBoxedSourceName() + ""> callback"";
        }
        return ""org.fusesource.restygwt.client.MethodCallback<"" + method.getReturnType().getParameterizedQualifiedSourceName() + ""> callback"";
    }
","    private String getMethodCallback(JMethod method) {
START         if (isVoidMethod(method)) { END 
            return ""org.fusesource.restygwt.client.MethodCallback<java.lang.Void> callback"";
        } else if (method.getReturnType().isPrimitive() != null) {
        	JPrimitiveType primitiveType = method.getReturnType().isPrimitive();
        	return ""org.fusesource.restygwt.client.MethodCallback<"" + primitiveType.getQualifiedBoxedSourceName() + ""> callback"";
        }
        return ""org.fusesource.restygwt.client.MethodCallback<"" + method.getReturnType().getParameterizedQualifiedSourceName() + ""> callback"";
    }
","    private String getMethodCallback(JMethod method) {
        if (method.getReturnType().isPrimitive() != null) {
            JPrimitiveType primitiveType = method.getReturnType().isPrimitive();
            return ""org.fusesource.restygwt.client.MethodCallback<"" + primitiveType.getQualifiedBoxedSourceName() + ""> callback"";
        }
        return ""org.fusesource.restygwt.client.MethodCallback<"" + method.getReturnType().getParameterizedQualifiedSourceName() + ""> callback"";
    }
"
48,"I am not sure if it is a good practice to create GoogleApiClient with ApplicationContext. 

GoogleApiClient is really tied to the Activity. We are recreating it on every Activity. That's how it needs to be done. So I am not sure if this makes sense.","    protected GoogleApiClient createGoogleApiClient() {
        return GoogleApiClientFactory.createWithoutSignIn(getApplicationContext());
    }
","    protected GoogleApiClient createGoogleApiClient() {
START         return GoogleApiClientFactory.createWithoutSignIn(getApplicationContext()); END 
    }
","    protected GoogleApiClient createGoogleApiClient() {
        return GoogleApiClientFactory.createWithoutSignIn(this);
    }
"
49,Doesn't StringUtils.isNotBlank already compare for null?,"	private boolean matchNamePattern(String value, String namePattern) {
		boolean match = true;
		if (value != null && StringUtils.isNotBlank(value)) {
			match = value.matches(namePattern);
		} 
		return match;
	}
","	private boolean matchNamePattern(String value, String namePattern) {
		boolean match = true;
START 		if (value != null && StringUtils.isNotBlank(value)) { END 
			match = value.matches(namePattern);
		} 
		return match;
	}
","	private boolean matchNamePattern(String value, String namePattern) {
		boolean match = true;
		if (StringUtils.isNotBlank(value)) {
			match = value.matches(namePattern);
		} 
		return match;
	}
"
50,"I think this check should happen before applying the wrapper (i.e. if the current status code is 200 don't apply the wrapper, if it is not 200 don't let it be modified). Otherwise if there are multiple calls to setStatus the first one may work and the second will fail.","        public void setStatus(int sc, String sm) {
            if (super.getStatus() == OK) {
                super.setStatus(sc, sm);
            }
            status = sc;
        }
","        public void setStatus(int sc, String sm) {
START             if (super.getStatus() == OK) { END 
                super.setStatus(sc, sm);
            }
            status = sc;
        }
","        public void setStatus(int sc, String sm) {
            status = sc;
        }
"
51,"Maybe we should define the int outside of the for? Not sure if this gets optimized, but I introduced a ""bug"" with String once, so I became a bit cautious with these things.","    public final GHIntArrayList reverse() {
        final int[] buffer = this.buffer;
        for (int start = 0, end = size() - 1; start < end; start++, end--) {
            // swap the values
            int tmp = buffer[start];
            buffer[start] = buffer[end];
            buffer[end] = tmp;
        }
        return this;
    }
","    public final GHIntArrayList reverse() {
        final int[] buffer = this.buffer;
        for (int start = 0, end = size() - 1; start < end; start++, end--) {
            // swap the values
START             int tmp = buffer[start]; END 
            buffer[start] = buffer[end];
            buffer[end] = tmp;
        }
        return this;
    }
","    public final GHIntArrayList reverse() {
        final int[] buffer = this.buffer;
        int tmp;
        for (int start = 0, end = size() - 1; start < end; start++, end--) {
            // swap the values
            tmp = buffer[start];
            buffer[start] = buffer[end];
            buffer[end] = tmp;
        }
        return this;
    }
"
52,Is a Set really necessary here? A treenode can wrap a single eobject so the same treenode will be returned only once by #getNonNavigableInverseReferences(),"	public Collection<TreeNode> getTreeNodes(Diff diff) {
		final Collection<EStructuralFeature.Setting> settings = treeNodeToDiffCrossReferencer
				.getNonNavigableInverseReferences(diff, false);
		final Set<TreeNode> nodes = new LinkedHashSet<TreeNode>(settings.size());
		for (EStructuralFeature.Setting setting : settings) {
			final EObject referencing = setting.getEObject();
			if (referencing instanceof TreeNode) {
				nodes.add((TreeNode)referencing);
			}
		}
		return nodes;
	}
","	public Collection<TreeNode> getTreeNodes(Diff diff) {
		final Collection<EStructuralFeature.Setting> settings = treeNodeToDiffCrossReferencer
				.getNonNavigableInverseReferences(diff, false);
START 		final Set<TreeNode> nodes = new LinkedHashSet<TreeNode>(settings.size()); END 
		for (EStructuralFeature.Setting setting : settings) {
			final EObject referencing = setting.getEObject();
			if (referencing instanceof TreeNode) {
				nodes.add((TreeNode)referencing);
			}
		}
		return nodes;
	}
","	public Collection<TreeNode> getTreeNodes(Diff diff) {
		final Collection<EStructuralFeature.Setting> settings = treeNodeToDiffCrossReferencer
				.getNonNavigableInverseReferences(diff, false);
		final List<TreeNode> nodes = new ArrayList<TreeNode>(settings.size());
		for (EStructuralFeature.Setting setting : settings) {
			final EObject referencing = setting.getEObject();
			if (referencing instanceof TreeNode) {
				nodes.add((TreeNode)referencing);
			}
		}
		return nodes;
	}
"
53,This branch is not needed,"  public int lookupId(String name)
  {
    if (value == null) {
      return Strings.isNullOrEmpty(name) ? 0 : -1;
    } else {
      return value.equals(name) ? 0 : -1;
    }
  }
","  public int lookupId(String name)
  {
START     if (value == null) { END 
      return Strings.isNullOrEmpty(name) ? 0 : -1;
    } else {
      return value.equals(name) ? 0 : -1;
    }
  }
","  public int lookupId(String name)
  {
    return value.equals(name) ? 0 : -1;
  }
"
54,private,"	public String getAbsoluteFilePath(String relPath) {
		Bundle bundle = Platform.getBundle(MulticoreVisualizerUIPlugin.PLUGIN_ID);
		URL fileURL = bundle.getEntry(relPath);
		File file = null;

		try {
			file = new File(FileLocator.resolve(fileURL).toURI());
		} catch (URISyntaxException | IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return file.getAbsolutePath();
	}
","START 	public String getAbsoluteFilePath(String relPath) { END 
		Bundle bundle = Platform.getBundle(MulticoreVisualizerUIPlugin.PLUGIN_ID);
		URL fileURL = bundle.getEntry(relPath);
		File file = null;

		try {
			file = new File(FileLocator.resolve(fileURL).toURI());
		} catch (URISyntaxException | IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return file.getAbsolutePath();
	}
","	private String getAbsoluteFilePath(String relPath) {
		Bundle bundle = Platform.getBundle(MulticoreVisualizerUIPlugin.PLUGIN_ID);
		URL fileURL = bundle.getEntry(relPath);
		File file = null;

		try {
			file = new File(FileLocator.resolve(fileURL).toURI());
		} catch (URISyntaxException | IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return file.getAbsolutePath();
	}
"
55,Can we avoid the switch as its not common practice and maybe people dont know about how it works and would think that remove and put does nothing in this example etc. Make the code understandable and maintainable for everyone.,"    private void timeoutEvent(TimeoutMap.Listener.Type type, String cid) {
        switch (type) {
            case Remove:
            case Evict:
                correlationIds.remove(cid);
                break;
            case Put:
            default:
                correlationIds.add(cid);
        }
        dirty = true;
    }
","START     private void timeoutEvent(TimeoutMap.Listener.Type type, String cid) { END 
        switch (type) {
            case Remove:
            case Evict:
                correlationIds.remove(cid);
                break;
            case Put:
            default:
                correlationIds.add(cid);
        }
        dirty = true;
    }
","    private void timeoutEvent(TimeoutMap.Listener.Type type, String cid) {
        if (type == Put) {
            correlationIds.add(cid);
        } else if (type == Remove || type == Evict) {
            correlationIds.remove(cid);
        }
        dirty = true;
    }
"
56,"please use baseActivityTestRule.launchActivity() 
(without the ""null"")","	public void setUp() throws Exception {
		createProject();
		baseActivityTestRule.launchActivity(null);
	}
","	public void setUp() throws Exception {
		createProject();
START 		baseActivityTestRule.launchActivity(null); END 
	}
","	public void setUp() throws Exception {
		createProject();
		baseActivityTestRule.launchActivity();
	}
"
57,The closing is already done in the driver. No need to repeat it here.,"    public void tearDown() {
        col.drop();
        client.close();
    }
","    public void tearDown() {
        col.drop();
START         client.close(); END 
    }
","    public void tearDown() {
        col.drop();
    }
"
58,Shouldn't we return true?,"    private View makeSpaceView(int width, int height) {
        View view = new View(getActivity());
        view.setLayoutParams(new ListView.LayoutParams(width, height));
        view.setClickable(true);
        view.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (event.getAction() == MotionEvent.ACTION_DOWN) {
                    dismiss();
                }
                return false;
            }
        });
        return view;
    }
","    private View makeSpaceView(int width, int height) {
        View view = new View(getActivity());
        view.setLayoutParams(new ListView.LayoutParams(width, height));
        view.setClickable(true);
        view.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (event.getAction() == MotionEvent.ACTION_DOWN) {
                    dismiss();
                }
START                 return false; END 
            }
        });
        return view;
    }
","    private View makeSpaceView(int width, int height) {
        View view = new View(getActivity());
        view.setLayoutParams(new ListView.LayoutParams(width, height));
        view.setClickable(true);
        view.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                if (event.getAction() == MotionEvent.ACTION_DOWN) {
                    dismiss();
                }
                return true;
            }
        });
        return view;
    }
"
59,fmt,"    public boolean needsInput()
    {
        // Since SetBuildOperator is always the last operator (no next operator that needs input from it),
        // we handle the unfinished work in this method instead of getOutput(). The Driver always
        // calls it in each iteration.
        if (unfinishedWork != null) {
            boolean done = processUnfinishedWork();
            channelSetBuilder.updateMemoryReservation();
            if (!done) { return false; }
        }
        return !finished;
    }
","    public boolean needsInput()
    {
        // Since SetBuildOperator is always the last operator (no next operator that needs input from it),
        // we handle the unfinished work in this method instead of getOutput(). The Driver always
        // calls it in each iteration.
        if (unfinishedWork != null) {
            boolean done = processUnfinishedWork();
            channelSetBuilder.updateMemoryReservation();
START             if (!done) { return false; } END 
        }
        return !finished;
    }
","    public boolean needsInput()
    {
        // Since SetBuilderOperator doesn't produce any output, the getOutput()
        // method may never be called. We need to handle any unfinished work
        // before addInput() can be called again.
        return !finished && (unfinishedWork == null || processUnfinishedWork());
    }
"
60,"Add 
````java
super.onLoad();
````
Just so that we don't have to worry about future additions to the parent's onLoad function not being called by this.","    public void onLoad() {
        offset = world.rand.nextInt(10);
    }
","    public void onLoad() {
START         offset = world.rand.nextInt(10); END 
    }
","    public void onLoad() {
        super.onLoad();
        offset = world.rand.nextInt(10);
    }
"
61,How about to use here `NamedParameterJdbcTemplate` as you've done in the `JdbcChannelMessageStore#doPollForMessage` ?,"	protected Message<?> doPollForMessage(String groupIdKey) {
		List<Message<?>> messages = jdbcTemplate.query(getQuery(Query.POLL_FROM_GROUP), new Object[] { groupIdKey, region, groupIdKey }, mapper);
		Assert.isTrue(messages.size() == 0 || messages.size() == 1);
		if (messages.size() > 0){
			return messages.get(0);
		}
		return null;
	}
","	protected Message<?> doPollForMessage(String groupIdKey) {
START 		List<Message<?>> messages = jdbcTemplate.query(getQuery(Query.POLL_FROM_GROUP), new Object[] { groupIdKey, region, groupIdKey }, mapper); END 
		Assert.isTrue(messages.size() == 0 || messages.size() == 1);
		if (messages.size() > 0){
			return messages.get(0);
		}
		return null;
	}
","	protected Message<?> doPollForMessage(String groupIdKey) {
		List<Message<?>> messages = jdbcTemplate.query(getQuery(Query.POLL_FROM_GROUP), new Object[] { groupIdKey, region, groupIdKey, region }, mapper);
		Assert.isTrue(messages.size() == 0 || messages.size() == 1);
		if (messages.size() > 0){
			return messages.get(0);
		}
		return null;
	}
"
62,move the null check as first action in the method to ensure we also throw if `watcherThread == null` and `unit` is null,"    public static boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {
        Thread watcherThread = ThreadDeathWatcher.watcherThread;
        if (watcherThread != null) {
            watcherThread.join(
                    ObjectUtil.checkNotNull(unit, ""unit"").toMillis(timeout));
            return !watcherThread.isAlive();
        } else {
            return true;
        }
    }
","    public static boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {
        Thread watcherThread = ThreadDeathWatcher.watcherThread;
        if (watcherThread != null) {
            watcherThread.join(
START                     ObjectUtil.checkNotNull(unit, ""unit"").toMillis(timeout)); END 
            return !watcherThread.isAlive();
        } else {
            return true;
        }
    }
","    public static boolean awaitInactivity(long timeout, TimeUnit unit) throws InterruptedException {
        ObjectUtil.checkNotNull(unit, ""unit"");

        Thread watcherThread = ThreadDeathWatcher.watcherThread;
        if (watcherThread != null) {
            watcherThread.join(unit.toMillis(timeout));
            return !watcherThread.isAlive();
        } else {
            return true;
        }
    }
"
63,I think I'd have rather looped over the `members`' entry set to `put()` each entry into `builder.members` instead of using `putAll` and then replacing the entries' values.,"  public Builder toBuilder() {
    Builder builder = new Builder(type);
    builder.members.putAll(members);
    for (Map.Entry<String, List<CodeBlock>> entry : builder.members.entrySet()) {
      entry.setValue(new ArrayList<>(entry.getValue()));
    }
    return builder;
  }
","  public Builder toBuilder() {
    Builder builder = new Builder(type);
    builder.members.putAll(members);
START     for (Map.Entry<String, List<CodeBlock>> entry : builder.members.entrySet()) { END 
      entry.setValue(new ArrayList<>(entry.getValue()));
    }
    return builder;
  }
","  public Builder toBuilder() {
    Builder builder = new Builder(type);
    for (Map.Entry<String, List<CodeBlock>> entry : members.entrySet()) {
      builder.members.put(entry.getKey(), new ArrayList<>(entry.getValue()));
    }
    return builder;
  }
"
64,"why isn't this `onCompletion(null, gse)`?","  public void closeJob(GeneralSecurityException gse) {
    callback.onCompletion(new EncryptJobResult(null, null, null), gse);
  }
","  public void closeJob(GeneralSecurityException gse) {
START     callback.onCompletion(new EncryptJobResult(null, null, null), gse); END 
  }
","  public void closeJob(GeneralSecurityException gse) {
    callback.onCompletion(null, gse);
  }
"
65,Nit: in another file you've imported ListChangesOption statically (for MESSAGES). Umport it statically here too?,"  private ChangeInfo getChange(PushOneCommit.Result pr) throws IOException {
    return getChange(pr.getChangeId(), ListChangesOption.DETAILED_LABELS);
  }
","  private ChangeInfo getChange(PushOneCommit.Result pr) throws IOException {
    return getChange(pr.getChangeId(), START  ListChangesOption.DETAILED_LABELS); END 
  }
","  private ChangeInfo getChange(PushOneCommit.Result pr) throws IOException {
    return getChange(pr.getChangeId(), DETAILED_LABELS);
  }
"
66,Spacing,"   private void clearIfNeeded(Address lockHolder) {
      if(!rpcManager.getMembers().contains(lockHolder)) {
         final Directory directory = getDirectoryProvider().getDirectory();
         log.warn(""Forcing clear of index lock"");
         ((DirectoryExtensions) directory).forceUnlock(IndexWriter.WRITE_LOCK_NAME);
      }
   }
","   private void clearIfNeeded(Address lockHolder) {
START       if(!rpcManager.getMembers().contains(lockHolder)) { END 
         final Directory directory = getDirectoryProvider().getDirectory();
         log.warn(""Forcing clear of index lock"");
         ((DirectoryExtensions) directory).forceUnlock(IndexWriter.WRITE_LOCK_NAME);
      }
   }
","   private void clearIfNeeded(Address lockHolder) {
      if (!rpcManager.getMembers().contains(lockHolder)) {
         final Directory directory = getDirectoryProvider().getDirectory();
         log.debug(""Forcing clear of index lock"");
         ((DirectoryExtensions) directory).forceUnlock(IndexWriter.WRITE_LOCK_NAME);
      }
   }
"
67,You ignore result here. You need to return result.,"  public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
      return result;
    }

    result = MagicBranch.checkMagicBranchRefs(repo, project);

    return Capable.OK;
  }
","  public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
      return result;
    }

START     result = MagicBranch.checkMagicBranchRefs(repo, project); END 

    return Capable.OK;
  }
","  public Capable canUpload() {
    Capable result = projectControl.canPushToAtLeastOneRef();
    if (result != Capable.OK) {
      return result;
    }

    return MagicBranch.checkMagicBranchRefs(repo, project);
  }
"
68,Maybe also here `StringUtils` but I am thinking if it is good idea to bring dependency for that class.,"    private int getColumnWidth(final Pattern52 pattern) {
        if (pattern.getBoundName() == null || pattern.getBoundName().trim().isEmpty()) {
            return 1;
        } else {
            return pattern.getChildColumns().size();
        }
    }
","    private int getColumnWidth(final Pattern52 pattern) {
START         if (pattern.getBoundName() == null || pattern.getBoundName().trim().isEmpty()) { END 
            return 1;
        } else {
            return pattern.getChildColumns().size();
        }
    }
","    private int getColumnWidth(final Pattern52 pattern) {
        if (StringUtils.isEmpty(pattern.getBoundName())) {
            return 1;
        } else {
            return pattern.getChildColumns().size();
        }
    }
"
69,Could you please remove this line?,"    public void onStart(ITestContext iTestContext) {
        getLifecycle().fire(new TestSuiteStartedEvent(
                getSuiteUid(iTestContext), iTestContext.getSuite().getName()
        ).withTitle(
                getCurrentSuiteTitle(iTestContext)
        ).withLabels(
                AllureModelUtils.createTestFrameworkLabel(""TestNG""),
                AllureModelUtils.createFeatureLabel(getCurrentSuiteTitle(iTestContext))
        ));
    }
","    public void onStart(ITestContext iTestContext) {
        getLifecycle().fire(new TestSuiteStartedEvent(
                getSuiteUid(iTestContext), iTestContext.getSuite().getName()
        ).withTitle(
                getCurrentSuiteTitle(iTestContext)
        ).withLabels(
                AllureModelUtils.createTestFrameworkLabel(""TestNG""),
START                 AllureModelUtils.createFeatureLabel(getCurrentSuiteTitle(iTestContext)) END 
        ));
    }
","    public void onStart(ITestContext iTestContext) {
        getLifecycle().fire(new TestSuiteStartedEvent(
                getSuiteUid(iTestContext), iTestContext.getSuite().getName()
        ).withTitle(
                getCurrentSuiteTitle(iTestContext)
        ).withLabels(
                AllureModelUtils.createTestFrameworkLabel(""TestNG"")
        ));
    }
"
70,"Not sure about this one @taba90, even if the default implementation supports it we still want to override the default check no?","    public boolean supportsSorting(SortBy[] sortAttributes) {
        if (super.supportsSorting(sortAttributes)) return true;
        for (SortBy sort : sortAttributes) {
            if (!supportsPropertySorting(sort.getPropertyName())) return false;
        }
        return true;
    }
","    public boolean supportsSorting(SortBy[] sortAttributes) {
START         if (super.supportsSorting(sortAttributes)) return true; END 
        for (SortBy sort : sortAttributes) {
            if (!supportsPropertySorting(sort.getPropertyName())) return false;
        }
        return true;
    }
","    public boolean supportsSorting(SortBy[] sortAttributes) {
        for (SortBy sort : sortAttributes) {
            if (!supportsPropertySorting(sort.getPropertyName())) return false;
        }
        return true;
    }
"
71,"yes but if you change the impl to something that would not always set it and forget about changing the initialization....
It's simply very good but simple practice: always initialize local variables, instance variable are automagically always in a sane state. I really dont see the point of removing the existing initializations. Spare some characters? And as said, it's a good practice to always initialize local variables to a defined state.","	public static boolean hasGitFolder(InputStream inputStream) throws IOException {
		TarArchiveInputStream tarInputStream = null;
		try {
			boolean gitFolderPresent = false;
			tarInputStream = new TarArchiveInputStream(new GzipCompressorInputStream(inputStream));
			for (TarArchiveEntry entry; (entry = tarInputStream.getNextTarEntry()) != null;) {
				if (GIT_FOLDER_NAME.equals(entry.getName())
						&& entry.isDirectory()) {
					gitFolderPresent = true;
					break;
				}
			}
			return gitFolderPresent;
		} finally {
			StreamUtils.close(tarInputStream);
		}
	}
","	public static boolean hasGitFolder(InputStream inputStream) throws IOException {
		TarArchiveInputStream tarInputStream = null;
		try {
			boolean gitFolderPresent = false;
			tarInputStream = new TarArchiveInputStream(new GzipCompressorInputStream(inputStream));
START 			for (TarArchiveEntry entry; (entry = tarInputStream.getNextTarEntry()) != null;) { END 
				if (GIT_FOLDER_NAME.equals(entry.getName())
						&& entry.isDirectory()) {
					gitFolderPresent = true;
					break;
				}
			}
			return gitFolderPresent;
		} finally {
			StreamUtils.close(tarInputStream);
		}
	}
","	public static boolean hasGitFolder(InputStream inputStream) throws IOException {
		TarArchiveInputStream tarInputStream = null;
		try {
			boolean gitFolderPresent = false;
			tarInputStream = new TarArchiveInputStream(new GzipCompressorInputStream(inputStream));
			for (TarArchiveEntry entry = null; (entry = tarInputStream.getNextTarEntry()) != null;) {
				if (GIT_FOLDER_NAME.equals(entry.getName())
						&& entry.isDirectory()) {
					gitFolderPresent = true;
					break;
				}
			}
			return gitFolderPresent;
		} finally {
			StreamUtils.close(tarInputStream);
		}
	}
"
72,I think this might return null.,"    protected void updateDetailsAvailability() {
        super.updateDetailsAvailability();
        NetworkView network = (NetworkView) getSelectedItem();
        networkExternalSubnetListModel.setIsAvailable(network.isExternal());
    }
","    protected void updateDetailsAvailability() {
        super.updateDetailsAvailability();
START         NetworkView network = (NetworkView) getSelectedItem(); END 
        networkExternalSubnetListModel.setIsAvailable(network.isExternal());
    }
","    protected void updateDetailsAvailability() {
        super.updateDetailsAvailability();
        NetworkView network = (NetworkView) getSelectedItem();
        networkExternalSubnetListModel.setIsAvailable(network != null && network.isExternal());
    }
"
73,seems `false` is also a valid response.,"    public Object getResponse() {
        return true;
    }
","    public Object getResponse() {
START         return true; END 
    }
","    public Object getResponse() {
        return response;
    }
"
74,this doesnt need to be on a different line,"    public InputContent parseInputStream(
            InputStream inputStream,
            Boolean strict
    ) throws IOException,
            ReadException {
        Description description = deserialize(new InputStreamReader(inputStream), strict);
        Content content = complexify(description);

        return new InputContent(content, description.getType());
    }
","    public InputContent parseInputStream(
            InputStream inputStream,
            Boolean strict
    ) throws IOException,
START             ReadException { END 
        Description description = deserialize(new InputStreamReader(inputStream), strict);
        Content content = complexify(description);

        return new InputContent(content, description.getType());
    }
","    public InputContent parseInputStream(
            InputStream inputStream, Boolean strict
    ) throws IOException, ReadException {
        Description description = deserialize(new InputStreamReader(inputStream), strict);
        Content content = complexify(description);

        return InputContent.create(content, description.getType());
    }
"
75,Why is this necessary? This is the default behaviour for mocked Object returning methods.,"    private void setUpAccessBaseAgingExpectations() {
        ReferenceQueue<Integer> queue = mock(ReferenceQueue.class);
        map = new ReapedMap<String, Integer>(1000, true, queue);
        when(queue.poll()).thenReturn(null);
    }
","    private void setUpAccessBaseAgingExpectations() {
        ReferenceQueue<Integer> queue = mock(ReferenceQueue.class);
        map = new ReapedMap<String, Integer>(1000, true, queue);
START         when(queue.poll()).thenReturn(null); END 
    }
","    private void setUpAccessBaseAgingExpectations() {
        ReferenceQueue<Integer> queue = mock(ReferenceQueue.class);
        map = new ReapedMap<String, Integer>(1000, true, queue);
    }
"
76,Can use the static import too. And I assume you can then remove the `RollCycles` import.,"    protected RollCycle decodeRollCycle(String retentionDuration) {
        if (retentionDuration == null || retentionDuration.isEmpty()) {
            return DAILY;
        }
        String rollingPeriod = retentionDuration.substring(retentionDuration.length() - 1);
        switch (rollingPeriod) {
        case SECOND_ROLLING_PERIOD:
            return RollCycles.TEST_SECONDLY;
        case MINUTE_ROLLING_PERIOD:
            return MINUTELY;
        case HOUR_ROLLING_PERIOD:
            return HOURLY;
        case DAY_ROLLING_PERIOD:
            return DAILY;
        default:
            throw new IllegalArgumentException(""Unknown rolling period: "" + rollingPeriod);
        }
    }
","    protected RollCycle decodeRollCycle(String retentionDuration) {
        if (retentionDuration == null || retentionDuration.isEmpty()) {
            return DAILY;
        }
        String rollingPeriod = retentionDuration.substring(retentionDuration.length() - 1);
        switch (rollingPeriod) {
        case SECOND_ROLLING_PERIOD:
START             return RollCycles.TEST_SECONDLY; END 
        case MINUTE_ROLLING_PERIOD:
            return MINUTELY;
        case HOUR_ROLLING_PERIOD:
            return HOURLY;
        case DAY_ROLLING_PERIOD:
            return DAILY;
        default:
            throw new IllegalArgumentException(""Unknown rolling period: "" + rollingPeriod);
        }
    }
","    protected RollCycle decodeRollCycle(String retentionDuration) {
        if (retentionDuration == null || retentionDuration.isEmpty()) {
            return DAILY;
        }
        String rollingPeriod = retentionDuration.substring(retentionDuration.length() - 1);
        switch (rollingPeriod) {
        case SECOND_ROLLING_PERIOD:
            return TEST_SECONDLY;
        case MINUTE_ROLLING_PERIOD:
            return MINUTELY;
        case HOUR_ROLLING_PERIOD:
            return HOURLY;
        case DAY_ROLLING_PERIOD:
            return DAILY;
        default:
            throw new IllegalArgumentException(""Unknown rolling period: "" + rollingPeriod);
        }
    }
"
77,"`i` should start at 1, as it's already processed by the preceding LOC.","    void process(BitVector changedBits, BitVector deletedBits) {
        toEntityIntBags(changedBits, deletedBits);

        // note: processAll != process
        subscriptions.get(0).processAll(changed, deleted);

        for (int i = 0, s = subscriptions.size(); s > i; i++) {
            subscriptions.get(i).process(changed, deleted);
        }
    }
","    void process(BitVector changedBits, BitVector deletedBits) {
        toEntityIntBags(changedBits, deletedBits);

        // note: processAll != process
        subscriptions.get(0).processAll(changed, deleted);

START         for (int i = 0, s = subscriptions.size(); s > i; i++) { END 
            subscriptions.get(i).process(changed, deleted);
        }
    }
","	void process(BitVector changedBits, BitVector deletedBits) {
		toEntityIntBags(changedBits, deletedBits);

		// note: processAll != process
		subscriptions.get(0).processAll(changed, deleted);

		for (int i = 1, s = subscriptions.size(); s > i; i++) {
			subscriptions.get(i).process(changed, deleted);
		}
	}
"
78,private?,"    void setMinMax(double min, double max)
    {
        this.min = min;
        this.max = max;
    }
","START     void setMinMax(double min, double max) END 
    {
        this.min = min;
        this.max = max;
    }
","    private void setMinMax(double min, double max)
    {
        this.min = min;
        this.max = max;
    }
"
79,"Nit: I wouldn't wrap here, since it's short and there's only one item, so wrapping makes it harder to read","    private void checkTableNotExists(SchemaTableName tableName)
    {
        if (tables.values().stream()
                .map(MemoryTableHandle::toSchemaTableName)
                .anyMatch(tableName::equals)) {
            throw new PrestoException(ALREADY_EXISTS, format(""Table [%s] already exists"", tableName.toString()));
        }
        if (views.keySet().stream()
                .anyMatch(tableName::equals)) {
            throw new PrestoException(ALREADY_EXISTS, format(""View [%s] already exists"", tableName.toString()));
        }
    }
","    private void checkTableNotExists(SchemaTableName tableName)
    {
        if (tables.values().stream()
                .map(MemoryTableHandle::toSchemaTableName)
                .anyMatch(tableName::equals)) {
            throw new PrestoException(ALREADY_EXISTS, format(""Table [%s] already exists"", tableName.toString()));
        }
START         if (views.keySet().stream() END 
                .anyMatch(tableName::equals)) {
            throw new PrestoException(ALREADY_EXISTS, format(""View [%s] already exists"", tableName.toString()));
        }
    }
","    private void checkTableNotExists(SchemaTableName tableName)
    {
        if (tables.values().stream()
                .map(MemoryTableHandle::toSchemaTableName)
                .anyMatch(tableName::equals)) {
            throw new PrestoException(ALREADY_EXISTS, format(""Table [%s] already exists"", tableName.toString()));
        }
        if (views.keySet().contains(tableName)) {
            throw new PrestoException(ALREADY_EXISTS, format(""View [%s] already exists"", tableName.toString()));
        }
    }
"
80,"same, I think this method has no need to be `static`","    private static void addCaseFileVariableToResult(Collection<Pair<Object, String>> result, String element) {
        if (element.length() > 0) {
            List<String> list = Arrays.asList(element.split("",""));
            list.forEach(s1 -> {
                String value = CaseFileVariables.CASE_FILE_PREFIX + s1.split("":"")[0];
                result.add(new Pair<>(value, value));
            });
        }
    }
","START     private static void addCaseFileVariableToResult(Collection<Pair<Object, String>> result, String element) { END 
        if (element.length() > 0) {
            List<String> list = Arrays.asList(element.split("",""));
            list.forEach(s1 -> {
                String value = CaseFileVariables.CASE_FILE_PREFIX + s1.split("":"")[0];
                result.add(new Pair<>(value, value));
            });
        }
    }
","    private void addCaseFileVariableToResult(Collection<Pair<Object, String>> result, String element) {
        if (element.length() > 0) {
            List<String> list = Arrays.asList(element.split("",""));
            list.forEach(s1 -> {
                String value = CaseFileVariables.CASE_FILE_PREFIX + s1.split("":"")[0];
                result.add(new Pair<>(value, value));
            });
        }
    }
"
81,"This causes the `message` argument to be unsued.... IMO is confusing, as the Alerts panel could be not present (standalone/submarine)...","    public SessionPresenterView showError(final String message) {
        Notify.hideAll();
        getSettings().setType(kieNotificationCssClass(NotifyType.DANGER));
        showNotification(translate(SessionPresenterView_Error),
                         translate(SessionPresenterView_Notifications),
                         IconType.EXCLAMATION_CIRCLE);

        return this;
    }
","    public SessionPresenterView showError(final String message) {
        Notify.hideAll();
        getSettings().setType(kieNotificationCssClass(NotifyType.DANGER));
START         showNotification(translate(SessionPresenterView_Error), END 
                         translate(SessionPresenterView_Notifications),
                         IconType.EXCLAMATION_CIRCLE);

        return this;
    }
","    public SessionPresenterView showError(final String message) {

        getSettings().setType(kieNotificationCssClass(NotifyType.DANGER));
        showNotification(translate(SessionPresenterView_Error), message, IconType.EXCLAMATION_CIRCLE);

        return this;
    }
"
82,lambda,"    private void encodeDistribution(DBObject dbObject, Described entity) {
        TranslatorUtils.fromIterable(dbObject, DISTRIBUTION_KEY, entity.getDistributions(),
                new Function<Distribution, DBObject>() {

                    @Override
                    public DBObject apply(Distribution distribution) {
                        return distributionTranslator.toDBObject(new BasicDBObject(), distribution);
                    }

                });
    }
","    private void encodeDistribution(DBObject dbObject, Described entity) {
        TranslatorUtils.fromIterable(dbObject, DISTRIBUTION_KEY, entity.getDistributions(),
START                 new Function<Distribution, DBObject>() { END 

                    @Override
                    public DBObject apply(Distribution distribution) {
                        return distributionTranslator.toDBObject(new BasicDBObject(), distribution);
                    }

                });
    }
","    private void encodeDistribution(DBObject dbObject, Described entity) {
        TranslatorUtils.fromIterable(dbObject, DISTRIBUTION_KEY, entity.getDistributions(),
                distribution -> distributionTranslator.toDBObject(
                        new BasicDBObject(), distribution)
        );
    }
"
83,Why we aren't using foreach here like in checkServiceNode()? Wouldn't it do extra work if the first child already contains the variable but there many more children?,"	private boolean checkJoinGroupNode(StaticAnalysis sa, JoinGroupNode node, Set<IVariable<?>> projectedVars) {
		AtomicBoolean res = new AtomicBoolean();
		node.forEach(child -> {
			res.compareAndSet(false, checkIfNodeProducesVars(sa, child, projectedVars));
		});
		return res.get();
	}
","	private boolean checkJoinGroupNode(StaticAnalysis sa, JoinGroupNode node, Set<IVariable<?>> projectedVars) {
		AtomicBoolean res = new AtomicBoolean();
START 		node.forEach(child -> { END 
			res.compareAndSet(false, checkIfNodeProducesVars(sa, child, projectedVars));
		});
		return res.get();
	}
","	private boolean checkJoinGroupNode(StaticAnalysis sa, JoinGroupNode node, Set<IVariable<?>> projectedVars) {
		AtomicBoolean res = new AtomicBoolean();
		node.forEach(child -> res.compareAndSet(false, checkIfNodeProducesVars(sa, child, projectedVars)));
		return res.get();
	}
"
84,"Style-nit: Our public API should return Map, Set, List and not a concrete implementation type.  Sorry I missed this during earlier review iterations.","	public HashMap<String, ObjectId> getUpdated() {
		return updated;
	}
","START 	public HashMap<String, ObjectId> getUpdated() { END 
		return updated;
	}
","	public Map<String, ObjectId> getUpdated() {
		return updated;
	}
"
85,"`t1` shows up as unused variable, please remove the assignment.","    public void timeUnitNullFail() throws Exception {
        Timed<Integer> t1 = new Timed<Integer>(1, 5, null);
    }
","    public void timeUnitNullFail() throws Exception {
START         Timed<Integer> t1 = new Timed<Integer>(1, 5, null); END 
    }
","    public void timeUnitNullFail() throws Exception {
        new Timed<Integer>(1, 5, null);
    }
"
86,"```
View root = inflater.inflate(R.layout.fragment_for_leads, container, false);
```

should be used instead","    public View onCreateView(final LayoutInflater inflater, @Nullable final ViewGroup container, @Nullable final Bundle savedInstanceState) {
        View root = inflater.inflate(R.layout.fragment_for_leads, null);
        return root;
    }
","    public View onCreateView(final LayoutInflater inflater, @Nullable final ViewGroup container, @Nullable final Bundle savedInstanceState) {
START         View root = inflater.inflate(R.layout.fragment_for_leads, null); END 
        return root;
    }
","    public View onCreateView(final LayoutInflater inflater, @Nullable final ViewGroup container, @Nullable final Bundle savedInstanceState) {
        View root = inflater.inflate(R.layout.fragment_for_leads, container, false);
        return root;
    }
"
87,"Size in bytes, max Integer will be 2Gb, i think some crazy repo may have such number. Long looks better.","    public Map<String,Integer> listLanguages() throws IOException {
        return root.retrieve().to(getApiTailUrl(""languages""), HashMap.class);
    }
","START     public Map<String,Integer> listLanguages() throws IOException { END 
        return root.retrieve().to(getApiTailUrl(""languages""), HashMap.class);
    }
","    public Map<String,Long> listLanguages() throws IOException {
        return root.retrieve().to(getApiTailUrl(""languages""), HashMap.class);
    }
"
88,Any reason to special case this? The fall through to line 300 should catch it.,"	public static Win32VK fromValue(final int code) {
		if (code < 0 || code > 0xFF) {
			throw new IllegalArgumentException(String.format(""No mapping for %02x"", code));
		}
		for (Win32VK vk : Win32VK.values()) {
			if (vk.code == code) {
				return vk;
			}
		}
		// We shall not reach here.
		throw new IllegalArgumentException(String.format(""No mapping for %02x"", code));
	}
","	public static Win32VK fromValue(final int code) {
START 		if (code < 0 || code > 0xFF) { END 
			throw new IllegalArgumentException(String.format(""No mapping for %02x"", code));
		}
		for (Win32VK vk : Win32VK.values()) {
			if (vk.code == code) {
				return vk;
			}
		}
		// We shall not reach here.
		throw new IllegalArgumentException(String.format(""No mapping for %02x"", code));
	}
","    public static Win32VK fromValue(final int code) {
        for (Win32VK vk : Win32VK.values()) {
            if (vk.code == code) {
                return vk;
            }
        }
        throw new IllegalArgumentException(String.format(""No mapping for %02x"", code));
    }
"
89,"It might be good to add a sanity check to validate that `getBinding()` is empty, to catch users who forget to call `add()`. Mockito does something similar e.g. if you call `verify(mock)` without chaining a method call on the mock.","    public <R> R execute(ResultProducer<R> producer) {
        if (bindings.isEmpty()) {
            throw new IllegalStateException(""No batch parts to execute"");
        }

        try {
            return producer.produce(() -> internalBatchExecute().stmt, getContext());
        } catch (SQLException e) {
            throw new UnableToProduceResultException(""Exception producing batch result"", e, getContext());
        }
    }
","    public <R> R execute(ResultProducer<R> producer) {
START         if (bindings.isEmpty()) { END 
            throw new IllegalStateException(""No batch parts to execute"");
        }

        try {
            return producer.produce(() -> internalBatchExecute().stmt, getContext());
        } catch (SQLException e) {
            throw new UnableToProduceResultException(""Exception producing batch result"", e, getContext());
        }
    }
","    public <R> R execute(ResultProducer<R> producer) {
        try {
            return producer.produce(() -> internalBatchExecute().stmt, getContext());
        } catch (SQLException e) {
            throw new UnableToProduceResultException(""Exception producing batch result"", e, getContext());
        }
    }
"
90,Has to be animationFrameId = (animationFrameId + 1) ...,"    private void print() {
        if (canceled) {
            out.print(""[CANCELED] "");
        } else if (total == IProgressMonitor.UNKNOWN) {
            out.print(animationFrames[animationFrameId]);
            animationFrame = (animationFrame + 1) % animationFrames.length;
        } else {
            out.printf(""[%2d%%] "", worked / total);
        }
        out.print(task);
        if (subTask != null) {
            out.printf("" - %s"", subTask);
        }
        out.print('\r');
    }
","    private void print() {
        if (canceled) {
            out.print(""[CANCELED] "");
        } else if (total == IProgressMonitor.UNKNOWN) {
            out.print(animationFrames[animationFrameId]);
START             animationFrame = (animationFrame + 1) % animationFrames.length; END 
        } else {
            out.printf(""[%2d%%] "", worked / total);
        }
        out.print(task);
        if (subTask != null) {
            out.printf("" - %s"", subTask);
        }
        out.print('\r');
    }
","    private void print() {
        if (canceled) {
            out.print(""[CANCELED] "");
        } else if (total == IProgressMonitor.UNKNOWN) {
            out.print(animationFrames[animationFrameId]);
            animationFrameId = (animationFrameId + 1) % animationFrames.length;
        } else {
            out.printf(""[%2d%%] "", worked / total);
        }
        out.print(task);
        if (subTask != null) {
            out.printf("" - %s"", subTask);
        }
        out.print('\r');
    }
"
91,should this just proxy to the plain resolveIds method?,"    default ListenableFuture<Resolved<I>> resolveIds(Iterable<Id> ids, Boolean refreshCache) {
        throw new UnsupportedOperationException();
    }
","    default ListenableFuture<Resolved<I>> resolveIds(Iterable<Id> ids, Boolean refreshCache) {
START         throw new UnsupportedOperationException(); END 
    }
","    default ListenableFuture<Resolved<I>> resolveIds(Iterable<Id> ids, Boolean refreshCache) {
        return resolveIds(ids);
    }
"
92,Should be PcdmModels.Collection to agree with the rest of the code,"	public URI createAdminUnit(URI path, Model model) {
		// Add types to the object being created
		model = populateModelTypes(path, model,
				Arrays.asList(Cdr.AdminUnit, PcdmModels.Object));

		return createContentContainerObject(path, model);
	}
","	public URI createAdminUnit(URI path, Model model) {
		// Add types to the object being created
		model = populateModelTypes(path, model,
START 				Arrays.asList(Cdr.AdminUnit, PcdmModels.Object)); END 

		return createContentContainerObject(path, model);
	}
","	public URI createAdminUnit(URI path, Model model) {
		// Add types to the object being created
		model = populateModelTypes(path, model,
				Arrays.asList(Cdr.AdminUnit, PcdmModels.Collection));

		return createContentContainerObject(path, model);
	}
"
93,It looks like the bounds check is also done by String constructor. Can you check if this line is still necessary ?,"    public final String readUTF() throws IOException {
        int numberOfBytes = readInt();
        if (numberOfBytes == NULL_ARRAY_LENGTH) {
            return null;
        }

        checkAvailable(pos, numberOfBytes);
        String result = new String(data, pos, numberOfBytes, UTF_8);
        pos += numberOfBytes;
        return result;
    }
","    public final String readUTF() throws IOException {
        int numberOfBytes = readInt();
        if (numberOfBytes == NULL_ARRAY_LENGTH) {
            return null;
        }

START         checkAvailable(pos, numberOfBytes); END 
        String result = new String(data, pos, numberOfBytes, UTF_8);
        pos += numberOfBytes;
        return result;
    }
","    public final String readUTF() throws IOException {
        int numberOfBytes = readInt();
        if (numberOfBytes == NULL_ARRAY_LENGTH) {
            return null;
        }

        String result = new String(data, pos, numberOfBytes, UTF_8);
        pos += numberOfBytes;
        return result;
    }
"
94,"This type check should be removed. There are storage provider types build on top of the AMAZON_S3 implementation which would have a different type, but would still work just as well for streaming. For example, using the CHRONOPOLIS provider but where some spaces are not used for snapshots (left in S3) could support this. Also, the 4Science-proposed AMAZON_ONE type would fit this category.","    private S3StorageProvider getS3StorageProvider() {
        if (!storageAccountManager.isInitialized()) {
            throw new DuraCloudRuntimeException(""storageAccountManager is not initialized!!!"");
        }
        StorageAccount account = storageAccountManager.getPrimaryStorageAccount();
        StorageProviderType type = account.getType();
        if (!type.equals(StorageProviderType.AMAZON_S3)) {
            throw new DuraCloudRuntimeException(
                ""The type of primary storage provider on "" + storageAccountManager.getAccountName() + "" must be "" +
                StorageProviderType.AMAZON_S3);
        }

        return new S3StorageProvider(account.getUsername(), account.getPassword(), account.getOptions());
    }
","    private S3StorageProvider getS3StorageProvider() {
        if (!storageAccountManager.isInitialized()) {
            throw new DuraCloudRuntimeException(""storageAccountManager is not initialized!!!"");
        }
        StorageAccount account = storageAccountManager.getPrimaryStorageAccount();
        StorageProviderType type = account.getType();
START         if (!type.equals(StorageProviderType.AMAZON_S3)) { END 
            throw new DuraCloudRuntimeException(
                ""The type of primary storage provider on "" + storageAccountManager.getAccountName() + "" must be "" +
                StorageProviderType.AMAZON_S3);
        }

        return new S3StorageProvider(account.getUsername(), account.getPassword(), account.getOptions());
    }
","    private S3StorageProvider getS3StorageProvider() {
        if (!storageAccountManager.isInitialized()) {
            throw new DuraCloudRuntimeException(""storageAccountManager is not initialized!!!"");
        }
        StorageAccount account = storageAccountManager.getPrimaryStorageAccount();
        StorageProviderType type = account.getType();
        return new S3StorageProvider(account.getUsername(), account.getPassword(), account.getOptions());
    }
"
95,ShellIsAvailable,"	private static void closeSettingsChangedShell() {
		new WaitUntil(new ShellIsAvailable(""Validator Settings Changed""), TimePeriod.LONG);
		DefaultShell shell = new DefaultShell(""Validator Settings Changed"");
		String shellText = shell.getText();
		new PushButton(""Yes"").click();
		new WaitWhile(new ShellIsActive(shellText), TimePeriod.LONG);
	}
","	private static void closeSettingsChangedShell() {
		new WaitUntil(new ShellIsAvailable(""Validator Settings Changed""), TimePeriod.LONG);
		DefaultShell shell = new DefaultShell(""Validator Settings Changed"");
		String shellText = shell.getText();
		new PushButton(""Yes"").click();
START 		new WaitWhile(new ShellIsActive(shellText), TimePeriod.LONG); END 
	}
","	private static void closeSettingsChangedShell() {
		new WaitUntil(new ShellIsAvailable(""Validator Settings Changed""), TimePeriod.LONG);
		DefaultShell shell = new DefaultShell(""Validator Settings Changed"");
		String shellText = shell.getText();
		new PushButton(""Yes"").click();
		new WaitWhile(new ShellIsAvailable(shellText), TimePeriod.LONG);
	}
"
96,Can this throw an Exception?,"    public void setUp() throws Exception {
        User.disableStorage(); // don't change the app login from this test
    }
","    public void setUp() START  throws Exception { END 
        User.disableStorage(); // don't change the app login from this test
    }
","    public void setUp() {
        User.disableStorage(); // don't change the app login from this test
    }
"
97,IMHO copy-paste bug - should be `checkServerTrusted` instead.,"    public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {
        if (delegate instanceof X509ExtendedTrustManager) {
            ((X509ExtendedTrustManager)delegate).checkClientTrusted(chain, authType, socket);
        } else {
            throw new UnsupportedOperationException();
        }
        verifier.checkChain(chain);
    }
","    public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {
        if (delegate instanceof X509ExtendedTrustManager) {
START             ((X509ExtendedTrustManager)delegate).checkClientTrusted(chain, authType, socket); END 
        } else {
            throw new UnsupportedOperationException();
        }
        verifier.checkChain(chain);
    }
","    public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket) throws CertificateException {
        if (delegate instanceof X509ExtendedTrustManager) {
            ((X509ExtendedTrustManager)delegate).checkServerTrusted(chain, authType, socket);
        } else {
            throw new UnsupportedOperationException();
        }
        verifier.checkChain(chain);
    }
"
98,Can you combine these 2 lines into 1,"	private boolean isEmailValid(String email) {
		EmailValidator emailValidator = EmailValidator.getInstance();
		return emailValidator.isValid(email);
		
	}
","	private boolean isEmailValid(String email) {
START 		EmailValidator emailValidator = EmailValidator.getInstance(); END 
		return emailValidator.isValid(email);
		
	}
","	private boolean isEmailValid(String email) {
		return EmailValidator.getInstance().isValid(email);
	}
"
99,We should add an if check here for ice and only do this line and the next if it is not null. Prevents another possible loop through the linked list if it exists.,"   public void evict(WrappedBytes key) {
      Lock lock = locks.getLock(key).writeLock();
      lock.lock();
      try {
         checkDeallocation();
         long address = memoryLookup.getMemoryAddress(key);
         if (address != 0) {
            // TODO: this could be more efficient
            InternalCacheEntry<WrappedBytes, WrappedBytes> ice = performGet(address, key);
            passivator.passivate(ice);
            performRemove(address, key);
         }
      } finally {
         lock.unlock();
      }
   }
","   public void evict(WrappedBytes key) {
      Lock lock = locks.getLock(key).writeLock();
      lock.lock();
      try {
         checkDeallocation();
         long address = memoryLookup.getMemoryAddress(key);
         if (address != 0) {
            // TODO: this could be more efficient
            InternalCacheEntry<WrappedBytes, WrappedBytes> ice = performGet(address, key);
START             passivator.passivate(ice); END 
            performRemove(address, key);
         }
      } finally {
         lock.unlock();
      }
   }
","   public void evict(WrappedBytes key) {
      Lock lock = locks.getLock(key).writeLock();
      lock.lock();
      try {
         checkDeallocation();
         long address = memoryLookup.getMemoryAddress(key);
         if (address != 0) {
            // TODO: this could be more efficient
            InternalCacheEntry<WrappedBytes, WrappedBytes> ice = performGet(address, key);
            if (ice != null) {
               passivator.passivate(ice);
               performRemove(address, key);
            }
         }
      } finally {
         lock.unlock();
      }
   }
"
100,"If having subclasses inherit a common implementation is the goal, using an instance method is preferred (i.e. non-static). Using static methods for inheritance purposes is bit of an anti-pattern.","	public static Put getHadoopVersionPut(int historyFileVersion, byte[] jobKeyBytes) {
	  Put pVersion = new Put(jobKeyBytes);
	  byte[] valueBytes = null;
	  valueBytes = Bytes.toBytes(Integer.toString(historyFileVersion));
	  byte[] qualifier = Bytes.toBytes(JobHistoryKeys.hadoopversion.toString().toLowerCase());
	  pVersion.add(Constants.INFO_FAM_BYTES, qualifier, valueBytes);
	  return pVersion;
	}
","START 	public static Put getHadoopVersionPut(int historyFileVersion, byte[] jobKeyBytes) { END 
	  Put pVersion = new Put(jobKeyBytes);
	  byte[] valueBytes = null;
	  valueBytes = Bytes.toBytes(Integer.toString(historyFileVersion));
	  byte[] qualifier = Bytes.toBytes(JobHistoryKeys.hadoopversion.toString().toLowerCase());
	  pVersion.add(Constants.INFO_FAM_BYTES, qualifier, valueBytes);
	  return pVersion;
	}
","	public Put getHadoopVersionPut(int historyFileVersion, byte[] jobKeyBytes) {
	  Put pVersion = new Put(jobKeyBytes);
	  byte[] valueBytes = null;
	  valueBytes = Bytes.toBytes(Integer.toString(historyFileVersion));
	  byte[] qualifier = Bytes.toBytes(JobHistoryKeys.hadoopversion.toString().toLowerCase());
	  pVersion.add(Constants.INFO_FAM_BYTES, qualifier, valueBytes);
	  return pVersion;
	}
"
101,"+1 to future proofing the name

Have a look at one of the Adapters in [NovaParserModule.java](https://github.com/jclouds/jclouds/blob/master/apis/openstack-nova/src/main/java/org/jclouds/openstack/nova/v2_0/config/NovaParserModule.java). You'll want to do something like that for the Image class. Don't forget to add it to the [provideCustomAdapterBindings()](https://github.com/jclouds/jclouds/blob/master/apis/openstack-nova/src/main/java/org/jclouds/openstack/nova/v2_0/config/NovaParserModule.java#L57) method.","   public Map<String, Object> getMetadata() {
      return this.metadata;
   }
","START    public Map<String, Object> getMetadata() { END 
      return this.metadata;
   }
","   public Map<String, String> getMetadata() {
      return this.metadata;
   }
"
102,"This check is not necessary, we do not compute MD5 hashes for directories.","    protected Node[] createNodes(AbstractFile t) {
        Node[] node = new Node[1];
        if(t.isDir()){
            //TODO log an error ???
            return node;            
        } else {
            //replace FileNode with our own subclass of its base type or similar
            node[0] = new DataResultFilterNode(new FileNode(t, false), DirectoryTreeTopComponent.findInstance().getExplorerManager());
            return node;
        }
    }    
","    protected Node[] createNodes(AbstractFile t) {
        Node[] node = new Node[1];
START         if(t.isDir()){ END 
            //TODO log an error ???
            return node;            
        } else {
            //replace FileNode with our own subclass of its base type or similar
            node[0] = new DataResultFilterNode(new FileNode(t, false), DirectoryTreeTopComponent.findInstance().getExplorerManager());
            return node;
        }
    }    
","    protected Node[] createNodes(AbstractFile t) {
        Node[] node = new Node[1];

        //TODO replace FileNode with our own subclass of its base type or similar
        node[0] = new DataResultFilterNode(new FileNode(t, false), DirectoryTreeTopComponent.findInstance().getExplorerManager());
        return node;
    }
"
103,"Can be:

```java
return ByteBufferImpl.create(b, offset, length);`
```","   public ByteBuffer newByteBuffer(byte[] b, int offset, int length) {
      return b == null || b.length == 0 || length == 0 ? ByteBufferImpl.EMPTY_INSTANCE : new ByteBufferImpl(b, offset, length);
   }
","   public ByteBuffer newByteBuffer(byte[] b, int offset, int length) {
START       return b == null || b.length == 0 || length == 0 ? ByteBufferImpl.EMPTY_INSTANCE : new ByteBufferImpl(b, offset, length); END 
   }
","   public ByteBuffer newByteBuffer(byte[] b, int offset, int length) {
      return ByteBufferImpl.create(b, offset, length);
   }
"
104,of course it is initialized if it is in the initialized entries... now?,"    public List<ExtensionProxy> getExtensionsByService(String provides) {
        List<ExtensionProxy> results = new ArrayList<>();
        for (ExtensionEntry entry : initializedEntries.values()) {
            if (entry.initialized
                    && entry.extension.getContext().<List> get(Base.ContextKeys.PROVIDES).contains(provides)) {
                results.add(entry.extension);
            }
        }
        return results;
    }
","    public List<ExtensionProxy> getExtensionsByService(String provides) {
        List<ExtensionProxy> results = new ArrayList<>();
        for (ExtensionEntry entry : initializedEntries.values()) {
START             if (entry.initialized END 
                    && entry.extension.getContext().<List> get(Base.ContextKeys.PROVIDES).contains(provides)) {
                results.add(entry.extension);
            }
        }
        return results;
    }
","    public List<ExtensionProxy> getExtensionsByService(String provides) {
        List<ExtensionProxy> results = new ArrayList<>();
        for (ExtensionEntry entry : initializedEntries.values()) {
            if (entry.extension.getContext().<List> get(Base.ContextKeys.PROVIDES).contains(provides)) {
                results.add(entry.extension);
            }
        }
        return results;
    }
"
105,"you can do 
return (!StringExtensions.IsNullOrBlank(brokerVersion) 
                && AuthenticationConstants.Broker.BROKER_PROTOCOL_VERSION.equalsIgnoreCase(brokerVersion)); #Closed","    private boolean isBrokerWithPRTSupport(final Intent intent) {
        if (intent == null) {
            throw new IllegalArgumentException(""intent"");
        }
        
        // Only new broker with PRT support will send down the value and the version will be v2
        final String brokerVersion = intent.getStringExtra(AuthenticationConstants.Broker.BROKER_VERSION);
        if (!StringExtensions.IsNullOrBlank(brokerVersion) 
                && AuthenticationConstants.Broker.BROKER_PROTOCOL_VERSION.equalsIgnoreCase(brokerVersion)) {
            return true;
        }
        
        return false;
    }
","    private boolean isBrokerWithPRTSupport(final Intent intent) {
        if (intent == null) {
            throw new IllegalArgumentException(""intent"");
        }
        
        // Only new broker with PRT support will send down the value and the version will be v2
        final String brokerVersion = intent.getStringExtra(AuthenticationConstants.Broker.BROKER_VERSION);
        if (!StringExtensions.IsNullOrBlank(brokerVersion) 
START                 && AuthenticationConstants.Broker.BROKER_PROTOCOL_VERSION.equalsIgnoreCase(brokerVersion)) { END 
            return true;
        }
        
        return false;
    }
","    private boolean isBrokerWithPRTSupport(final Intent intent) {
        if (intent == null) {
            throw new IllegalArgumentException(""intent"");
        }
        
        // Only new broker with PRT support will send down the value and the version will be v2
        final String brokerVersion = intent.getStringExtra(AuthenticationConstants.Broker.BROKER_VERSION);
        return AuthenticationConstants.Broker.BROKER_PROTOCOL_VERSION.equalsIgnoreCase(brokerVersion);
    }
"
106,"I believe the existing behavior may be intentional and have something to do with the parent of the `DelegatingClassLoader` being something other than the system class loader. However, I'm not familiar enough with this part of the code base to say for sure; we should probably err on the side of keeping the existing functionality as-is unless someone else (e.g., @kkonstantine or a committer) can vouch that the current changes here wouldn't break anything.","    public PluginClassLoader pluginClassLoader(String name) {
        if (PluginUtils.shouldLoadInIsolation(name)) {
            SortedMap<PluginDesc<?>, ClassLoader> inner = pluginLoaders.get(name);
            if (inner != null) {
                ClassLoader pluginLoader = inner.get(inner.lastKey());
                if (pluginLoader instanceof PluginClassLoader)  {
                    return (PluginClassLoader) pluginLoader;
                }
            }
        }
        return null;
    }
","    public PluginClassLoader pluginClassLoader(String name) {
        if (PluginUtils.shouldLoadInIsolation(name)) {
            SortedMap<PluginDesc<?>, ClassLoader> inner = pluginLoaders.get(name);
            if (inner != null) {
                ClassLoader pluginLoader = inner.get(inner.lastKey());
START                 if (pluginLoader instanceof PluginClassLoader)  { END 
                    return (PluginClassLoader) pluginLoader;
                }
            }
        }
        return null;
    }
","    public PluginClassLoader pluginClassLoader(String name) {
        if (!PluginUtils.shouldLoadInIsolation(name)) {
            return null;
        }
        SortedMap<PluginDesc<?>, ClassLoader> inner = pluginLoaders.get(name);
        if (inner == null) {
            return null;
        }
        ClassLoader pluginLoader = inner.get(inner.lastKey());
        return pluginLoader instanceof PluginClassLoader
               ? (PluginClassLoader) pluginLoader
               : null;
    }
"
107,"I don't understand how this is used, or why BLOB_TYPE is the default here. Can you give me an example of where you use it?","  private PyUDFExpression() {
    name = """";
    //set default return type this is changed once pythonfunction is retrived.
    outputType = Type.BLOB_TYPE;
  }
","  private PyUDFExpression() {
    name = """";
    //set default return type this is changed once pythonfunction is retrived.
    outputType = Type.BLOB_TYPE;
START   } END 
","  private PyUDFExpression() {}
"
108,Why are we setting it to new a new empty CompletableFuture?  Is removing not sufficient?,"   public void removeInstance(Object instance) {
      deployedCacheStores.put(instance.getClass().getName(), new CompletableFuture<>());
   }
","   public void removeInstance(Object instance) {
START       deployedCacheStores.put(instance.getClass().getName(), new CompletableFuture<>()); END 
   }
","   public void removeInstance(Object instance) {
      deployedCacheStores.remove(instance.getClass().getName());
   }
"
109,You don't need `Formatter`. You can replace these lines with a single `String.format(...)` statement.,"    protected String createRecordName(String objectType) {
        StringBuilder sb = new StringBuilder();
        Formatter formatter = new Formatter(sb, Locale.US);
        formatter.format(""ManagerTest_%s_%08d"", objectType, System.currentTimeMillis());
        return sb.toString();
    }
","    protected String createRecordName(String objectType) {
        StringBuilder sb = new StringBuilder();
START         Formatter formatter = new Formatter(sb, Locale.US); END 
        formatter.format(""ManagerTest_%s_%08d"", objectType, System.currentTimeMillis());
        return sb.toString();
    }
","    protected String createRecordName(String objectType) {
        return String.format(Locale.US, ""ManagerTest_%s_%08d"", objectType, System.currentTimeMillis());
    }
"
110,"Change it to `new String[0]`, it's just shorter.","        EagerQueryResult()
        {
            fields = originalResult.columns().toArray( new String[originalResult.columns().size()] );
        }
","        EagerQueryResult()
        {
START             fields = originalResult.columns().toArray( new String[originalResult.columns().size()] ); END 
        }
","        EagerQueryResult()
        {
            fields = originalResult.columns().toArray( new String[0] );
        }
"
111,"I suggest to add an initialization in the declaration, instead of this `if` and the `if` in line 148:
private List<HttpRequestInterceptor> requestInterceptorLis = new ArrayList<>();","    public ArtifactoryClientBuilder addInterceptorLast(HttpRequestInterceptor httpRequestInterceptor) {
        if (this.requestInterceptorList == null) {
            this.requestInterceptorList = new ArrayList<>();
        }
        this.requestInterceptorList.add(httpRequestInterceptor);
        return this;
    }
","    public ArtifactoryClientBuilder addInterceptorLast(HttpRequestInterceptor httpRequestInterceptor) {
        if (this.requestInterceptorList == null) {
START             this.requestInterceptorList = new ArrayList<>(); END 
        }
        this.requestInterceptorList.add(httpRequestInterceptor);
        return this;
    }
","    public ArtifactoryClientBuilder addInterceptorLast(HttpRequestInterceptor httpRequestInterceptor) {
        this.requestInterceptorList.add(httpRequestInterceptor);
        return this;
    }
"
112,super() is not necessary,"	public Stock(String symbol, String name, double price) {
		super();
		this.symbol = symbol;
		this.name = name;
		this.price = price;
	}
","	public Stock(String symbol, String name, double price) {
START 		super(); END 
		this.symbol = symbol;
		this.name = name;
		this.price = price;
	}
","	public Stock(String symbol, String name, double price) {
		//super();
		this.symbol = symbol;
		this.name = name;
		this.price = price;
	}
"
113,s/`removeMe`/`key`/ ?,"      public boolean removeAll(Collection<?> c) {
         boolean removedSomething = false;
         for (Object removeMe : c) {
            removedSomething |= remove(removeMe);
         }
         return removedSomething;
      }
","      public boolean removeAll(Collection<?> c) {
         boolean removedSomething = false;
START          for (Object removeMe : c) { END 
            removedSomething |= remove(removeMe);
         }
         return removedSomething;
      }
","      public boolean removeAll(Collection<?> c) {
         boolean removedSomething = false;
         for (Object key : c) {
            removedSomething |= remove(key);
         }
         return removedSomething;
      }
"
114,"dimFilter is non-null, so could be simplified unless you want to stick to ""as IntelliJ generated"" form.","  public boolean equals(Object o)
  {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    DimFilterHavingSpec that = (DimFilterHavingSpec) o;

    return dimFilter != null ? dimFilter.equals(that.dimFilter) : that.dimFilter == null;

  }
","  public boolean equals(Object o)
  {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    DimFilterHavingSpec that = (DimFilterHavingSpec) o;

START     return dimFilter != null ? dimFilter.equals(that.dimFilter) : that.dimFilter == null; END 

  }
","  public boolean equals(Object o)
  {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    DimFilterHavingSpec that = (DimFilterHavingSpec) o;

    return dimFilter.equals(that.dimFilter);
  }
"
115,Same question as above: why change the scope?,"    private Session openSession() {
        final Session currentSession = (Session) this.emProvider.get().getDelegate();
        final SessionFactory factory = currentSession.getSessionFactory();

        return factory.openSession();
    }
","START     private Session openSession() { END 
        final Session currentSession = (Session) this.emProvider.get().getDelegate();
        final SessionFactory factory = currentSession.getSessionFactory();

        return factory.openSession();
    }
","    protected Session openSession() {
        final Session currentSession = (Session) this.emProvider.get().getDelegate();
        final SessionFactory factory = currentSession.getSessionFactory();

        return factory.openSession();
    }
"
116,"Amend message as it no longer represent the correct error state?

A full queue on call is now allowed (which you correctly test for by now using `>` instead of `>=`).

The issue you are checking for now it that there already are too many entries before the addition, meaning the queue was already in an illegal state before the call.","  Pair<IAnnotationModel, List<ContributionAnnotation>> addNewEntry(
      final List<ContributionAnnotation> annotations) {

    if (queue.size() > maxHistoryLength) {
      throw new IllegalStateException(
          ""The queue already contains the allowed number of annotations."");
    }

    Pair<IAnnotationModel, List<ContributionAnnotation>> removedEntry = removeEntryIfFull();
    queue.add(annotations);
    return removedEntry;
  }
","  Pair<IAnnotationModel, List<ContributionAnnotation>> addNewEntry(
      final List<ContributionAnnotation> annotations) {

    if (queue.size() > maxHistoryLength) {
      throw new IllegalStateException(
START           ""The queue already contains the allowed number of annotations.""); END 
    }

    Pair<IAnnotationModel, List<ContributionAnnotation>> removedEntry = removeEntryIfFull();
    queue.add(annotations);
    return removedEntry;
  }
","  Pair<IAnnotationModel, List<ContributionAnnotation>> addNewEntry(
      final List<ContributionAnnotation> annotations) {

    Pair<IAnnotationModel, List<ContributionAnnotation>> removedEntry = removeEntryIfFull();
    queue.add(annotations);
    return removedEntry;
  }
"
117,this can be reduced to protected.,"    public Optional<Guid> getUserIdIfExternal() {
        return isInternalExecution() ? Optional.empty() : Optional.ofNullable(getUserId());
    }
","    START  public Optional<Guid> END  getUserIdIfExternal() {
        return isInternalExecution() ? Optional.empty() : Optional.ofNullable(getUserId());
    }
","    protected Optional<Guid> getUserIdIfExternal() {
        return isInternalExecution() ? Optional.empty() : Optional.ofNullable(getUserId());
    }
"
118,`href`s are case sensitive. Please use `equals(String)` instead of `equalsIgnoreCase(String)`,"    public Group removeAccount(Account account) {
        Assert.notNull(account, ""account cannot be null"");

        GroupMembership groupMembership = null;
        for (GroupMembership accountGroupMembership : getAccountMemberships()) {
            if (accountGroupMembership.getAccount().getHref().equalsIgnoreCase(account.getHref())) {
                groupMembership = accountGroupMembership;
                break;
            }
        }
        if (groupMembership != null){
            groupMembership.delete();
        } else {
            throw new IllegalStateException(""The specified account does not belong to this Group."");
        }
        return this;
    }
","    public Group removeAccount(Account account) {
        Assert.notNull(account, ""account cannot be null"");

        GroupMembership groupMembership = null;
        for (GroupMembership accountGroupMembership : getAccountMemberships()) {
START             if (accountGroupMembership.getAccount().getHref().equalsIgnoreCase(account.getHref())) { END 
                groupMembership = accountGroupMembership;
                break;
            }
        }
        if (groupMembership != null){
            groupMembership.delete();
        } else {
            throw new IllegalStateException(""The specified account does not belong to this Group."");
        }
        return this;
    }
","    public Group removeAccount(Account account) {
        Assert.notNull(account, ""account cannot be null"");

        GroupMembership groupMembership = null;
        for (GroupMembership accountGroupMembership : getAccountMemberships()) {
            if (accountGroupMembership.getAccount().getHref().equals(account.getHref())) {
                groupMembership = accountGroupMembership;
                break;
            }
        }
        if (groupMembership != null){
            groupMembership.delete();
        } else {
            throw new IllegalStateException(""The specified account does not belong to this Group."");
        }
        return this;
    }
"
119,rename to source,"			private boolean canPasteAll(IJavaElement destination) {
				for (TypedSource fSource : fSources) {
					if (!canPaste(fSource.getType(), destination)) {
						return false;
					}
				}
				return true;
			}
","			private boolean canPasteAll(IJavaElement destination) {
				for (TypedSource START  fSource : END  fSources) {
					if (!canPaste(fSource.getType(), destination)) {
						return false;
					}
				}
				return true;
			}
","			private boolean canPasteAll(IJavaElement destination) {
				for (TypedSource source : fSources) {
					if (!canPaste(source.getType(), destination)) {
						return false;
					}
				}
				return true;
			}
"
120,Could you inline the first call? `mRequest.setMarker(mResult.getNextMarker())`,"    public ObjectListingChunk getNextChunk() throws IOException {
      if (mResult.isTruncated()) {
        String nextMarker = mResult.getNextMarker();
        mRequest.setMarker(nextMarker);
        ObjectListing nextResult = mClient.listObjects(mRequest);
        if (nextResult != null) {
          return new OSSObjectListingChunk(mRequest, nextResult);
        }
      }
      return null;
    }
","    public ObjectListingChunk getNextChunk() throws IOException {
      if (mResult.isTruncated()) {
        String nextMarker = mResult.getNextMarker();
START         mRequest.setMarker(nextMarker); END 
        ObjectListing nextResult = mClient.listObjects(mRequest);
        if (nextResult != null) {
          return new OSSObjectListingChunk(mRequest, nextResult);
        }
      }
      return null;
    }
","    public ObjectListingChunk getNextChunk() throws IOException {
      if (mResult.isTruncated()) {
        mRequest.setMarker(mResult.getNextMarker());
        ObjectListing nextResult = mClient.listObjects(mRequest);
        if (nextResult != null) {
          return new OSSObjectListingChunk(mRequest, nextResult);
        }
      }
      return null;
    }
"
121,"Is there a particular reason why `getClass()` is used instead of `instanceof`. 
`instanceof` is less restrictive and may be the better choice.","        public boolean equals(final Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            final LoopDetectionCriteria that = (LoopDetectionCriteria) o;

            return seen.equals(that.seen);
        }
","        public boolean equals(final Object o) {
            if (this == o) {
                return true;
            }
START             if (o == null || getClass() != o.getClass()) { END 
                return false;
            }

            final LoopDetectionCriteria that = (LoopDetectionCriteria) o;

            return seen.equals(that.seen);
        }
","        public boolean equals(final Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof LoopDetectionCriteria)) {
                return false;
            }

            final LoopDetectionCriteria that = (LoopDetectionCriteria) o;

            return seen.equals(that.seen);
        }
"
122,"What is the purpose of wrapping the Boolean in a class and getting the boolean back out, rather than a direct `m1 == m2` expression?","    public void testBool() {
        final Arbitrary<Boolean> arbBooleanR = arbitrary(arbBoolean.gen);
        final Property p = property(arbBooleanR, arbBooleanR, (m1, m2) -> bool(m1.equals(m2))
                .implies(new BoolTestClass(m1).getBoolean() == new BoolTestClass(m2).getBoolean()));
        PropertyAssert.assertResult(p);
    }
","    public void testBool() {
        final Arbitrary<Boolean> arbBooleanR = arbitrary(arbBoolean.gen);
        final Property p = property(arbBooleanR, arbBooleanR, (m1, m2) -> bool(m1.equals(m2))
START                 .implies(new BoolTestClass(m1).getBoolean() == new BoolTestClass(m2).getBoolean())); END 
        PropertyAssert.assertResult(p);
    }
","    public void testBool() {
        final Arbitrary<Boolean> arbBooleanR = arbitrary(arbBoolean.gen);
        final Property p = property(arbBooleanR, arbBooleanR, (m1, m2) -> bool(m1.equals(m2))
                .implies(m1 == m2));
        PropertyAssert.assertResult(p);
    }
"
123,Shouldn't this pass the exception to the logger so the user will know what the failure was?,"    private void update() {
        // OK to ignore calls to update() if already busy updating 
        if (busy.compareAndSet(false, true)) {
            try {
                PollingResponse response = reader.call();
                if (response.hasData()) {
                    current = response.getToAdd();
                    notifyConfigUpdated(this);
                }
            }
            catch (Exception e) {
                try {
                    notifyError(e, this);
                }
                catch (Exception e2) {
                    LOG.warn(""Failed to notify error observer"");
                }
            }
            finally {
                busy.set(false);
            }
        }
    }
","    private void update() {
        // OK to ignore calls to update() if already busy updating 
        if (busy.compareAndSet(false, true)) {
            try {
                PollingResponse response = reader.call();
                if (response.hasData()) {
                    current = response.getToAdd();
                    notifyConfigUpdated(this);
                }
            }
            catch (Exception e) {
                try {
                    notifyError(e, this);
                }
                catch (Exception e2) {
START                     LOG.warn(""Failed to notify error observer""); END 
                }
            }
            finally {
                busy.set(false);
            }
        }
    }
","    private void update() {
        // OK to ignore calls to update() if already busy updating 
        if (busy.compareAndSet(false, true)) {
            try {
                PollingResponse response = reader.call();
                if (response.hasData()) {
                    current = response.getToAdd();
                    notifyConfigUpdated(this);
                }
            }
            catch (Exception e) {
                try {
                    notifyError(e, this);
                }
                catch (Exception e2) {
                    LOG.warn(""Failed to notify error observer"", e2);
                }
            }
            finally {
                busy.set(false);
            }
        }
    }
"
124,Do you need the fully qualified class name here?,"    public javax.ws.rs.core.Response toResponse(InvalidValueException e) {
        Fault fault = new Fault();
        fault.setReason(""Invalid Value"");
        fault.setDetail(e.getMessage());
        return Response.status(Response.Status.BAD_REQUEST).entity(fault).build();
    }
","START     public javax.ws.rs.core.Response toResponse(InvalidValueException e) { END 
        Fault fault = new Fault();
        fault.setReason(""Invalid Value"");
        fault.setDetail(e.getMessage());
        return Response.status(Response.Status.BAD_REQUEST).entity(fault).build();
    }
","    public Response toResponse(InvalidValueException e) {
        Fault fault = new Fault();
        fault.setReason(""Invalid Value"");
        fault.setDetail(e.getMessage());
        return Response.status(Response.Status.BAD_REQUEST).entity(fault).build();
    }
"
125,"Return sizeInByte instead, if available.","  static long calculateDirSizeAndSave(final File dir) throws IOException {
    final Path path = Paths.get(dir.getPath(), FlowPreparer.PROJECT_DIR_SIZE_FILE_NAME);
    if (!Files.exists(path)) {
      final long sizeInByte = FileUtils.sizeOfDirectory(dir);
      FileIOUtils.dumpNumberToFile(path, sizeInByte);
    }
    return FileIOUtils.readNumberFromFile(path);
  }
","  static long calculateDirSizeAndSave(final File dir) throws IOException {
    final Path path = Paths.get(dir.getPath(), FlowPreparer.PROJECT_DIR_SIZE_FILE_NAME);
    if (!Files.exists(path)) {
      final long sizeInByte = FileUtils.sizeOfDirectory(dir);
      FileIOUtils.dumpNumberToFile(path, sizeInByte);
    }
START     return FileIOUtils.readNumberFromFile(path); END 
  }
","  static long calculateDirSizeAndSave(final File dir) throws IOException {
    final Path path = Paths.get(dir.getPath(), FlowPreparer.PROJECT_DIR_SIZE_FILE_NAME);
    if (!Files.exists(path)) {
      final long sizeInByte = FileUtils.sizeOfDirectory(dir);
      FileIOUtils.dumpNumberToFile(path, sizeInByte);
      return sizeInByte;
    } else {
      return FileIOUtils.readNumberFromFile(path);
    }
  }
"
126,static import `readIntLittleEndianOnOneByte`.,"    public void initFromPage(int valueCount, ByteBufferInputStream inputStream)
            throws IOException
    {
        int bitWidth = BytesUtils.readIntLittleEndianOnOneByte(inputStream);
        decoder = new RunLengthBitPackingHybridDecoder(bitWidth, inputStream);
    }
","    public void initFromPage(int valueCount, ByteBufferInputStream inputStream)
            throws IOException
    {
START         int bitWidth = BytesUtils.readIntLittleEndianOnOneByte(inputStream); END 
        decoder = new RunLengthBitPackingHybridDecoder(bitWidth, inputStream);
    }
","    public void initFromPage(int valueCount, ByteBufferInputStream inputStream)
            throws IOException
    {
        int bitWidth = readIntLittleEndianOnOneByte(inputStream);
        decoder = new RunLengthBitPackingHybridDecoder(bitWidth, inputStream);
    }
"
127,"if you want to override the singleton instance, then, you need to remove the ContentProvider from the manifest, right?
or is there another way?","  @Override public boolean onCreate() {
    Picasso.setSingletonInstance(new Picasso.Builder(getContext()).build());
    return true;
  }
","  @Override public boolean onCreate() {
START     Picasso.setSingletonInstance(new Picasso.Builder(getContext()).build()); END 
    return true;
  }
","  @Override public boolean onCreate() {
    context = getContext();
    return true;
  }
"
128,"No, this one was correct... 😈 We want to convert the internal delay (expressed in milliseconds) to whatever unit the client asked.","    public long getDelayBetweenSyncs(@NonNull TimeUnit unit) {
        return TimeUnit.MILLISECONDS.convert(this.getDelayBetweenSyncs(), unit);
    }
","    public long getDelayBetweenSyncs(@NonNull TimeUnit unit) {
START         return TimeUnit.MILLISECONDS.convert(this.getDelayBetweenSyncs(), unit); END 
    }
","    public long getDelayBetweenSyncs(@NonNull TimeUnit unit) {
        return unit.convert(this.getDelayBetweenSyncs(), TimeUnit.MILLISECONDS);
    }
"
129,`new HashMap(delegates)` - don't keep a reference to the caller's map - he might change it.,"	public CompositeCodec(Map<Class<?>, Codec> delegates, Codec defaultCodec) {
		Assert.notNull(defaultCodec, ""'defaultCodec' cannot be null"");
		this.defaultCodec = defaultCodec;
		this.delegates = delegates;
	}
","	public CompositeCodec(Map<Class<?>, Codec> delegates, Codec defaultCodec) {
		Assert.notNull(defaultCodec, ""'defaultCodec' cannot be null"");
		this.defaultCodec = defaultCodec;
START 		this.delegates = delegates; END 
	}
","	public CompositeCodec(Map<Class<?>, Codec> delegates, Codec defaultCodec) {
		Assert.notNull(defaultCodec, ""'defaultCodec' cannot be null"");
		this.defaultCodec = defaultCodec;
		this.delegates = new HashMap<Class<?>, Codec>(delegates);
	}
"
130,final?,"	public T get() {
		return getOr(defaultValue);
	}
","START 	public T get() { END 
		return getOr(defaultValue);
	}
","	public final T get() {
		return getOr(defaultValue);
	}
"
131,"if you are going to assign the local variable to the field, why not skip the local variable and use the field in the method?","    private void updateNics(List<NetworkInterfaceModel> nics) {
        nicList.clear();
        Collections.sort(nics);
        List<NetworkGroup> groups = new ArrayList<>();
        for (NetworkInterfaceModel nic : nics) {
            groups.add(new NetworkGroup(nic, eventBus, style));
        }
        nicList.addAll(groups, !rendered);
        nicGroups = groups;
    }
","    private void updateNics(List<NetworkInterfaceModel> nics) {
        nicList.clear();
        Collections.sort(nics);
        List<NetworkGroup> groups = new ArrayList<>();
        for (NetworkInterfaceModel nic : nics) {
            groups.add(new NetworkGroup(nic, eventBus, style));
        }
        nicList.addAll(groups, !rendered);
START         nicGroups = groups; END 
    }
","    private void updateNics(List<NetworkInterfaceModel> nics) {
        nicList.clear();
        Collections.sort(nics);
        nicGroups = new ArrayList<>();
        for (NetworkInterfaceModel nic : nics) {
            nicGroups.add(new NetworkGroup(nic, eventBus, style));
        }
        nicList.addAll(nicGroups, !rendered);
    }
"
132,"nitpick: replace `if` with `&&`
```suggestion
      return timeout == options.timeout && 
             deliverOrder == options.deliverOrder && 
             unit == options.unit;
```","   public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;

      RpcOptions options = (RpcOptions) o;

      if (timeout != options.timeout) return false;
      if (deliverOrder != options.deliverOrder) return false;
      return unit == options.unit;
   }
","   public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;

      RpcOptions options = (RpcOptions) o;

      if (timeout != options.timeout) return false;
      if (deliverOrder != options.deliverOrder) return false;
START       return unit == options.unit; END 
   }
","   public boolean equals(Object o) {
      if (this == o) return true;
      if (o == null || getClass() != o.getClass()) return false;

      RpcOptions options = (RpcOptions) o;

      return timeout == options.timeout &&
            deliverOrder == options.deliverOrder &&
            unit == options.unit;
   }
"
133,Why is it necessary to rename these methods?,"    protected abstract OutputStream getOutputStreamInternal(RepositoryPath repositoryPath)
        throws IOException;

    protected final RepositoryOutputStream decorate(RepositoryPath repositoryPath,
                                                    OutputStream os) throws IOException
    {
        if (os == null || os instanceof RepositoryOutputStream)
        {
            return (RepositoryOutputStream) os;
        }

        String path = RepositoryFiles.stringValue(repositoryPath);
        return RepositoryOutputStream.of(repositoryPath.getRepository(), path, os).with(this);
    }
","START     protected abstract OutputStream getOutputStreamInternal(RepositoryPath repositoryPath) END 
        throws IOException;

    protected final RepositoryOutputStream decorate(RepositoryPath repositoryPath,
                                                    OutputStream os) throws IOException
    {
        if (os == null || os instanceof RepositoryOutputStream)
        {
            return (RepositoryOutputStream) os;
        }

        String path = RepositoryFiles.stringValue(repositoryPath);
        return RepositoryOutputStream.of(repositoryPath.getRepository(), path, os).with(this);
    }
","    protected abstract OutputStream getOutputStreamInternal(RepositoryPath repositoryPath)
        throws IOException;

    protected final RepositoryOutputStream decorate(RepositoryPath repositoryPath,
                                                    OutputStream os) throws IOException
    {
        if (os == null || os instanceof RepositoryOutputStream)
        {
            return (RepositoryOutputStream) os;
        }

        return RepositoryOutputStream.of(repositoryPath, os).with(this);
    }
"
134,"Why DOTALL?
As I know, it's needed to support multiline Strings, which hardly can happen to attribute values.","  public MatchAttributeWithValue(String attributeName, String attributeRegex) {
    super(""match attribute"");
    this.attributeName = attributeName;
    this.attributeRegex = Pattern.compile(attributeRegex, DOTALL);
  }
","  public MatchAttributeWithValue(String attributeName, String attributeRegex) {
    super(""match attribute"");
    this.attributeName = attributeName;
START     this.attributeRegex = Pattern.compile(attributeRegex, DOTALL); END 
  }
","  public MatchAttributeWithValue(String attributeName, String attributeRegex) {
    super(""match attribute"");
    this.attributeName = attributeName;
    this.attributeRegex = Pattern.compile(attributeRegex);
  }
"
135,"saw NPE here - change to `if (exampleEntity != null && exampleEntity.getApplication() != null)`

(happened when `ExampleAppInFile.groovy` was not on my classpath due to annoying Eclipse behaviour).","    public void tearDown() throws Exception {
        if (executor != null) executor.shutdownNow();
        if (app != null) Entities.destroyAll(app.getManagementContext());
        if (exampleEntity != null) Entities.destroyAll(exampleEntity.getApplication().getManagementContext());
    }
","    public void tearDown() throws Exception {
        if (executor != null) executor.shutdownNow();
        if (app != null) Entities.destroyAll(app.getManagementContext());
START         if (exampleEntity != null) Entities.destroyAll(exampleEntity.getApplication().getManagementContext()); END 
    }
","    public void tearDown() throws Exception {
        if (executor != null) executor.shutdownNow();
        if (app != null) Entities.destroyAll(app.getManagementContext());
        if (exampleEntity != null && exampleEntity.getApplication() != null) Entities.destroyAll(exampleEntity.getApplication().getManagementContext());
    }
"
136,inline listeners.getListeners(),"	public void refreshJobInfo(JobInfo info) {
		GroupInfo group = info.getGroupInfo();
		if (group != null) {
			refreshGroup(group);
		}

		Object[] listenersArray = listeners.getListeners();
		for (Object element : listenersArray) {
			IJobProgressManagerListener listener = (IJobProgressManagerListener) element;
			if (!isCurrentDisplaying(info.getJob(), listener.showsDebug())) {
				listener.refreshJobInfo(info);
			}
		}
	}
","	public void refreshJobInfo(JobInfo info) {
		GroupInfo group = info.getGroupInfo();
		if (group != null) {
			refreshGroup(group);
		}

		Object[] listenersArray = listeners.getListeners();
START 		for (Object element : listenersArray) { END 
			IJobProgressManagerListener listener = (IJobProgressManagerListener) element;
			if (!isCurrentDisplaying(info.getJob(), listener.showsDebug())) {
				listener.refreshJobInfo(info);
			}
		}
	}
","	public void refreshJobInfo(JobInfo info) {
		GroupInfo group = info.getGroupInfo();
		if (group != null) {
			refreshGroup(group);
		}

		for (Object element : listeners.getListeners()) {
			IJobProgressManagerListener listener = (IJobProgressManagerListener) element;
			if (!isCurrentDisplaying(info.getJob(), listener.showsDebug())) {
				listener.refreshJobInfo(info);
			}
		}
	}
"
137,"Is it obvious if we pass config class so it is not intrinsic but if StoragePlugin instance it is?
Maybe it's better to have this done using static methods for better readability?

For example:

We'll have only one constructor and two static methods:
```
private ConnectorHandle(ConnectorLocator locator, Class<? extends StoragePluginConfig> configClass, boolean isIntrinsic) {
     this.locator = locator;
     this.configClass = configClass;
     this.isIntrinsic = isIntrinsic;
   }

public static ConnectorHandle initIntrinsic(ConnectorLocator locator, 
Class<? extends StoragePluginConfig> configClass) {
 return new ConnectorHandle(...);
}

public static ConnectorHandle initNonIntrinsic(ConnectorLocator locator, 
Class<? extends StoragePluginConfig> configClass) {
 return new ConnectorHandle(...);
}
```","  public ConnectorHandle(ConnectorLocator locator,
      Class<? extends StoragePluginConfig> configClass) {
    this.locator = locator;
    this.configClass = configClass;
    this.isIntrinsic = false;
  }
","START   public ConnectorHandle(ConnectorLocator locator, END 
      Class<? extends StoragePluginConfig> configClass) {
    this.locator = locator;
    this.configClass = configClass;
    this.isIntrinsic = false;
  }
","  private ConnectorHandle(ConnectorLocator locator,
      Class<? extends StoragePluginConfig> configClass) {
    this.locator = locator;
    this.configClass = configClass;
    this.isIntrinsic = false;
  }
"
138,Is it possible that the reconfigure operation is fast enough that we don't actually see this state? Does it really make sense to wait for intermediate states?,"   public void testReconfigureServer() {
      api().reconfigureServer(serverId, 4, CpuSpeed.HIGHPERFORMANCE.name(), 1);
      waitForServerState(api(), serverId, State.PENDING_CHANGE, 30 * 60 * 1000, ""Error"");
      waitForServerState(api(), serverId, State.NORMAL, 30 * 60 * 1000, ""Error"");
   }
","   public void testReconfigureServer() {
      api().reconfigureServer(serverId, 4, CpuSpeed.HIGHPERFORMANCE.name(), 1);
START       waitForServerState(api(), serverId, State.PENDING_CHANGE, 30 * 60 * 1000, ""Error""); END 
      waitForServerState(api(), serverId, State.NORMAL, 30 * 60 * 1000, ""Error"");
   }
","   public void testReconfigureServer() {
      api().reconfigureServer(serverId, 4, CpuSpeed.HIGHPERFORMANCE.name(), 1);
      waitForServerState(api(), serverId, State.NORMAL, 30 * 60 * 1000, ""Error"");
   }
"
139,Revert back to sessionFactory.getCurrentSession(),"	public void run() {
		try {
			log.info(""Running reporting task: "" + getClass().getSimpleName());
			currentSession = sessionFactory.getHibernateSessionFactory().getCurrentSession();
			executeTask();
			log.info(""Completed reporting task: "" + getClass().getSimpleName());
		}
		catch (Exception e) {
			log.error(""An error occurred while running reporting task: "" + getClass(), e);
		}
	}
","	public void run() {
		try {
			log.info(""Running reporting task: "" + getClass().getSimpleName());
START 			currentSession = sessionFactory.getHibernateSessionFactory().getCurrentSession(); END 
			executeTask();
			log.info(""Completed reporting task: "" + getClass().getSimpleName());
		}
		catch (Exception e) {
			log.error(""An error occurred while running reporting task: "" + getClass(), e);
		}
	}
","	public void run() {
		try {
			log.info(""Running reporting task: "" + getClass().getSimpleName());
			currentSession = sessionFactory.getCurrentSession();
			executeTask();
			log.info(""Completed reporting task: "" + getClass().getSimpleName());
		}
		catch (Exception e) {
			log.error(""An error occurred while running reporting task: "" + getClass(), e);
		}
	}
"
140,"This should imho be implemented with an equals since you are comparing Strings and to make it null safe I would suggest:

`return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());`","    public static final boolean isStorageWritable() {
        return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED;
    }
","    public static final boolean isStorageWritable() {
START         return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED; END 
    }
","    public static final boolean isStorageWritable() {
        return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
    }
"
141,"I foresee clashes here. Should at least use <type> + ""/"" + <name>","	public ModuleMetadataResource toResource(ModuleMetadata entity) {
		return createResourceWithId(entity.getName(), entity);
	}
","	public ModuleMetadataResource toResource(ModuleMetadata entity) {
START 		return createResourceWithId(entity.getName(), entity); END 
	}
","	public ModuleMetadataResource toResource(ModuleMetadata entity) {
		return createResourceWithId(entity.getId(), entity);
	}
"
142,"Hm, this method was meant to contain GIN bindings for ""frontend communication infra"" classes, so I'd rather put AssetProvider binding elsewhere, e.g. at the end of bindCommonInfrastructure method?","    private void bindFrontendInfrastructure() {
        bind(Frontend.class).in(Singleton.class);
        requestStaticInjection(Frontend.InstanceHolder.class);
        requestStaticInjection(AssetProvider.class);
        bind(VdcOperationManager.class).in(Singleton.class);
        bind(OperationProcessor.class).in(Singleton.class);
        bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    }
","    private void bindFrontendInfrastructure() {
        bind(Frontend.class).in(Singleton.class);
        requestStaticInjection(Frontend.InstanceHolder.class);
START         requestStaticInjection(AssetProvider.class); END 
        bind(VdcOperationManager.class).in(Singleton.class);
        bind(OperationProcessor.class).in(Singleton.class);
        bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    }
","    private void bindFrontendInfrastructure() {
        bind(Frontend.class).in(Singleton.class);
        requestStaticInjection(Frontend.InstanceHolder.class);
        bind(VdcOperationManager.class).in(Singleton.class);
        bind(OperationProcessor.class).in(Singleton.class);
        bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    }
"
143,What is this lazySet about? What about visibility would not work if this wasn't done?,"    public Subscriber<Observable<? extends T>> call(final Subscriber<? super T> child) {
        MergeSubscriber<T> subscriber = new MergeSubscriber<T>(child, delayErrors, maxConcurrent);
        MergeProducer<T> producer = new MergeProducer<T>(subscriber);
        subscriber.producer = producer;
        producer.lazySet(0); // make sure subscriber.producer is visible
        
        child.add(subscriber);
        child.setProducer(producer);
        
        return subscriber;
    }
","    public Subscriber<Observable<? extends T>> call(final Subscriber<? super T> child) {
        MergeSubscriber<T> subscriber = new MergeSubscriber<T>(child, delayErrors, maxConcurrent);
        MergeProducer<T> producer = new MergeProducer<T>(subscriber);
        subscriber.producer = producer;
START         producer.lazySet(0); // make sure subscriber.producer is visible END 
        
        child.add(subscriber);
        child.setProducer(producer);
        
        return subscriber;
    }
","    public Subscriber<Observable<? extends T>> call(final Subscriber<? super T> child) {
        MergeSubscriber<T> subscriber = new MergeSubscriber<T>(child, delayErrors, maxConcurrent);
        MergeProducer<T> producer = new MergeProducer<T>(subscriber);
        subscriber.producer = producer;
        
        child.add(subscriber);
        child.setProducer(producer);
        
        return subscriber;
    }
"
144,@bgeVam why did you add patient ?,"    public void getRadiologyOrders_shouldReturnAllRadiologyOrdersForGivenUrgency() throws Exception {
        
        Patient patient = patientService.getPatient(PATIENT_ID_WITH_ONE_VOIDED_AND_TWO_NON_VOIDED_RADIOLOGY_ORDERS);
        RadiologyOrderSearchCriteria radiologyOrderSearchCriteria =
                new RadiologyOrderSearchCriteria.Builder().withPatient(patient)
                        .withUrgency(Urgency.STAT)
                        .build();
        
        List<RadiologyOrder> radiologyOrders = radiologyOrderService.getRadiologyOrders(radiologyOrderSearchCriteria);
        assertThat(radiologyOrders.size(), is(2));
        for (RadiologyOrder radiologyOrder : radiologyOrders) {
            assertThat(radiologyOrder.getUrgency(), is(Urgency.STAT));
        }
    }
","    public void getRadiologyOrders_shouldReturnAllRadiologyOrdersForGivenUrgency() throws Exception {
        
        Patient patient = patientService.getPatient(PATIENT_ID_WITH_ONE_VOIDED_AND_TWO_NON_VOIDED_RADIOLOGY_ORDERS);
        RadiologyOrderSearchCriteria radiologyOrderSearchCriteria =
START                 new RadiologyOrderSearchCriteria.Builder().withPatient(patient) END 
                        .withUrgency(Urgency.STAT)
                        .build();
        
        List<RadiologyOrder> radiologyOrders = radiologyOrderService.getRadiologyOrders(radiologyOrderSearchCriteria);
        assertThat(radiologyOrders.size(), is(2));
        for (RadiologyOrder radiologyOrder : radiologyOrders) {
            assertThat(radiologyOrder.getUrgency(), is(Urgency.STAT));
        }
    }
","    public void getRadiologyOrders_shouldReturnAllRadiologyOrdersForGivenUrgency() throws Exception {
        
        RadiologyOrderSearchCriteria radiologyOrderSearchCriteria =
                new RadiologyOrderSearchCriteria.Builder().withUrgency(Urgency.STAT)
                        .build();
        
        List<RadiologyOrder> radiologyOrders = radiologyOrderService.getRadiologyOrders(radiologyOrderSearchCriteria);
        assertThat(radiologyOrders.size(), is(5));
        for (RadiologyOrder radiologyOrder : radiologyOrders) {
            assertThat(radiologyOrder.getUrgency(), is(Urgency.STAT));
        }
    }
"
145,`format` should be able to deal with `Enum`s just fine. no need to call `name()`,"  static FeignException errorReading(Request request, Response ignored, IOException cause) {
    return new FeignException(
        format(""%s reading %s %s"", cause.getMessage(), request.httpMethod().name(), request.url()),
        cause);
  }
","  static FeignException errorReading(Request request, Response ignored, IOException cause) {
    return new FeignException(
START         format(""%s reading %s %s"", cause.getMessage(), request.httpMethod().name(), request.url()), END 
        cause);
  }
","  static FeignException errorReading(Request request, Response ignored, IOException cause) {
    return new FeignException(
        format(""%s reading %s %s"", cause.getMessage(), request.httpMethod(), request.url()),
        cause);
  }
"
146,nit: you can merge both lines above as `checkNotNull` will return the given argument,"    protected WrappedByteBuf(ByteBuf buf) {
        ObjectUtil.checkNotNull(buf, ""buf"");
        this.buf = buf;
    }
","    protected WrappedByteBuf(ByteBuf buf) {
        ObjectUtil.checkNotNull(buf, ""buf"");
START         this.buf = buf; END 
    }
","    protected WrappedByteBuf(ByteBuf buf) {
        this.buf = ObjectUtil.checkNotNull(buf, ""buf"");
    }
"
147,Should this check that chunks.get(0) exists?,"  public boolean isFull()
  {
    return chunks.size() == chunks.get(0).getObject().getAtomicUpdateGroupSize();
  }
","  public boolean isFull()
  {
START     return chunks.size() == chunks.get(0).getObject().getAtomicUpdateGroupSize(); END 
  }
","  public boolean isFull()
  {
    return !isEmpty() && chunks.size() == chunks.get(0).getObject().getAtomicUpdateGroupSize();
  }
"
148,private,"  public String me() {
    return """" + state + ME_SEPARATOR;
  }
","  START  public String END  me() {
    return """" + state + ME_SEPARATOR;
  }
","  public String me() {
    return state + ME_SEPARATOR;
  }
"
149,Couldn't we just use Arrays.asList(getWikiCodes).indexOf(wikiCode) instead of importing a whole new library?,"    public int findWikiIndex(String wikiCode) {
        int index = ArrayUtils.indexOf(getWikiCodes(), wikiCode);
        if (index == ArrayUtils.INDEX_NOT_FOUND) {
            // FIXME: Instrument this with EL to find out what is happening on places where there is a lang we can't find
            // In the meantime, just fall back to en. See https://bugzilla.wikimedia.org/show_bug.cgi?id=66140
            return findWikiIndex(FALLBACK_WIKI_LANG_CODE);
        }
        return index;
    }
","    public int findWikiIndex(String wikiCode) {
START         int index = ArrayUtils.indexOf(getWikiCodes(), wikiCode); END 
        if (index == ArrayUtils.INDEX_NOT_FOUND) {
            // FIXME: Instrument this with EL to find out what is happening on places where there is a lang we can't find
            // In the meantime, just fall back to en. See https://bugzilla.wikimedia.org/show_bug.cgi?id=66140
            return findWikiIndex(FALLBACK_WIKI_LANG_CODE);
        }
        return index;
    }
","    public int findWikiIndex(String wikiCode) {
        int index = getWikiCodes().indexOf(wikiCode);
        if (index == -1) {
            // FIXME: Instrument this with EL to find out what is happening on places where there is a lang we can't find
            // In the meantime, just fall back to en. See https://bugzilla.wikimedia.org/show_bug.cgi?id=66140
            return findWikiIndex(FALLBACK_WIKI_LANG_CODE);
        }
        return index;
    }
"
150,nit: I would prefer to use the junit assertion functions.,"    public void testRayCasting(){

        final double[][] platform = {{ 59.8925348, 10.5242855}, { 59.8927012, 10.524743}, { 59.8926397, 10.5248089}, {59.8924888, 10.5243485}};

        double[] testPointInside = { 59.8926474, 10.524729};
        double[] testPointOutside = { 59.8925344, 10.5249007};

        assert(PlatformLinker.contains(platform, testPointInside));
        assert(!PlatformLinker.contains(platform, testPointOutside));
    }
","    public void testRayCasting(){

        final double[][] platform = {{ 59.8925348, 10.5242855}, { 59.8927012, 10.524743}, { 59.8926397, 10.5248089}, {59.8924888, 10.5243485}};

        double[] testPointInside = { 59.8926474, 10.524729};
        double[] testPointOutside = { 59.8925344, 10.5249007};

START         assert(PlatformLinker.contains(platform, testPointInside)); END 
        assert(!PlatformLinker.contains(platform, testPointOutside));
    }
","    public void testRayCasting(){

        final double[][] platform = {{10.5242855, 59.8925348}, {10.524743, 59.8927012}, { 10.5248089, 59.8926397}, {10.5243485, 59.8924888}};

        double[] testPointInside = { 10.524729, 59.8926474};
        double[] testPointOutside = { 10.5249007, 59.8925344};

        assert(PlatformLinker.contains(platform, testPointInside));
        assert(!PlatformLinker.contains(platform, testPointOutside));
    }
"
151,"@PostConstruct would not be called concurrently, rite? Do we need the current status as AtomicRef?","    public void init() {
        try {
            eventBus.registerSubscriber(this);
            
            // Must set the initial status
            currentStatus.compareAndSet(InstanceInfo.InstanceStatus.UNKNOWN, client.getInstanceRemoteStatus());
        } catch (InvalidSubscriberException e) {
            LOG.error(""Error registring for discovery status change events."", e);
        }
    }
","    public void init() {
        try {
            eventBus.registerSubscriber(this);
            
            // Must set the initial status
START             currentStatus.compareAndSet(InstanceInfo.InstanceStatus.UNKNOWN, client.getInstanceRemoteStatus()); END 
        } catch (InvalidSubscriberException e) {
            LOG.error(""Error registring for discovery status change events."", e);
        }
    }
","    public void init() {
        try {
            eventBus.registerSubscriber(this);
            
            // Must set the initial status
            currentStatus = client.getInstanceRemoteStatus();
        } catch (InvalidSubscriberException e) {
            LOG.error(""Error registring for discovery status change events."", e);
        }
    }
"
152,Shouldn't this be appended to pageProlog?,"	public static void insertPageProlog(StringBuilder buffer, int position) {
		StringBuilder pageProlog= new StringBuilder(60);
		pageProlog.append(""<html>""); //$NON-NLS-1$
		buffer.append(""<head>""); //$NON-NLS-1$
		appendStyleSheetWithBodyColorRules(pageProlog, FG_COLOR_RGB, BG_COLOR_RGB);
		buffer.append(""</head>""); //$NON-NLS-1$
		buffer.insert(position,  pageProlog.toString());
	}
","	public static void insertPageProlog(StringBuilder buffer, int position) {
		StringBuilder pageProlog= new StringBuilder(60);
		pageProlog.append(""<html>""); //$NON-NLS-1$
		buffer.append(""<head>""); //$NON-NLS-1$
		appendStyleSheetWithBodyColorRules(pageProlog, FG_COLOR_RGB, BG_COLOR_RGB);
START 		buffer.append(""</head>""); //$NON-NLS-1$ END 
		buffer.insert(position,  pageProlog.toString());
	}
","	public static void insertPageProlog(StringBuilder buffer, int position) {
		StringBuilder pageProlog= new StringBuilder(60);
		pageProlog.append(""<html>""); //$NON-NLS-1$
		pageProlog.append(""<head>""); //$NON-NLS-1$
		appendStyleSheetWithBodyColorRules(pageProlog, FG_COLOR_RGB, BG_COLOR_RGB);
		pageProlog.append(""</head>""); //$NON-NLS-1$
		buffer.insert(position,  pageProlog.toString());
	}
"
153,final?,"    private void verifyCertificateChain(final List<X509Certificate> certificates)
            throws GeneralSecurityException, AuthenticationException {
        // create certificate chain, find the self signed cert first and chain all the way back
        // to the signer cert. Also perform certificate signing validation when chaining them back.
        X509Certificate issuerCert = getSelfSignedCert(certificates);
        final TrustAnchor trustAnchor = new TrustAnchor(issuerCert, null);
        PKIXParameters pkixParameters = new PKIXParameters(Collections.singleton(trustAnchor));
        pkixParameters.setRevocationEnabled(false);
        final CertPath certPath = CertificateFactory.getInstance(""X.509"")
                .generateCertPath(certificates);

        final CertPathValidator certPathValidator = CertPathValidator.getInstance(""PKIX"");
        certPathValidator.validate(certPath, pkixParameters);
    }
","    private void verifyCertificateChain(final List<X509Certificate> certificates)
            throws GeneralSecurityException, AuthenticationException {
        // create certificate chain, find the self signed cert first and chain all the way back
        // to the signer cert. Also perform certificate signing validation when chaining them back.
        X509Certificate issuerCert = getSelfSignedCert(certificates);
        final TrustAnchor trustAnchor = new TrustAnchor(issuerCert, null);
START         PKIXParameters pkixParameters = new PKIXParameters(Collections.singleton(trustAnchor)); END 
        pkixParameters.setRevocationEnabled(false);
        final CertPath certPath = CertificateFactory.getInstance(""X.509"")
                .generateCertPath(certificates);

        final CertPathValidator certPathValidator = CertPathValidator.getInstance(""PKIX"");
        certPathValidator.validate(certPath, pkixParameters);
    }
","    private void verifyCertificateChain(final List<X509Certificate> certificates)
            throws GeneralSecurityException, AuthenticationException {
        // create certificate chain, find the self signed cert first and chain all the way back
        // to the signer cert. Also perform certificate signing validation when chaining them back.
        final X509Certificate issuerCert = getSelfSignedCert(certificates);
        final TrustAnchor trustAnchor = new TrustAnchor(issuerCert, null);
        final PKIXParameters pkixParameters = new PKIXParameters(Collections.singleton(trustAnchor));
        pkixParameters.setRevocationEnabled(false);
        final CertPath certPath = CertificateFactory.getInstance(""X.509"")
                .generateCertPath(certificates);

        final CertPathValidator certPathValidator = CertPathValidator.getInstance(""PKIX"");
        certPathValidator.validate(certPath, pkixParameters);
    }
"
154,"This change causes regression of JaxrsRuntimeNameTestCase. JaxrsRuntimeNameTestCase uses HelloApplication.java as well, but HelloBadResource is not added to the deployment from JaxrsRuntimeNameTestCase. So JaxrsRuntimeNameTestCase fails.","    public Set<Class<?>> getClasses() {
        final Set<Class<?>> classes = new HashSet<>();
        classes.add(HelloResource.class);
        classes.add(PureProxyEndPoint.class);
        classes.add(HelloBadResource.class);
        classes.add(HelloSometimesBadResource.class);
        return classes;
    }
","    public Set<Class<?>> getClasses() {
        final Set<Class<?>> classes = new HashSet<>();
        classes.add(HelloResource.class);
        classes.add(PureProxyEndPoint.class);
START         classes.add(HelloBadResource.class); END 
        classes.add(HelloSometimesBadResource.class);
        return classes;
    }
","    public Set<Class<?>> getClasses() {
        final Set<Class<?>> classes = new HashSet<>();
        classes.add(HelloResource.class);
        classes.add(PureProxyEndPoint.class);
        return classes;
    }
"
155,"Subclasses are also doing this.
The method should be _protected_, and the same code should be replaced by a call to this method in the subclasses.","    private void reconnectExceptionally(final String message) throws DatabaseEngineException {
        try {
            getConnection();
        } catch (final Exception e) {
            throw new DatabaseEngineException(message, e);
        }
    }
","START     private void reconnectExceptionally(final String message) throws DatabaseEngineException {
        try {
            getConnection();
        } catch (final Exception e) {
            throw new DatabaseEngineException(message, e);
        }
    } END 
","    protected void reconnectExceptionally(final String message) throws DatabaseEngineException {
        try {
            getConnection();
        } catch (final Exception e) {
            throw new DatabaseEngineException(message, e);
        }
    }
"
156,minor nit: can we pass time column selector before field selector to be consistent with buffered aggregator ?,"  public Aggregator factorize(ColumnSelectorFactory metricFactory)
  {
    return new LongLastAggregator(
        name, metricFactory.makeLongColumnSelector(fieldName),
        metricFactory.makeLongColumnSelector(Column.TIME_COLUMN_NAME)
    );
  }
","  public Aggregator factorize(ColumnSelectorFactory metricFactory)
  {
    return new LongLastAggregator(
        name, metricFactory.makeLongColumnSelector(fieldName),
START         metricFactory.makeLongColumnSelector(Column.TIME_COLUMN_NAME) END 
    );
  }
","  public Aggregator factorize(ColumnSelectorFactory metricFactory)
  {
    return new LongLastAggregator(
        name,
        metricFactory.makeLongColumnSelector(Column.TIME_COLUMN_NAME),
        metricFactory.makeLongColumnSelector(fieldName)
    );
  }
"
157,"This won't do what you think.

The base class should probably have a sholdLog() method, and the caller should implement

protected final void logToAudit() {
    if (shouldLog()) {
        realLogToAudit());
    }
}","    protected void logToAudit(){
        super.logToAudit();

        if (isPolicyResetMessage(getReturnStatus().message)) {
            return;
        }

        AuditLogableBase auditLogableBase = new AuditLogableBase(vds.getId());
        auditLogableBase.setVds(vds);
        auditLogableBase.addCustomValue(""message"", getReturnStatus().message);

        auditLogDirector.log(auditLogableBase, AuditLogType.VDS_BROKER_COMMAND_FAILURE);
    }
","    protected void logToAudit(){
START         super.logToAudit(); END 

        if (isPolicyResetMessage(getReturnStatus().message)) {
            return;
        }

        AuditLogableBase auditLogableBase = new AuditLogableBase(vds.getId());
        auditLogableBase.setVds(vds);
        auditLogableBase.addCustomValue(""message"", getReturnStatus().message);

        auditLogDirector.log(auditLogableBase, AuditLogType.VDS_BROKER_COMMAND_FAILURE);
    }
","    protected void logToAudit(){
        if (isPolicyResetMessage(getReturnStatus().message)) {
            return;
        }

        AuditLogableBase auditLogableBase = new AuditLogableBase(vds.getId());
        auditLogableBase.setVds(vds);
        auditLogableBase.addCustomValue(""message"", getReturnStatus().message);

        auditLogDirector.log(auditLogableBase, AuditLogType.VDS_BROKER_COMMAND_FAILURE);
    }
"
158,This should not be protected but package.,"protected String gtk_rgba_to_css_string (GdkRGBA rgba) {
	String color = ""rgba("" + (int)(rgba.red * 255) + "","" + (int)(rgba.green * 255) + "","" + (int)(rgba.blue * 255) + "","" + (int)(rgba.alpha * 255) + "")"";
	return color;
}
","START protected String gtk_rgba_to_css_string (GdkRGBA rgba) { END 
	String color = ""rgba("" + (int)(rgba.red * 255) + "","" + (int)(rgba.green * 255) + "","" + (int)(rgba.blue * 255) + "","" + (int)(rgba.alpha * 255) + "")"";
	return color;
}
","String gtk_rgba_to_css_string (GdkRGBA rgba) {
	/*
	 * In GdkRGBA, values are a double between 0-1.<br>
     * In CSS, values are typically integers between 0-255.<br>
     * I.e, note, there is a slight loss of precision.
     * Thus setting/getting color *might* return slight differences.
	 */
	String color = ""rgba("" + (int)(rgba.red * 255) + "","" + (int)(rgba.green * 255) + "","" + (int)(rgba.blue * 255) + "","" + (int)(rgba.alpha * 255) + "")"";
	return color;
}
"
159,"style nit: missing braces, the style guide was changed a while back since then we use braces around single line blocks","		public FileMode getMode(File f, FS.Attributes attributes) {
			if (attributes.isSymbolicLink())
				return FileMode.SYMLINK;
			else if (attributes.isDirectory()) {
				if (new File(f, Constants.DOT_GIT).exists())
					return FileMode.GITLINK;
				else
					return FileMode.TREE;
			} else if (attributes.isExecutable())
				return FileMode.EXECUTABLE_FILE;
			else
				return FileMode.REGULAR_FILE;
		}
","		public FileMode getMode(File f, FS.Attributes attributes) {
START 			if (attributes.isSymbolicLink()) END 
				return FileMode.SYMLINK;
			else if (attributes.isDirectory()) {
				if (new File(f, Constants.DOT_GIT).exists())
					return FileMode.GITLINK;
				else
					return FileMode.TREE;
			} else if (attributes.isExecutable())
				return FileMode.EXECUTABLE_FILE;
			else
				return FileMode.REGULAR_FILE;
		}
","		public FileMode getMode(File f, FS.Attributes attributes) {
			if (attributes.isSymbolicLink()) {
				return FileMode.SYMLINK;
			} else if (attributes.isDirectory()) {
				if (new File(f, Constants.DOT_GIT).exists()) {
					return FileMode.GITLINK;
				} else {
					return FileMode.TREE;
				}
			} else if (attributes.isExecutable()) {
				return FileMode.EXECUTABLE_FILE;
			} else {
				return FileMode.REGULAR_FILE;
			}
		}
"
160,Move to constructor? We already do a defensive copy might as well front-load this work instead.,"  public Map<String, Set<ExecutableElement>> setters() {
    return Maps.transformValues(setters.asMap(), Sets::newHashSet);
  }
","  public Map<String, Set<ExecutableElement>> setters() {
START     return Maps.transformValues(setters.asMap(), Sets::newHashSet); END 
  }
","  public Map<String, Set<ExecutableElement>> setters() {
    return setters;
  }
"
161,throws is not required,"    public void sendBannerChange(Location location, CompoundTag nbt) throws NullPointerException {
        sendBlockEntityChange(location, nbt, GlowBlockEntity.BANNER);
    }
","START     public void sendBannerChange(Location location, CompoundTag nbt) throws NullPointerException { END 
        sendBlockEntityChange(location, nbt, GlowBlockEntity.BANNER);
    }
","    public void sendBannerChange(Location location, CompoundTag nbt) {
        sendBlockEntityChange(location, nbt, GlowBlockEntity.BANNER);
    }
"
162,"@e-cuellar is the reason this is set to 1 because of line number 133?  If so, I'd prefer this to be String[0], and add some safety on getSchemeRestriction() to check array length (because it could be 0, as set by setSchemeRestrictions).  Looks like setSchemeRestriction needs to be a little smarter too.  I'd suggest that if the API call setSchemeRestriction that we wipe the schemeRestriction and stuff it only with the incoming schemeRestriction.","  public VfsFileChooserHelper( Shell shell, VfsFileChooserDialog fileChooserDialog, VariableSpace variableSpace,
      FileSystemOptions fileSystemOptions ) {
    this.fileChooserDialog = fileChooserDialog;
    this.shell = shell;
    this.variableSpace = variableSpace;
    this.fileSystemOptions = fileSystemOptions;
    this.schemeRestrictions = new String[1];
  }
","  public VfsFileChooserHelper( Shell shell, VfsFileChooserDialog fileChooserDialog, VariableSpace variableSpace,
      FileSystemOptions fileSystemOptions ) {
    this.fileChooserDialog = fileChooserDialog;
    this.shell = shell;
    this.variableSpace = variableSpace;
    this.fileSystemOptions = fileSystemOptions;
START     this.schemeRestrictions = new String[1]; END 
  }
","  public VfsFileChooserHelper( Shell shell, VfsFileChooserDialog fileChooserDialog, VariableSpace variableSpace,
      FileSystemOptions fileSystemOptions ) {
    this.fileChooserDialog = fileChooserDialog;
    this.shell = shell;
    this.variableSpace = variableSpace;
    this.fileSystemOptions = fileSystemOptions;
    this.schemeRestrictions = new String[0];
  }
"
163,Default access (no modifier) suffices.,"        public static int getCurrentCounterValue() {
            return COUNTER.intValue();
        }
","        public static int getCurrentCounterValue() {
            return COUNTER.intValue();
START         } END 
","        static int getCurrentCounterValue() {
            return COUNTER.intValue();
        }
"
164,Should eliminate the extraneous use of `this.` throughout.,"    private void setCharset(String charsetName) {
        try {
            if (charsetName == null) {
                this.charset = Charset.defaultCharset();
            } else {
                this.charset = Charset.forName(charsetName);
            }

            logger.debug(""Serial port '{}' charset '{}' set."", this.port, charsetName);
        } catch (IllegalCharsetNameException e) {
            logger.error(""Serial port '{}' charset '{}' not found."", this.port, charsetName);
        }
    }
","    private void setCharset(String charsetName) {
        try {
            if (charsetName == null) {
START                 this.charset = Charset.defaultCharset(); END 
            } else {
                this.charset = Charset.forName(charsetName);
            }

            logger.debug(""Serial port '{}' charset '{}' set."", this.port, charsetName);
        } catch (IllegalCharsetNameException e) {
            logger.error(""Serial port '{}' charset '{}' not found."", this.port, charsetName);
        }
    }
","    private void setCharset(String charsetName) {
        try {
            if (charsetName == null) {
                charset = Charset.defaultCharset();
            } else {
                charset = Charset.forName(charsetName);
            }

            logger.debug(""Serial port '{}' charset '{}' set."", port, charsetName);
        } catch (IllegalCharsetNameException e) {
            logger.warn(""Serial port '{}' charset '{}' not found."", port, charsetName);
            charset = Charset.defaultCharset();
        }
    }
"
165,"Now that we have the `constraintType `, we need change this to something like this:
```suggestion
         if (!isEmpty(constraintValue) || constraintType != null) {
```
Otherwise, when the user selects the ""Expression"" type and leaves the expression blank, the _Expression component_ wont be loaded.","    void prepareView(final String type,
                     final String constraintValue,
                     final ConstraintType constraintType) {

        getView().setType(type);

        if (!isEmpty(constraintValue)) {
            getView().loadComponent(constraintType);
        } else {
            getView().setupEmptyContainer();
        }
    }
","    void prepareView(final String type,
                     final String constraintValue,
                     final ConstraintType constraintType) {

        getView().setType(type);

START         if (!isEmpty(constraintValue)) { END 
            getView().loadComponent(constraintType);
        } else {
            getView().setupEmptyContainer();
        }
    }
","    void prepareView(final String type,
                     final String constraintValue,
                     final ConstraintType constraintType) {

        getView().setType(type);

        if (!isEmpty(constraintValue) || constraintType != null) {
            getView().loadComponent(constraintType);
        } else {
            getView().setupEmptyContainer();
        }
    }
"
166,"I do not know much about databases but whether this method is properly constructed? 
My Eclipse returns ""This method must return a result of type boolean"" and I can add return for firstRun of false.","	public boolean shutdown() {
	}
","START 	public boolean shutdown() { END 
	}
","	public boolean shutdown() {
		
		return true;
	}
"
167,"Why not just return ""emrapi.title""?","	public String getTitle() {
		return Context.getMessageSourceService().getMessage(""emrapi.title"");
	}
","	public String getTitle() {
START 		return Context.getMessageSourceService().getMessage(""emrapi.title""); END 
	}
","	public String getTitle() {
		return ""emrapi.title"";
	}
"
168,Unnecessary null check for path; trivial; ignoring.,"    public static String resolveName(Object context, String path) {
        Preconditions.checkNotNull(path, ""path must not be null"");
        if (path==null || path.startsWith(""/"") || Urls.isUrlWithProtocol(path)) return path;
        Preconditions.checkNotNull(context, ""context must not be null when path is relative"");
        return packagePath(context)+path;
    }
","    public static String resolveName(Object context, String path) {
        Preconditions.checkNotNull(path, ""path must not be null"");
START         if (path==null || path.startsWith(""/"") || Urls.isUrlWithProtocol(path)) return path; END 
        Preconditions.checkNotNull(context, ""context must not be null when path is relative"");
        return packagePath(context)+path;
    }
","    public static String resolveName(Object context, String path) {
        Preconditions.checkNotNull(path, ""path must not be null"");
        if (path.startsWith(""/"") || Urls.isUrlWithProtocol(path)) return path;
        Preconditions.checkNotNull(context, ""context must not be null when path is relative"");
        return packagePath(context)+path;
    }
"
169,can be removed.,"   private void sendCancelCommand(IntSet cancelledSegments) {
      Address origin = rpcManager.getAddress();
      CacheRpcCommand cmd = commandsFactory.buildStateTransferCancelCommand(topologyId, cancelledSegments);
      try {
         rpcManager.sendTo(source, cmd, DeliverOrder.NONE);
      } catch (Exception e) {
         // Ignore exceptions here, the worst that can happen is that the provider will send some extra state
         log.debugf(""Caught an exception while cancelling state transfer from node %s for segments %s"",
                    source, cancelledSegments);
      }
   }
","   private void sendCancelCommand(IntSet cancelledSegments) {
START       Address origin = rpcManager.getAddress(); END 
      CacheRpcCommand cmd = commandsFactory.buildStateTransferCancelCommand(topologyId, cancelledSegments);
      try {
         rpcManager.sendTo(source, cmd, DeliverOrder.NONE);
      } catch (Exception e) {
         // Ignore exceptions here, the worst that can happen is that the provider will send some extra state
         log.debugf(""Caught an exception while cancelling state transfer from node %s for segments %s"",
                    source, cancelledSegments);
      }
   }
","   private void sendCancelCommand(IntSet cancelledSegments) {
      CacheRpcCommand cmd = commandsFactory.buildStateTransferCancelCommand(topologyId, cancelledSegments);
      try {
         rpcManager.sendTo(source, cmd, DeliverOrder.NONE);
      } catch (Exception e) {
         // Ignore exceptions here, the worst that can happen is that the provider will send some extra state
         log.debugf(""Caught an exception while cancelling state transfer from node %s for segments %s"",
                    source, cancelledSegments);
      }
   }
"
170,This might be too expensive to call on every eviction attempt. We want to keep the eviction loop fast and without dependencies on external services.,"  public void heartbeat() {
    // Sync the pin list before attempting to reserve space
    mBlockWorker.syncPinList();
    reserveSpace();
  }
","  public void heartbeat() {
    // Sync the pin list before attempting to reserve space
START     mBlockWorker.syncPinList(); END 
    reserveSpace();
  }
","  public void heartbeat() {
    reserveSpace();
  }
"
171,Is this intentionally a bitwise AND?,"    private final void decrementResponseOrExpired()
    {
        int decrementedValue = responsesAndExpirations.decrementAndGet();
        if (decrementedValue == 0)
        {
            // The condition being signaled is a valid proxy for the CL being achieved
            // Only mark it as failed if the requested CL was achieved.
            if (!condition.isSignaled() & requestedCLAchieved)
            {
                replicaPlan.keyspace().metric.writeFailedIdealCL.inc();
            }
            else
            {
                replicaPlan.keyspace().metric.idealCLWriteLatency.addNano(System.nanoTime() - queryStartNanoTime);
            }
        }
    }
","    private final void decrementResponseOrExpired()
    {
        int decrementedValue = responsesAndExpirations.decrementAndGet();
        if (decrementedValue == 0)
        {
            // The condition being signaled is a valid proxy for the CL being achieved
            // Only mark it as failed if the requested CL was achieved.
START             if (!condition.isSignaled() & requestedCLAchieved) END 
            {
                replicaPlan.keyspace().metric.writeFailedIdealCL.inc();
            }
            else
            {
                replicaPlan.keyspace().metric.idealCLWriteLatency.addNano(System.nanoTime() - queryStartNanoTime);
            }
        }
    }
","    private final void decrementResponseOrExpired()
    {
        int decrementedValue = responsesAndExpirations.decrementAndGet();
        if (decrementedValue == 0)
        {
            // The condition being signaled is a valid proxy for the CL being achieved
            // Only mark it as failed if the requested CL was achieved.
            if (!condition.isSignaled() && requestedCLAchieved)
            {
                replicaPlan.keyspace().metric.writeFailedIdealCL.inc();
            }
            else
            {
                replicaPlan.keyspace().metric.idealCLWriteLatency.addNano(System.nanoTime() - queryStartNanoTime);
            }
        }
    }
"
172,You can use parameterized constructor call instead of addAll(),"	public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Resource resource, Group group, boolean withGroupAttributes) throws GroupResourceMismatchException {
		this.checkGroupIsFromTheSameVoLikeResource(sess, group, resource);

		List<Attribute> attributes = new ArrayList<>();
		attributes.addAll(getAttributesManagerImpl().getRequiredAttributes(sess, services, resource, group));
		if (withGroupAttributes) {
			attributes.addAll(getAttributesManagerImpl().getRequiredAttributes(sess, services, group));
		}
		return attributes;
	}
","	public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Resource resource, Group group, boolean withGroupAttributes) throws GroupResourceMismatchException {
		this.checkGroupIsFromTheSameVoLikeResource(sess, group, resource);

		List<Attribute> attributes = new ArrayList<>();
START 		attributes.addAll(getAttributesManagerImpl().getRequiredAttributes(sess, services, resource, group)); END 
		if (withGroupAttributes) {
			attributes.addAll(getAttributesManagerImpl().getRequiredAttributes(sess, services, group));
		}
		return attributes;
	}
","	public List<Attribute> getRequiredAttributes(PerunSession sess, List<Service> services, Resource resource, Group group, boolean withGroupAttributes) throws GroupResourceMismatchException {
		this.checkGroupIsFromTheSameVoLikeResource(sess, group, resource);

		List<Attribute> attributes = getAttributesManagerImpl().getRequiredAttributes(sess, services, resource, group);
		if (withGroupAttributes) {
			attributes.addAll(getAttributesManagerImpl().getRequiredAttributes(sess, services, group));
		}
		return attributes;
	}
"
173,"If we open up the expression for user specification, this if test would have to go inside the default `FunctionExpression`.","	private boolean extractZsetIncrementHeader(Message<?> message) {
		if (message.getHeaders().containsKey(RedisHeaders.ZSET_INCREMENT_SCORE)) {
			return this.zsetIncrementScoreExpression.getValue(this.evaluationContext, message, Boolean.class);
		}
		return false;
	}
","	private boolean extractZsetIncrementHeader(Message<?> message) {
START 		if (message.getHeaders().containsKey(RedisHeaders.ZSET_INCREMENT_SCORE)) { END 
			return this.zsetIncrementScoreExpression.getValue(this.evaluationContext, message, Boolean.class);
		}
		return false;
	}
","	private boolean extractZsetIncrementHeader(Message<?> message) {
		Boolean value = this.zsetIncrementScoreExpression.getValue(this.evaluationContext, message, Boolean.class);
		return value != null ? value : false;
	}
"
174,We can get rid of the above variable,"	public void shouldGetDiagnosisById() {
		int diagnosisId = 1;
		Diagnosis diagnosis = diagnosisDAO.getDiagnosisById(diagnosisId);
		assertEquals(""4e663d66-6b78-11e0-93c3-18a905e044dc"", diagnosis.getUuid());
	}
","	public void shouldGetDiagnosisById() {
START 		int diagnosisId = 1; END 
		Diagnosis diagnosis = diagnosisDAO.getDiagnosisById(diagnosisId);
		assertEquals(""4e663d66-6b78-11e0-93c3-18a905e044dc"", diagnosis.getUuid());
	}
","	public void shouldGetDiagnosisById() {
		Diagnosis diagnosis = diagnosisDAO.getDiagnosisById(1);
		assertEquals(""4e663d66-6b78-11e0-93c3-18a905e044dc"", diagnosis.getUuid());
	}
"
175,split lines,"        public Operator createOperator(DriverContext driverContext)
        {
            checkState(!closed, ""Factory is already closed"");
            OperatorContext operatorContext = driverContext.addOperatorContext(operatorId, planNodeId, HashBuilderOperator.class.getSimpleName());
            return new SpatialJoinOperator(operatorContext, getTypes(), probeTypes, probeOutputChannels, probeGeometryChannel, pagesSpatialIndexFactory.createPagesSpatialIndex(), spatialRelationshipTest);
        }
","        public Operator createOperator(DriverContext driverContext)
        {
            checkState(!closed, ""Factory is already closed"");
            OperatorContext operatorContext = driverContext.addOperatorContext(operatorId, planNodeId, HashBuilderOperator.class.getSimpleName());
START             return new SpatialJoinOperator(operatorContext, getTypes(), probeTypes, probeOutputChannels, probeGeometryChannel, pagesSpatialIndexFactory.createPagesSpatialIndex(), spatialRelationshipTest); END 
        }
","        public Operator createOperator(DriverContext driverContext)
        {
            checkState(!closed, ""Factory is already closed"");
            OperatorContext operatorContext = driverContext.addOperatorContext(
                    operatorId,
                    planNodeId,
                    SpatialJoinOperator.class.getSimpleName());
            return new SpatialJoinOperator(
                    operatorContext,
                    getTypes(),
                    probeTypes,
                    probeOutputChannels,
                    probeGeometryChannel,
                    pagesSpatialIndexFactory);
        }
"
176,Evtl. geht auch `clear()` dann braucht man gar keinen Parameter...,"    private IssuesRecorder enableWarningsForNewFixedOutstandingTest(final FreeStyleProject job, IssuesRecorder oldPublisher, String pattern) {
        if(oldPublisher != null) {
            job.getPublishersList().remove(oldPublisher);
        }
        IssuesRecorder publisher = new IssuesRecorder();
        publisher.setTools(Collections.singletonList(new ToolConfiguration(pattern, new Eclipse())));
        job.getPublishersList().add(publisher);
        return publisher;
    }
","    private IssuesRecorder enableWarningsForNewFixedOutstandingTest(final FreeStyleProject job, IssuesRecorder oldPublisher, String pattern) {
START         if(oldPublisher != null) { END 
            job.getPublishersList().remove(oldPublisher);
        }
        IssuesRecorder publisher = new IssuesRecorder();
        publisher.setTools(Collections.singletonList(new ToolConfiguration(pattern, new Eclipse())));
        job.getPublishersList().add(publisher);
        return publisher;
    }
","    private IssuesRecorder enableWarningsForNewFixedOutstandingTest(final FreeStyleProject job, IssuesRecorder oldPublisher, String pattern) {
        if(oldPublisher != null) {
            job.getPublishersList().remove(oldPublisher);
        }
        return enableWarningsForNewFixedOutstandingTest(job, pattern);
    }
"
177,"There are more non PHD students than there are PHD students, thus switching the order of the || will probably improve performance.","    public boolean isMember(User user) {
        if (user == null || user.getPerson() == null) {
            return false;
        }
        return new ActivePhdProcessesGroup().isMember(user) || (user.getPerson().getStudent() != null && user.getPerson()
                .getStudent().hasActiveRegistrations());
    }
","    public boolean isMember(User user) {
        if (user == null || user.getPerson() == null) {
            return false;
        }
START         return new ActivePhdProcessesGroup().isMember(user) || (user.getPerson().getStudent() != null && user.getPerson() END 
                .getStudent().hasActiveRegistrations());
    }
","    public boolean isMember(User user) {
        if (user == null || user.getPerson() == null) {
            return false;
        }
        return (user.getPerson().getStudent() != null && user.getPerson().getStudent().hasActiveRegistrations())
                || new ActivePhdProcessesGroup().isMember(user);
    }
"
178,maybe you could rename this `getNotFullFuture` to `waitForWriting`?,"    public ListenableFuture<?> waitForWriting()
    {
        if (isFinished()) {
            return NOT_BLOCKED;
        }
        return exchanger.getNotFullFuture();
    }
","    public ListenableFuture<?> waitForWriting()
    {
        if (isFinished()) {
            return NOT_BLOCKED;
        }
START         return exchanger.getNotFullFuture(); END 
    }
","    public ListenableFuture<?> waitForWriting()
    {
        if (isFinished()) {
            return NOT_BLOCKED;
        }
        return exchanger.waitForWriting();
    }
"
179,What's the relation between this change and WFLY-19339?,"    public Map<String, TransportConfiguration> getConnectors() {
        return Collections.unmodifiableMap(connectors);
    }
","    public Map<String, TransportConfiguration> getConnectors() {
START         return Collections.unmodifiableMap(connectors); END 
    }
","    public Map<String, TransportConfiguration> getConnectors() {
        return connectors;
    }
"
180,rename to entry,"	public void setEntries(IRuntimeClasspathEntry[] entries) {
		model.removeAll();
		IRuntimeClasspathEntry entry;
		for (IRuntimeClasspathEntry entrie : entries) {
			entry = entrie;
			switch (entry.getClasspathProperty()) {
			case IRuntimeClasspathEntry.USER_CLASSES:
				model.addEntry(ClasspathModel.USER, entry);
				break;
			default:
				model.addEntry(ClasspathModel.BOOTSTRAP, entry);
				break;
			}
		}
		refresh();
	}
","	public void setEntries(IRuntimeClasspathEntry[] entries) {
		model.removeAll();
		IRuntimeClasspathEntry entry;
		for (IRuntimeClasspathEntry START  entrie : END  entries) {
			entry = entrie;
			switch (entry.getClasspathProperty()) {
			case IRuntimeClasspathEntry.USER_CLASSES:
				model.addEntry(ClasspathModel.USER, entry);
				break;
			default:
				model.addEntry(ClasspathModel.BOOTSTRAP, entry);
				break;
			}
		}
		refresh();
	}
","	public void setEntries(IRuntimeClasspathEntry[] entries) {
		model.removeAll();
		for (IRuntimeClasspathEntry entry : entries) {
			switch (entry.getClasspathProperty()) {
			case IRuntimeClasspathEntry.USER_CLASSES:
				model.addEntry(ClasspathModel.USER, entry);
				break;
			default:
				model.addEntry(ClasspathModel.BOOTSTRAP, entry);
				break;
			}
		}
		refresh();
	}
"
181,"This is not a new code, you just mved it, but consider to use Java7 try-with-resources statement:

  try (JarFile jarFile = new JarFile(srcFile)) {
    return jarFile.getManifest().getMainAttributes()
        .getValue(""Gerrit-PluginName"");
  }","  public static String getGerritJarPluginName(File srcFile) throws IOException {
    JarFile jarFile = new JarFile(srcFile);
    try {
      return jarFile.getManifest().getMainAttributes()
          .getValue(""Gerrit-PluginName"");
    } finally {
      jarFile.close();
    }
  }
","  public static String getGerritJarPluginName(File srcFile) throws IOException {
    START  JarFile jarFile = new JarFile(srcFile);
    try {
      return jarFile.getManifest().getMainAttributes()
          .getValue(""Gerrit-PluginName"");
    } finally {
      jarFile.close();
    } END 
  }
","  public static String getGerritJarPluginName(File srcFile) throws IOException {
    try (JarFile jarFile = new JarFile(srcFile)) {
      return jarFile.getManifest().getMainAttributes()
          .getValue(""Gerrit-PluginName"");
    }
  }
"
182,primitive boolean cannot be compared with null.,"    protected String getContextId(String name) {
        boolean includeHostName = camelContext != null && camelContext.getManagementStrategy().getManagementAgent().getIncludeHostName();
        if (includeHostName != null && includeHostName) {
            return hostName + ""/"" + (name != null ? name : VALUE_UNKNOWN);
        } else {
            return name != null ? name : VALUE_UNKNOWN;
        }
    }
","    protected String getContextId(String name) {
        boolean includeHostName = camelContext != null && camelContext.getManagementStrategy().getManagementAgent().getIncludeHostName();
START         if (includeHostName != null && includeHostName) { END 
            return hostName + ""/"" + (name != null ? name : VALUE_UNKNOWN);
        } else {
            return name != null ? name : VALUE_UNKNOWN;
        }
    }
","    protected String getContextId(String name) {
        boolean includeHostName = camelContext != null && camelContext.getManagementStrategy().getManagementAgent().getIncludeHostName();
        if (includeHostName) {
            return hostName + ""/"" + (name != null ? name : VALUE_UNKNOWN);
        } else {
            return name != null ? name : VALUE_UNKNOWN;
        }
    }
"
183,"If it's possible for an element to be checked in the viewer but not in the map, then other code is wrong, e.g. getCheckedElements(). If it's not possible, then you can just return false here.","    public boolean getChecked(Object element) {
        if (fObjects.containsKey(element)) {
            return fObjects.get(element);
        }
        return fCheckboxTreeViewer.getChecked(element);
    }
","    public boolean getChecked(Object element) {
        if (fObjects.containsKey(element)) {
            return fObjects.get(element);
        }
START         return fCheckboxTreeViewer.getChecked(element); END 
    }
","    public boolean getChecked(Object element) {
        return fObjects.contains(element);
    }
"
184,"Should we swallow typo-case without even issue a warning? Delete email method above doesn't really matter, because if a mail doesn't exist, all is fine. Here someone rellies on this command to change something, yet when she spelled email wrong, it should fail, i think.","  private void putPreferred(String email) throws RestApiException,
      OrmException {
    List<EmailInfo> emails = getEmails.apply(rsrc);
    for (EmailInfo e : emails) {
      if (e.email.equals(email)) {
        putPreferred.apply(new AccountResource.Email(user, email), null);
      }
    }
  }
","  START  private void putPreferred(String email) throws RestApiException,
      OrmException {
    List<EmailInfo> emails = getEmails.apply(rsrc);
    for (EmailInfo e : emails) {
      if (e.email.equals(email)) {
        putPreferred.apply(new AccountResource.Email(user, email), null);
      }
    }
  } END 
","  private void putPreferred(String email) throws RestApiException,
      OrmException {
    putPreferred.apply(new AccountResource.Email(user, email), null);
  }
"
185,"The ""brackets for single statements"" cleanup in this file should be done in a separate commit, as we should not mix unrelated changes.","	private void cancel(Job[] jobs) {
		for (Job job : jobs) {
			job.cancel();
		}
	}
","	private void cancel(Job[] jobs) {
START 		for (Job job : jobs) { END 
			job.cancel();
		}
	}
","	private void cancel(Job[] jobs) {
		for (Job job : jobs)
			job.cancel();
	}
"
186,Please swap the order to `private static` like in the [google code style guide](https://google.github.io/styleguide/javaguide.html#s4.8.7-modifiers),"    static private long toMillis(String seconds) {
        if (seconds.contains(""."")) {
            float value = Float.parseFloat(seconds);
            float millis = value % 1;
            return SECONDS.toMillis((long) value) + (long) (millis * 1000);
        } else {
            return SECONDS.toMillis(Long.parseLong(seconds));
        }
    }
","START     static private long toMillis(String seconds) { END 
        if (seconds.contains(""."")) {
            float value = Float.parseFloat(seconds);
            float millis = value % 1;
            return SECONDS.toMillis((long) value) + (long) (millis * 1000);
        } else {
            return SECONDS.toMillis(Long.parseLong(seconds));
        }
    }
","    private static long toMillis(String seconds) {
        if (seconds.contains(""."")) {
            float value = Float.parseFloat(seconds);
            float millis = value % 1;
            return SECONDS.toMillis((long) value) + (long) (millis * 1000);
        } else {
            return SECONDS.toMillis(Long.parseLong(seconds));
        }
    }
"
187,"This might be pre-mature optimization, but I worry about how this data structure is being used.  One option would be to view the list as a revolving buffer and essentially maintain an index of the oldest ""valid"" item.  You can replace and increment that on `add` and start your search from there wrapping back around.","  public synchronized void addSegmentChangeRequests(List<DataSegmentChangeRequest> requests)
  {
    for (DataSegmentChangeRequest request : requests) {
      if (changes.size() >= maxSize) {
        changes.remove(0);
      }
      changes.add(new Holder(request, getLastCounter().inc()));
    }

    singleThreadedExecutor.execute(resolveWaitingFuturesRunnable);
  }
","  public synchronized void addSegmentChangeRequests(List<DataSegmentChangeRequest> requests)
  {
    for (DataSegmentChangeRequest request : requests) {
      if (changes.size() >= maxSize) {
START         changes.remove(0); END 
      }
      changes.add(new Holder(request, getLastCounter().inc()));
    }

    singleThreadedExecutor.execute(resolveWaitingFuturesRunnable);
  }
","  public synchronized void addSegmentChangeRequests(List<DataSegmentChangeRequest> requests)
  {
    for (DataSegmentChangeRequest request : requests) {
      changes.add(new Holder(request, getLastCounter().inc()));
    }

    singleThreadedExecutor.execute(resolveWaitingFuturesRunnable);
  }
"
188,"catch `Throwable`? When methods shouldn't throw, like where `shouldThrow` is `false` here, it's easy to end up with a hang because an exception type changed.","  static boolean checkStartObject(JsonParser parser, boolean shouldThrow) throws IOException {
    try {
      JsonToken currentToken = parser.currentToken();
      // The parser may not be at a token, yet. If that's the case advance.
      if (currentToken == null) currentToken = parser.nextToken();

      // If we are still not at the expected token, we could be an another or an empty body.
      if (currentToken == JsonToken.START_OBJECT) return true;
      if (shouldThrow) {
        throw new IllegalArgumentException(""Expected start object, was "" + currentToken);
      }
      return false;
    } catch (JsonParseException e) { // likely not json
      if (shouldThrow) throw e;
      return false;
    }
  }
","  static boolean checkStartObject(JsonParser parser, boolean shouldThrow) throws IOException {
    try {
      JsonToken currentToken = parser.currentToken();
      // The parser may not be at a token, yet. If that's the case advance.
      if (currentToken == null) currentToken = parser.nextToken();

      // If we are still not at the expected token, we could be an another or an empty body.
      if (currentToken == JsonToken.START_OBJECT) return true;
      if (shouldThrow) {
        throw new IllegalArgumentException(""Expected start object, was "" + currentToken);
      }
      return false;
START     } catch (JsonParseException e) { // likely not json END 
      if (shouldThrow) throw e;
      return false;
    }
  }
","  static boolean checkStartObject(JsonParser parser, boolean shouldThrow) throws IOException {
    try {
      JsonToken currentToken = parser.currentToken();
      // The parser may not be at a token, yet. If that's the case advance.
      if (currentToken == null) currentToken = parser.nextToken();

      // If we are still not at the expected token, we could be an another or an empty body.
      if (currentToken == JsonToken.START_OBJECT) return true;
      if (shouldThrow) {
        throw new IllegalArgumentException(""Expected start object, was "" + currentToken);
      }
      return false;
    } catch (Throwable e) { // likely not json
      if (shouldThrow) throw e;
      return false;
    }
  }
"
189,"It seems that we can get rid from this injection by moving the initialization of the _vdsManager from the c'tor to the executeVDSCommand() method.

we actually can just keep the newHost as a member and use it from the executeVDSCommand() by referring to the already initialized ResourceManager to obtain the vdsManager associated with the host.","    public VdsIdVDSCommandBase(P parameters, boolean newHost) {
        super(parameters);
        if (!newHost) {
            _vdsManager = Injector.get(ResourceManager.class).getVdsManager(parameters.getVdsId());
        }
    }
","    public VdsIdVDSCommandBase(P parameters, boolean newHost) {
        super(parameters);
        if (!newHost) {
START             _vdsManager = Injector.get(ResourceManager.class).getVdsManager(parameters.getVdsId()); END 
        }
    }
","    public VdsIdVDSCommandBase(P parameters, boolean newHost) {
        super(parameters);
        this.newHost = newHost;
    }
"
190,This seems not needed.,"    public DRCatalogDiffEngine(Catalog localCatalog, Catalog remoteCatalog) {
        super(localCatalog, remoteCatalog);
        localCatalog.getClusters().get(""cluster"").getDrclusterid();
    }
","    public DRCatalogDiffEngine(Catalog localCatalog, Catalog remoteCatalog) {
        super(localCatalog, remoteCatalog);
START         localCatalog.getClusters().get(""cluster"").getDrclusterid(); END 
    }
","    public DRCatalogDiffEngine(Catalog localCatalog, Catalog remoteCatalog) {
        super(localCatalog, remoteCatalog);
    }
"
191,If you annotate the interface methods you don't need to repeat them here (we have to setting to inherit annotations).,"    public List<@NonNull Integer> getSubAttributes(int quark, boolean recursive)
            throws AttributeNotFoundException {
        return getAttributeTree().getSubAttributes(quark, recursive);
    }
","START     public List<@NonNull Integer> getSubAttributes(int quark, boolean recursive) END 
            throws AttributeNotFoundException {
        return getAttributeTree().getSubAttributes(quark, recursive);
    }
","    public List<Integer> getSubAttributes(int quark, boolean recursive)
            throws AttributeNotFoundException {
        return getAttributeTree().getSubAttributes(quark, recursive);
    }
"
192,this.lsRegisterOutput,"	private String getLsRegisterOutput() throws Exception {
		if (lsRegisterOutput != null) {
			return lsRegisterOutput;
		}
		long beforeCallLsRegister = System.currentTimeMillis();
		lsRegisterOutput = processExecutor.execute(LSREGISTER, DUMP);
		long afterCallLsRegister = System.currentTimeMillis();
		System.out.println(""Call to lsregister took :"" + (afterCallLsRegister - beforeCallLsRegister)); //$NON-NLS-1$
		return lsRegisterOutput;
	}
","	private String getLsRegisterOutput() throws Exception {
		if START (lsRegisterOutput != END  null) {
			return lsRegisterOutput;
		}
		long beforeCallLsRegister = System.currentTimeMillis();
		lsRegisterOutput = processExecutor.execute(LSREGISTER, DUMP);
		long afterCallLsRegister = System.currentTimeMillis();
		System.out.println(""Call to lsregister took :"" + (afterCallLsRegister - beforeCallLsRegister)); //$NON-NLS-1$
		return lsRegisterOutput;
	}
","	private String getLsRegisterOutput() throws Exception {
		if (this.lsRegisterOutput != null) {
			return this.lsRegisterOutput;
		}
		this.lsRegisterOutput = processExecutor.execute(LSREGISTER, DUMP);
		return this.lsRegisterOutput;
	}
"
193,Again lets remove the try/catch/log/rethrow,"    public static String masterInbox(Map conf) throws IOException {
        String ret = masterLocalDir(conf) + FILE_SEPARATOR + ""inbox"";
        try {
            FileUtils.forceMkdir(new File(ret));
        } catch (IOException e) {
            LOG.error(""Failed to create dir "" + ret, e);
            throw e;
        }
        return ret;
    }
","    public static String masterInbox(Map conf) throws IOException {
        String ret = masterLocalDir(conf) + FILE_SEPARATOR + ""inbox"";
        try {
            FileUtils.forceMkdir(new File(ret));
        } catch (IOException e) {
            LOG.error(""Failed to create dir "" + ret, e);
START             throw e; END 
        }
        return ret;
    }
","    public static String masterInbox(Map conf) throws IOException {
        String ret = masterLocalDir(conf) + FILE_SEPARATOR + ""inbox"";
        FileUtils.forceMkdir(new File(ret));
        return ret;
    }
"
194,not public,"    public MockReplicaId(String storeId, long capacity, String filePath) {
      this.storeId = storeId;
      this.capacity = capacity;
      this.filePath = filePath;
      partitionId = mock(PartitionId.class);
      when(partitionId.toString()).thenReturn(storeId);
    }
","START     public MockReplicaId(String storeId, long capacity, String filePath) { END 
      this.storeId = storeId;
      this.capacity = capacity;
      this.filePath = filePath;
      partitionId = mock(PartitionId.class);
      when(partitionId.toString()).thenReturn(storeId);
    }
","    MockReplicaId(String storeId, long capacity, String filePath) {
      this.storeId = storeId;
      this.capacity = capacity;
      this.filePath = filePath;
      partitionId = mock(PartitionId.class);
      when(partitionId.toString()).thenReturn(storeId);
    }
"
195,"Log this at error level? I don't think we should put the stack trace, but the end result is crashing the system which seems to be more of an issue than warn.","  public static void main(String[] args) {
    LOG.info(""Validating configuration."");
    try {
      Configuration.validate();
      LOG.info(""Configuration is valid."");
    } catch (IllegalStateException e) {
      LOG.warn(""Configuration is invalid: {}"", e.getMessage());
      System.exit(-1);
    }
    System.exit(0);
  }
","  public static void main(String[] args) {
    LOG.info(""Validating configuration."");
    try {
      Configuration.validate();
      LOG.info(""Configuration is valid."");
    } catch (IllegalStateException e) {
START       LOG.warn(""Configuration is invalid: {}"", e.getMessage()); END 
      System.exit(-1);
    }
    System.exit(0);
  }
","  public static void main(String[] args) {
    LOG.info(""Validating configuration."");
    try {
      Configuration.validate();
      LOG.info(""Configuration is valid."");
    } catch (IllegalStateException e) {
      LOG.error(""Configuration is invalid: {}"", e.getMessage());
      System.exit(-1);
    }
    System.exit(0);
  }
"
196,static,"    private boolean isConstantFilterFunction(FilterFunction filter, Block[] constantBlocks)
    {
        return Arrays.stream(filter.getInputChannels()).allMatch(channel -> constantBlocks[channel] != null);
    }
","START     private boolean isConstantFilterFunction(FilterFunction filter, Block[] constantBlocks) END 
    {
        return Arrays.stream(filter.getInputChannels()).allMatch(channel -> constantBlocks[channel] != null);
    }
","    private static boolean isConstantFilterFunction(FilterFunction filter, Block[] constantBlocks)
    {
        return Arrays.stream(filter.getInputChannels()).allMatch(channel -> constantBlocks[channel] != null);
    }
"
197,Nit: static import `recordDefaults`,"    public void testDefaults()
    {
        assertRecordedDefaults(ConfigAssertions.recordDefaults(FileSessionPropertyManagerConfig.class)
                .setConfigFile(null));
    }
","    public void testDefaults()
    {
START         assertRecordedDefaults(ConfigAssertions.recordDefaults(FileSessionPropertyManagerConfig.class) END 
                .setConfigFile(null));
    }
","    public void testDefaults()
    {
        assertRecordedDefaults(recordDefaults(FileSessionPropertyManagerConfig.class)
                .setConfigFile(null));
    }
"
198,Let's break up this line please,"    public int hashCode() {
        return Objects.hash(storageDomainId, imageGroupId, baseImageId, topImageId, baseImageGeneration, baseImage, topImage);
    }
","    public int hashCode() {
        START  return Objects.hash(storageDomainId, imageGroupId, baseImageId, topImageId, baseImageGeneration, baseImage, topImage); END 
    }
","    public int hashCode() {
        return Objects.hash(storageDomainId,
                imageGroupId,
                baseImageGeneration,
                baseImage,
                topImage);
    }
"
199,`return itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class)`.,"    public boolean isApplicable(Class<? extends Item> itemClass) {
        if (itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class)) {
            return true;
        } else {
            return false;
        }
    }
","    public boolean isApplicable(Class<? extends Item> itemClass) {
START         if (itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class)) { END 
            return true;
        } else {
            return false;
        }
    }
","    public boolean isApplicable(Class<? extends Item> itemClass) {
        return itemClass.isAssignableFrom(MavenModule.class) || itemClass.isAssignableFrom(MavenModuleSet.class);
    }
"
200,Use fluent interface in here,"	public void TestWikiaLogoInGlobalNav_001_centralWikiExists(String wikiName, String expectedCentralUrl) {
		HomePageObject homePage = new HomePageObject(driver);
		homePage.getUrl(urlBuilder.getUrlForWiki(wikiName));
		VenusGlobalNavPageObject globalNav = homePage.getVenusGlobalNav();
		globalNav.waitForCorrectUrl(config.getEnv());
		globalNav.clickWikiaLogo();

		Assertion.assertStringContains(urlBuilder.getUrlForWiki(expectedCentralUrl), driver.getCurrentUrl());
	}
","	public void TestWikiaLogoInGlobalNav_001_centralWikiExists(String wikiName, String expectedCentralUrl) {
		HomePageObject homePage = new HomePageObject(driver);
		homePage.getUrl(urlBuilder.getUrlForWiki(wikiName));
		VenusGlobalNavPageObject globalNav = homePage.getVenusGlobalNav();
		globalNav.waitForCorrectUrl(config.getEnv());
START 		globalNav.clickWikiaLogo(); END 

		Assertion.assertStringContains(urlBuilder.getUrlForWiki(expectedCentralUrl), driver.getCurrentUrl());
	}
","	public void TestWikiaLogoInGlobalNav_001_centralWikiExists(String wikiName, String expectedCentralUrl) {
		HomePageObject homePage = new HomePageObject(driver);
		homePage.getUrl(urlBuilder.getUrlForWiki(wikiName));
		homePage.getVenusGlobalNav()
			.clickWikiaLogo();

		Assertion.assertStringContains(urlBuilder.getUrlForWiki(expectedCentralUrl), driver.getCurrentUrl());
	}
"
201,"There's no issue with the argument (`workflowExecutor`), so an `IllegalStateException` makes more sense here","  public void execute(WorkflowExecutor workflowExecutor) throws IOException {
    if (!isComplete()) throw new IllegalArgumentException(""Workflow is not complete"");

    Pool pool = step1.getInput();
    pool.setConcentration((double) step0.getInput());

    workflowExecutor.save(pool);
  }
","  public void execute(WorkflowExecutor workflowExecutor) throws IOException {
START     if (!isComplete()) throw new IllegalArgumentException(""Workflow is not complete""); END 

    Pool pool = step1.getInput();
    pool.setConcentration((double) step0.getInput());

    workflowExecutor.save(pool);
  }
","  public void execute(WorkflowExecutor workflowExecutor) throws IOException {
    if (!isComplete()) throw new IllegalStateException(""Workflow is not complete"");

    Pool pool = step1.getInput();
    pool.setConcentration((double) step0.getInput());

    workflowExecutor.save(pool);
  }
"
202,Please remove this `System.out.println`,"  public void should_return_null_when_encountering_parsing_issue() {
    logTester.setLevel(LoggerLevel.DEBUG);
    assertThat(XmlParser.parseXML(new File(""src/test/files/xml/parsing-issue.xml""))).isNull();
    assertThat(logTester.logs(LoggerLevel.ERROR)).contains(""Unable to parse xml file: src/test/files/xml/parsing-issue.xml"");
    System.out.println(logTester.logs(LoggerLevel.DEBUG));
    assertThat(logTester.logs(LoggerLevel.DEBUG)).hasSize(1).allSatisfy(s -> s.startsWith(""XML file parsing failed because of : org.xml.sax.SAXParseException; systemId: file: ""));
  }
","  public void should_return_null_when_encountering_parsing_issue() {
    logTester.setLevel(LoggerLevel.DEBUG);
    assertThat(XmlParser.parseXML(new File(""src/test/files/xml/parsing-issue.xml""))).isNull();
    assertThat(logTester.logs(LoggerLevel.ERROR)).contains(""Unable to parse xml file: src/test/files/xml/parsing-issue.xml"");
START     System.out.println(logTester.logs(LoggerLevel.DEBUG)); END 
    assertThat(logTester.logs(LoggerLevel.DEBUG)).hasSize(1).allSatisfy(s -> s.startsWith(""XML file parsing failed because of : org.xml.sax.SAXParseException; systemId: file: ""));
  }
","  public void should_return_null_when_encountering_parsing_issue() {
    logTester.setLevel(LoggerLevel.DEBUG);
    assertThat(XmlParser.parseXML(new File(""src/test/files/xml/parsing-issue.xml""))).isNull();
    assertThat(logTester.logs(LoggerLevel.ERROR)).contains(""Unable to parse xml file: src/test/files/xml/parsing-issue.xml"");
    assertThat(logTester.logs(LoggerLevel.DEBUG)).hasSize(1).allSatisfy(s -> s.startsWith(""XML file parsing failed because of : org.xml.sax.SAXParseException; systemId: file: ""));
  }
"
203,Remove log.warn since we already cover in log.trace,"	boolean getHl7PrefixProperty() {
		try {
			return PropertyAccessor.getInstance().getPropertyBoolean(NhincConstants.GATEWAY_PROPERTY_FILE,
					NhincConstants.HL7_PREFIX_FOR_ATTR_PROPERTY);
		} catch (final PropertyAccessException ex) {
			LOG.warn(ex.getLocalizedMessage());
			LOG.trace(""Get HL7 Prefix Property exception: {}"", ex.getLocalizedMessage(), ex);
		}
		return false;
	}
","	boolean getHl7PrefixProperty() {
		try {
			return PropertyAccessor.getInstance().getPropertyBoolean(NhincConstants.GATEWAY_PROPERTY_FILE,
					NhincConstants.HL7_PREFIX_FOR_ATTR_PROPERTY);
		} catch (final PropertyAccessException ex) {
START 			LOG.warn(ex.getLocalizedMessage()); END 
			LOG.trace(""Get HL7 Prefix Property exception: {}"", ex.getLocalizedMessage(), ex);
		}
		return false;
	}
","    boolean getHl7PrefixProperty() {
        try {
            return PropertyAccessor.getInstance().getPropertyBoolean(NhincConstants.GATEWAY_PROPERTY_FILE,
                NhincConstants.HL7_PREFIX_FOR_ATTR_PROPERTY);
        } catch (final PropertyAccessException ex) {
            LOG.trace(""Get HL7 Prefix Property exception: {}"", ex.getLocalizedMessage(), ex);
        }
        return false;
    }
"
204,"this shouldn't be here. Users automatically friend ""peergos"" during signup","    public void followPeergos() throws Exception {
        UserContext u1 = PeergosNetworkUtils.ensureSignedUp(""peergos"", ""testpassword"", network, crypto);
        UserContext u2 = PeergosNetworkUtils.ensureSignedUp(""w"", ""w"", network, crypto);

        u2.sendFollowRequest(u1.username, SymmetricKey.random()).get();

        List<FollowRequestWithCipherText> u1Requests = u1.processFollowRequests().get();
        assertTrue(""Receive a follow request"", u1Requests.size() > 0);
    }
","    public void followPeergos() throws Exception {
        UserContext u1 = PeergosNetworkUtils.ensureSignedUp(""peergos"", ""testpassword"", network, crypto);
        UserContext u2 = PeergosNetworkUtils.ensureSignedUp(""w"", ""w"", network, crypto);

START         u2.sendFollowRequest(u1.username, SymmetricKey.random()).get(); END 

        List<FollowRequestWithCipherText> u1Requests = u1.processFollowRequests().get();
        assertTrue(""Receive a follow request"", u1Requests.size() > 0);
    }
","    public void followPeergos() throws Exception {
        UserContext u1 = PeergosNetworkUtils.ensureSignedUp(""peergos"", ""testpassword"", network, crypto);
        UserContext u2 = PeergosNetworkUtils.ensureSignedUp(""w"", ""w"", network, crypto);

        List<FollowRequestWithCipherText> u1Requests = u1.processFollowRequests().get();
        assertTrue(""Receive a follow request"", u1Requests.size() > 0);
    }
"
205,"тут ты ловишь и то, что вылетит из `chain.doFilter()`. надо более узкий `try` - только на `getRequestHeadersMap()` и `getQueryParamsMap()`","  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    requireNonNull(contextThreadLocalSupplier, ""httpClientContextSupplier should not be null"");
    try {
      contextThreadLocalSupplier.addContext(getRequestHeadersMap(request), getQueryParamsMap(request));
      chain.doFilter(request, response);
    } catch (IllegalArgumentException e) {
      ((HttpServletResponse) response).sendError(HttpServletResponse.SC_BAD_REQUEST);
    } finally {
      contextThreadLocalSupplier.clear();
    }
  }
","  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    requireNonNull(contextThreadLocalSupplier, ""httpClientContextSupplier should not be null"");
    try {
      contextThreadLocalSupplier.addContext(getRequestHeadersMap(request), getQueryParamsMap(request));
      chain.doFilter(request, response);
START     } catch (IllegalArgumentException e) { END 
      ((HttpServletResponse) response).sendError(HttpServletResponse.SC_BAD_REQUEST);
    } finally {
      contextThreadLocalSupplier.clear();
    }
  }
","  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    requireNonNull(contextThreadLocalSupplier, ""httpClientContextSupplier should not be null"");
    try {
      try {
        contextThreadLocalSupplier.addContext(getRequestHeadersMap(request), getQueryParamsMap(request));
      } catch (IllegalArgumentException e) {
        ((HttpServletResponse) response).sendError(HttpServletResponse.SC_BAD_REQUEST);
        return;
      }
      chain.doFilter(request, response);
    } finally {
      contextThreadLocalSupplier.clear();
    }
  }
"
206,`throw new SpoonException(e);` ... the orgin exception should be used as cause of the SpoonException,"	public CtPath getPath() {
		try {
			return new CtElementPathBuilder().fromElement(this, getParent(CtModelImpl.CtRootPackage.class));
		} catch (CtPathException e) {
			throw new SpoonException();
		}
	}
","	public CtPath getPath() {
		try {
			return new CtElementPathBuilder().fromElement(this, getParent(CtModelImpl.CtRootPackage.class));
		} catch (CtPathException e) {
START 			throw new SpoonException(); END 
		}
	}
","	public CtPath getPath() {
		try {
			return new CtElementPathBuilder().fromElement(this, getParent(CtModelImpl.CtRootPackage.class));
		} catch (CtPathException e) {
			throw new SpoonException(e);
		}
	}
"
207,"I think we can delegate to the overloaded method here:

	public void instrument(final InputStream input, final OutputStream output,
			final String name) throws IOException {
		output.write(instrument(input, name));
	}","	public void instrument(final InputStream input, final OutputStream output,
			final String name) throws IOException {
		final byte[] bytes;
		try {
			bytes = Java9Support.readFully(input);
		} catch (final IOException e) {
			throw instrumentError(name, e);
		}
		output.write(instrument(bytes, name));
	}
","	public void instrument(final InputStream input, final OutputStream output,
			final String name) throws IOException {
START 		final byte[] bytes; END 
		try {
			bytes = Java9Support.readFully(input);
		} catch (final IOException e) {
			throw instrumentError(name, e);
		}
		output.write(instrument(bytes, name));
	}
","	public void instrument(final InputStream input, final OutputStream output,
			final String name) throws IOException {
		output.write(instrument(input, name));
	}
"
208,Drop the println.  :-),"  public WorkQueue.Executor getBatchQueue() {
    System.out.println(""Job scheduled in batch Queue"");
    return batchExecutor;
  }
","  public WorkQueue.Executor getBatchQueue() {
START     System.out.println(""Job scheduled in batch Queue""); END 
    return batchExecutor;
  }
","  public WorkQueue.Executor getBatchQueue() {
    return batchExecutor;
  }
"
209,"This will fail if the `testCreateRole` test fails. Better leave the assertions for the tests, not the tearDown methods.","   protected void tearDown() {
      boolean removed = api().deleteRole(roleName);
      assertTrue(removed);
   }
","   protected void tearDown() {
      boolean removed = api().deleteRole(roleName);
START       assertTrue(removed); END 
   }
","   protected void tearDown() {
      api().deleteRole(roleName);
   }
"
210,"No need for an empty message here
`assertNull(node.get(""properties"").get(""password""));`","    public void itDoesntWritePassword() throws Exception {
        // When I call JSON for user1
        JsonNode node = getResponseAsJson(RequestType.GET, ""/user/user1"");

        // Then it doesn't contain the password at all
        assertNull("""", node.get(""properties"").get(""password""));

    }
","    public void itDoesntWritePassword() throws Exception {
        // When I call JSON for user1
        JsonNode node = getResponseAsJson(RequestType.GET, ""/user/user1"");

        // Then it doesn't contain the password at all
START         assertNull("""", node.get(""properties"").get(""password"")); END 

    }
","    public void itDoesntWritePassword() throws Exception {
        // When I call JSON for user1
        JsonNode node = getResponseAsJson(RequestType.GET, ""/user/user1"");

        // Then it doesn't contain the password at all
        assertNull(node.get(""properties"").get(""password""));

    }
"
211,"why do you need to lock this code? ExecutorService.execute is thread safe, isn't it ?","	protected void demandUnload(SynchronizedResourceSet resourceSet, Resource resource,
			IProgressMonitor monitor) {
		lock.lock();
		try {
			unloadingPool.execute(new ResourceUnloader(resourceSet, resource, monitor));
		} finally {
			lock.unlock();
		}
	}
","	protected void demandUnload(SynchronizedResourceSet resourceSet, Resource resource,
			IProgressMonitor monitor) {
START 		lock.lock(); END 
		try {
			unloadingPool.execute(new ResourceUnloader(resourceSet, resource, monitor));
		} finally {
			lock.unlock();
		}
	}
","	protected void demandUnload(SynchronizedResourceSet resourceSet, Resource resource,
			IProgressMonitor monitor) {
		unloadingPool.execute(new ResourceUnloader(resourceSet, resource, monitor));
	}
"
212,"This is an unrelated change snuck in. Sorry for bitching, but it makes reviewing harder for big refactorings like this one.","    private void checkSigOps() throws VerificationException {
        // Check there aren't too many signature verifications in the block. This is an anti-DoS measure, see the
        // comments for MAX_BLOCK_SIGOPS.
        int sigOps = 0;
        for (Transaction tx : transactions) {
            sigOps += tx.getSigOpCount();
        }
        if (sigOps > MAX_BLOCK_SIGOPS) {
            throw new VerificationException(""Block had too many Signature Operations"");
        }
    }
","    private void checkSigOps() throws VerificationException {
        // Check there aren't too many signature verifications in the block. This is an anti-DoS measure, see the
        // comments for MAX_BLOCK_SIGOPS.
        int sigOps = 0;
        for (Transaction tx : transactions) {
            sigOps += tx.getSigOpCount();
        }
START         if (sigOps > MAX_BLOCK_SIGOPS) { END 
            throw new VerificationException(""Block had too many Signature Operations"");
        }
    }
","    private void checkSigOps() throws VerificationException {
        // Check there aren't too many signature verifications in the block. This is an anti-DoS measure, see the
        // comments for MAX_BLOCK_SIGOPS.
        int sigOps = 0;
        for (Transaction tx : transactions) {
            sigOps += tx.getSigOpCount();
        }
        if (sigOps > MAX_BLOCK_SIGOPS)
            throw new VerificationException(""Block had too many Signature Operations"");
    }
"
213,"There are no conjuncts in the API (no `List`, just an `expression`). Make it `private`.","    public static Expression filterConjuncts(Expression expression, Predicate<Expression> predicate)
    {
        List<Expression> conjuncts = extractConjuncts(expression).stream()
                .filter(predicate)
                .collect(toList());

        return combineConjuncts(conjuncts);
    }
","START     public static Expression filterConjuncts(Expression expression, Predicate<Expression> predicate) END 
    {
        List<Expression> conjuncts = extractConjuncts(expression).stream()
                .filter(predicate)
                .collect(toList());

        return combineConjuncts(conjuncts);
    }
","    private static Expression filterConjuncts(Expression expression, Predicate<Expression> predicate)
    {
        List<Expression> conjuncts = extractConjuncts(expression).stream()
                .filter(predicate)
                .collect(toList());

        return combineConjuncts(conjuncts);
    }
"
214,"NPE: timeGraphViewer is null before super is called.

But I don't think the next line is necessary.","    public void createPartControl(Composite parent) {
        String name = getViewSite().getSecondaryId();
        if (name != null) {
            name = TmfViewFactory.getBaseSecId(name);
        }
        if (name != null) {
            /* must initialize view info before calling super */
            fViewInfo.setName(name);
        }
        fPresentationProvider = new XmlPresentationProvider(name);
        TimeGraphViewer timeGraphViewer = getTimeGraphViewer();
        timeGraphViewer.getTimeGraphControl().colorSettingsChanged(timeGraphViewer.getTimeGraphProvider().getStateTable());
        super.createPartControl(parent);
    }
","    public void createPartControl(Composite parent) {
        String name = getViewSite().getSecondaryId();
        if (name != null) {
            name = TmfViewFactory.getBaseSecId(name);
        }
        if (name != null) {
            /* must initialize view info before calling super */
            fViewInfo.setName(name);
        }
        fPresentationProvider = new XmlPresentationProvider(name);
START         TimeGraphViewer timeGraphViewer = getTimeGraphViewer(); END 
        timeGraphViewer.getTimeGraphControl().colorSettingsChanged(timeGraphViewer.getTimeGraphProvider().getStateTable());
        super.createPartControl(parent);
    }
","    public void createPartControl(Composite parent) {
        String name = getViewSite().getSecondaryId();
        if (name != null) {
            name = TmfViewFactory.getBaseSecId(name);
        }
        if (name != null) {
            /* must initialize view info before calling super */
            fViewInfo.setName(name);
        }
        fPresentationProvider = new XmlPresentationProvider(name);
        super.createPartControl(parent);
        TimeGraphViewer timeGraphViewer = getTimeGraphViewer();
        timeGraphViewer.getTimeGraphControl().colorSettingsChanged(timeGraphViewer.getTimeGraphProvider().getStateTable());
    }
"
215,Let's not change this signature. Maybe add a separate method,"   public ProtocolVersion protocolVersion() {
      return protocolVersion;
   }
","START    public ProtocolVersion protocolVersion() { END 
      return protocolVersion;
   }
","   public String protocolVersion() {
      return protocolVersion.toString();
   }
"
216,"Please, do not use `this` when it's unnecessary. You can write just `factory`.","    public Matrix removeRow(int i) {
        return removeRow(i, this.factory);
    }
","    public Matrix removeRow(int i) {
START         return removeRow(i, this.factory); END 
    }
","    public Matrix removeRow(int i) {
        return removeRow(i, factory);
    }
"
217,"I presume you want to have all those line in .gitattributes? I think you need to do a single writeTrashFile with the four lines:

  writeTrashFile("".gitattributes"", ""[[]] bar\n"" + ""[\\[]] bar2\n"" + ... );","	public void testBracketsInGroup() throws Exception {
		createFiles(""["", ""]"", ""[]"", ""]["", ""[[]"", ""[]]"", ""[[]]"");
		writeTrashFile("".gitattributes"", ""[[]] bar1\n"");
		writeTrashFile("".gitattributes"", ""[\\[]] bar2\n"");
		writeTrashFile("".gitattributes"", ""[[\\]] bar3\n"");
		writeTrashFile("".gitattributes"", ""[\\[\\]] bar4\n"");
		assertSameAsCGit();
	}
","	public void testBracketsInGroup() throws Exception {
		createFiles(""["", ""]"", ""[]"", ""]["", ""[[]"", ""[]]"", ""[[]]"");
		writeTrashFile("".gitattributes"", ""[[]] bar1\n"");
		writeTrashFile("".gitattributes"", ""[\\[]] bar2\n"");
		writeTrashFile("".gitattributes"", ""[[\\]] bar3\n"");
START 		writeTrashFile("".gitattributes"", ""[\\[\\]] bar4\n""); END 
		assertSameAsCGit();
	}
","	public void testBracketsInGroup() throws Exception {
		createFiles(""["", ""]"", ""[]"", ""]["", ""[[]"", ""[]]"", ""[[]]"");
		writeTrashFile("".gitattributes"", ""[[]] bar1\n"" + ""[\\[]] bar2\n"" + ""[[\\]] bar3\n"" + ""[\\[\\]] bar4\n"");
		assertSameAsCGit();
	}
"
218,"We could just pass `null` to every parameter here, there is no need for mocking in this case.","	public void notIgnoredAfterOnCreateView() {
		assertFalse(myListFragment.didExecute);
		LayoutInflater inflater = mock(LayoutInflater.class);
		ViewGroup viewGroup = mock(ViewGroup.class);
		Bundle bundle = mock(Bundle.class);
		myListFragment.onCreateView(inflater, viewGroup, bundle);
		assertFalse(myListFragment.didExecute);
		myListFragment.ignoreWhenViewDestroyed();
		assertTrue(myListFragment.didExecute);
	}
","	public void notIgnoredAfterOnCreateView() {
		assertFalse(myListFragment.didExecute);
		LayoutInflater inflater = mock(LayoutInflater.class);
		ViewGroup viewGroup = mock(ViewGroup.class);
		Bundle bundle = mock(Bundle.class);
START 		myListFragment.onCreateView(inflater, viewGroup, bundle); END 
		assertFalse(myListFragment.didExecute);
		myListFragment.ignoreWhenViewDestroyed();
		assertTrue(myListFragment.didExecute);
	}
","	public void notIgnoredAfterOnCreateView() {
		assertFalse(myListFragment.didExecute);
		myListFragment.onCreateView(null, null, null);
		assertFalse(myListFragment.didExecute);
		myListFragment.ignoreWhenViewDestroyed();
		assertTrue(myListFragment.didExecute);
	}
"
219,why `8`?,"  private static String checkSitePathToken(Site site, String pattern) {
    if (site.getRequestScheme().hasPathToken()) {
      StringBuilder modified = new StringBuilder(pattern.length() + 8);
      modified.append(""/*"");
      if (!pattern.isEmpty() && !pattern.startsWith(""/"")) {
        modified.append('/');
      }
      modified.append(pattern);
      return modified.toString();
    } else {
      return pattern;
    }
  }
","  private static String checkSitePathToken(Site site, String pattern) {
    if (site.getRequestScheme().hasPathToken()) {
START       StringBuilder modified = new StringBuilder(pattern.length() + 8); END 
      modified.append(""/*"");
      if (!pattern.isEmpty() && !pattern.startsWith(""/"")) {
        modified.append('/');
      }
      modified.append(pattern);
      return modified.toString();
    } else {
      return pattern;
    }
  }
","  private static String checkSitePathToken(Site site, String pattern) {
    if (site.getRequestScheme().hasPathToken()) {
      StringBuilder modified = new StringBuilder(pattern.length() + 3);
      modified.append(""/*"");
      if (!pattern.isEmpty() && !pattern.startsWith(""/"")) {
        modified.append('/');
      }
      modified.append(pattern);
      return modified.toString();
    } else {
      return pattern;
    }
  }
"
220,Minor: don't really need to call getDataNodeId() since it's a class member.,"  public JSONObject getSnapshot() {
    JSONObject snapshot = new JSONObject();
    DataNodeId dataNodeId = getDataNodeId();
    snapshot.put(REPLICA_NODE, dataNodeId.getHostname() + "":"" + dataNodeId.getPort());
    snapshot.put(REPLICA_PARTITION, getPartitionId().toPathString());
    snapshot.put(REPLICA_PATH, getReplicaPath());
    snapshot.put(CAPACITY_BYTES, getCapacityInBytes());
    return snapshot;
  }
","  public JSONObject getSnapshot() {
    JSONObject snapshot = new JSONObject();
START     DataNodeId dataNodeId = getDataNodeId(); END 
    snapshot.put(REPLICA_NODE, dataNodeId.getHostname() + "":"" + dataNodeId.getPort());
    snapshot.put(REPLICA_PARTITION, getPartitionId().toPathString());
    snapshot.put(REPLICA_PATH, getReplicaPath());
    snapshot.put(CAPACITY_BYTES, getCapacityInBytes());
    return snapshot;
  }
","  public JSONObject getSnapshot() {
    JSONObject snapshot = new JSONObject();
    snapshot.put(REPLICA_NODE, dataNodeId.getHostname() + "":"" + dataNodeId.getPort());
    snapshot.put(REPLICA_PARTITION, getPartitionId().toPathString());
    snapshot.put(REPLICA_PATH, getReplicaPath());
    snapshot.put(CAPACITY_BYTES, getCapacityInBytes());
    return snapshot;
  }
"
221,"This doesn't work. These Java 6 enhancements only help if you want to *add* permissions to the file, not if you wan't to remove them.","    protected String createPassFile(String value) throws IOException {
        File temp = File.createTempFile(""ovirt"", "".tmp"");
        String filePath = temp.getAbsolutePath();

        temp.setReadable(true, true);
        temp.setWritable(true, true);
        temp.setExecutable(false);

        BufferedWriter out = new BufferedWriter(new FileWriter(temp));
        out.write(value);
        out.close();

        return filePath;
    }
","    protected String createPassFile(String value) throws IOException {
        File temp = File.createTempFile(""ovirt"", "".tmp"");
        String filePath = temp.getAbsolutePath();

        temp.setReadable(true, true);
        temp.setWritable(true, true);
START         temp.setExecutable(false); END 

        BufferedWriter out = new BufferedWriter(new FileWriter(temp));
        out.write(value);
        out.close();

        return filePath;
    }
","    protected String createPassFile(String value) throws IOException {
        File temp = File.createTempFile(""ovirt"", "".tmp"");
        String filePath = temp.getAbsolutePath();

        temp.setReadable(true, true);
        temp.setWritable(true, true);

        BufferedWriter out = new BufferedWriter(new FileWriter(temp));
        out.write(value);
        out.close();

        return filePath;
    }
"
222,Can you avoid repeating 1 in several places?,"	public void retireIdentifierSource_shouldRetireAnIdentifierSourceFromTheSystem() throws Exception {
		IdentifierSource identifierSource = identifierSourceService.getIdentifierSource(1);
		Assert.assertFalse(identifierSourceService.getIdentifierSource(1).isRetired());
		identifierSourceService.retireIdentifierSource(identifierSource, ""testing"");
		Assert.assertTrue(identifierSourceService.getIdentifierSource(1).isRetired());
	}
","	public void retireIdentifierSource_shouldRetireAnIdentifierSourceFromTheSystem() throws Exception {
START 		IdentifierSource identifierSource = identifierSourceService.getIdentifierSource(1); END 
		Assert.assertFalse(identifierSourceService.getIdentifierSource(1).isRetired());
		identifierSourceService.retireIdentifierSource(identifierSource, ""testing"");
		Assert.assertTrue(identifierSourceService.getIdentifierSource(1).isRetired());
	}
","	public void retireIdentifierSource_shouldRetireAnIdentifierSourceFromTheSystem() throws Exception {
		IdentifierSource identifierSource = identifierSourceService.getIdentifierSource(2);
		Assert.assertFalse(identifierSourceService.getIdentifierSource(2).isRetired());
		identifierSourceService.retireIdentifierSource(identifierSource, ""testing"");
		Assert.assertTrue(identifierSourceService.getIdentifierSource(2).isRetired());
	}
"
223,Can you remove this? OPENNLP-922 changes that in one style across all equals and hashCode implementations.,"  public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final LinkedSpan<T> other = (LinkedSpan<T>) obj;
    return Objects.equals(this.linkedEntries, other.linkedEntries) &&
        this.sentenceid == other.sentenceid &&
        Objects.equals(this.searchTerm, other.searchTerm);
  }
","  public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final LinkedSpan<T> other = (LinkedSpan<T>) obj;
START     return Objects.equals(this.linkedEntries, other.linkedEntries) && END 
        this.sentenceid == other.sentenceid &&
        Objects.equals(this.searchTerm, other.searchTerm);
  }
","  public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final LinkedSpan<T> other = (LinkedSpan<T>) obj;
    if (!Objects.equals(this.linkedEntries, other.linkedEntries)) {
      return false;
    }
    return this.sentenceid == other.sentenceid && Objects.equals(this.searchTerm, other.searchTerm);
  }
"
224,"`literalEncoder.toExpression()` already returns the Expression if the value is an instanceof Expression, and a NullLiteral if it equals null.  

I would get rid of the if statements and always return `literalEncoder.toExpression(value,BOOLEAN)`.  And add a `visitNullLiteral` to FilterExpressionStatsCalculatingVisitor.","    private Expression simplifyExpression(Session session, Expression predicate, TypeProvider types)
    {
        Map<NodeRef<Expression>, Type> expressionTypes = getExpressionTypes(session, predicate, types);
        ExpressionInterpreter interpreter = ExpressionInterpreter.expressionOptimizer(predicate, metadata, session, expressionTypes);
        Object value = interpreter.optimize(NoOpSymbolResolver.INSTANCE);

        if (value instanceof Expression) {
            return (Expression) value;
        }
        if (value == null) {
            // expression evaluates to SQL null, which in Filter is equivalent to false
            value = false;
        }
        return literalEncoder.toExpression(value, BOOLEAN);
    }
","    private Expression simplifyExpression(Session session, Expression predicate, TypeProvider types)
    {
        Map<NodeRef<Expression>, Type> expressionTypes = getExpressionTypes(session, predicate, types);
        ExpressionInterpreter interpreter = ExpressionInterpreter.expressionOptimizer(predicate, metadata, session, expressionTypes);
        Object value = interpreter.optimize(NoOpSymbolResolver.INSTANCE);

START         if (value instanceof Expression) { END 
            return (Expression) value;
        }
        if (value == null) {
            // expression evaluates to SQL null, which in Filter is equivalent to false
            value = false;
        }
        return literalEncoder.toExpression(value, BOOLEAN);
    }
","    private Expression simplifyExpression(Session session, Expression predicate, TypeProvider types)
    {
        // TODO reuse com.facebook.presto.sql.planner.iterative.rule.SimplifyExpressions.rewrite

        Map<NodeRef<Expression>, Type> expressionTypes = getExpressionTypes(session, predicate, types);
        ExpressionInterpreter interpreter = ExpressionInterpreter.expressionOptimizer(predicate, metadata, session, expressionTypes);
        Object value = interpreter.optimize(NoOpSymbolResolver.INSTANCE);

        if (value == null) {
            // Expression evaluates to SQL null, which in Filter is equivalent to false. This assumes the expression is a top-level expression (eg. not in NOT).
            value = false;
        }
        return literalEncoder.toExpression(value, BOOLEAN);
    }
"
225,"That is incorrect, in case the logger and eventAdmin is null we get a NPE","	public boolean post(String topic, Object data) {
		Event event = constructEvent(topic, data);
		EventAdmin eventAdmin = Activator.getDefault().getEventAdmin();
		if (eventAdmin == null && logger != null) {
			logger.error(NLS.bind(ServiceMessages.NO_EVENT_ADMIN, event.toString()));
			return false;
		}
		eventAdmin.postEvent(event);
		return true;
	}
","	public boolean post(String topic, Object data) {
		Event event = constructEvent(topic, data);
		EventAdmin eventAdmin = Activator.getDefault().getEventAdmin();
		if (eventAdmin == null && logger != null) {
			logger.error(NLS.bind(ServiceMessages.NO_EVENT_ADMIN, event.toString()));
START 			return false; END 
		}
		eventAdmin.postEvent(event);
		return true;
	}
","	public boolean post(String topic, Object data) {
		Event event = constructEvent(topic, data);
		EventAdmin eventAdmin = Activator.getDefault().getEventAdmin();
		if (eventAdmin == null) {
			if (logger != null) {
				logger.error(NLS.bind(ServiceMessages.NO_EVENT_ADMIN, event.toString()));
			}
			return false;
		}
		eventAdmin.postEvent(event);
		return true;
	}
"
226,The expected value (1) must be the second parameter of `assertEquals`,"	public void testTypeAccessInLambdaNoClassPath() {
		final Launcher runLaunch = new Launcher();
		runLaunch.getEnvironment().setNoClasspath(true);
		runLaunch.addInputResource(""./src/test/resources/noclasspath/lambdas/TypeAccessInLambda.java"");
		runLaunch.buildModel();

		assertEquals(""The token 'Strings' has not been parsed as CtTypeAccess"",
				runLaunch.getModel().getElements(new Filter<CtTypeAccess>() {
			@Override
			public boolean matches(final CtTypeAccess element) {
				return element.getAccessedType().getSimpleName().equals(""Strings"");
			}
		}).size(), 1);
	}
","	public void testTypeAccessInLambdaNoClassPath() {
		final Launcher runLaunch = new Launcher();
		runLaunch.getEnvironment().setNoClasspath(true);
		runLaunch.addInputResource(""./src/test/resources/noclasspath/lambdas/TypeAccessInLambda.java"");
		runLaunch.buildModel();

		assertEquals(""The token 'Strings' has not been parsed as CtTypeAccess"",
				runLaunch.getModel().getElements(new Filter<CtTypeAccess>() {
			@Override
			public boolean matches(final CtTypeAccess element) {
				return element.getAccessedType().getSimpleName().equals(""Strings"");
			}
START 		}).size(), 1); END 
	}
","	public void testTypeAccessInLambdaNoClassPath() {
		final Launcher runLaunch = new Launcher();
		runLaunch.getEnvironment().setNoClasspath(true);
		runLaunch.addInputResource(""./src/test/resources/noclasspath/lambdas/TypeAccessInLambda.java"");
		runLaunch.buildModel();

		assertEquals(""The token 'Strings' has not been parsed as CtTypeAccess"", 1,
				runLaunch.getModel().getElements(new Filter<CtTypeAccess>() {
			@Override
			public boolean matches(final CtTypeAccess element) {
				return element.getAccessedType().getSimpleName().equals(""Strings"");
			}
		}).size());
	}
"
227,![redundantarraycreation](https://cloud.githubusercontent.com/assets/1071590/15787201/e1d4932a-298e-11e6-9dc8-243abf4e1f9f.jpg),"		public RecipientListRouter rlRouter() {
			RecipientListRouter router = new RecipientListRouter();
			router.setChannels(Arrays.asList(new MessageChannel[] { barChannel(), bazChannel() }));
			router.setDefaultOutputChannel(discards());
			return router;
		}
","		public RecipientListRouter rlRouter() {
			RecipientListRouter router = new RecipientListRouter();
START 			router.setChannels(Arrays.asList(new MessageChannel[] { barChannel(), bazChannel() })); END 
			router.setDefaultOutputChannel(discards());
			return router;
		}
","		public RecipientListRouter rlRouter() {
			RecipientListRouter router = new RecipientListRouter();
			router.setChannels(Arrays.asList(barChannel(), bazChannel()));
			router.setDefaultOutputChannel(discards());
			return router;
		}
"
228,This should probably be package rather than protected,"  protected List<MetricFamilySamples> familySamplesList(Collector.Type type, List<MetricFamilySamples.Sample> samples) {
    MetricFamilySamples mfs = new MetricFamilySamples(fullname, type, help, samples);
    List<MetricFamilySamples> mfsList = new ArrayList<MetricFamilySamples>(1);
    mfsList.add(mfs);
    return mfsList;
  }
","START   protected List<MetricFamilySamples> familySamplesList(Collector.Type type, List<MetricFamilySamples.Sample> samples) { END 
    MetricFamilySamples mfs = new MetricFamilySamples(fullname, type, help, samples);
    List<MetricFamilySamples> mfsList = new ArrayList<MetricFamilySamples>(1);
    mfsList.add(mfs);
    return mfsList;
  }
","  List<MetricFamilySamples> familySamplesList(Collector.Type type, List<MetricFamilySamples.Sample> samples) {
    MetricFamilySamples mfs = new MetricFamilySamples(fullname, type, help, samples);
    List<MetricFamilySamples> mfsList = new ArrayList<MetricFamilySamples>(1);
    mfsList.add(mfs);
    return mfsList;
  }
"
229,should be static,"    private VmTemplate createVmTemplate() {
        VmTemplate template = new VmTemplate();
        template.setname(""test-template"");
        template.setorigin(OriginType.OVIRT);
        template.setId(new Guid());
        template.setdescription(""test-description"");
        template.setDbGeneration(2L);
        return template;
    }
","START     private VmTemplate createVmTemplate() { END 
        VmTemplate template = new VmTemplate();
        template.setname(""test-template"");
        template.setorigin(OriginType.OVIRT);
        template.setId(new Guid());
        template.setdescription(""test-description"");
        template.setDbGeneration(2L);
        return template;
    }
","    private static VmTemplate createVmTemplate() {
        VmTemplate template = new VmTemplate();
        template.setname(""test-template"");
        template.setorigin(OriginType.OVIRT);
        template.setId(new Guid());
        template.setdescription(""test-description"");
        template.setDbGeneration(2L);
        return template;
    }
"
230,Why handle t_decltype_auto here? We should never get in here for decltype(auto) because getDeclTypeExpression() will be null.,"	private static IType getDeclType(ICPPASTSimpleDeclSpecifier spec) {
		IASTExpression expr = spec.getDeclTypeExpression();
		if (expr == null) {
			return null;
		}
		int specifierType = spec.getType();
		if (specifierType == IASTSimpleDeclSpecifier.t_decltype || specifierType == IASTSimpleDeclSpecifier.t_decltype_auto) {
			return getDeclType(expr);
		}
		return expr.getExpressionType();
	}
","	private static IType getDeclType(ICPPASTSimpleDeclSpecifier spec) {
		IASTExpression expr = spec.getDeclTypeExpression();
		if (expr == null) {
			return null;
		}
		int specifierType = spec.getType();
START 		if (specifierType == IASTSimpleDeclSpecifier.t_decltype || specifierType == IASTSimpleDeclSpecifier.t_decltype_auto) { END 
			return getDeclType(expr);
		}
		return expr.getExpressionType();
	}
","	private static IType getDeclType(ICPPASTSimpleDeclSpecifier spec) {
		IASTExpression expr = spec.getDeclTypeExpression();
		if (expr == null) {
			return null;
		}
		int specifierType = spec.getType();
		if (specifierType == IASTSimpleDeclSpecifier.t_decltype) {
			return getDeclType(expr);
		}
		return expr.getExpressionType();
	}
"
231,I think the underscore should be a dash,"    public Number getLineMiterLimit() {
        if (paint.get(""line-miter_limit"") != null) {
            return (Number) paint.get(""line-miter-limit"");
        } else {
            return 2;
        }
    }
","    public Number getLineMiterLimit() {
START         if (paint.get(""line-miter_limit"") != null) { END 
            return (Number) paint.get(""line-miter-limit"");
        } else {
            return 2;
        }
    }
","    public Number getLineMiterLimit() {
        if (paint.get(""line-miter-limit"") != null) {
            return (Number) paint.get(""line-miter-limit"");
        } else {
            return 2;
        }
    }
"
232,change this to INFO level,"  public void start() {
    if (started.compareAndSet(false, true)) {
      register();
      scheduler = Utils.newScheduler(1, false);
      scheduler.scheduleAtFixedRate(new NettyMetricCollector(), 0, config.nettyMetricsRefreshIntervalSeconds,
          TimeUnit.SECONDS);
      logger.trace(""Schedule netty metric collector"");
    }
  }
","  public void start() {
    if (started.compareAndSet(false, true)) {
      register();
      scheduler = Utils.newScheduler(1, false);
      scheduler.scheduleAtFixedRate(new NettyMetricCollector(), 0, config.nettyMetricsRefreshIntervalSeconds,
          TimeUnit.SECONDS);
START       logger.trace(""Schedule netty metric collector""); END 
    }
  }
","  public void start() {
    if (started.compareAndSet(false, true)) {
      register();
      scheduler = Utils.newScheduler(1, false);
      scheduler.scheduleAtFixedRate(new NettyMetricCollector(), 0, config.nettyMetricsRefreshIntervalSeconds,
          TimeUnit.SECONDS);
      logger.info(""Schedule netty metric collector"");
    }
  }
"
233,At this point any reason we wouldn't throw the exception up and return error to client?,"    public String getFile(@PathVariable(""id"") final String id, final HttpServletRequest request) {
        String encodedId;
        try {
            // When forwarding, the downstream ApplicationContext will perform URL decoding.
            // If the job ID contains special characters (such as '+'), they will be interpreted as url-encoded and
            // decoded, resulting in an invalid job ID that cannot be found.
            // To prevent this, always perform URL encoding on the ID before forwarding.
            encodedId = URLEncoder.encode(id, ""UTF-8"");
        } catch (UnsupportedEncodingException e) {
            log.warn(""Failed to encode id: {}"", id, e);
            encodedId = id;
        }
        final String path = ""/api/v3/jobs/"" + encodedId + ""/"" + ControllerUtils.getRemainingPath(request);
        return ""forward:"" + path;
    }
","    public String getFile(@PathVariable(""id"") final String id, final HttpServletRequest request) {
        String encodedId;
        try {
            // When forwarding, the downstream ApplicationContext will perform URL decoding.
            // If the job ID contains special characters (such as '+'), they will be interpreted as url-encoded and
            // decoded, resulting in an invalid job ID that cannot be found.
            // To prevent this, always perform URL encoding on the ID before forwarding.
            encodedId = URLEncoder.encode(id, ""UTF-8"");
        } catch (UnsupportedEncodingException e) {
            log.warn(""Failed to encode id: {}"", id, e);
START             encodedId = id; END 
        }
        final String path = ""/api/v3/jobs/"" + encodedId + ""/"" + ControllerUtils.getRemainingPath(request);
        return ""forward:"" + path;
    }
","    public String getFile(
        @PathVariable(""id"") final String id,
        final HttpServletRequest request
    ) throws UnsupportedEncodingException {
        // When forwarding, the downstream ApplicationContext will perform URL decoding.
        // If the job ID contains special characters (such as '+'), they will be interpreted as url-encoded and
        // decoded, resulting in an invalid job ID that cannot be found.
        // To prevent this, always perform URL encoding on the ID before forwarding.
        final String encodedId = URLEncoder.encode(id, ""UTF-8"");
        final String path = ""/api/v3/jobs/"" + encodedId + ""/"" + ControllerUtils.getRemainingPath(request);
        return ""forward:"" + path;
    }
"
234,"How is it possible to get a non-integer value? Is there a way to set the value via the host? If there is, it would be more accurate to save the qos parameters on HostNetworkQos as doubles. Or even saving it as integer but in bits and just displaying it to the user in Mb.
I don't understand the benefit of sending/receiving bits as doubles through the api with vdsm.","    private Integer deserializeValue(Map<String, Object> entry, String curveKey, int conversionRate) {
        Map<String, Double> parameters = (Map<String, Double>) entry.get(curveKey);
        if (parameters == null) {
            return null;
        }

        Double average = parameters.get(VdsProperties.HOST_QOS_AVERAGE);
        return (average == null) ? null : (int) (average / conversionRate);
    }
","    private Integer deserializeValue(Map<String, Object> entry, String curveKey, int conversionRate) {
        Map<String, Double> parameters = (Map<String, Double>) entry.get(curveKey);
        if (parameters == null) {
            return null;
        }

        Double average = parameters.get(VdsProperties.HOST_QOS_AVERAGE);
START         return (average == null) ? null : (int) (average / conversionRate); END 
    }
","    private Integer deserializeValue(Map<String, Object> entry, String curveKey, int conversionRate) {
        Map<String, Integer> parameters = (Map<String, Integer>) entry.get(curveKey);
        if (parameters == null) {
            return null;
        }

        Integer average = parameters.get(VdsProperties.HOST_QOS_AVERAGE);
        return (average == null) ? null : (average / conversionRate);
    }
"
235,Seems this if else block here can just be replaced by `listener.futureDone(this);`,"      public NotifyingFuture<V> attachListener(final FutureListener<V> listener) {
         future.whenComplete((value, throwable) -> {
            if (throwable == null) {
               listener.futureDone(this);
            } else {
               listener.futureDone(this);
            }
         });
         return this;
      }
","      public NotifyingFuture<V> attachListener(final FutureListener<V> listener) {
         future.whenComplete((value, throwable) -> {
START             if (throwable == null) { END 
               listener.futureDone(this);
            } else {
               listener.futureDone(this);
            }
         });
         return this;
      }
","      public NotifyingFuture<V> attachListener(final FutureListener<V> listener) {
         future.whenComplete((value, throwable) -> {
            listener.futureDone(this);
         });
         return this;
      }
"
236,Just let it throw the error.,"    public TranslatedExpression<T> translate(FunctionMetadata functionMetadata, RowExpression original, List<TranslatedExpression<T>> translatedArguments)
    {
        if (!isFunctionPresent(functionMetadata)) {
            return untranslated(original);
        }
        try {
            return new TranslatedExpression<>(Optional.of((T) functionMapping.get(functionMetadata).invokeWithArguments(translatedArguments)), original, translatedArguments);
        }
        catch (Throwable t) {
            return untranslated(original);
        }
    }
","    public TranslatedExpression<T> translate(FunctionMetadata functionMetadata, RowExpression original, List<TranslatedExpression<T>> translatedArguments)
    {
        if (!isFunctionPresent(functionMetadata)) {
            return untranslated(original);
        }
        try {
            return new TranslatedExpression<>(Optional.of((T) functionMapping.get(functionMetadata).invokeWithArguments(translatedArguments)), original, translatedArguments);
        }
START         catch (Throwable t) { END 
            return untranslated(original);
        }
    }
","    public TranslatedExpression<T> translate(FunctionMetadata functionMetadata, RowExpression original, List<TranslatedExpression<T>> translatedArguments)
            throws Throwable
    {
        if (!functionMapping.containsKey(functionMetadata)) {
            return new TranslatedExpression<>(Optional.empty(), original, translatedArguments);
        }
        return new TranslatedExpression<>(Optional.of((T) functionMapping.get(functionMetadata).invokeWithArguments(translatedArguments)), original, translatedArguments);
    }
"
237,"Since it is always true, can be get rid of this variable?","    public void maintenance() {
        Guid clusterId = getClusterIdOfSelectedHosts();
        if (clusterId == null) {
            maintenance(false, false, null);
        } else {
            AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(
                    cluster -> {
                        if (cluster != null) {
                            maintenance(true, cluster.supportsGlusterService(), clusterId);
                        }
                    }), clusterId);
        }
    }
","    public void maintenance() {
        Guid clusterId = getClusterIdOfSelectedHosts();
        if (clusterId == null) {
            maintenance(false, false, null);
        } else {
            AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(
                    cluster -> {
                        if (cluster != null) {
START                             maintenance(true, cluster.supportsGlusterService(), clusterId); END 
                        }
                    }), clusterId);
        }
    }
","    public void maintenance() {
        Guid clusterId = getClusterIdOfSelectedHosts();
        if (clusterId == null) {
            maintenance(false, null);
        } else {
            AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(
                    cluster -> {
                        if (cluster != null) {
                            maintenance(cluster.supportsGlusterService(), clusterId);
                        }
                    }), clusterId);
        }
    }
"
238,"Should this be `requireNonNull(dagProcessor, ` ?","  public DagBuilder(final String name, final DagProcessor dagProcessor) {
    requireNonNull(name, ""The name of the DagBuilder can't be null"");
    requireNonNull(name, ""The dagProcessor of the DagBuilder can't be null"");
    this.dag = new Dag(name, dagProcessor);
  }
","  public DagBuilder(final String name, final DagProcessor dagProcessor) {
    requireNonNull(name, ""The name of the DagBuilder can't be null"");
START     requireNonNull(name, ""The dagProcessor of the DagBuilder can't be null""); END 
    this.dag = new Dag(name, dagProcessor);
  }
","  public DagBuilder(final String name, final DagProcessor dagProcessor) {
    requireNonNull(name, ""The name of the DagBuilder can't be null"");
    requireNonNull(dagProcessor, ""The dagProcessor of the DagBuilder can't be null"");
    this.dag = new Dag(name, dagProcessor);
  }
"
239,"You should add a `null` check here, as the selected functionality may not be installed, yielding a `null` Menu Item.","    private void selectStrutsFunctionality(HttpServletRequest request) {
        Functionality functionality = RenderersAnnotationProcessor.getFunctionalityForType(getFunctionalityType());
        MenuFunctionality menuItem = MenuFunctionality.findFunctionality(functionality.getProvider(), functionality.getKey());
        if (!menuItem.isAvailableForCurrentUser()) {
            throw AuthorizationException.unauthorized();
        }
        BennuPortalDispatcher.selectFunctionality(request, menuItem);
    }
","    private void selectStrutsFunctionality(HttpServletRequest request) {
        Functionality functionality = RenderersAnnotationProcessor.getFunctionalityForType(getFunctionalityType());
        MenuFunctionality menuItem = MenuFunctionality.findFunctionality(functionality.getProvider(), functionality.getKey());
START         if (!menuItem.isAvailableForCurrentUser()) { END 
            throw AuthorizationException.unauthorized();
        }
        BennuPortalDispatcher.selectFunctionality(request, menuItem);
    }
","    private void selectStrutsFunctionality(HttpServletRequest request) {
        Functionality functionality = RenderersAnnotationProcessor.getFunctionalityForType(getFunctionalityType());
        MenuFunctionality menuItem = MenuFunctionality.findFunctionality(functionality.getProvider(), functionality.getKey());
        if (menuItem == null || !menuItem.isAvailableForCurrentUser()) {
            throw AuthorizationException.unauthorized();
        }
        BennuPortalDispatcher.selectFunctionality(request, menuItem);
    }
"
240,String.valueOf,"  private void logFailureResponseObject(MockHttpException httpEx, String url, long callDelay) {
    LogLevel logLevel = restAdapter.logLevel;
    RestAdapter.Log log = restAdapter.log;

    if (logLevel.log()) {
      log.log(String.format(""<--- MOCK %s %s (%sms)"", httpEx.code, url, callDelay));
      if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
        log.log(httpEx.responseBody + """"); // Hack to convert toString while supporting null.
        log.log(""<--- END MOCK"");
      }
    }
  }
","  private void logFailureResponseObject(MockHttpException httpEx, String url, long callDelay) {
    LogLevel logLevel = restAdapter.logLevel;
    RestAdapter.Log log = restAdapter.log;

    if (logLevel.log()) {
      log.log(String.format(""<--- MOCK %s %s (%sms)"", httpEx.code, url, callDelay));
      if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
START         log.log(httpEx.responseBody + """"); // Hack to convert toString while supporting null. END 
        log.log(""<--- END MOCK"");
      }
    }
  }
","  private void logFailureResponseObject(MockHttpException httpEx, String url, long callDelay) {
    LogLevel logLevel = restAdapter.logLevel;
    RestAdapter.Log log = restAdapter.log;

    if (logLevel.log()) {
      log.log(String.format(""<--- MOCK %s %s (%sms)"", httpEx.code, url, callDelay));
      if (logLevel.ordinal() >= LogLevel.FULL.ordinal()) {
        log.log(String.valueOf(httpEx.responseBody));
        log.log(""<--- END MOCK"");
      }
    }
  }
"
241,just use context,"    public void newSelection(final TmfPieChartViewer context) {
        if (context.isDisposed()) {
            return;
        }

        Display.getDefault().asyncExec(new Runnable() {
            @Override
            public void run() {
                synchronized (context.getMutexLayoutChange()) {
                    if (!context.isDisposed()) {
                        context.updateTimeRangeSelectionPieChart();
                        context.getTimeRangePC().redraw();
                        context.layout();
                    }
                }
            }
        });
    }
","    public void newSelection(final TmfPieChartViewer context) {
        if (context.isDisposed()) {
            return;
        }

        Display.getDefault().asyncExec(new Runnable() {
            @Override
            public void run() {
START                 synchronized (context.getMutexLayoutChange()) { END 
                    if (!context.isDisposed()) {
                        context.updateTimeRangeSelectionPieChart();
                        context.getTimeRangePC().redraw();
                        context.layout();
                    }
                }
            }
        });
    }
","    public void newSelection(final TmfPieChartViewer context) {
        if (context.isDisposed()) {
            return;
        }

        Display.getDefault().asyncExec(new Runnable() {
            @Override
            public void run() {
                synchronized (context) {
                    if (!context.isDisposed()) {
                        context.updateTimeRangeSelectionPieChart();
                        context.getTimeRangePC().redraw();
                        context.layout();
                    }
                }
            }
        });
    }
"
242,"It reads a bit strange to fall through to `lookupCoordinator` if we know the request doesn't need the coordinator. Maybe clearer with a slight restructure:
```java

transactionManager.retry(nextRequestHandler);

if (nextRequestHandler.needsCoordinator()) {
  transactionManager.lookupCoordinator(nextRequestHandler);
} else {
  // For non-coordinator requests, sleep here to prevent a tight loop when no node is available
  time.sleep(retryBackoffMs);
  metadata.requestUpdate();	            
}
```","    private void lookupCoordinatorAndRetry(TransactionManager.TxnRequestHandler nextRequestHandler) {
        if (!nextRequestHandler.needsCoordinator()) {
            // For non-coordinator requests, sleep here to prevent a tight loop when no node is available
            time.sleep(retryBackoffMs);
            metadata.requestUpdate();
        }

        transactionManager.lookupCoordinator(nextRequestHandler);
        transactionManager.retry(nextRequestHandler);
    }
","    private void lookupCoordinatorAndRetry(TransactionManager.TxnRequestHandler nextRequestHandler) {
        if (!nextRequestHandler.needsCoordinator()) {
            // For non-coordinator requests, sleep here to prevent a tight loop when no node is available
            time.sleep(retryBackoffMs);
            metadata.requestUpdate();
        }

START         transactionManager.lookupCoordinator(nextRequestHandler); END 
        transactionManager.retry(nextRequestHandler);
    }
","    private void lookupCoordinatorAndRetry(TransactionManager.TxnRequestHandler nextRequestHandler) {
        if (nextRequestHandler.needsCoordinator()) {
            transactionManager.lookupCoordinator(nextRequestHandler);
        } else {
            // For non-coordinator requests, sleep here to prevent a tight loop when no node is available
            time.sleep(retryBackoffMs);
            metadata.requestUpdate();
        }

        transactionManager.retry(nextRequestHandler);
    }
"
243,(spelling) I guess there is a reason you can't use asserEquals here as oppossed to compareTo? Not sure why the semantics should be different there.,"	public void testGetVersion() throws Exception {
		BugzillaRestClient client = new BugzillaRestClient(actualFixture.location());
		assertNotNull(client.getClient());
		assertNull(client.getClient().getLoginToken());
		BugzillaRestVersion version = client.getVersion(new NullOperationMonitor());
		assertTrue(""expeccted: "" + actualFixture.getVersion() + "" actual: "" + version.toString(),
				actualFixture.getVersion().compareTo(version.toString()) == 0);
	}
","	public void testGetVersion() throws Exception {
		BugzillaRestClient client = new BugzillaRestClient(actualFixture.location());
		assertNotNull(client.getClient());
		assertNull(client.getClient().getLoginToken());
		BugzillaRestVersion version = client.getVersion(new NullOperationMonitor());
		assertTrue(""expeccted: "" + actualFixture.getVersion() + "" actual: "" + version.toString(),
START 				actualFixture.getVersion().compareTo(version.toString()) == 0); END 
	}
","	public void testGetVersion() throws Exception {
		BugzillaRestClient client = new BugzillaRestClient(actualFixture.location());
		assertNotNull(client.getClient());
		assertNull(client.getClient().getLoginToken());
		BugzillaRestVersion version = client.getVersion(new NullOperationMonitor());
		assertEquals(""expeccted: "" + actualFixture.getVersion() + "" actual: "" + version.toString(),
				actualFixture.getVersion(), version.toString());
	}
"
244,Not sure we need a reference to your particular nodes setup,"	private String locateTool(String tool) {
		String[] roots = { ""/usr/bin/"", ""/usr/local/bin/"", ""/Users/christian/.nvm/versions/node/v6.6.0/bin/"" };
		for (String root : roots) {
			if (new File(root + tool).exists()) {
				return root + tool;
			}
		}
		return null;
	}
","	private String locateTool(String tool) {
START 		String[] roots = { ""/usr/bin/"", ""/usr/local/bin/"", ""/Users/christian/.nvm/versions/node/v6.6.0/bin/"" }; END 
		for (String root : roots) {
			if (new File(root + tool).exists()) {
				return root + tool;
			}
		}
		return null;
	}
","	private String locateTool(String tool) {
		String[] roots = { ""/usr/bin/"", ""/usr/local/bin/"" };
		for (String root : roots) {
			if (new File(root + tool).exists()) {
				return root + tool;
			}
		}
		return null;
	}
"
245,"this logging may be spammy, so we should not log this.","  public void setAcl(FileSystem hdfs, String path, AccessControlList acl) throws IOException {
    // convert AccessControlList into hdfsAcl
    List<AclEntry> aclSpecs = new ArrayList<>();

    for (alluxio.security.authorization.AclEntry entry : acl.getEntries()) {
      AclEntry hdfsAclEntry = getHdfsAclEntry(entry);
      aclSpecs.add(hdfsAclEntry);
    }
    // set hdfsAcl;
    try {
      hdfs.setAcl(new Path(path), aclSpecs);
    } catch (UnsupportedOperationException e) {
      LOG.warn(""Setting ACL on HDFS with acl disabled"");
    }
  }
","  public void setAcl(FileSystem hdfs, String path, AccessControlList acl) throws IOException {
    // convert AccessControlList into hdfsAcl
    List<AclEntry> aclSpecs = new ArrayList<>();

    for (alluxio.security.authorization.AclEntry entry : acl.getEntries()) {
      AclEntry hdfsAclEntry = getHdfsAclEntry(entry);
      aclSpecs.add(hdfsAclEntry);
    }
    // set hdfsAcl;
    try {
      hdfs.setAcl(new Path(path), aclSpecs);
    } catch (UnsupportedOperationException e) {
START       LOG.warn(""Setting ACL on HDFS with acl disabled""); END 
    }
  }
","  public void setAcl(FileSystem hdfs, String path, AccessControlList acl) throws IOException {
    // convert AccessControlList into hdfsAcl
    List<AclEntry> aclSpecs = new ArrayList<>();

    for (alluxio.security.authorization.AclEntry entry : acl.getEntries()) {
      AclEntry hdfsAclEntry = getHdfsAclEntry(entry);
      aclSpecs.add(hdfsAclEntry);
    }
    // set hdfsAcl;
    try {
      hdfs.setAcl(new Path(path), aclSpecs);
    } catch (UnsupportedOperationException e) {
      // noop if hdfs does not support acl
    }
  }
"
246,Lets use a TAG variable,"    public void sendUserListMessage(UserList userlist){
        UserListMessage ulm = new UserListMessage(userlist);
        broadcastMessageToFans(ulm);
        Log.i(""Messaging Service"", ""User List Message Sent"");
    }
","    public void sendUserListMessage(UserList userlist){
        UserListMessage ulm = new UserListMessage(userlist);
        broadcastMessageToFans(ulm);
START         Log.i(""Messaging Service"", ""User List Message Sent""); END 
    }
","    public void sendUserListMessage(UserList userlist){
        UserListMessage ulm = new UserListMessage(userlist);
        broadcastMessageToFans(ulm);
    }
"
247,make it if-then-else since we dont't need the increment in the line below? Also split this line since we don't include the statement in the same line as `if`.,"    private int nextCorrelationId() {
        if (SaslClientAuthenticator.isReserved(correlation)) correlation = SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID + 1;
        return correlation++;
    }
","    private int nextCorrelationId() {
START         if (SaslClientAuthenticator.isReserved(correlation)) correlation = SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID + 1; END 
        return correlation++;
    }
","    int nextCorrelationId() {
        if (SaslClientAuthenticator.isReserved(correlation)) {
            // the numeric overflow is fine as negative values is acceptable
            correlation = SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID + 1;
        }
        return correlation++;
    }
"
248,static import for `is`,"  public void uniqueCorrelationIDs() throws MuleException {
    CoreEvent firstEvent = getEventBuilder().message(of(""first"")).build();
    CoreEvent secondEvent = getEventBuilder().message(of(""second"")).build();

    assertThat(""Duplicated correlationID"", firstEvent.getContext().getCorrelationId(),
                             not(Is.is(secondEvent.getContext().getCorrelationId())));
  }
","  public void uniqueCorrelationIDs() throws MuleException {
    CoreEvent firstEvent = getEventBuilder().message(of(""first"")).build();
    CoreEvent secondEvent = getEventBuilder().message(of(""second"")).build();

    assertThat(""Duplicated correlationID"", firstEvent.getContext().getCorrelationId(),
START                              not(Is.is(secondEvent.getContext().getCorrelationId()))); END 
  }
","  public void uniqueCorrelationIDs() throws MuleException {
    CoreEvent firstEvent = getEventBuilder().message(of(""first"")).build();
    CoreEvent secondEvent = getEventBuilder().message(of(""second"")).build();

    assertThat(""Duplicated correlationID"", firstEvent.getContext().getCorrelationId(),
               not(is(secondEvent.getContext().getCorrelationId())));
  }
"
249,Single if can be used here too,"    private void setupActivityFromState(final Bundle state) {
        if (state != null) {
            if (!shouldShowDualPane) {
                toggleNavigationDrawer(state.getBoolean(STATE_DRAWER_OPENED, false));
            }
        }
    }
","    private void setupActivityFromState(final Bundle state) {
        if (state != null) {
START             if (!shouldShowDualPane) { END 
                toggleNavigationDrawer(state.getBoolean(STATE_DRAWER_OPENED, false));
            }
        }
    }
","    private void setupActivityFromState(final Bundle state) {
        if (state != null && !shouldShowDualPane) {
            toggleNavigationDrawer(state.getBoolean(STATE_DRAWER_OPENED, false));
        }
    }
"
250,why hardcode?,"        public VdcActionParametersBase getParameters(Host incoming, VDS entity) {
            VdsStatic updated = getMapper(modelType, VdsStatic.class).map(incoming,
                    entity.getStaticData());
            UpdateVdsActionParameters updateParams = new UpdateVdsActionParameters(updated, ""root"", """", false);
            if (incoming.isSetOverrideIptables()) {
                updateParams.setOverrideFirewall(incoming.isOverrideIptables());
            }
            return updateParams;
        }
","        public VdcActionParametersBase getParameters(Host incoming, VDS entity) {
            VdsStatic updated = getMapper(modelType, VdsStatic.class).map(incoming,
                    entity.getStaticData());
START             UpdateVdsActionParameters updateParams = new UpdateVdsActionParameters(updated, ""root"", """", false); END 
            if (incoming.isSetOverrideIptables()) {
                updateParams.setOverrideFirewall(incoming.isOverrideIptables());
            }
            return updateParams;
        }
","        public VdcActionParametersBase getParameters(Host incoming, VDS entity) {
            VdsStatic updated = getMapper(modelType, VdsStatic.class).map(incoming,
                    entity.getStaticData());
            UpdateVdsActionParameters updateParams = new UpdateVdsActionParameters(updated, """", false);
            if (incoming.isSetOverrideIptables()) {
                updateParams.setOverrideFirewall(incoming.isOverrideIptables());
            }
            return updateParams;
        }
"
251,Style-nit: This method can be static.,"	private boolean isSamePrefix(String a, String b) {
		int as = a.lastIndexOf('/');
		int bs = b.lastIndexOf('/');
		return a.substring(0, as + 1).equals(b.substring(0, bs + 1));
	}
","START 	private boolean isSamePrefix(String a, String b) { END 
		int as = a.lastIndexOf('/');
		int bs = b.lastIndexOf('/');
		return a.substring(0, as + 1).equals(b.substring(0, bs + 1));
	}
","	private static boolean isSamePrefix(String a, String b) {
		int as = a.lastIndexOf('/');
		int bs = b.lastIndexOf('/');
		return a.substring(0, as + 1).equals(b.substring(0, bs + 1));
	}
"
252,"Do we need it after stop ? If not, it makes more sense to put it in `start` method (and maybe remove the field init).","    public void stop(ComponentContext context) throws InterruptedException {
        super.stop(context);
        redirectResolver = new DefaultRedirectResolver();
    }
","    public void stop(ComponentContext context) throws InterruptedException {
        super.stop(context);
START         redirectResolver = new DefaultRedirectResolver(); END 
    }
","    public void stop(ComponentContext context) throws InterruptedException {
        super.stop(context);
        redirectResolver = null;
    }
"
253,"I am not a fan of this, cant we move this to doStart so its initialized there?","    public synchronized void initCamelCronService() {
        if (this.service == null) {
            this.service = CronHelper.resolveCamelCronService(
                    getCamelContext(),
                    this.cronService
            );

            if (this.service == null) {
                throw new RuntimeCamelException(""Cannot find any CamelCronService: please add a valid implementation, such as 'camel-quartz', in order to use the 'camel-cron' component"");
            }

            try {
                getCamelContext().addService(this.service, true, false);
            } catch (Exception e) {
                throw new RuntimeCamelException(e);
            }
        }
    }
","START     public synchronized void initCamelCronService() { END 
        if (this.service == null) {
            this.service = CronHelper.resolveCamelCronService(
                    getCamelContext(),
                    this.cronService
            );

            if (this.service == null) {
                throw new RuntimeCamelException(""Cannot find any CamelCronService: please add a valid implementation, such as 'camel-quartz', in order to use the 'camel-cron' component"");
            }

            try {
                getCamelContext().addService(this.service, true, false);
            } catch (Exception e) {
                throw new RuntimeCamelException(e);
            }
        }
    }
","    public void initCamelCronService() {
        if (this.service == null) {
            this.service = CronHelper.resolveCamelCronService(
                    getCamelContext(),
                    this.cronService
            );

            if (this.service == null) {
                throw new RuntimeCamelException(""Cannot find any CamelCronService: please add a valid implementation, such as 'camel-quartz', in order to use the 'camel-cron' component"");
            }

            try {
                getCamelContext().addService(this.service, true, false);
            } catch (Exception e) {
                throw new RuntimeCamelException(e);
            }
        }
    }
"
254,Doing this in a live test is a symptom of something that users will probably have to do themselves. better use the build-in `Predicates2.retry` construct to wait until the server is deleted and consider binding it to the guice context so it can be reused where needed.,"   public void teardownTest() throws InterruptedException {
      //give time for operations to finish
      firewallPolicyApi().delete(currentFirewallPolicy.id());
      Thread.sleep(15000);
      assertNodeAvailable(currentServer);
      deleteServer(currentServer.id());
   }
","   public void teardownTest() throws InterruptedException {
      //give time for operations to finish
      firewallPolicyApi().delete(currentFirewallPolicy.id());
START       Thread.sleep(15000); END 
      assertNodeAvailable(currentServer);
      deleteServer(currentServer.id());
   }
","   public void teardownTest() throws InterruptedException {
      assertNodeAvailable(currentServer);
      firewallPolicyApi().delete(currentFirewallPolicy.id());
      assertNodeAvailable(currentServer);
      deleteServer(currentServer.id());
   }
"
255,In what way is this an improvement?,"        public Object next()
        {
            if ( position >= len )
            {
                throw new NoSuchElementException();
            }
            Object result = Array.get( array, position );
            position++;
            return result;
        }
","        public Object next()
        {
            if ( position >= len )
            {
                throw new NoSuchElementException();
            }
            Object result = Array.get( array, position );
            position++;
START             return result; END 
        }
","        public Object next()
        {
            if ( position >= len )
            {
                throw new NoSuchElementException();
            }
            int offset = position++;
            return Array.get( array, offset );
        }
"
256,"Why are you assigning 0 to numElementOnPage, as you assign some value again in the next line?","	protected int getNumOfElementOnPage(By cssSelectorBy) {
		changeImplicitWait(500, TimeUnit.MILLISECONDS);
		int numElementOnPage = 0;
		try {
			numElementOnPage = driver.findElements(cssSelectorBy).size();
		} catch (Exception ex) {
			numElementOnPage = 0;
		} finally {
			restoreDeaultImplicitWait();
		}
		return numElementOnPage;
	}
","	protected int getNumOfElementOnPage(By cssSelectorBy) {
		changeImplicitWait(500, TimeUnit.MILLISECONDS);
START 		int numElementOnPage = 0; END 
		try {
			numElementOnPage = driver.findElements(cssSelectorBy).size();
		} catch (Exception ex) {
			numElementOnPage = 0;
		} finally {
			restoreDeaultImplicitWait();
		}
		return numElementOnPage;
	}
","	protected int getNumOfElementOnPage(By cssSelectorBy) {
		changeImplicitWait(500, TimeUnit.MILLISECONDS);
		int numElementOnPage;
		try {
			numElementOnPage = driver.findElements(cssSelectorBy).size();
		} catch (Exception ex) {
			numElementOnPage = 0;
		} finally {
			restoreDeaultImplicitWait();
		}
		return numElementOnPage;
	}
"
257,"I don't understand this, why testing if the field name is not empty? Shouldn't this be removed?","    public void set(String field, final String value) {
        if (!"""".equals(field)) {

            if (isUserDefinedField(field)) {
                userDefinedFields.put(field, value);
                String fieldName = getUserDefinedFieldName(field);

                if (fieldName != null) {
                    userDefinedFieldNames.add(new ControlField(fieldName));
                }

                field = fieldName;
            }

            if (field != null) {
                values.put(field, value);
            }
        }
    }
","    public void set(String field, final String value) {
START         if (!"""".equals(field)) { END 

            if (isUserDefinedField(field)) {
                userDefinedFields.put(field, value);
                String fieldName = getUserDefinedFieldName(field);

                if (fieldName != null) {
                    userDefinedFieldNames.add(new ControlField(fieldName));
                }

                field = fieldName;
            }

            if (field != null) {
                values.put(field, value);
            }
        }
    }
","    public void set(String field, final String value) {
        if (field != null && isUserDefinedField(field)) {
            userDefinedFields.put(field, value);
            String fieldName = getUserDefinedFieldName(field);

            if (fieldName != null) {
                userDefinedFieldNames.add(new ControlField(fieldName));
            }

            field = fieldName;
        }

        if (field != null && !"""".equals(field)) {
            values.put(field, value);
        }
    }
"
258,nit: you can merge lines above as `checkNotNull` will return the given argument,"        public Result(String targetContentEncoding, EmbeddedChannel contentEncoder) {
            ObjectUtil.checkNotNull(targetContentEncoding, ""targetContentEncoding"");
            ObjectUtil.checkNotNull(contentEncoder, ""contentEncoder"");
            this.targetContentEncoding = targetContentEncoding;
            this.contentEncoder = contentEncoder;
        }
","        public Result(String targetContentEncoding, EmbeddedChannel contentEncoder) {
            ObjectUtil.checkNotNull(targetContentEncoding, ""targetContentEncoding"");
            ObjectUtil.checkNotNull(contentEncoder, ""contentEncoder"");
            this.targetContentEncoding = targetContentEncoding;
START             this.contentEncoder = contentEncoder; END 
        }
","        public Result(String targetContentEncoding, EmbeddedChannel contentEncoder) {
            this.targetContentEncoding = ObjectUtil.checkNotNull(targetContentEncoding, ""targetContentEncoding"");
            this.contentEncoder = ObjectUtil.checkNotNull(contentEncoder, ""contentEncoder"");
        }
"
259,"Just change this to
```
setVisible(adapter != null && adapter.getMediaType() == MediaUtils.TYPE_FILE)
```

and get rid of isLibraryAdapter","	public boolean onPrepareOptionsMenu(Menu menu)
	{
		LibraryAdapter adapter = mCurrentAdapter;
		boolean isLibraryAdapter = (adapter != null && adapter.getMediaType() != MediaUtils.TYPE_FILE);
		menu.findItem(MENU_GO_HOME).setVisible(!isLibraryAdapter);
		menu.findItem(MENU_SORT).setEnabled(adapter != null);
		return super.onPrepareOptionsMenu(menu);
	}
","	public boolean onPrepareOptionsMenu(Menu menu)
	{
		LibraryAdapter adapter = mCurrentAdapter;
		boolean isLibraryAdapter = (adapter != null && adapter.getMediaType() != MediaUtils.TYPE_FILE);
START 		menu.findItem(MENU_GO_HOME).setVisible(!isLibraryAdapter); END 
		menu.findItem(MENU_SORT).setEnabled(adapter != null);
		return super.onPrepareOptionsMenu(menu);
	}
","	public boolean onPrepareOptionsMenu(Menu menu)
	{
		LibraryAdapter adapter = mCurrentAdapter;
		menu.findItem(MENU_GO_HOME).setVisible(
				adapter != null && adapter.getMediaType() == MediaUtils.TYPE_FILE);
		menu.findItem(MENU_SORT).setEnabled(adapter != null);
		return super.onPrepareOptionsMenu(menu);
	}
"
260,Looks strange.,"	public void login() {
		page.login(validAdminPassword, validAdminLogin);
	}
","	public void login() {
START 		page.login(validAdminPassword, validAdminLogin); END 
	}
","	public void login() {
		page.login(validAdminLogin, validAdminPassword);
	}
"
261,Could you use StringUtils.truncate instead?,"    protected static String truncateValueToMaxLength(String inputValue, int maxLength) {
        if (StringUtils.length(inputValue) <= maxLength) {
            return inputValue;
        } else {
            return inputValue.substring(0, maxLength);
        }
    }
","START     protected static String truncateValueToMaxLength(String inputValue, int maxLength) { END 
        if (StringUtils.length(inputValue) <= maxLength) {
            return inputValue;
        } else {
            return inputValue.substring(0, maxLength);
        }
    }
","    protected String truncateValueToMaxLength(String inputValue, int maxLength) {
        return StringUtils.substring(inputValue, 0, maxLength);
    }
"
262,style nit: we don't use braces around single line blocks,"	private void init() {
		// Creating ObjectChecker must be deferred. Unit tests change
		// behavior of is{Windows,MacOS} in constructor of subclass.
		if (platformChecker == null) {
			setPlatformChecker();
		}
	}
","	private void init() {
		// Creating ObjectChecker must be deferred. Unit tests change
		// behavior of is{Windows,MacOS} in constructor of subclass.
START 		if (platformChecker == null) { END 
			setPlatformChecker();
		}
	}
","	private void init() {
		// Creating ObjectChecker must be deferred. Unit tests change
		// behavior of is{Windows,MacOS} in constructor of subclass.
		if (platformChecker == null)
			setPlatformChecker();
	}
"
263,"Again, prefer ""isEmpty()"" over a ""size()"" comparison.","    private static II getLivingSubjectId(PRPAMT201306UV02LivingSubjectId id) {
        II oII = null;

        if (id != null && id.getValue() != null && id.getValue().size() > 0) {
            oII = id.getValue().get(0);
        }

        return oII;
    }
","    private static II getLivingSubjectId(PRPAMT201306UV02LivingSubjectId id) {
        II oII = null;

START         if (id != null && id.getValue() != null && id.getValue().size() > 0) { END 
            oII = id.getValue().get(0);
        }

        return oII;
    }
","    private static II getLivingSubjectId(PRPAMT201306UV02LivingSubjectId id) {
        II oII = null;

        if (id != null && id.getValue() != null && !id.getValue().isEmpty()) {
            oII = id.getValue().get(0);
        }

        return oII;
    }
"
264,"This can be improved. The `this.readOnly` check shows that this method is mixing two concerns: map lookup and caching. I would prefer if caching was done in a separate wrapper class(`ReadOnlyHttpHeaders`), that is returned when `HttpHeaders.readOnlyHttpHeaders` is called (instead of backing the map with an unmodifiable `MultiValueMap`).","	public MediaType getContentType() {
		if (this.readOnly && this.cachedContentType != null) {
			return this.cachedContentType;
		}
		else {
			String value = getFirst(CONTENT_TYPE);
			MediaType contentType = (StringUtils.hasLength(value) ? MediaType.parseMediaType(value) : null);
			if (this.readOnly) {
				this.cachedContentType = contentType;
			}
			return contentType;
		}
	}
","	public MediaType getContentType() {
		if (this.readOnly && this.cachedContentType != null) {
			return this.cachedContentType;
		}
		else {
			String value = getFirst(CONTENT_TYPE);
			MediaType contentType = (StringUtils.hasLength(value) ? MediaType.parseMediaType(value) : null);
			if (this.readOnly) {
				this.cachedContentType = contentType;
			}
			return contentType;
START 		} END 
	}
","	public MediaType getContentType() {
		String value = getFirst(CONTENT_TYPE);
		return (StringUtils.hasLength(value) ? MediaType.parseMediaType(value) : null);
	}
"
265,change to List,"	protected String[] fillTypeCombo() {		
		ArrayList<String> list = new ArrayList<>();
		for(DataType dataType : EventTypeLibrary.getInstance().getEventTypes()){
			list.add(dataType.getName());
		}
		return list.toArray(new String[0]);
	}
","	protected String[] fillTypeCombo() {		
START 		ArrayList<String> END  list = new ArrayList<>();
		for(DataType dataType : EventTypeLibrary.getInstance().getEventTypes()){
			list.add(dataType.getName());
		}
		return list.toArray(new String[0]);
	}
","	protected String[] fillTypeCombo() {		
		List<String> list = new ArrayList<>();
		for(DataType dataType : EventTypeLibrary.getInstance().getEventTypes()){
			list.add(dataType.getName());
		}
		return list.toArray(new String[0]);
	}
"
266,Can be simplified to `cacheManager != null && cacheManager.getCacheManagerConfiguration().globalJmxStatistics().enabled()`,"   public NettyTransportConnectionStats(EmbeddedCacheManager cacheManager, ChannelGroup acceptedChannels, String threadNamePrefix) {
      this.cacheManager = cacheManager;
      this.isGlobalStatsEnabled = cacheManager != null ? cacheManager.getCacheManagerConfiguration().globalJmxStatistics().enabled() : false;
      this.acceptedChannels = acceptedChannels;
      this.threadNamePrefix = threadNamePrefix;
   }
","   public NettyTransportConnectionStats(EmbeddedCacheManager cacheManager, ChannelGroup acceptedChannels, String threadNamePrefix) {
      this.cacheManager = cacheManager;
START       this.isGlobalStatsEnabled = cacheManager != null ? cacheManager.getCacheManagerConfiguration().globalJmxStatistics().enabled() : false; END 
      this.acceptedChannels = acceptedChannels;
      this.threadNamePrefix = threadNamePrefix;
   }
","   public NettyTransportConnectionStats(EmbeddedCacheManager cacheManager, ChannelGroup acceptedChannels, String threadNamePrefix) {
      this.cacheManager = cacheManager;
      this.isGlobalStatsEnabled = cacheManager != null && cacheManager.getCacheManagerConfiguration().globalJmxStatistics().enabled();
      this.acceptedChannels = acceptedChannels;
      this.threadNamePrefix = threadNamePrefix;
   }
"
267,"I don't like putting a synchronized block in the line of fire on something like this that doesn't need to be.

This is a global lock and exactly the type of stuff I find in our production environments.","    public static Scheduler computation() {
        synchronized (computationGuard) {
            if (computationScheduler == null) {
                Scheduler c = RxJavaPlugins.getInstance().getSchedulersHook().getComputationScheduler();
                if (c != null) {
                    computationScheduler = c;
                } else {
                    computationScheduler = new EventLoopsScheduler();
                }
            }
            return computationScheduler;
        }
    }
","    public static Scheduler computation() {
START         synchronized (computationGuard) { END 
            if (computationScheduler == null) {
                Scheduler c = RxJavaPlugins.getInstance().getSchedulersHook().getComputationScheduler();
                if (c != null) {
                    computationScheduler = c;
                } else {
                    computationScheduler = new EventLoopsScheduler();
                }
            }
            return computationScheduler;
        }
    }
","    public static Scheduler computation() {
        Scheduler s = computationScheduler;
        if (s != null) {
            return s;
        }
        synchronized (computationGuard) {
            if (computationScheduler == null) {
                Scheduler c = RxJavaPlugins.getInstance().getSchedulersHook().getComputationScheduler();
                if (c != null) {
                    computationScheduler = c;
                } else {
                    computationScheduler = new EventLoopsScheduler();
                }
            }
            return computationScheduler;
        }
    }
"
268,missing return,"    public Change munge(String entityId, Collection<Statement> statements) {
        munge(entityId, statements, emptySet(), emptySet(), null, null);
    }
","    public Change munge(String entityId, Collection<Statement> statements) {
        START  munge(entityId, END  statements, emptySet(), emptySet(), null, null);
    }
","    public Change munge(String entityId, Collection<Statement> statements) {
        return munge(entityId, statements, emptySet(), emptySet(), null, null);
    }
"
269,The whole point of the SizeLimitedVector is that you can append as many things to it as you like but it only stores the last X amount.,"    public void testMaxSizePassed() throws ArrayIndexOutOfBoundsException {
        try{SizeLimitedVector slv = new SizeLimitedVector(1);
        slv.add(13);
        slv.add(14);
        }
        catch (ArrayIndexOutOfBoundsException e) {
            fail(""array capacity is passed, capacity was 1, but 2 elements got added"");
        }

    }
","    public void testMaxSizePassed() throws ArrayIndexOutOfBoundsException {
START         try{SizeLimitedVector slv = new SizeLimitedVector(1);
        slv.add(13);
        slv.add(14);
        }
        catch (ArrayIndexOutOfBoundsException e) {
            fail(""array capacity is passed, capacity was 1, but 2 elements got added"");
        } END 

    }
","    public void testMaxSizePassed() throws ArrayIndexOutOfBoundsException {
        SizeLimitedVector slv = new SizeLimitedVector(1);
        slv.add(13);
        slv.add(14);
        assertEquals(slv.get(0), 14);

    }
"
270,Again I don't think this log message adds much.,"    public Double getTotalCpuReqTask(ExecutorDetails exec) {
        if (hasExecInTopo(exec)) {
            return _resourceList
                    .get(exec)
                    .get(Config.TOPOLOGY_COMPONENT_CPU_PCORE_PERCENT);
        }
        LOG.warn(""cannot find - {}"", exec);
        return null;
    }
","    public Double getTotalCpuReqTask(ExecutorDetails exec) {
        if (hasExecInTopo(exec)) {
            return _resourceList
                    .get(exec)
                    .get(Config.TOPOLOGY_COMPONENT_CPU_PCORE_PERCENT);
        }
START         LOG.warn(""cannot find - {}"", exec); END 
        return null;
    }
","    public Double getTotalCpuReqTask(ExecutorDetails exec) {
        if (hasExecInTopo(exec)) {
            return _resourceList
                    .get(exec)
                    .get(Config.TOPOLOGY_COMPONENT_CPU_PCORE_PERCENT);
        }
        return null;
    }
"
271,Perhaps try-with-resources? And there are also tabs here that could be fixed.,"	public static void writeStyle(final InputStream in, final Resource styleFile)
			throws IOException {
		BufferedOutputStream out = null;
		try {
			out = new BufferedOutputStream(styleFile.out());
			IOUtils.copy(in, out);
			out.flush();
		} finally {
			out.close();
		}
	}
","	public static void writeStyle(final InputStream in, final Resource styleFile)
			throws IOException {
		BufferedOutputStream out = null;
		try {
			out = new BufferedOutputStream(styleFile.out());
			IOUtils.copy(in, out);
			out.flush();
		} finally {
START 			out.close(); END 
		}
	}
","    public static void writeStyle(final InputStream in, final Resource styleFile)
            throws IOException {
        try (BufferedOutputStream out = new BufferedOutputStream(styleFile.out())) {
            IOUtils.copy(in, out);
            out.flush();
        } 
    }
"
272,"Please dont use this {0} , and use String.format instead.","    private void RestoreVmFromBaseSnapshot(VM vm) {
        if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getId()).size() > 0) {
            log.infoFormat(""Deleting snapshots for stateless vm {0}"", vm.getId());
            Backend.getInstance().runInternalAction(VdcActionType.RestoreStatelessVm,
                    new VmOperationParameterBase(vm.getId()),
                    new CommandContext(getCompensationContext()));
        }
    }
","    private void RestoreVmFromBaseSnapshot(VM vm) {
        if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getId()).size() > 0) {
START             log.infoFormat(""Deleting snapshots for stateless vm {0}"", vm.getId()); END 
            Backend.getInstance().runInternalAction(VdcActionType.RestoreStatelessVm,
                    new VmOperationParameterBase(vm.getId()),
                    new CommandContext(getCompensationContext()));
        }
    }
","    private void RestoreVmFromBaseSnapshot(VM vm) {
        if (getDiskImageDAO().getAllStatelessVmImageMapsForVm(vm.getId()).size() > 0) {
            log.infoFormat(""Deleting snapshots for stateless vm {0}"", vm.getId());
            Backend.getInstance().runInternalAction(VdcActionType.RestoreStatelessVm,
                    new VmOperationParameterBase(vm.getId()),
                    new CommandContext(getCompensationContext()));
        }
    }
"
273,"Please use Map<?,?>","  public void setParams(Object[] params) {
    if (params.length != 1) {
      throw new IllegalArgumentException(""expecting one parameter"");
    }
    setParams((Map<Object, Number>) params[0]);
  }
","  public void setParams(Object[] params) {
    if (params.length != 1) {
      throw new IllegalArgumentException(""expecting one parameter"");
    }
START     setParams((Map<Object, Number>) params[0]); END 
  }
","  public void setParams(Object[] params) {
    if (params.length != 1) {
      throw new IllegalArgumentException(""expecting one parameter"");
    }
    setParams((Map<?, ?>) params[0]);
  }
"
274,No `super();` needed.,"	public LuceneAnalysisDefinitionTranslationMapBuilder(Class<D> targetClass) {
		super();
		this.targetClass = targetClass;
	}
","	public LuceneAnalysisDefinitionTranslationMapBuilder(Class<D> targetClass) {
START 		super(); END 
		this.targetClass = targetClass;
	}
","	public LuceneAnalysisDefinitionTranslationMapBuilder(Class<D> targetClass) {
		this.targetClass = targetClass;
	}
"
275,"Introduction 5 seconds delay in a test seems like a lot, maybe instead we could create a new `AtomicInteger successfullRequests = simultaneousRequests`, increment it in every successful session execute, and change the sleep to:
`awaitUntil( () successfullRequests == simultaneousRequests)`? The test will keep the characteristic because we will be waiting until all succeed OR error will happen. wdyt?","  public void should_balance_requests_across_connections() throws InterruptedException {
    // Generate just the right load to completely fill the pool. All requests should succeed.
    int simultaneousRequests = POOL_SIZE * REQUESTS_PER_CONNECTION;

    for (int i = 0; i < simultaneousRequests; i++) {
      reschedule(null, null);
    }
    SECONDS.sleep(5);
    done.countDown();

    Throwable unexpectedError = unexpectedErrorRef.get();
    if (unexpectedError != null) {
      fail(""At least one request failed unexpectedly"", unexpectedError);
    }
  }
","  public void should_balance_requests_across_connections() throws InterruptedException {
    // Generate just the right load to completely fill the pool. All requests should succeed.
    int simultaneousRequests = POOL_SIZE * REQUESTS_PER_CONNECTION;

    for (int i = 0; i < simultaneousRequests; i++) {
      reschedule(null, null);
    }
START     SECONDS.sleep(5); END 
    done.countDown();

    Throwable unexpectedError = unexpectedErrorRef.get();
    if (unexpectedError != null) {
      fail(""At least one request failed unexpectedly"", unexpectedError);
    }
  }
","  public void should_balance_requests_across_connections() throws InterruptedException {
    // Generate just the right load to completely fill the pool. All requests should succeed.
    int simultaneousRequests = POOL_SIZE * REQUESTS_PER_CONNECTION;

    for (int i = 0; i < simultaneousRequests; i++) {
      reschedule(null, null);
    }
    SECONDS.sleep(1);
    done.countDown();

    Throwable unexpectedError = unexpectedErrorRef.get();
    if (unexpectedError != null) {
      fail(""At least one request failed unexpectedly"", unexpectedError);
    }
  }
"
276,"```
assertTrue(b);
```","    public void generateSourceMaps() throws Exception
    {
        when(xwikiPropertiesSource.getProperty(""lesscss.generateInlineSourceMaps"", false)).thenReturn(true);
        boolean b  = mocker.getComponentUnderTest().isGenerateInlineSourceMaps();
        assertTrue(b == true);
    }
","    public void generateSourceMaps() throws Exception
    {
        when(xwikiPropertiesSource.getProperty(""lesscss.generateInlineSourceMaps"", false)).thenReturn(true);
        boolean b  = mocker.getComponentUnderTest().isGenerateInlineSourceMaps();
START         assertTrue(b == true); END 
    }
","    public void generateSourceMaps() throws Exception
    {
        when(xwikiPropertiesSource.getProperty(""lesscss.generateInlineSourceMaps"", false)).thenReturn(true);
        boolean b  = mocker.getComponentUnderTest().isGenerateInlineSourceMaps();
        assertTrue(b);
    }
"
277,"i don't think that `formPresenterSupport` can be `null`.
If i miss something, then these null checks must be also added to `dispose` method","	private IStatus getFormPresenterStatus() {
		IStatus saveStatus = Status.OK_STATUS;
		if (formPresenterSupport != null
				&& formPresenterSupport.getCurrentStatus() != null) {
			saveStatus = formPresenterSupport.getCurrentStatus();
		}
		return saveStatus;
	}
","	private IStatus getFormPresenterStatus() {
		IStatus saveStatus = Status.OK_STATUS;
		if (formPresenterSupport != null
				&& formPresenterSupport.getCurrentStatus() != null) {
			saveStatus = formPresenterSupport.getCurrentStatus();
		}
START 		return saveStatus; END 
	}
","	private IStatus getFormPresenterStatus() {
		IStatus status = Status.OK_STATUS;
		if (formPresenterSupport.getCurrentStatus() != null) {
			status = formPresenterSupport.getCurrentStatus();
		}
		return status;
	}
"
278,"Put `""cache-"" + getName()` in a local variable to avoid repetition.","    protected void fallbackOnDefaultCache() {
        CacheService cacheService = Framework.getService(CacheService.class);
        if (cacheService != null) {
            if (descriptor.cacheEntryName == null) {
                cache.setEntryCacheName(""cache-"" + getName());
                cacheService.registerCache(""cache-"" + getName());
            }
            if (descriptor.cacheEntryWithoutReferencesName == null) {
                cache.setEntryCacheWithoutReferencesName(""cacheWithoutReference-"" + getName());
                cacheService.registerCache(""cacheWithoutReference-"" + getName());
            }
        }
    }
","    protected void fallbackOnDefaultCache() {
        CacheService cacheService = Framework.getService(CacheService.class);
        if (cacheService != null) {
            if (descriptor.cacheEntryName == null) {
                cache.setEntryCacheName(""cache-"" + getName());
START                 cacheService.registerCache(""cache-"" + getName()); END 
            }
            if (descriptor.cacheEntryWithoutReferencesName == null) {
                cache.setEntryCacheWithoutReferencesName(""cacheWithoutReference-"" + getName());
                cacheService.registerCache(""cacheWithoutReference-"" + getName());
            }
        }
    }
","    protected void fallbackOnDefaultCache() {
        CacheService cacheService = Framework.getService(CacheService.class);
        if (cacheService != null) {
            if (descriptor.cacheEntryName == null) {
                String cacheEntryName = ""cache-"" + getName();
                cache.setEntryCacheName(cacheEntryName);
                cacheService.registerCache(cacheEntryName);
            }
            if (descriptor.cacheEntryWithoutReferencesName == null) {
                String cacheEntryWithoutReferencesName = ""cacheWithoutReference-"" + getName();
                cache.setEntryCacheWithoutReferencesName(cacheEntryWithoutReferencesName);
                cacheService.registerCache(cacheEntryWithoutReferencesName);
            }
        }
    }
"
279,There is no reason for these formatting changes,"    public void addInformation(ItemStack stack, World world, List<String> tooltip, ITooltipFlag flag) {
        if (stack.hasTagCompound()) {
            Binding binding = getBinding(stack);
            if (binding != null) {
                tooltip.add(new TextComponentTranslation(""tooltip.bloodmagic.currentOwner"", binding.getOwnerName()).getFormattedText());
            }
        }
    }
","    public void addInformation(ItemStack stack, World world, List<String> tooltip, ITooltipFlag flag) {
START         if (stack.hasTagCompound()) { END 
            Binding binding = getBinding(stack);
            if (binding != null) {
                tooltip.add(new TextComponentTranslation(""tooltip.bloodmagic.currentOwner"", binding.getOwnerName()).getFormattedText());
            }
        }
    }
","    public void addInformation(ItemStack stack, World world, List<String> tooltip, ITooltipFlag flag) {
        if (!stack.hasTagCompound())
            return;

        Binding binding = getBinding(stack);
        if (binding != null)
            tooltip.add(new TextComponentTranslation(""tooltip.bloodmagic.currentOwner"", binding.getOwnerName()).getFormattedText());
    }
"
280,"There no whitespace around `<=`.
Also - good to enclose blocks of that that if/else in {}.","    private static String normaliseTypeName(String dataType) {
        if (dataType.indexOf(""("")<=0) 
           dataType = dataType.toUpperCase().trim();
        else
           dataType = dataType.toUpperCase().trim().substring(0,dataType.indexOf(""(""));
        return dataType;
    }
","    private static String normaliseTypeName(String dataType) {
START         if (dataType.indexOf(""("")<=0)  END 
           dataType = dataType.toUpperCase().trim();
        else
           dataType = dataType.toUpperCase().trim().substring(0,dataType.indexOf(""(""));
        return dataType;
    }
","    private static String normaliseTypeName(String dataType) {
        if (dataType.indexOf(""("") <= 0) {
           dataType = dataType.toUpperCase().trim();
        } else {
           dataType = dataType.toUpperCase().trim().substring(0,dataType.indexOf(""(""));
        }
        return dataType;
    }
"
281,private,"    public String sendHttpGetToBroker(String table, String path)
    {
        return doHttpActionWithHeaders(
                Request.builder().prepareGet().setUri(URI.create(String.format(""http://%s/%s"", getBrokerHost(table), path))),
                Optional.empty(),
                Optional.empty());
    }
","START     public String sendHttpGetToBroker(String table, String path) END 
    {
        return doHttpActionWithHeaders(
                Request.builder().prepareGet().setUri(URI.create(String.format(""http://%s/%s"", getBrokerHost(table), path))),
                Optional.empty(),
                Optional.empty());
    }
","    private String sendHttpGetToBroker(String table, String path)
    {
        return doHttpActionWithHeaders(
                Request.builder().prepareGet().setUri(URI.create(String.format(""http://%s/%s"", getBrokerHost(table), path))),
                Optional.empty(),
                Optional.empty());
    }
"
282,Not sure if this would be the best place to print it.  I was thinking it may be useful to print which config file it ended up using.,"  public FluoConfiguration resolveFluoConfiguration(String appName) {
    try {
      return getAppConfiguration(appName);
    } catch (FluoException e) {
      FluoConfiguration config = new FluoConfiguration(getFluoConfiguration());
      config.setApplicationName(appName);
      return config;
    }
  }
","START   public FluoConfiguration resolveFluoConfiguration(String appName) { END 
    try {
      return getAppConfiguration(appName);
    } catch (FluoException e) {
      FluoConfiguration config = new FluoConfiguration(getFluoConfiguration());
      config.setApplicationName(appName);
      return config;
    }
  }
","  public FluoConfiguration resolveFluoConfiguration(String appName) {
    return resolveFluoConfiguration(appName, true);
  }
"
283,This variable is useless. Please just use `return` in your `if/…` branches.,"    public String getCachedString() {
        String rv;

        if (variableData.expression == null || variableData.expression.length() == 0)
            rv = ""_"";
        else if (Double.isNaN(getCachedValue()))
            rv = ""*"";
        else
            rv = """" + (int) getCachedValue();

        return rv;
    }
","    public String getCachedString() {
START         String rv; END 

        if (variableData.expression == null || variableData.expression.length() == 0)
            rv = ""_"";
        else if (Double.isNaN(getCachedValue()))
            rv = ""*"";
        else
            rv = """" + (int) getCachedValue();

        return rv;
    }
","    public String getCachedString() {
        final String rv;

        if (variableData.expression == null || variableData.expression.length() == 0) {
            rv = ""_"";
        } else if (Double.isNaN(getCachedValue())) {
            rv = ""*"";
        } else {
            rv = String.valueOf((int) getCachedValue());
        }

        return rv;
    }
"
284,Please use {} even for one line if clauses.,"	public static boolean anyRunning() {
		IConsole ic[] = ConsolePlugin.getDefault().getConsoleManager().getConsoles();
		ScriptConsole console;

		for(int i=0; i<ic.length; i++) {
			if (ic[i] instanceof ScriptConsole){
				console = (ScriptConsole)ic[i];
				if(console.isRunning())
					return true;
			}
		}
		return false;
	}
","	public static boolean anyRunning() {
		IConsole ic[] = ConsolePlugin.getDefault().getConsoleManager().getConsoles();
		ScriptConsole console;

		for(int i=0; i<ic.length; i++) {
			if (ic[i] instanceof ScriptConsole){
				console = (ScriptConsole)ic[i];
				if(console.isRunning())
START 					return true; END 
			}
		}
		return false;
	}
","	public static boolean anyRunning() {
		IConsole ic[] = ConsolePlugin.getDefault().getConsoleManager().getConsoles();
		ScriptConsole console;

		for(int i=0; i<ic.length; i++) {
			if (ic[i] instanceof ScriptConsole){
				console = (ScriptConsole)ic[i];
				if(console.isRunning()){
					return true;
				}
			}
		}
		return false;
	}
"
285,"oups, bad rebase.","    private void checkVersionForProfileLI(PackageSetting ps, PackageParser.Package pkg) {
        if (isUpgrade() && ps != null && pkg != null) {
            if (ps.versionCode != pkg.mVersionCode) {
                Slog.d(TAG, ps.name + "" clear profile due to version change "" +
                    ps.versionCode + "" != "" + pkg.mVersionCode);
                clearAppProfilesLIF(pkg, UserHandle.USER_ALL);
                return true;
            }
            if (DEBUG_INSTALL) {
              Slog.d(TAG, ""Package "" + ps.name + "" keep profile"");
            }
        }
    }
","    private void checkVersionForProfileLI(PackageSetting ps, PackageParser.Package pkg) {
        if (isUpgrade() && ps != null && pkg != null) {
            if (ps.versionCode != pkg.mVersionCode) {
                Slog.d(TAG, ps.name + "" clear profile due to version change "" +
                    ps.versionCode + "" != "" + pkg.mVersionCode);
                clearAppProfilesLIF(pkg, UserHandle.USER_ALL);
            START   END     return true;
            }
            if (DEBUG_INSTALL) {
              Slog.d(TAG, ""Package "" + ps.name + "" keep profile"");
            }
        }
    }
","    private void checkVersionForProfileLI(PackageSetting ps, PackageParser.Package pkg) {
        if (isUpgrade() && ps != null && pkg != null) {
            if (ps.versionCode != pkg.mVersionCode) {
                Slog.d(TAG, ps.name + "" clear profile due to version change "" +
                    ps.versionCode + "" != "" + pkg.mVersionCode);
                clearAppProfilesLIF(pkg, UserHandle.USER_ALL);
                return;
            }
            if (DEBUG_INSTALL) {
              Slog.d(TAG, ""Package "" + ps.name + "" keep profile"");
            }
        }
    }
"
286,"```suggestion
                RealmLog.info(""Log out user "" + user.getEmail());
```","    RealmAsyncTask logOutAsync(RealmUser user, Callback<RealmUser> callback) {
        checkLooperThread(""Asynchronous log out is only possible from looper threads."");
        return new Request<RealmUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
            @Override
            public RealmUser run() throws ObjectServerError {
                RealmLog.error(""Log out user"");
                logOut(user);
                return user;
            }
        }.start();
    }
","    RealmAsyncTask logOutAsync(RealmUser user, Callback<RealmUser> callback) {
        checkLooperThread(""Asynchronous log out is only possible from looper threads."");
        return new Request<RealmUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
            @Override
            public RealmUser run() throws ObjectServerError {
START                 RealmLog.error(""Log out user""); END 
                logOut(user);
                return user;
            }
        }.start();
    }
","    RealmAsyncTask logOutAsync(RealmUser user, Callback<RealmUser> callback) {
        checkLooperThread(""Asynchronous log out is only possible from looper threads."");
        return new Request<RealmUser>(SyncManager.NETWORK_POOL_EXECUTOR, callback) {
            @Override
            public RealmUser run() throws ObjectServerError {
                logOut(user);
                return user;
            }
        }.start();
    }
"
287,please put the @Override annotation on its own line,"    @Override protected Map<String, Pair<String, String>> getExclusiveLocks() {
        final LockMessage lockMessage = createLockMessage();
        return templatesLockedForUpdate.stream()
                .collect(Collectors.toMap(
                        template -> template.getId().toString(),
                        template -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, lockMessage)));
    }
","    START  @Override END  protected Map<String, Pair<String, String>> getExclusiveLocks() {
        final LockMessage lockMessage = createLockMessage();
        return templatesLockedForUpdate.stream()
                .collect(Collectors.toMap(
                        template -> template.getId().toString(),
                        template -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, lockMessage)));
    }
","    protected Map<String, Pair<String, String>> getExclusiveLocks() {
        final LockMessage lockMessage = createLockMessage();
        return templatesLockedForUpdate.stream()
                .collect(Collectors.toMap(
                        template -> template.getId().toString(),
                        template -> LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, lockMessage)));
    }
"
288,"imo this should be added only when it's needed by the message,
theres no need to add the disk alias if we get a message that the vm isn't down for example..as we do for all the messages.","    protected void setActionMessageParameters() {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__HOT_PLUG);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_DISK);

        if (getDisk() != null) {
            addCanDoActionMessage(String.format(""$%1$s %2$s"", ""diskAliases"", getDiskAlias()));
        }
    }
","    protected void setActionMessageParameters() {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__HOT_PLUG);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_DISK);

        if (getDisk() != null) {
            addCanDoActionMessage(String.format(""$%1$s %2$s"", ""diskAliases"", getDiskAlias()));
START         } END 
    }
","    protected void setActionMessageParameters() {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__HOT_PLUG);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_DISK);
    }
"
289,could be `final`.,"  public <B> Eval<B> map(final F<A, B> f) {
    return bind(a -> now(f.f(a)));
  }
","START   public <B> Eval<B> map(final F<A, B> f) { END 
    return bind(a -> now(f.f(a)));
  }
","  public final <B> Eval<B> map(final F<A, B> f) {
    return bind(a -> now(f.f(a)));
  }
"
290,Remove the 'this' qualifier .,"  protected PhysicalOperator getNewWithChild(PhysicalOperator child) {
    return new IteratorValidator(child, this.isRepeatable);
  }
","  protected PhysicalOperator getNewWithChild(PhysicalOperator child) {
START     return new IteratorValidator(child, this.isRepeatable); END 
  }
","  protected PhysicalOperator getNewWithChild(PhysicalOperator child) {
    return new IteratorValidator(child, isRepeatable);
  }
"
291,does `LockList#getInodes` already make a copy?,"  public synchronized List<Inode<?>> getInodeList() {
    return Lists.newArrayList(mLockList.getInodes());
  }
","  public synchronized List<Inode<?>> getInodeList() {
START     return Lists.newArrayList(mLockList.getInodes()); END 
  }
","  public synchronized List<Inode<?>> getInodeList() {
    return mLockList.getInodes();
  }
"
292,And here return the proper ID as well - you're trying to mimic real behavior.,"    private void setupNetworkDao() {
        when(getDbFacadeMockInstance().getNetworkDao()).thenReturn(networkDaoMock);
        when(networkDaoMock.get(networkId)).thenReturn((networkMocked));
        when(networkMocked.getQosId()).thenReturn(null);
    }
","    private void setupNetworkDao() {
        when(getDbFacadeMockInstance().getNetworkDao()).thenReturn(networkDaoMock);
        when(networkDaoMock.get(networkId)).thenReturn((networkMocked));
START         when(networkMocked.getQosId()).thenReturn(null); END 
    }
","    private void setupNetworkDao() {
        when(getDbFacadeMockInstance().getNetworkDao()).thenReturn(networkDaoMock);
        when(networkDaoMock.get(networkId)).thenReturn((networkMocked));
    }
"
293,shouldn't actual <--> expected be replaced here as well ?,"    public void checkStorageDomainNotEqualWithStatusActive() {
        setStorageDomainStatus(StorageDomainStatus.Active);
        assertFalse(cmd.checkStorageDomainStatusNotEqual(StorageDomainStatus.Active));
        List<String> messages = cmd.getReturnValue().getCanDoActionMessages();
        assertEquals(2, messages.size());
        assertEquals(messages.get(0), VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2.toString());
        assertEquals(messages.get(1), String.format(""$status %1$s"", StorageDomainStatus.Active));
    }
","    public void checkStorageDomainNotEqualWithStatusActive() {
        setStorageDomainStatus(StorageDomainStatus.Active);
        assertFalse(cmd.checkStorageDomainStatusNotEqual(StorageDomainStatus.Active));
        List<String> messages = cmd.getReturnValue().getCanDoActionMessages();
START         assertEquals(2, messages.size()); END 
        assertEquals(messages.get(0), VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2.toString());
        assertEquals(messages.get(1), String.format(""$status %1$s"", StorageDomainStatus.Active));
    }
","    public void checkStorageDomainNotEqualWithStatusActive() {
        setStorageDomainStatus(StorageDomainStatus.Active);
        assertFalse(cmd.checkStorageDomainStatusNotEqual(StorageDomainStatus.Active));
        List<String> messages = cmd.getReturnValue().getCanDoActionMessages();
        assertEquals(2, messages.size());
        assertEquals(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2.toString(), messages.get(0));
        assertEquals(String.format(""$status %1$s"", StorageDomainStatus.Active), messages.get(1));
    }
"
294,this can be replaced by `textToDisplay.isEmpty()`,"	public ShowBubbleActor createBubbleActor() throws InterpretationException {
		String textToDisplay = text == null ? """" : text.interpretString(sprite);
		if (textToDisplay.equals("""")) {
			return null;
		}
		return new ShowBubbleActor(textToDisplay, sprite, type);
	}
","	public ShowBubbleActor createBubbleActor() throws InterpretationException {
		String textToDisplay = text == null ? """" : text.interpretString(sprite);
START 		if (textToDisplay.equals("""")) { END 
			return null;
		}
		return new ShowBubbleActor(textToDisplay, sprite, type);
	}
","	public ShowBubbleActor createBubbleActor() throws InterpretationException {
		String textToDisplay = text == null ? """" : text.interpretString(sprite);
		if (textToDisplay.isEmpty()) {
			return null;
		}
		return new ShowBubbleActor(textToDisplay, sprite, type);
	}
"
295,Maybe remove the package name as it is already in the import statements.,"	public List<String> getGroupsForUser(String userId) {
		
		List<String> groups = groupStore.get(userId);
		if( groups == null ) { 
		    groups = new ArrayList<String>(0);
		}
		return new java.util.ArrayList<String>(groups);
	}
","	public List<String> getGroupsForUser(String userId) {
		
		List<String> groups = groupStore.get(userId);
		if( groups == null ) { 
		    groups = new ArrayList<String>(0);
		}
START 		return new java.util.ArrayList<String>(groups); END 
	}
","	public List<String> getGroupsForUser(String userId) {
		
		List<String> groups = groupStore.get(userId);
		if( groups == null ) { 
		    groups = new ArrayList<String>(0);
		}
		return new ArrayList<String>(groups);
	}
"
296,please leave it that way - it's intentionally referencing the deprecated version.,"    public FlashScope getFlashCookie() {
        return wrapped.getFlashScope();
    }
","    public FlashScope getFlashCookie() {
START         return wrapped.getFlashScope(); END 
    }
","    public FlashScope getFlashCookie() {
        return wrapped.getFlashCookie();
    }
"
297,style nit: no braces around single line blocks,"	public Object execute(ExecutionEvent event) throws ExecutionException {
		Repository repository = getRepository(event);
		if (repository == null) {
			return null;
		}

		PushToGerritWizard wiz = new PushToGerritWizard(repository);
		WizardDialog dlg = new WizardDialog(HandlerUtil
				.getActiveShellChecked(event), wiz);
		dlg.setHelpAvailable(false);
		dlg.open();
		return null;
	}
","	public Object execute(ExecutionEvent event) throws ExecutionException {
		Repository repository = getRepository(event);
START 		if (repository == null) { END 
			return null;
		}

		PushToGerritWizard wiz = new PushToGerritWizard(repository);
		WizardDialog dlg = new WizardDialog(HandlerUtil
				.getActiveShellChecked(event), wiz);
		dlg.setHelpAvailable(false);
		dlg.open();
		return null;
	}
","	public Object execute(ExecutionEvent event) throws ExecutionException {
		Repository repository = getRepository(event);
		if (repository == null)
			return null;

		PushToGerritWizard wiz = new PushToGerritWizard(repository);
		WizardDialog dlg = new WizardDialog(HandlerUtil
				.getActiveShellChecked(event), wiz);
		dlg.setHelpAvailable(false);
		dlg.open();
		return null;
	}
"
298,I think we can remove the streamAddresses field,"    public WriteRequest(ByteBuf buf) {
        writeMode = ICorfuPayload.fromBuffer(buf, WriteMode.class);
        streamAddresses = null;
        data = ICorfuPayload.fromBuffer(buf, LogData.class);
    }
","    public WriteRequest(ByteBuf buf) {
        writeMode = ICorfuPayload.fromBuffer(buf, WriteMode.class);
START         streamAddresses = null; END 
        data = ICorfuPayload.fromBuffer(buf, LogData.class);
    }
","    public WriteRequest(ByteBuf buf) {
        writeMode = ICorfuPayload.fromBuffer(buf, WriteMode.class);
        data = ICorfuPayload.fromBuffer(buf, LogData.class);
    }
"
299,"Do we need the `assertTrueEventually()` in these methods? In the concrete tests a reference is obtained to the stats instance, which means, by the time the operations return the stats instance is updated.","    protected void assertSameLastUpdateTime() {
        assertTrueEventually(() -> {
            long lastUpdateTime = localCollectionStats.getLastUpdateTime();
            assertEqualsStringFormat(""Expected the lastUpdateTime to be %d, but was %d"", previousUpdateTime, lastUpdateTime);
            previousUpdateTime = lastUpdateTime;
        });
    }
","    protected void assertSameLastUpdateTime() {
        assertTrueEventually(() -> {
START             long lastUpdateTime = localCollectionStats.getLastUpdateTime(); END 
            assertEqualsStringFormat(""Expected the lastUpdateTime to be %d, but was %d"", previousUpdateTime, lastUpdateTime);
            previousUpdateTime = lastUpdateTime;
        });
    }
","    protected void assertSameLastUpdateTime() {
        long lastUpdateTime = localCollectionStats.getLastUpdateTime();
        assertEqualsStringFormat(""Expected the lastUpdateTime to be %d, but was %d"", previousUpdateTime, lastUpdateTime);
        previousUpdateTime = lastUpdateTime;
    }
"
300,Missing ! operator,"    public List<RepoImage> getUserRequestForStorageDomainRepoFileList(Guid storageDomainId,
            ImageFileType imageType,
            boolean forceRefresh) {
        // Query for storageDoaminId is looking for Active ISO domain
        if (!isStorageDomainIdValid(storageDomainId)) {
            throw new EngineException(EngineError.GetIsoListError);
        }

        if (forceRefresh) {
            if (refreshRepos(storageDomainId, imageType)) {
                throw new EngineException(EngineError.IMAGES_NOT_SUPPORTED_ERROR);
            }
        }
        else {
            refreshReposIfIntervalPassed(storageDomainId, imageType);
        }
        // In any case, whether refreshed or not, get Iso list from the cache.
        return getCachedIsoListByDomainId(storageDomainId, imageType);
    }
","    public List<RepoImage> getUserRequestForStorageDomainRepoFileList(Guid storageDomainId,
            ImageFileType imageType,
            boolean forceRefresh) {
        // Query for storageDoaminId is looking for Active ISO domain
        if (!isStorageDomainIdValid(storageDomainId)) {
            throw new EngineException(EngineError.GetIsoListError);
        }

        if (forceRefresh) {
START             if (refreshRepos(storageDomainId, imageType)) { END 
                throw new EngineException(EngineError.IMAGES_NOT_SUPPORTED_ERROR);
            }
        }
        else {
            refreshReposIfIntervalPassed(storageDomainId, imageType);
        }
        // In any case, whether refreshed or not, get Iso list from the cache.
        return getCachedIsoListByDomainId(storageDomainId, imageType);
    }
","    public List<RepoImage> getUserRequestForStorageDomainRepoFileList(Guid storageDomainId,
            ImageFileType imageType,
            boolean forceRefresh) {
        // Query for storageDoaminId is looking for Active ISO domain
        if (!isStorageDomainIdValid(storageDomainId)) {
            throw new EngineException(EngineError.GetIsoListError);
        }

        if (forceRefresh) {
            if (!refreshRepos(storageDomainId, imageType)) {
                throw new EngineException(EngineError.IMAGES_NOT_SUPPORTED_ERROR);
            }
        }
        else {
            refreshReposIfIntervalPassed(storageDomainId, imageType);
        }
        // In any case, whether refreshed or not, get Iso list from the cache.
        return getCachedIsoListByDomainId(storageDomainId, imageType);
    }
"
301,"I wouldn't get the display here. It forces you to have a ModelAwareGitSynchronizer(Display) constructor even though that class itself doesn't need it.

I'd just go with parameterless constructors, and use PlatformUI.getWorkbench().getDisplay() in DefaultGitSynchronizer.openGitTreeCompare() instead.","	private static GitSynchronizer getSynchronizer() {
		Display display = Display.getCurrent();
		Assert.isNotNull(display);
		if (Activator.getDefault().getPreferenceStore()
				.getBoolean(UIPreferences.USE_LOGICAL_MODEL)) {
			return new ModelAwareGitSynchronizer(display);
		}
		return new DefaultGitSynchronizer(display);
	}
","	private static GitSynchronizer getSynchronizer() {
		Display display = Display.getCurrent();
		Assert.isNotNull(display);
		if (Activator.getDefault().getPreferenceStore()
				.getBoolean(UIPreferences.USE_LOGICAL_MODEL)) {
			return new ModelAwareGitSynchronizer(display);
		}
START 		return new DefaultGitSynchronizer(display); END 
	}
","	private static GitSynchronizer getSynchronizer() {
		if (Activator.getDefault().getPreferenceStore()
				.getBoolean(UIPreferences.USE_LOGICAL_MODEL)) {
			return new ModelAwareGitSynchronizer();
		}
		return new DefaultGitSynchronizer();
	}
"
302,Why is the synchronized block here within the 'try' part of the try-catch block? Shouldn't the 'catch' part also run in the synchronized block ?,"   public long getAvgExecutionTime() {
      long avgExecTime = -1;

      try
      {
         synchronized (this)
         {
            avgExecTime = totalExecutionTime / invocationCnt;
         }
      } catch (Exception e) {

         if (invocationCnt == 0 && totalExecutionTime == 0)
         {
            avgExecTime = 0;
         }
      }
      return avgExecTime;
   }
","   public long getAvgExecutionTime() {
      long avgExecTime = -1;

      try
      {
         synchronized (this)
         {
            avgExecTime = totalExecutionTime / invocationCnt;
START          } END 
      } catch (Exception e) {

         if (invocationCnt == 0 && totalExecutionTime == 0)
         {
            avgExecTime = 0;
         }
      }
      return avgExecTime;
   }
","   public long getAvgExecutionTime() {
      long avgExecTime = -1;
      synchronized (this)
      {
         try
         {
            avgExecTime = totalExecutionTime / invocationCnt;
         } catch (Exception e)
         {

            if (invocationCnt == 0 && totalExecutionTime == 0)
            {
               avgExecTime = 0;
            }
         }
      }
      return avgExecTime;
   }
"
303,"Technically, you still need to null-check ftrace, just like all other fields, as you never know why the test fails, maybe the first line exploded, this method is still called, but everything is null.","    public void cleanUpEnvironment() {
        fTrace.dispose();
        fScriptingMarkerSource.dispose();
        fScriptingMarkerSource = null;
        fScriptingMarkerSourceFactory.dispose();
        fTraceMarkerScriptingModule = null;
    }
","    public void cleanUpEnvironment() {
START         fTrace.dispose(); END 
        fScriptingMarkerSource.dispose();
        fScriptingMarkerSource = null;
        fScriptingMarkerSourceFactory.dispose();
        fTraceMarkerScriptingModule = null;
    }
","    public void cleanUpEnvironment() {
        if (fTrace != null) {
            fTrace.dispose();
            fTrace = null;
        }
        if (fScriptingMarkerSource != null) {
            fScriptingMarkerSource.dispose();
            fScriptingMarkerSource = null;
        }
        if (fScriptingMarkerSourceFactory != null) {
            fScriptingMarkerSourceFactory.dispose();
            fScriptingMarkerSourceFactory = null;
        }
    }
"
304,This should call .append(formField.getPageNumber()).build();,"		public int hashCode() {
			return HashCodeBuilder.reflectionHashCode(formField.getPageNumber());
		}
","		public int hashCode() {
START 			return HashCodeBuilder.reflectionHashCode(formField.getPageNumber()); END 
		}
","		public int hashCode() {
			return new HashCodeBuilder().append(formField.getPageNumber()).build();
		}
"
305,annotate with nullable.,"  public static byte[] toUtf8(final String string)
  {
    if(string == null){
      return null;
    }
    try {
      return string.getBytes(UTF8_STRING);
    }
    catch (UnsupportedEncodingException e) {
      // Should never happen
      throw Throwables.propagate(e);
    }
  }
","  public static byte[] toUtf8(final String string)
  {
    if(string == null){
START       return null; END 
    }
    try {
      return string.getBytes(UTF8_STRING);
    }
    catch (UnsupportedEncodingException e) {
      // Should never happen
      throw Throwables.propagate(e);
    }
  }
","  public static byte[] toUtf8(final String string)
  {
    try {
      return string.getBytes(UTF8_STRING);
    }
    catch (UnsupportedEncodingException e) {
      // Should never happen
      throw Throwables.propagate(e);
    }
  }
"
306,"I don't think you need this condition. `TranslatorUtils.toDBObjectList` will return an emptylist if the key isn't set, which should then be fine.","    private void decodeLocalizedTitles(DBObject dbObject, Described entity) {
        if (dbObject.containsField(LOCALIZED_TITLES_KEY)) {
            List<DBObject> localisedTitlesDBO = TranslatorUtils.toDBObjectList(dbObject, LOCALIZED_TITLES_KEY);
            
            entity.setLocalizedTitles(Iterables.transform(localisedTitlesDBO, new Function<DBObject, LocalizedTitle>() {
                @Override
                public LocalizedTitle apply(DBObject input) {
                    return localizedTitleTranslator.fromDBObject(input, new LocalizedTitle());
                }
            }));
        }
    }
","    private void decodeLocalizedTitles(DBObject dbObject, Described entity) {
START         if (dbObject.containsField(LOCALIZED_TITLES_KEY)) { END 
            List<DBObject> localisedTitlesDBO = TranslatorUtils.toDBObjectList(dbObject, LOCALIZED_TITLES_KEY);
            
            entity.setLocalizedTitles(Iterables.transform(localisedTitlesDBO, new Function<DBObject, LocalizedTitle>() {
                @Override
                public LocalizedTitle apply(DBObject input) {
                    return localizedTitleTranslator.fromDBObject(input, new LocalizedTitle());
                }
            }));
        }
    }
","    private void decodeLocalizedTitles(DBObject dbObject, Described entity) {
        List<DBObject> localisedTitlesDBO = TranslatorUtils.toDBObjectList(dbObject,
                LOCALIZED_TITLES_KEY);

        entity.setLocalizedTitles(Iterables.transform(localisedTitlesDBO,
                new Function<DBObject, LocalizedTitle>() {

                    @Override
                    public LocalizedTitle apply(DBObject input) {
                        return localizedTitleTranslator.fromDBObject(input, new LocalizedTitle());
                    }
                }));
    }
"
307,Is there a chance of a NPE?  could be getFile() null?,"    public String getText(Object element) {
        if (element instanceof String) {
            return (String) element;
        }
        if (element instanceof FileAndName) {
            return ((FileAndName) element).getFile().getName();
        }
        return null;
    }
","    public String getText(Object element) {
        if (element instanceof String) {
            return (String) element;
        }
        if (element instanceof FileAndName) {
START             return ((FileAndName) element).getFile().getName(); END 
        }
        return null;
    }
","    public String getText(Object element) {
        if (element instanceof String) {
            return (String) element;
        }
        if (element instanceof FileAndName) {
            final File file = ((FileAndName) element).getFile();
            if (file != null) { // should never not happen since file is final
                                // and always set automatically
                return file.getName();
            }
        }
        return null;
    }
"
308,this needs to be a concurrent hashmap.,"  public QueryManager()
  {
    this.queries = Multimaps.synchronizedSetMultimap(
        HashMultimap.<String, ListenableFuture>create()
    );
    this.queryDatasources = Maps.newHashMap();
  }
","  public QueryManager()
  {
    this.queries = Multimaps.synchronizedSetMultimap(
        HashMultimap.<String, ListenableFuture>create()
    );
START     this.queryDatasources = Maps.newHashMap(); END 
  }
","  public QueryManager()
  {
    this.queries = Multimaps.synchronizedSetMultimap(
        HashMultimap.<String, ListenableFuture>create()
    );
    this.queryDatasources = Multimaps.synchronizedSetMultimap(
        HashMultimap.<String, String>create()
    );
  }
"
309,Please make it `final`.,"    public void setProgressMessage(String progressMessage) {
        this.progressMessage = progressMessage;
    }
","START     public void setProgressMessage(String progressMessage) { END 
        this.progressMessage = progressMessage;
    }
","    public final void setProgressMessage(String progressMessage) {
        this.progressMessage = progressMessage;
    }
"
310,"consider being paranoid and prefix with ""line.length() > 0""?","	static String chomp(String line) {
		if (line.charAt(line.length() - 1) == '\n') {
			return line.substring(0, line.length() - 1);
		}
		return line;
	}
","	static String chomp(String line) {
START 		if (line.charAt(line.length() - 1) == '\n') { END 
			return line.substring(0, line.length() - 1);
		}
		return line;
	}
","	static String chomp(String line) {
		if (line != null && !line.isEmpty()
				&& line.charAt(line.length() - 1) == '\n') {
			return line.substring(0, line.length() - 1);
		}
		return line;
	}
"
311,"Since you removed `throw new LauncherStartFailedException();` this method should not throw such an exception anymore.

```suggestion
    private Platform getPlatform() {
```","    private Platform getPlatform() throws LauncherStartFailedException {
        logger.trace(""Init Platform..."");
        updateMessage(BundleUtils.getLabel(""splash_checkOS""));
        final Platform platform = Platform.getPlatform();
        if (!platform.isLinux() && !platform.isMac() && !platform.isWindows()) {
            logger.warn(""Detected unexpected platform: {}"", platform);
        }
        logger.debug(""Platform: {}"", platform);
        return platform;
    }
","START     private Platform getPlatform() throws LauncherStartFailedException { END 
        logger.trace(""Init Platform..."");
        updateMessage(BundleUtils.getLabel(""splash_checkOS""));
        final Platform platform = Platform.getPlatform();
        if (!platform.isLinux() && !platform.isMac() && !platform.isWindows()) {
            logger.warn(""Detected unexpected platform: {}"", platform);
        }
        logger.debug(""Platform: {}"", platform);
        return platform;
    }
","    private Platform getPlatform() {
        logger.trace(""Init Platform..."");
        updateMessage(BundleUtils.getLabel(""splash_checkOS""));
        final Platform platform = Platform.getPlatform();
        if (!platform.isLinux() && !platform.isMac() && !platform.isWindows()) {
            logger.warn(""Detected unexpected platform: {}"", platform);
        }
        logger.debug(""Platform: {}"", platform);
        return platform;
    }
"
312,Can be package-private,"    public SpatialLayoutUnique( CoordinateReferenceSystem crs, SpaceFillingCurve curve )
    {
        super( crs, curve );
    }
","START     public SpatialLayoutUnique( CoordinateReferenceSystem crs, SpaceFillingCurve curve ) END 
    {
        super( crs, curve );
    }
","    SpatialLayoutUnique( CoordinateReferenceSystem crs, SpaceFillingCurve curve )
    {
        super( crs, curve );
    }
"
313,I wonder if this should be an atomic operation?,"    public void close() throws IOException {
        // mark this context as closed. The real cleanup like closing of EJB receivers
        // *isn't* the responsibility of the EJB client context. We'll just let our EJBClientContextListeners
        // (if any) know about the context being closed and let them handle closing the receivers if they want to
        this.closed = true;

        for (final EJBClientContextListener listener : this.ejbClientContextListeners) {
            try {
                listener.contextClosed(this);
            } catch (Throwable t) {
                logger.debug(""Ignoring the exception thrown by an EJB client context listener while closing the context "" + this, t);
            }
        }

        // close the executor we use for reconnect handlers
        this.reconnectionExecutorService.shutdownNow();

    }
","    public void close() throws IOException {
        // mark this context as closed. The real cleanup like closing of EJB receivers
        // *isn't* the responsibility of the EJB client context. We'll just let our EJBClientContextListeners
        // (if any) know about the context being closed and let them handle closing the receivers if they want to
START         this.closed = true; END 

        for (final EJBClientContextListener listener : this.ejbClientContextListeners) {
            try {
                listener.contextClosed(this);
            } catch (Throwable t) {
                logger.debug(""Ignoring the exception thrown by an EJB client context listener while closing the context "" + this, t);
            }
        }

        // close the executor we use for reconnect handlers
        this.reconnectionExecutorService.shutdownNow();

    }
","    public synchronized void close() throws IOException {
        if (closed) {
            return;
        }
        // mark this context as closed. The real cleanup like closing of EJB receivers
        // *isn't* the responsibility of the EJB client context. We'll just let our EJBClientContextListeners
        // (if any) know about the context being closed and let them handle closing the receivers if they want to
        this.closed = true;

        for (final EJBClientContextListener listener : this.ejbClientContextListeners) {
            try {
                listener.contextClosed(this);
            } catch (Throwable t) {
                logger.debug(""Ignoring the exception thrown by an EJB client context listener while closing the context "" + this, t);
            }
        }

        // close the executor we use for reconnect handlers
        this.reconnectionExecutorService.shutdownNow();

    }
"
314,Don't catch bare Exception,"    public void run() {
        log.info(""Starting writer"");
        try {
            writerRegistry.register(this);
            running = true;
            runUntilCanceled();
        } catch (InterruptedException ie) {
            log.info(""Exiting due to thread interrupt"");
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            log.error(""Caught exception running writer: {}"", e.getMessage(), e);
        }
        finally
        {
            running = false;
            writerRegistry.unregister(this);
        }
    }
","    public void run() {
        log.info(""Starting writer"");
        try {
            writerRegistry.register(this);
            running = true;
            runUntilCanceled();
        } catch (InterruptedException ie) {
            log.info(""Exiting due to thread interrupt"");
            Thread.currentThread().interrupt();
START         } catch (Exception e) { END 
            log.error(""Caught exception running writer: {}"", e.getMessage(), e);
        }
        finally
        {
            running = false;
            writerRegistry.unregister(this);
        }
    }
","    public void run() {
        log.info(""Starting writer"");
        try {
            writerRegistry.register(this);
            running = true;
            runUntilCanceled();
        } catch (InterruptedException ie) {
            log.info(""Exiting due to thread interrupt"");
            Thread.currentThread().interrupt();
        } finally {
            running = false;
            writerRegistry.unregister(this);
        }
    }
"
315,"I almost feel a factory approach coming here: `factory.getFacingDeterminer(type)` etc. So we can abstract it. Renaming is nice (now) btw, so it is very explicit for terrain! :)","        private TerrainFacing determineFacing() {
            Terrain terrain = getTerrain();
            TerrainFacingDeterminer facingDeterminer = new TerrainFacingDeterminer();
            facingDeterminer.setTopSame(terrain.isSame(topTerrain()));
            facingDeterminer.setRightSame(terrain.isSame(rightTerrain()));
            facingDeterminer.setBottomSame(terrain.isSame(bottomTerrain()));
            facingDeterminer.setLeftSame(terrain.isSame(leftTerrain()));
            return facingDeterminer.getFacing();
        }
","        private TerrainFacing determineFacing() {
            Terrain terrain = getTerrain();
START             TerrainFacingDeterminer facingDeterminer = new TerrainFacingDeterminer(); END 
            facingDeterminer.setTopSame(terrain.isSame(topTerrain()));
            facingDeterminer.setRightSame(terrain.isSame(rightTerrain()));
            facingDeterminer.setBottomSame(terrain.isSame(bottomTerrain()));
            facingDeterminer.setLeftSame(terrain.isSame(leftTerrain()));
            return facingDeterminer.getFacing();
        }
","        private TerrainFacing determineFacing() {
            Terrain terrain = getTerrain();

            return TerrainFacingDeterminer.getFacing(
                    terrain.isSame(topTerrain()),
                    terrain.isSame(rightTerrain()),
                    terrain.isSame(bottomTerrain()),
                    terrain.isSame(leftTerrain())
            );
        }
"
316,"Please use ""something <operator> null"" convention","    public static Locale getLocaleFromString(String localeString, boolean returnDefaultLocale) {
        Locale result = returnDefaultLocale ? null : Locale.US;
        try {
            result = org.apache.commons.lang.LocaleUtils.toLocale(localeString);
            if(null == result && returnDefaultLocale) {
                result = Locale.US;
            }
        }
        catch(IllegalArgumentException e) {
            result = returnDefaultLocale ? Locale.US : null;
        }
        return result;
    }
","    public static Locale getLocaleFromString(String localeString, boolean returnDefaultLocale) {
        Locale result = returnDefaultLocale ? null : Locale.US;
        try {
            result = org.apache.commons.lang.LocaleUtils.toLocale(localeString);
START             if(null == result && returnDefaultLocale) { END 
                result = Locale.US;
            }
        }
        catch(IllegalArgumentException e) {
            result = returnDefaultLocale ? Locale.US : null;
        }
        return result;
    }
","    public static Locale getLocaleFromString(String localeString, boolean returnDefaultLocale) {
        Locale result = returnDefaultLocale ? null : Locale.US;
        try {
            result = org.apache.commons.lang.LocaleUtils.toLocale(localeString);
            if(result == null && returnDefaultLocale) {
                result = Locale.US;
            }
        }
        catch(IllegalArgumentException e) {
            result = returnDefaultLocale ? Locale.US : null;
        }
        return result;
    }
"
317,Seems the callers are conditioned on `usesPatternSubscription()` already?,"    private void updateSubscribedTopics(final Set<String> topics, final String logPrefix) {
        final Collection<String> existingTopics = subscriptionUpdates();

        if  (usesPatternSubscription() && !existingTopics.equals(topics)) {
            topics.addAll(existingTopics);

            subscriptionUpdates.clear();
            subscriptionUpdates.addAll(topics);

            log.debug(""{}found {} topics possibly matching subscription"", logPrefix, topics.size());

            setRegexMatchedTopicsToSourceNodes();
            setRegexMatchedTopicToStateStore();
        }
    }
","    private void updateSubscribedTopics(final Set<String> topics, final String logPrefix) {
        final Collection<String> existingTopics = subscriptionUpdates();

START         if  (usesPatternSubscription() && !existingTopics.equals(topics)) { END 
            topics.addAll(existingTopics);

            subscriptionUpdates.clear();
            subscriptionUpdates.addAll(topics);

            log.debug(""{}found {} topics possibly matching subscription"", logPrefix, topics.size());

            setRegexMatchedTopicsToSourceNodes();
            setRegexMatchedTopicToStateStore();
        }
    }
","    private void updateSubscribedTopics(final Set<String> topics, final String logPrefix) {
        final Collection<String> existingTopics = subscriptionUpdates();

        if  (!existingTopics.equals(topics)) {
            topics.addAll(existingTopics);

            subscriptionUpdates.clear();
            subscriptionUpdates.addAll(topics);

            log.debug(""{}found {} topics possibly matching subscription"", logPrefix, topics.size());

            setRegexMatchedTopicsToSourceNodes();
            setRegexMatchedTopicToStateStore();
        }
    }
"
318,is this is a typo? (checking for `origApp != null` and then calling method on `newApp`),"    public void tearDown() throws Exception {
        super.tearDown();
        if (origApp != null) Entities.destroyAll(newApp.getManagementContext());
        if (mementoDir != null) RebindTestUtils.deleteMementoDir(mementoDir);
    }
","    public void tearDown() throws Exception {
        super.tearDown();
START         if (origApp != null) Entities.destroyAll(newApp.getManagementContext()); END 
        if (mementoDir != null) RebindTestUtils.deleteMementoDir(mementoDir);
    }
","    public void tearDown() throws Exception {
        super.tearDown();
        if (origApp != null) Entities.destroyAll(origApp.getManagementContext());
        if (mementoDir != null) RebindTestUtils.deleteMementoDir(mementoDir);
    }
"
319,"Why do you use a new array to do iteration?
If it is to avoid possible ConcurrentModificationException in multi-thread use case, a synchronized block would be more adapted.","    public void notifyUnlock(Collection<? extends EObject> elements) {
        for (IAuthorityListener listener : Lists.newArrayList(listeners)) {
            listener.notifyIsReleased((Collection<EObject>) elements);
        }
    }
","    public void notifyUnlock(Collection<? extends EObject> elements) {
START         for (IAuthorityListener listener : Lists.newArrayList(listeners)) { END 
            listener.notifyIsReleased((Collection<EObject>) elements);
        }
    }
","    public void notifyUnlock(Collection<? extends EObject> elements) {
        for (IAuthorityListener listener : listeners) {
            listener.notifyIsReleased((Collection<EObject>) elements);
        }
    }
"
320,Any reason to not make this return `Path`? It's new API.,"    public File getWorkingDir() {
        return this.workingDir.toFile();
    }
","START     public File getWorkingDir() { END 
        return this.workingDir.toFile();
    }
","    public Path getWorkingDir() {
        return this.workingDir;
    }
"
321,"Please invert this condition, additional loop breakers make code reading worse.","  protected void readHiveRecordAndInsertIntoRecordBatch(Object rowValue) {
    for (int columnRefIdx = 0; columnRefIdx < selectedStructFieldRefs.length; columnRefIdx++) {
      Object columnValue = finalObjInspector.getStructFieldData(rowValue, selectedStructFieldRefs[columnRefIdx]);
      if (columnValue == null) {
        continue;
      }
      columnValueWriters[columnRefIdx].write(columnValue);
    }
  }
","  protected void readHiveRecordAndInsertIntoRecordBatch(Object rowValue) {
    for (int columnRefIdx = 0; columnRefIdx < selectedStructFieldRefs.length; columnRefIdx++) {
      Object columnValue = finalObjInspector.getStructFieldData(rowValue, selectedStructFieldRefs[columnRefIdx]);
START       if (columnValue == null) { END 
        continue;
      }
      columnValueWriters[columnRefIdx].write(columnValue);
    }
  }
","  protected void readHiveRecordAndInsertIntoRecordBatch(Object rowValue) {
    for (int columnRefIdx = 0; columnRefIdx < selectedStructFieldRefs.length; columnRefIdx++) {
      Object columnValue = finalObjInspector.getStructFieldData(rowValue, selectedStructFieldRefs[columnRefIdx]);
      if (columnValue != null) {
        columnValueWriters[columnRefIdx].write(columnValue);
      }
    }
  }
"
322,"This logic is not correct since it would stop at the first '\r' in ""// blah \r blah \r\n"".","	private void matchSinglelineComment(boolean includeNewline) {
	    int c = getChar();
	    while (c != '\n' && c != EOFCHAR && (includeNewline || (c != '\r'))) {
	        c = getChar();
	    }
	    if (c == EOFCHAR || !includeNewline) {
	    	ungetChar(c);
	    }
	}
","	private void matchSinglelineComment(boolean includeNewline) {
	    int c = getChar();
START 	    while (c != '\n' && c != EOFCHAR && (includeNewline || (c != '\r'))) { END 
	        c = getChar();
	    }
	    if (c == EOFCHAR || !includeNewline) {
	    	ungetChar(c);
	    }
	}
","	private void matchSinglelineComment(boolean includeNewline) {
	    int c = getChar();
	    while (c != '\n' && c != EOFCHAR) {
	        int next = getChar();
	        if (c == '\r' && next == '\n' && !includeNewline) {
	            // exclude CRLF line ending
	            ungetChar(next);
	            break;
	        }
	        c = next;
	    }
	    if (c == EOFCHAR || !includeNewline) {
	    	ungetChar(c);
	    }
	}
"
323,Also there do not use Privilege Exception. You are calling Bl method so no need throw Privilege Exception at all.,"	private Member createSomeMember(final Vo createdVo) throws ExtendMembershipException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, InternalErrorException, PrivilegeException {
		final Candidate candidate = setUpCandidate();
		final Member createdMember = perun.getMembersManagerBl().createMemberSync(sess, createdVo, candidate);
		return createdMember;
	}
","START 	private Member createSomeMember(final Vo createdVo) throws ExtendMembershipException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, InternalErrorException, PrivilegeException { END 
		final Candidate candidate = setUpCandidate();
		final Member createdMember = perun.getMembersManagerBl().createMemberSync(sess, createdVo, candidate);
		return createdMember;
	}
","	private Member createSomeMember(final Vo createdVo) throws ExtendMembershipException, AlreadyMemberException, WrongAttributeValueException, WrongReferenceAttributeValueException, InternalErrorException {
		final Candidate candidate = setUpCandidate();
		final Member createdMember = perun.getMembersManagerBl().createMemberSync(sess, createdVo, candidate);
		return createdMember;
	}
"
324,"This is missing the translation of `bb.putLong(eid-1);`, and the allocation needs to be updated to match it.","    private ByteBuf createByteBuffer(int i, long lid, long eid) {
        ByteBuf bb = Unpooled.buffer(4 + 16);
        bb.writeLong(lid);
        bb.writeLong(eid);
        bb.writeInt(i);
        return bb;
    }
","    private ByteBuf createByteBuffer(int i, long lid, long eid) {
        ByteBuf bb = Unpooled.buffer(4 + 16);
        bb.writeLong(lid);
START         bb.writeLong(eid); END 
        bb.writeInt(i);
        return bb;
    }
","    private ByteBuf createByteBuffer(int i, long lid, long eid) {
        ByteBuf bb = Unpooled.buffer(4 + 16);
        bb.writeLong(lid);
        bb.writeLong(eid);
        bb.writeLong(eid - 1);
        bb.writeInt(i);
        return bb;
    }
"
325,"use getDiskVmElementDao(), please apply to all the dao calls in that class","    private void attachDiskToTemplate(Guid templateId) {
        DiskImage templateDiskImage = getParameters().getDiskImage();
        DiskVmElement dve = new DiskVmElement(templateDiskImage.getId(), templateId);
        dve.setDiskInterface(DiskInterface.VirtIO);
        DbFacade.getInstance().getDiskVmElementDao().save(dve);
        VmDeviceUtils.addDiskDevice(templateId, templateDiskImage.getId());
    }
","    private void attachDiskToTemplate(Guid templateId) {
        DiskImage templateDiskImage = getParameters().getDiskImage();
        DiskVmElement dve = new DiskVmElement(templateDiskImage.getId(), templateId);
        dve.setDiskInterface(DiskInterface.VirtIO);
START         DbFacade.getInstance().getDiskVmElementDao().save(dve); END 
        VmDeviceUtils.addDiskDevice(templateId, templateDiskImage.getId());
    }
","    private void attachDiskToTemplate(Guid templateId) {
        DiskImage templateDiskImage = getParameters().getDiskImage();
        DiskVmElement dve = new DiskVmElement(templateDiskImage.getId(), templateId);
        dve.setDiskInterface(DiskInterface.VirtIO);
        getDiskVmElementDao().save(dve);
        VmDeviceUtils.addDiskDevice(templateId, templateDiskImage.getId());
    }
"
326,"Since the version is a enum, we can compare here using `==` directly.","        public double computeFor(ASTMethodOrConstructorDeclaration node, MetricVersion version) {

            JavaParserVisitor visitor = (CycloVersion.IGNORE_BOOLEAN_PATHS.equals(version))
                                        ? new CycloPathUnawareOperationVisitor()
                                        : new StandardCycloVisitor();

            MutableInt cyclo = (MutableInt) node.jjtAccept(visitor, new MutableInt(1));
            return (double) cyclo.getValue();
        }
","        public double computeFor(ASTMethodOrConstructorDeclaration node, MetricVersion version) {

START             JavaParserVisitor visitor = (CycloVersion.IGNORE_BOOLEAN_PATHS.equals(version)) END 
                                        ? new CycloPathUnawareOperationVisitor()
                                        : new StandardCycloVisitor();

            MutableInt cyclo = (MutableInt) node.jjtAccept(visitor, new MutableInt(1));
            return (double) cyclo.getValue();
        }
","        public double computeFor(ASTMethodOrConstructorDeclaration node, MetricVersion version) {

            JavaParserVisitor visitor = (CycloVersion.IGNORE_BOOLEAN_PATHS == version)
                                        ? new CycloPathUnawareOperationVisitor()
                                        : new StandardCycloVisitor();

            MutableInt cyclo = (MutableInt) node.jjtAccept(visitor, new MutableInt(1));
            return (double) cyclo.getValue();
        }
"
327,"nit: Druid code convention is like

```
                            .mapToLong(element -> dimLookup.getValue(element).length() * Character.BYTES)
                            .sum();
```","  public long estimateEncodedKeyComponentSize(int[] key)
  {
    // the size is calculated conservatively, first key may be accounted for twice
    long estimatedSize = (key.length * Integer.BYTES);
    estimatedSize += Arrays.stream(key)
                           .filter(element -> dimLookup.getValue(element) != null)
                           .mapToLong(element -> dimLookup.getValue(element).length() * Character.BYTES).sum();
    return estimatedSize;
  }
","  public long estimateEncodedKeyComponentSize(int[] key)
  {
    // the size is calculated conservatively, first key may be accounted for twice
    long estimatedSize = (key.length * Integer.BYTES);
    estimatedSize += Arrays.stream(key)
                           .filter(element -> dimLookup.getValue(element) != null)
START                            .mapToLong(element -> dimLookup.getValue(element).length() * Character.BYTES).sum(); END 
    return estimatedSize;
  }
","  public long estimateEncodedKeyComponentSize(int[] key)
  {
    // string length is being accounted for each time they are referenced, based on dimension handler interface,
    // even though they are stored just once. It may overestimate the size by a bit, but we wanted to leave
    // more buffer to be safe
    long estimatedSize = key.length * Integer.BYTES;
    estimatedSize += Arrays.stream(key)
                           .filter(element -> dimLookup.getValue(element) != null)
                           .mapToLong(element -> dimLookup.getValue(element).length() * Character.BYTES)
                           .sum();
    return estimatedSize;
  }
"
328,"nicely done! just one consideration: the `ioobException` contains the information on what went wrong (i.e. what the actual index was and the size of the list) and by catching it and then throwing a new one you lose this information.

so please change it such that the stacktrace and message of the original exception are passed on:

```
			} catch (IndexOutOfBoundsException ioobException) {
				comparingSet.remove(element);
				throw ioobException;
```","	public void add(int index, T element) {
		if (comparingSet.add(element)) {
			try {
				super.add(index, element);
			} catch (IndexOutOfBoundsException ioobException) {
				comparingSet.remove(element);
				throw new IndexOutOfBoundsException();
			}
		}
	}
","	public void add(int index, T element) {
		if (comparingSet.add(element)) {
			try {
				super.add(index, element);
			} catch (IndexOutOfBoundsException ioobException) {
				comparingSet.remove(element);
START 				throw new IndexOutOfBoundsException(); END 
			}
		}
	}
","	public void add(int index, T element) {
		if (comparingSet.add(element)) {
			try {
				super.add(index, element);
			} catch (IndexOutOfBoundsException ioobException) {
				comparingSet.remove(element);
				throw ioobException;
			}
		}
	}
"
329,how can a `clusterName` be `null`?,"    public String getClusterName() {
        final String clusterName = client.getClientConfig().getClusterName();
        if (clusterName == null) {
            throw new RuntimeException(""Cluster name cannot be null on the client which participates in XA Transaction"");
        }
        return clusterName;
    }
","    public String getClusterName() {
        final String clusterName = client.getClientConfig().getClusterName();
START         if (clusterName == null) { END 
            throw new RuntimeException(""Cluster name cannot be null on the client which participates in XA Transaction"");
        }
        return clusterName;
    }
","    public String getClusterName() {
        return client.getClientConfig().getClusterName();
    }
"
330,Redundant else.,"	public JSchConnection getProxyConnection() {
		String proxyConnectionName = getProxyConnectionName();
		if (proxyConnectionName.equals(EMPTY_STRING)) {
			return null;
		} else {
			return (JSchConnection) fManager.getConnection(proxyConnectionName);
		}
	}
","	public JSchConnection getProxyConnection() {
		String proxyConnectionName = getProxyConnectionName();
		if (proxyConnectionName.equals(EMPTY_STRING)) {
			return null;
START 		} else { END 
			return (JSchConnection) fManager.getConnection(proxyConnectionName);
		}
	}
","	public JSchConnection getProxyConnection() {
		String proxyConnectionName = getProxyConnectionName();
		if (proxyConnectionName.equals(EMPTY_STRING)) {
			return null;
		}
		return (JSchConnection) fManager.getConnection(proxyConnectionName);
	}
"
331,This commandContext seems unused.,"    protected void deleteLog() {
        CommandContext commandContext = new CommandContext();
        commandContext.setData(""SingleRun"", ""true"");
        commandContext.setData(""OlderThan"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"").format(new Date()));
        synchronized (this) {
            jobServicesClient.scheduleRequest(CONTAINER_ID,
                    JobRequestInstance.builder().command(""org.jbpm.executor.commands.LogCleanupCommand"").build());
        }
    }
","    protected void deleteLog() {
START         CommandContext commandContext = new CommandContext(); END 
        commandContext.setData(""SingleRun"", ""true"");
        commandContext.setData(""OlderThan"", new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"").format(new Date()));
        synchronized (this) {
            jobServicesClient.scheduleRequest(CONTAINER_ID,
                    JobRequestInstance.builder().command(""org.jbpm.executor.commands.LogCleanupCommand"").build());
        }
    }
","    protected void deleteLog() {
        synchronized (this) {
            jobServicesClient.scheduleRequest(CONTAINER_ID,
                    JobRequestInstance.builder().command(""org.jbpm.executor.commands.LogCleanupCommand"").build());
        }
    }
"
332,"Nit: this ""else"" is redundant since the ""if"" branch returns conditionally. We generally prefer to write such expressions as
```java
if (...) {
    return ...;
}
return ...;","    private static String buildPredicate(Column partitionKey, String value)
    {
        if (isQuotedType(partitionKey.getType())) {
            return String.format(""(%s='%s')"", partitionKey.getName(), value);
        }
        else {
            return String.format(""(%s=%s)"", partitionKey.getName(), value);
        }
    }
","    private static String buildPredicate(Column partitionKey, String value)
    {
        if (isQuotedType(partitionKey.getType())) {
            return String.format(""(%s='%s')"", partitionKey.getName(), value);
        }
START         else { END 
            return String.format(""(%s=%s)"", partitionKey.getName(), value);
        }
    }
","    private static String buildPredicate(Column partitionKey, String value)
    {
        if (isQuotedType(partitionKey.getType())) {
            return String.format(""(%s='%s')"", partitionKey.getName(), value);
        }
        return String.format(""(%s=%s)"", partitionKey.getName(), value);
    }
"
333,"@diegolovison the warning should be logged when setting the queue size, not when reading it.

This is what I had in mind: https://github.com/infinispan/infinispan/commit/4b40bf35dfbd892fb993b9096a30164ec0a4af39","   int expiryQueueSize() {
      log.warn(""The expiry queueSize attribute is deprecated and will be removed"");
      return expiryQueueSize.get();
   }
","   int expiryQueueSize() {
START       log.warn(""The expiry queueSize attribute is deprecated and will be removed""); END 
      return expiryQueueSize.get();
   }
","   int expiryQueueSize() {
      return expiryQueueSize.get();
   }
"
334,":art: Personally I would lean toward using a guard statement.

```java
if (entity == null) {
  return null
}

...
```","    public IAuthorizationPrincipal getPrincipalForEntity(Entity entity) {

        // attempt to determine the entity type class for this principal
        if (entity != null) {
            Class entityType;
            if (entity.getEntityType().equals(EntityEnum.GROUP.toString())) {
                entityType = IEntityGroup.class;
            } else {
                entityType = EntityEnum.getEntityEnum(entity.getEntityType()).getClazz();
            }

            // construct an authorization principal for this JsonEntityBean
            AuthorizationService authService = AuthorizationService.instance();
            IAuthorizationPrincipal p = authService.newPrincipal(entity.getId(), entityType);
            return p;
        }
        return null;
    }
","    public IAuthorizationPrincipal getPrincipalForEntity(Entity entity) {

        // attempt to determine the entity type class for this principal
START         if (entity != null) { END 
            Class entityType;
            if (entity.getEntityType().equals(EntityEnum.GROUP.toString())) {
                entityType = IEntityGroup.class;
            } else {
                entityType = EntityEnum.getEntityEnum(entity.getEntityType()).getClazz();
            }

            // construct an authorization principal for this JsonEntityBean
            AuthorizationService authService = AuthorizationService.instance();
            IAuthorizationPrincipal p = authService.newPrincipal(entity.getId(), entityType);
            return p;
        }
        return null;
    }
","    public IAuthorizationPrincipal getPrincipalForEntity(Entity entity) {

        // attempt to determine the entity type class for this principal
        if (entity == null) {
            return null;
        }
        Class entityType;
        if (entity.getEntityType().equals(EntityEnum.GROUP.toString())) {
            entityType = IEntityGroup.class;
        } else {
            entityType = EntityEnum.getEntityEnum(entity.getEntityType()).getClazz();
        }

        // construct an authorization principal for this JsonEntityBean
        AuthorizationService authService = AuthorizationService.instance();
        IAuthorizationPrincipal p = authService.newPrincipal(entity.getId(), entityType);
        return p;
    }
"
335,should move keys!=null out of while (add an if ),"    public static List<String> getKeyListFromBlobStore(BlobStore blobStore) throws Exception {
        Iterator<String> keys = blobStore.listKeys();
        List<String> keyList = new ArrayList<String>();
        while (keys != null && keys.hasNext()) {
            keyList.add(keys.next());
        }
        LOG.debug(""KeyList from blobstore {}"", keyList);
        return keyList;
    }
","    public static List<String> getKeyListFromBlobStore(BlobStore blobStore) throws Exception {
        Iterator<String> keys = blobStore.listKeys();
        List<String> keyList = new ArrayList<String>();
START         while (keys != null && keys.hasNext()) { END 
            keyList.add(keys.next());
        }
        LOG.debug(""KeyList from blobstore {}"", keyList);
        return keyList;
    }
","    public static List<String> getKeyListFromBlobStore(BlobStore blobStore) throws Exception {
        Iterator<String> keys = blobStore.listKeys();
        List<String> keyList = new ArrayList<String>();
        if (keys != null) {
            while (keys.hasNext()) {
                keyList.add(keys.next());
            }
        }
        LOG.debug(""KeyList from blobstore {}"", keyList);
        return keyList;
    }
"
336,can this return emptyMap? and just be another clause of the if below?,"    private @Nullable Map<@NonNull String, @NonNull SegmentStoreStatistics> getPerTypeStats(long start, long end , IProgressMonitor monitor) {
        Collection<@NonNull ISegment> store = getSegmentStore(start, end);
        if (store == null) {
            return null;
        }
        if (monitor.isCanceled()) {
            return Collections.EMPTY_MAP;
        }
        return calculateTotalPerType(store, monitor);
    }
","    private @Nullable Map<@NonNull String, @NonNull SegmentStoreStatistics> getPerTypeStats(long start, long end , IProgressMonitor monitor) {
        Collection<@NonNull ISegment> store = getSegmentStore(start, end);
        if (store == null) {
START             return null; END 
        }
        if (monitor.isCanceled()) {
            return Collections.EMPTY_MAP;
        }
        return calculateTotalPerType(store, monitor);
    }
","    private @Nullable Map<@NonNull String, @NonNull SegmentStoreStatistics> getPerTypeStats(long start, long end , IProgressMonitor monitor) {
        Collection<@NonNull ISegment> store = getSegmentStore(start, end);
        if (store == null || monitor.isCanceled()) {
            return null;
        }
        return calculateTotalPerType(store, monitor);
    }
"
337,Override,"    protected void toLegacyText(StringBuilder builder)
    {
        builder.append(this.selector);
    }
","START     protected void toLegacyText(StringBuilder builder) END 
    {
        builder.append(this.selector);
    }
","    protected void toLegacyText(StringBuilder builder)
    {
        builder.append( this.selector );
        super.toLegacyText( builder );
    }
"
338,We should not force all of the refreshes,"    public void refresh() {
        start();
        super.refresh(true);
    }
","    public void refresh() {
        start();
START         super.refresh(true); END 
    }
","    public void refresh() {
        start();
        super.refresh();
    }
"
339,"This `else if` block can be removed. We only have information about the saved request URL, so that is all we can really compare.","	private boolean matchesSavedRequest(HttpServletRequest request, SavedRequest savedRequest) {
		if (savedRequest == null) {
			return false;
		} else if (savedRequest instanceof DefaultSavedRequest) {
			DefaultSavedRequest defaultSavedRequest = (DefaultSavedRequest) savedRequest;
			return defaultSavedRequest.doesRequestMatch(request, this.portResolver);
		} else {
			String currentUrl = UrlUtils.buildFullRequestUrl(request);
			return savedRequest.getRedirectUrl().equals(currentUrl);
		}
	}
","	private boolean matchesSavedRequest(HttpServletRequest request, SavedRequest savedRequest) {
		if (savedRequest == null) {
			return false;
START 		} else if (savedRequest instanceof DefaultSavedRequest) { END 
			DefaultSavedRequest defaultSavedRequest = (DefaultSavedRequest) savedRequest;
			return defaultSavedRequest.doesRequestMatch(request, this.portResolver);
		} else {
			String currentUrl = UrlUtils.buildFullRequestUrl(request);
			return savedRequest.getRedirectUrl().equals(currentUrl);
		}
	}
","	private boolean matchesSavedRequest(HttpServletRequest request, SavedRequest savedRequest) {
		if (savedRequest == null) {
			return false;
		} else {
			String currentUrl = UrlUtils.buildFullRequestUrl(request);
			return savedRequest.getRedirectUrl().equals(currentUrl);
		}
	}
"
340,"Wouldn't it make more sense to add/remove a style class instead of hard coding a background color into the box? What if we change the default background color of the application to not be white, then this will have to change too. I did a quick search and I can't find any other 'disabled' color in the application as #E5E5E5, where did that color come from?","    public void setEnabled(boolean enabled) {
        asTextBox().setEnabled(enabled);
        if (enabled) {
            asTextBox().getElement().getStyle().setBackgroundColor(""#ffffff""); //$NON-NLS-1$
        } else {
            // the default background of the textbox is not the same as our disabled color
            asTextBox().getElement().getStyle().setBackgroundColor(""#e5e5e5""); //$NON-NLS-1$
        }
    }
","    public void setEnabled(boolean enabled) {
        asTextBox().setEnabled(enabled);
START         if (enabled) { END 
            asTextBox().getElement().getStyle().setBackgroundColor(""#ffffff""); //$NON-NLS-1$
        } else {
            // the default background of the textbox is not the same as our disabled color
            asTextBox().getElement().getStyle().setBackgroundColor(""#e5e5e5""); //$NON-NLS-1$
        }
    }
","    public void setEnabled(boolean enabled) {
        asTextBox().setEnabled(enabled);
    }
"
341,ParkingPositionLayer - delete,"	public void registerLayers(MapActivity activity) {
		// remove old if existing after turn
		if(parkingLayer != null) {
			activity.getMapView().removeLayer(parkingLayer);
		}
		parkingLayer = new ParkingPositionLayer(activity, this);
//		activity.getMapView().addLayer(parkingLayer, 5.5f);
		registerWidget(activity);
	}
","	public void registerLayers(MapActivity activity) {
		// remove old if existing after turn
		if(parkingLayer != null) {
			activity.getMapView().removeLayer(parkingLayer);
		}
START 		parkingLayer = new ParkingPositionLayer(activity, this); END 
//		activity.getMapView().addLayer(parkingLayer, 5.5f);
		registerWidget(activity);
	}
","	public void registerLayers(MapActivity activity) {
		registerWidget(activity);
	}
"
342,"If you are going to use ternary operator, might as well just drop it right into the return below, without the intermediate variable","    public String toString() {
        String prefix = (TotalMilliseconds < 0) ? ""-"" : """";

        // Ok to use String.format directly since GWT does not use TimeSpan from ui override package
        return String.format(""%s%d.%02d:%02d:%02d.%03d"", prefix, Days, Hours, Minutes, Seconds, Milliseconds);
    }
","    public String toString() {
START         String prefix = (TotalMilliseconds < 0) ? ""-"" : """"; END 

        // Ok to use String.format directly since GWT does not use TimeSpan from ui override package
        return String.format(""%s%d.%02d:%02d:%02d.%03d"", prefix, Days, Hours, Minutes, Seconds, Milliseconds);
    }
","    public String toString() {
        // Ok to use String.format directly since GWT does not use TimeSpan from ui override package
        return String.format(""%s%d.%02d:%02d:%02d.%03d"",
                (TotalMilliseconds < 0) ? ""-"" : """",
                Days, Hours, Minutes, Seconds, Milliseconds);
    }
"
343,Assuming this is another debugging call.,"    private void handleTransferComplete(final FileTransfer fileTransfer) {
        this.activeFileTransfers.remove(fileTransfer);
        this.concurrentTransfersSemaphore.release();
        System.out.println("">>> "" + this.concurrentTransfersSemaphore.availablePermits());

    }
","    private void handleTransferComplete(final FileTransfer fileTransfer) {
        this.activeFileTransfers.remove(fileTransfer);
        this.concurrentTransfersSemaphore.release();
START         System.out.println("">>> "" + this.concurrentTransfersSemaphore.availablePermits()); END 

    }
","    private void handleTransferComplete(final FileTransfer fileTransfer) {
        this.activeFileTransfers.remove(fileTransfer);
        this.concurrentTransfersSemaphore.release();
    }
"
344,"clone should not use duplicate... duplicate should be an alias of clone.

hmmm... you created infinite loop? clone->duplicate->clone?

this entire logic is incorrect...

should be, something line:

 CommandContext cloned = (CommandContext)super.clone();
 cloned.setFromContext(this);
 return cloned;","    public Object clone() throws CloneNotSupportedException {
        super.clone();
        CommandContext ctx = new CommandContext();
        ctx.setFromContext(this);
        return this.duplicate();

    }
","    public Object clone() throws CloneNotSupportedException {
        super.clone();
        CommandContext ctx = new CommandContext();
        ctx.setFromContext(this);
START         return this.duplicate(); END 

    }
","    public Object clone() {
        return new CommandContext(this);
    }
"
345,Drop the `this` here and two lines down.,"  @Override public Response execute(Request request) throws IOException {
    HttpUriRequest apacheRequest = createRequest(request);
    HttpResponse apacheResponse = execute(client, apacheRequest);

    String url = request.getUrl();
    if (this.redirectHandler != null && this.redirectHandler.finalUri != null) {
      // if we have a redirect handler, and it has been redirected, use it's url
      url = this.redirectHandler.finalUri.toString();
    }

    return parseResponse(url, apacheResponse);
  }
","  @Override public Response execute(Request request) throws IOException {
    HttpUriRequest apacheRequest = createRequest(request);
    HttpResponse apacheResponse = execute(client, apacheRequest);

    String url = request.getUrl();
START     if (this.redirectHandler != null && this.redirectHandler.finalUri != null) { END 
      // if we have a redirect handler, and it has been redirected, use it's url
      url = this.redirectHandler.finalUri.toString();
    }

    return parseResponse(url, apacheResponse);
  }
","  @Override public Response execute(Request request) throws IOException {
    HttpUriRequest apacheRequest = createRequest(request);
    HttpResponse apacheResponse = execute(client, apacheRequest);

    String url = request.getUrl();
    if (redirectHandler != null && redirectHandler.finalUri != null) {
      // If we have a redirect handler, and it has been redirected, use it's URL.
      url = redirectHandler.finalUri.toString();
    }

    return parseResponse(url, apacheResponse);
  }
"
346,"I thought you wanted to end this practice, Adrian?","   public GlobalMetricsConfigurationBuilder metrics() {
      globalConfig.metrics().gauges(true);
      return globalConfig.metrics();
   }
","   public GlobalMetricsConfigurationBuilder metrics() {
START       globalConfig.metrics().gauges(true); END 
      return globalConfig.metrics();
   }
","   public GlobalMetricsConfigurationBuilder metrics() {
      return globalConfig.metrics();
   }
"
347,I would always return from the trait set to avoid modifying the trait associated with a table itself,"    static RelDistribution getDistribution(RelNode node) {
        if (node instanceof VoltLogicalTableScan) {
            return node.getTable().getDistribution();
        }
        return node.getTraitSet().getTrait(RelDistributionTraitDef.INSTANCE);
    }
","    static RelDistribution getDistribution(RelNode node) {
START         if (node instanceof VoltLogicalTableScan) { END 
            return node.getTable().getDistribution();
        }
        return node.getTraitSet().getTrait(RelDistributionTraitDef.INSTANCE);
    }
","    static RelDistribution getDistribution(RelNode node) {
        return node.getTraitSet().getTrait(RelDistributionTraitDef.INSTANCE);
    }
"
348,"I don't think we should manipulate the correlation Id.
I would add input validator for validating the correlation Id length.","    public void setCorrelationId(String correlationId) {
        if (correlationId == null) {
            this.correlationId = Guid.NewGuid().toString();
        } else if (correlationId.length() <= 100) {
            this.correlationId = correlationId;
        } else {
            this.correlationId = correlationId.substring(0, 100);
        }
    }
","    public void setCorrelationId(String correlationId) {
        if (correlationId == null) {
            this.correlationId = Guid.NewGuid().toString();
        } else if (correlationId.length() <= 100) {
            this.correlationId = correlationId;
        } else {
            this.correlationId = correlationId.substring(0, 100);
        }
START     } END 
","    public void setCorrelationId(String correlationId) {
        this.correlationId = correlationId;
    }
"
349,we don't assert anywhere that on success cli exits with `0`.,"    public void shouldRunQueryFromFile()
            throws IOException, InterruptedException
    {
        try (TempFile file = new TempFile()) {
            Files.write(""select * from hive.default.nation;\n"", file.file(), UTF_8);

            launchPrestoCliWithServerArgument(""--file"", file.file().getAbsolutePath());
            assertThat(trimLines(presto.readRemainingOutputLines())).containsAll(nationTableBatchLines);

            presto.waitForWithTimeoutAndKill();
        }
    }
","    public void shouldRunQueryFromFile()
            throws IOException, InterruptedException
    {
        try (TempFile file = new TempFile()) {
            Files.write(""select * from hive.default.nation;\n"", file.file(), UTF_8);

            launchPrestoCliWithServerArgument(""--file"", file.file().getAbsolutePath());
            assertThat(trimLines(presto.readRemainingOutputLines())).containsAll(nationTableBatchLines);

            presto.waitForWithTimeoutAndKill();
        }
START     } END 
","    public void shouldRunQueryFromFile()
            throws Exception
    {
        try (TempFile file = new TempFile()) {
            Files.write(""select * from hive.default.nation;\n"", file.file(), UTF_8);

            launchPrestoCliWithServerArgument(""--file"", file.file().getAbsolutePath());
            assertThat(trimLines(presto.readRemainingOutputLines())).containsAll(nationTableBatchLines);

            presto.waitForWithTimeoutAndKill();
        }
    }
"
350,can / should this be `Optional<Class<E>>`?,"    static <E extends Enum<E>> Optional<Class<?>> ifEnum(Type type) {
        return Optional.of(type)
            .map(GenericTypes::getErasedType)
            .filter(Class::isEnum)
            .map(c -> (Class<E>) c);
    }
","START     static <E extends Enum<E>> Optional<Class<?>> ifEnum(Type type) { END 
        return Optional.of(type)
            .map(GenericTypes::getErasedType)
            .filter(Class::isEnum)
            .map(c -> (Class<E>) c);
    }
","    static <E extends Enum<E>> Optional<Class<E>> ifEnum(Type type) {
        return Optional.of(type)
            .map(GenericTypes::getErasedType)
            .filter(Class::isEnum)
            .map(c -> (Class<E>) c);
    }
"
351,I don't quite following this random separator logic...,"    private String getter() {
        ImmutableList<String> topSpeciesNames = featuredSpeciesService.getSpeciesNamesSortedByExperimentCount();

        return GSON.toJson(
                ImmutableMap.of(
                        ""topSpecies"", topSpeciesNames.subList(0, Math.min(topSpeciesNames.size(), FEATURED_SPECIES)),
                        ""allSpecies"", ImmutableList.sortedCopyOf(topSpeciesNames),
                        ""separator"", ThreadLocalRandom.current().nextDouble() > 0.999 ? BEST_SEPARATOR : NORMAL_SEPARATOR));
    }
","    private String getter() {
        ImmutableList<String> topSpeciesNames = featuredSpeciesService.getSpeciesNamesSortedByExperimentCount();

        return GSON.toJson(
                ImmutableMap.of(
                        ""topSpecies"", topSpeciesNames.subList(0, Math.min(topSpeciesNames.size(), FEATURED_SPECIES)),
                        ""allSpecies"", ImmutableList.sortedCopyOf(topSpeciesNames),
START                         ""separator"", ThreadLocalRandom.current().nextDouble() > 0.999 ? BEST_SEPARATOR : NORMAL_SEPARATOR)); END 
    }
","    private String getter() {
        ImmutableList<String> topSpeciesNames = featuredSpeciesService.getSpeciesNamesSortedByExperimentCount();

        return GSON.toJson(
                ImmutableMap.of(
                        ""topSpecies"", topSpeciesNames.subList(0, Math.min(topSpeciesNames.size(), FEATURED_SPECIES)),
                        ""allSpecies"", ImmutableList.sortedCopyOf(topSpeciesNames)));
    }
"
352,Shouldn't this be Calendar.getInstance() instead ? That way it's truly a no-op.,"    private long roundToNextMinute(long timeInMillis) {
        Calendar calendar = new GregorianCalendar();
        calendar.setTimeInMillis(timeInMillis);
        calendar.set(Calendar.MILLISECOND, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.add(Calendar.MINUTE, 1);

        return calendar.getTimeInMillis();
    }
","    private long roundToNextMinute(long timeInMillis) {
        Calendar calendar = START  new GregorianCalendar(); END 
        calendar.setTimeInMillis(timeInMillis);
        calendar.set(Calendar.MILLISECOND, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.add(Calendar.MINUTE, 1);

        return calendar.getTimeInMillis();
    }
","    private long roundToNextMinute(long timeInMillis) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTimeInMillis(timeInMillis);
        calendar.set(Calendar.MILLISECOND, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.add(Calendar.MINUTE, 1);

        return calendar.getTimeInMillis();
    }
"
353,Redundant assertion,"    public void testMapInvalidEnumValue() throws SQLException
    {
        Handle h = db.openHandle();
        h.createStatement(""insert into something (id, name) values (1, 'joe')"").execute();

        try {
            h.createQuery(""select * from something order by id"")
             .mapToBean(SomethingElse.class)
             .findFirst();
            fail(""Expected IllegalArgumentException was not thrown"");
        }
        catch (IllegalArgumentException e) {
            assertThat(e).isNotNull();
        }
    }
","    public void testMapInvalidEnumValue() throws SQLException
    {
        Handle h = db.openHandle();
        h.createStatement(""insert into something (id, name) values (1, 'joe')"").execute();

        try {
            h.createQuery(""select * from something order by id"")
             .mapToBean(SomethingElse.class)
             .findFirst();
            fail(""Expected IllegalArgumentException was not thrown"");
        }
        catch (IllegalArgumentException e) {
START             assertThat(e).isNotNull(); END 
        }
    }
","    public void testMapInvalidEnumValue() throws SQLException
    {
        Handle h = db.openHandle();
        h.createStatement(""insert into something (id, name) values (1, 'joe')"").execute();

        h.createQuery(""select * from something order by id"")
                .mapToBean(SomethingElse.class)
                .findFirst();
    }
"
354,"Again, this change modifies the is not semantic meaning.","	private static void cachePut(final CacheKey key, final boolean value) {
		final LRUMap<CacheKey, Boolean> cache = SecuredItemImpl.CACHE.get();
		if (cache != null) {
			cache.put(key, value);
			SecuredItemImpl.CACHE.set(cache);
		}
	}
","START 	private static void cachePut(final CacheKey key, final boolean value) { END 
		final LRUMap<CacheKey, Boolean> cache = SecuredItemImpl.CACHE.get();
		if (cache != null) {
			cache.put(key, value);
			SecuredItemImpl.CACHE.set(cache);
		}
	}
","	private void cachePut(final CacheKey key, final boolean value) {
		final LRUMap<CacheKey, Boolean> cache = SecuredItemImpl.CACHE.get();
		if (cache != null) {
			cache.put(key, value);
			SecuredItemImpl.CACHE.set(cache);
		}
	}
"
355,Don't you need a `super.setUp()` call here?,"    public void setUp() throws Exception {
        testContext = getInstrumentation().getContext();
    }
","    public void setUp() throws Exception {
START         testContext = getInstrumentation().getContext(); END 
    }
","    public void setUp() throws Exception {
        super.setUp();
        testContext = getInstrumentation().getContext();
    }
"
356,seems there is no IOException thrown from this method.,"  private void maybeAddCluster() throws IOException {
    for (Map.Entry<String, HelixAdmin> entry : adminForDc.entrySet()) {
      // Add a cluster entry in every DC
      String dcName = entry.getKey();
      HelixAdmin admin = entry.getValue();
      if (!admin.getClusters().contains(clusterName)) {
        info(""Adding cluster {} in {}"", clusterName, dcName);
        admin.addCluster(clusterName);
        admin.addStateModelDef(clusterName, LeaderStandbySMD.name, LeaderStandbySMD.build());
      }
    }
  }
","START   private void maybeAddCluster() throws IOException { END 
    for (Map.Entry<String, HelixAdmin> entry : adminForDc.entrySet()) {
      // Add a cluster entry in every DC
      String dcName = entry.getKey();
      HelixAdmin admin = entry.getValue();
      if (!admin.getClusters().contains(clusterName)) {
        info(""Adding cluster {} in {}"", clusterName, dcName);
        admin.addCluster(clusterName);
        admin.addStateModelDef(clusterName, LeaderStandbySMD.name, LeaderStandbySMD.build());
      }
    }
  }
","  private void maybeAddCluster() {
    for (Map.Entry<String, HelixAdmin> entry : adminForDc.entrySet()) {
      // Add a cluster entry in every DC
      String dcName = entry.getKey();
      HelixAdmin admin = entry.getValue();
      if (!admin.getClusters().contains(clusterName)) {
        info(""Adding cluster {} in {}"", clusterName, dcName);
        admin.addCluster(clusterName);
        admin.addStateModelDef(clusterName, LeaderStandbySMD.name, LeaderStandbySMD.build());
      }
    }
  }
"
357,"Any reason for this not assigning `colour` like the rest of the cases, instead of returning?","    private int matchResultColour(MatchResult result) {
        int colour;
        switch (result) {
            case WON:
                colour = R.color.battlereport_won;
                break;
            case LOST:
                colour = R.color.battlereport_lost;
                break;
            case DRAW:
                colour = R.color.battlereport_draw;
                break;
            default:
                return R.color.black;
        }
        return context.getResources().getColor(colour);
    }
","    private int matchResultColour(MatchResult result) {
        int colour;
        switch (result) {
            case WON:
                colour = R.color.battlereport_won;
                break;
            case LOST:
                colour = R.color.battlereport_lost;
                break;
            case DRAW:
                colour = R.color.battlereport_draw;
                break;
            default:
START                 return R.color.black; END 
        }
        return context.getResources().getColor(colour);
    }
","    private int matchResultColour(MatchResult result) {
        int colour;
        switch (result) {
            case WON:
                colour = R.color.battlereport_won;
                break;
            case LOST:
                colour = R.color.battlereport_lost;
                break;
            case DRAW:
                colour = R.color.battlereport_draw;
                break;
            default:
                colour = R.color.black;
                break;
        }
        return context.getResources().getColor(colour);
    }
"
358,Compile error here @mcenderdragon,"        public PotionEffect getPotionEffect()
        {
            return super.getPotionEffect;
        }
","        public PotionEffect getPotionEffect()
        {
START             return super.getPotionEffect; END 
        }
","        public PotionEffect getPotionEffect()
        {
            return super.getPotionEffect();
        }
"
359,I think this could be protected,"    public static CalledStringFunction create(long start, long end, int depth, String value, @Nullable ICalledFunction parent) {
        if (start > end) {
            throw new IllegalArgumentException(Messages.TimeError + '[' + start + ',' + end + ']');
        }
        return new CalledStringFunction(start, end, value, depth, parent);
    }
","    START  public static END  CalledStringFunction create(long start, long end, int depth, String value, @Nullable ICalledFunction parent) {
        if (start > end) {
            throw new IllegalArgumentException(Messages.TimeError + '[' + start + ',' + end + ']');
        }
        return new CalledStringFunction(start, end, value, depth, parent);
    }
","    protected static CalledStringFunction create(long start, long end, int depth, String value, @Nullable ICalledFunction parent) {
        if (start > end) {
            throw new IllegalArgumentException(Messages.TimeError + '[' + start + ',' + end + ']');
        }
        return new CalledStringFunction(start, end, value, depth, parent);
    }
"
360,should this be done internally by `RetryPolicyExhaustedException`? What other uses are there for it?,"  private Function<Throwable, Throwable> getThrowableFunction(CoreEvent event) {
    return throwable -> {
      Throwable cause = getMessagingExceptionCause(throwable);
      CoreEvent exceptionEvent = event;
      if (throwable instanceof MessagingException) {
        exceptionEvent = ((MessagingException) throwable).getEvent();
      }
      // MessagingException cause is set to null in order to avoid RETRY:EXHAUSTED ErrorType replacement
      // during ErrorType resolution (see ChainErrorHandlingUtils and MessagingExceptionResolver)
      return new MessagingException(exceptionEvent,
                                    new RetryPolicyExhaustedException(createStaticMessage(UNTIL_SUCCESSFUL_MSG_PREFIX,
                                                                                          cause.getMessage()),
                                                                      null, owner),
                                    owner);
    };
  }
","  private Function<Throwable, Throwable> getThrowableFunction(CoreEvent event) {
    return throwable -> {
      Throwable cause = getMessagingExceptionCause(throwable);
      CoreEvent exceptionEvent = event;
      if (throwable instanceof MessagingException) {
        exceptionEvent = ((MessagingException) throwable).getEvent();
      }
      // MessagingException cause is set to null in order to avoid RETRY:EXHAUSTED ErrorType replacement
      // during ErrorType resolution (see ChainErrorHandlingUtils and MessagingExceptionResolver)
      return new MessagingException(exceptionEvent,
                                    new RetryPolicyExhaustedException(createStaticMessage(UNTIL_SUCCESSFUL_MSG_PREFIX,
                                                                                          cause.getMessage()),
START                                                                       null, owner), END 
                                    owner);
    };
  }
","  private Function<Throwable, Throwable> getThrowableFunction(CoreEvent event) {
    return throwable -> {
      Throwable cause = getMessagingExceptionCause(throwable);
      CoreEvent exceptionEvent = event;
      if (throwable instanceof MessagingException) {
        exceptionEvent = ((MessagingException) throwable).getEvent();
      }
      // RetryPolicyExhaustedException cause is not set in order to avoid RETRY:EXHAUSTED ErrorType replacement
      // during ErrorType resolution (see ChainErrorHandlingUtils and MessagingExceptionResolver)
      return new MessagingException(exceptionEvent,
                                    new RetryPolicyExhaustedException(createStaticMessage(UNTIL_SUCCESSFUL_MSG_PREFIX,
                                                                                          cause.getMessage()),
                                                                      owner),
                                    owner);
    };
  }
"
361,"Please move the line in the if isRecoveredFromCrash block.
```java
if (isRecoveredFromCrash()) {
  CrashReporter.sendUnhandledCaughtException();
  …
```

This way we don't change the behavior in any kind. We will discuss where to put it later on.","	private void checkIfCrashRecoveryAndFinishActivity(final Activity context) {
		if (isRecoveredFromCrash()) {
			if (!(context instanceof MainMenuActivity)) {
				context.finish();
			} else {
				PreferenceManager.getDefaultSharedPreferences(this).edit().putBoolean(RECOVERED_FROM_CRASH, false).commit();
			}
		}
		CrashReporter.sendUnhandledCaughtException();
	}
","	private void checkIfCrashRecoveryAndFinishActivity(final Activity context) {
		if (isRecoveredFromCrash()) {
			if (!(context instanceof MainMenuActivity)) {
				context.finish();
			} else {
				PreferenceManager.getDefaultSharedPreferences(this).edit().putBoolean(RECOVERED_FROM_CRASH, false).commit();
			}
		}
START 		CrashReporter.sendUnhandledCaughtException(); END 
	}
","	private void checkIfCrashRecoveryAndFinishActivity(final Activity context) {
		if (isRecoveredFromCrash()) {
			CrashReporter.sendUnhandledCaughtException();
			if (!(context instanceof MainMenuActivity)) {
				context.finish();
			} else {
				PreferenceManager.getDefaultSharedPreferences(this).edit().putBoolean(RECOVERED_FROM_CRASH, false).commit();
			}
		}
	}
"
362,Loooooong line,"    public boolean evaluate(String uriHost, String uriPath, String uriQuery, String httpStatus, String contentType, String userAgent) {
        return Pageview.isPageview(uriHost.toString(), uriPath.toString(), uriQuery.toString(), httpStatus.toString(), contentType.toString(), userAgent.toString());
    }
","START     public boolean evaluate(String uriHost, String uriPath, String uriQuery, String httpStatus, String contentType, String userAgent) { END 
        return Pageview.isPageview(uriHost.toString(), uriPath.toString(), uriQuery.toString(), httpStatus.toString(), contentType.toString(), userAgent.toString());
    }
","    public boolean evaluate(
        String uriHost,
        String uriPath,
        String uriQuery,
        String httpStatus,
        String contentType,
        String userAgent
    ) {
        return Pageview.isPageview(
            uriHost,
            uriPath,
            uriQuery,
            httpStatus,
            contentType,
            userAgent
        );
    }
"
363,The `index` field should be read into a local variable outside the loop.,"        public Integer replayObserverFromIndex(Integer idx, SubjectObserver<? super T> observer) {
            int i = idx;
            while (i < index.get()) {
                accept(observer, i);
                i++;
            }

            return i;
        }
","        public Integer replayObserverFromIndex(Integer idx, SubjectObserver<? super T> observer) {
            int i = idx;
START             while (i < index.get()) { END 
                accept(observer, i);
                i++;
            }

            return i;
        }
","        public Integer replayObserverFromIndex(Integer idx, SubjectObserver<? super T> observer) {
            int i = idx;
            while (i < get()) {
                accept(observer, i);
                i++;
            }

            return i;
        }
"
364,"```suggestion
        return getInstance();
```","    public String getUnmodifiedInstance() {
        return m_ipAddress + ""["" + m_serviceName + ""]"";
    }
","    public String getUnmodifiedInstance() {
START         return m_ipAddress + ""["" + m_serviceName + ""]""; END 
    }
","    public String getUnmodifiedInstance() {
        return getInstance();
    }
"
365,Try to fill more of these methods bodies by copying ideas from that pull request or even the classes i pointed you to in the ticket description.,"    public LogEntry save(LogEntry delegate) throws ResourceDoesNotSupportOperationException {
        return null;

    }
","START     public LogEntry save(LogEntry delegate) throws ResourceDoesNotSupportOperationException { END 
        return null;

    }
","	public LogEntry save(LogEntry delegate) throws ResourceDoesNotSupportOperationException {
		throw new ResourceDoesNotSupportOperationException();
	}
"
366,"Two things:

* Arrays.binarySearch() returns a negative if not found, but not necessarily -1 like the original code. And that will make line 453 above fail. You'd also have to check other callers.
* IIRC this operation is called *very* frequently. I think you absolutely want to avoid allocating a dummy object here; it'll just put additional pressure on GC.","	protected int indexOfChild(String localName) {
		AbstractDataTreeNode[] nodes = this.children;
		NoDataDeltaNode localNameNode = new NoDataDeltaNode(localName);
		return Arrays.binarySearch(nodes, localNameNode, (n1, n2) -> n1.name.compareTo(n2.name));
	}
","	protected int indexOfChild(String localName) {
		AbstractDataTreeNode[] nodes = this.children;
		NoDataDeltaNode localNameNode = new NoDataDeltaNode(localName);
START 		return Arrays.binarySearch(nodes, localNameNode, (n1, n2) -> n1.name.compareTo(n2.name)); END 
	}
","	protected int indexOfChild(String localName) {
		AbstractDataTreeNode[] nodes = this.children;
		if (nodes.length == 0) {
			return -1;
		} else if (nodes.length == 1) {
			return nodes[0].name.equals(localName) ? 0 : -1;
		}
		NoDataDeltaNode localNameNode = new NoDataDeltaNode(localName);
		return Arrays.binarySearch(nodes, localNameNode, (n1, n2) -> n1.name.compareTo(n2.name));
	}
"
367,need to wait before doing scrollTop,"	public void test() {
		connect();
		jq("".z-listbox-body"").scrollTop(10000);
		waitResponse();
		Assert.assertTrue(jq(""@listcell:contains(199)"").exists());
	}
","	public void test() {
		connect();
		jq("".z-listbox-body"").scrollTop(10000);
START 		waitResponse(); END 
		Assert.assertTrue(jq(""@listcell:contains(199)"").exists());
	}
","	public void test() {
		connect();
		waitResponse();
		jq("".z-listbox-body"").scrollTop(10000);
		waitResponse();
		Assert.assertTrue(jq(""@listcell:contains(199)"").exists());
	}
"
368,"Our SDK can't be initialized without the internet permission either, so you don't need to check for this.","  @Override public void initialize(Context context, ValueMap settings, LogLevel logLevel)
      throws IllegalStateException {
    if (!hasPermission(context, Manifest.permission.INTERNET)) {
      throw new IllegalStateException(""Apptimize requires INTERNET permission"");
    }
    Apptimize.setup(context, settings.getString(""appkey""));
  }
","  @Override public void initialize(Context context, ValueMap settings, LogLevel logLevel)
      throws IllegalStateException {
START     if (!hasPermission(context, Manifest.permission.INTERNET)) { END 
      throw new IllegalStateException(""Apptimize requires INTERNET permission"");
    }
    Apptimize.setup(context, settings.getString(""appkey""));
  }
","  @Override public void initialize(Context context, ValueMap settings, LogLevel logLevel)
      throws IllegalStateException {
    Apptimize.setup(context, settings.getString(""appkey""));
  }
"
369,Nitpick: AS is complaining about the unnecessary `rootView` variable. 😿,"    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        ViewGroup rootView = createMainView(inflater, container, savedInstanceState);
        return rootView;
    }
","    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
START         ViewGroup rootView = createMainView(inflater, container, savedInstanceState);
        return rootView; END 
    }
","    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        return createMainView(inflater, container, savedInstanceState);
    }
"
370,"Formatting of `( DirectCompilerResult... sets )`, should be `(DirectCompilerResult... sets)`.","    public static Set<FieldDeclaration> mergeFDs( DirectCompilerResult... sets ) {
        Set<FieldDeclaration> result = new HashSet<>();
        for ( DirectCompilerResult fs : sets ) {
            result.addAll(fs.getFieldDeclarations());
        }
        return result;
    }
","START     public static Set<FieldDeclaration> mergeFDs( DirectCompilerResult... sets ) { END 
        Set<FieldDeclaration> result = new HashSet<>();
        for ( DirectCompilerResult fs : sets ) {
            result.addAll(fs.getFieldDeclarations());
        }
        return result;
    }
","    public static Set<FieldDeclaration> mergeFDs( DirectCompilerResult... sets ) {
        return mergeFDs(Arrays.asList(sets));
    }
"
371,Better return here when a host found with UEFI capability as that satisfies the return cond.,"    private Long getHostsByCapability(List<Long> hostList, String hostCapability) {
        int totalHostswithCapability = 0;
        for (Long host : hostList) { //TODO: Fix this in single query instead of polling request for each Host
            Map<String, String> details = hostDetailsDao.findDetails(host);
            if (details.containsKey(Host.HOST_UEFI_ENABLE)) {
                if (details.get(Host.HOST_UEFI_ENABLE).equalsIgnoreCase(""Yes"")) {
                    totalHostswithCapability++;
                }

            }
        }
        return totalHostswithCapability > 0 ? new Long(1) : new Long(0);
    }
","    private Long getHostsByCapability(List<Long> hostList, String hostCapability) {
        int totalHostswithCapability = 0;
        for (Long host : hostList) { //TODO: Fix this in single query instead of polling request for each Host
            Map<String, String> details = hostDetailsDao.findDetails(host);
            if (details.containsKey(Host.HOST_UEFI_ENABLE)) {
                if (details.get(Host.HOST_UEFI_ENABLE).equalsIgnoreCase(""Yes"")) {
START                     totalHostswithCapability++; END 
                }

            }
        }
        return totalHostswithCapability > 0 ? new Long(1) : new Long(0);
    }
","    private Long getHostsByCapability(List<Long> hostList, String hostCapability) {
        for (Long host : hostList) { //TODO: Fix this in single query instead of polling request for each Host
            Map<String, String> details = hostDetailsDao.findDetails(host);
            if (details.containsKey(Host.HOST_UEFI_ENABLE)) {
                if (details.get(Host.HOST_UEFI_ENABLE).equalsIgnoreCase(""Yes"")) {
                    return new Long(1);
                }

            }
        }
        return new Long(0);
    }
"
372,Probably another access modification we don't need (probably the same for `isLoadingAsServer()` ?),"    void setUniverseWrapper(UniverseWrapper wrapper) {
        this.universeWrapper = wrapper;
    }
","START     void setUniverseWrapper(UniverseWrapper wrapper) { END 
        this.universeWrapper = wrapper;
    }
","    public void setUniverseWrapper(UniverseWrapper wrapper) {
        this.universeWrapper = wrapper;
    }
"
373,"I suggest to check whether count is 0, and return null (so that the aggregate constraint simply will not match) in that case.","    public Double getAggregate(AverageAccumulator<Double> result) {
        return (result.value)/result.count;
    }
","    public Double getAggregate(AverageAccumulator<Double> result) {
START         return (result.value)/result.count; END 
    }
","    public Double getAggregate(AverageAccumulator<Double> result) {
        return (result.count == 0)
                ? null
                : ((double)result.value)/result.count;
    }
"
374,Did you mean to use the assert keyword here? Is it functional? Suggest either remove or switch to assertNotNull(),"  public static void openClassLoader() throws IOException {
    ClassLoader myClassLoader = RetentionPolicyTest.class.getClassLoader();
    assert myClassLoader != null;

    // Load the annotated class (and annotation classes) from the annotations-test.jar. See
    // http://b/132100102.
    File jarFile = new File(temporaryFolder.getRoot(), ""annotations-test.jar"");
    try (InputStream in = myClassLoader.getResourceAsStream(""annotations-test.jar"");
         OutputStream out = new FileOutputStream(jarFile))
    {
      Streams.copy(in, out);
    }

    classLoader = new PathClassLoader(jarFile.getAbsolutePath(), myClassLoader);
  }
","  public static void openClassLoader() throws IOException {
    ClassLoader myClassLoader = RetentionPolicyTest.class.getClassLoader();
    START  assert myClassLoader END  != null;

    // Load the annotated class (and annotation classes) from the annotations-test.jar. See
    // http://b/132100102.
    File jarFile = new File(temporaryFolder.getRoot(), ""annotations-test.jar"");
    try (InputStream in = myClassLoader.getResourceAsStream(""annotations-test.jar"");
         OutputStream out = new FileOutputStream(jarFile))
    {
      Streams.copy(in, out);
    }

    classLoader = new PathClassLoader(jarFile.getAbsolutePath(), myClassLoader);
  }
","    public static void openClassLoader() throws IOException {
        ClassLoader myClassLoader = RetentionPolicyTest.class.getClassLoader();
        assertNotNull(myClassLoader);

        // Load the annotated class (and annotation classes) from the annotations-test.jar.
        File jarFile = new File(temporaryFolder.getRoot(), ""annotations-test.jar"");
        try (InputStream in = myClassLoader.getResourceAsStream(""annotations-test.jar"");
             OutputStream out = new FileOutputStream(jarFile)) {
            Streams.copy(in, out);
        }

        classLoader = new PathClassLoader(jarFile.getAbsolutePath(), myClassLoader);
    }
"
375,"I think that the 1st check is not needed, because if method doesn't contains `Consumes`, observer will not called.","	private boolean isWithoutRoot(Parameter[] parameters, JsonObject root, ControllerMethod method) {
		if(method.containsAnnotation(Consumes.class) && method.getMethod().getAnnotation(Consumes.class).withoutRoot()) {
			return true;
		}
		for (Parameter parameter : parameters) {
			if (root.get(parameter.getName()) != null)
				return false;
		}
		return true;
	}
","	private boolean isWithoutRoot(Parameter[] parameters, JsonObject root, ControllerMethod method) {
START 		if(method.containsAnnotation(Consumes.class) && method.getMethod().getAnnotation(Consumes.class).withoutRoot()) { END 
			return true;
		}
		for (Parameter parameter : parameters) {
			if (root.get(parameter.getName()) != null)
				return false;
		}
		return true;
	}
","	private boolean isWithoutRoot(Parameter[] parameters, JsonObject root, ControllerMethod method) {
		if(method.getMethod().getAnnotation(Consumes.class).withoutRoot()) {
			return true;
		}
		for (Parameter parameter : parameters) {
			if (root.get(parameter.getName()) != null)
				return false;
		}
		return true;
	}
"
376,This should check that repository is not null.,"		public String getValue(ITask task) {
			AbstractRepositoryConnector connector = TasksUi.getRepositoryConnector(task.getConnectorKind());
			TaskRepository repository = TasksUiInternal.getRepository(task);
			URL url = connector.getBrowserUrl(repository, task);
			if (url == null) {
				return task.getUrl();
			}
			return url.toString();
		}
","		public String getValue(ITask task) {
			AbstractRepositoryConnector connector = TasksUi.getRepositoryConnector(task.getConnectorKind());
			TaskRepository repository = TasksUiInternal.getRepository(task);
START 			URL url = connector.getBrowserUrl(repository, task); END 
			if (url == null) {
				return task.getUrl();
			}
			return url.toString();
		}
","		public String getValue(ITask task) {
			AbstractRepositoryConnector connector = TasksUi.getRepositoryConnector(task.getConnectorKind());
			TaskRepository repository = TasksUiInternal.getRepository(task);
			if (repository != null) {
				URL url = connector.getBrowserUrl(repository, task);
				if (url != null) {
					return url.toString();
				}
			}
			return task.getUrl();
		}
"
377,"No, `this.` when you call methods.","	protected void onInit() {
		this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(this.getBeanFactory());
		if (this.mongoTemplate == null) {
			this.mongoTemplate = new ReactiveMongoTemplate(this.mongoDbFactory, this.mongoConverter);
		}
		this.initialized = true;
	}
","	protected void onInit() {
START 		this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(this.getBeanFactory()); END 
		if (this.mongoTemplate == null) {
			this.mongoTemplate = new ReactiveMongoTemplate(this.mongoDbFactory, this.mongoConverter);
		}
		this.initialized = true;
	}
","	protected void onInit() {
		this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(getBeanFactory());
		if (this.mongoTemplate == null) {
			this.mongoTemplate = new ReactiveMongoTemplate(this.mongoDbFactory, this.mongoConverter);
		}
		this.initialized = true;
	}
"
378,Missing a close bracket (`)`) before the `;`.,"    public String read(String key) {
        String data = dataManager.read(key);
        return (data == null) ? null : encode(cryptoBox.decrypt(iv, decode(data));
    }
","    public String read(String key) {
        String data = dataManager.read(key);
START         return (data == null) ? null : encode(cryptoBox.decrypt(iv, decode(data)); END 
    }
","    public String read(String key) {
        String data = dataManager.read(key);
        return (data == null) ? null : encode(cryptoBox.decrypt(iv, decode(data)));
    }
"
379,please break the line,"    protected void executeVdsBrokerCommand() {
        try {
            DeviceInfoReturn deviceInfoReturn =
                    getBroker().attachManagedBlockStorageVolume(getParameters().getVolumeId(), JsonHelper.mapToJson(getParameters().getConnectionInfo()));
            setReturnValue(deviceInfoReturn.getDeviceInfo());
        } catch (IOException e) {
            log.error(""attachment of managed block storage device failed {}"", e);
            return;
        }
    }
","    protected void executeVdsBrokerCommand() {
        try {
            DeviceInfoReturn deviceInfoReturn =
START                     getBroker().attachManagedBlockStorageVolume(getParameters().getVolumeId(), JsonHelper.mapToJson(getParameters().getConnectionInfo())); END 
            setReturnValue(deviceInfoReturn.getDeviceInfo());
        } catch (IOException e) {
            log.error(""attachment of managed block storage device failed {}"", e);
            return;
        }
    }
","    protected void executeVdsBrokerCommand() {
        DeviceInfoReturn deviceInfoReturn =
                getBroker().attachManagedBlockStorageVolume(getParameters().getVolumeId(), getParameters().getConnectionInfo());
        setReturnValue(deviceInfoReturn.getDeviceInfo());
    }
"
380,"Could be cached, `SingleIndexedInt.of()` and cache 0-127 :)","  public IndexedInts getRow()
  {
    // Treat any non-single-valued row as a row containing a single null value, to ensure consistency with
    // other expression selectors. See also ExpressionSelectors.supplierFromDimensionSelector for similar behavior.
    final IndexedInts row = selector.getRow();

    if (row.size() == 1) {
      if (nullAdjustment == 0) {
        return row;
      } else {
        return new SingleIndexedInt(row.get(0) + nullAdjustment);
      }
    } else {
      // Can't handle non-singly-valued rows in expressions.
      // Treat them as nulls until we think of something better to do.
      return new SingleIndexedInt(0);
    }
  }
","  public IndexedInts getRow()
  {
    // Treat any non-single-valued row as a row containing a single null value, to ensure consistency with
    // other expression selectors. See also ExpressionSelectors.supplierFromDimensionSelector for similar behavior.
    final IndexedInts row = selector.getRow();

    if (row.size() == 1) {
      if (nullAdjustment == 0) {
        return row;
      } else {
        return new SingleIndexedInt(row.get(0) + nullAdjustment);
      }
    } else {
      // Can't handle non-singly-valued rows in expressions.
      // Treat them as nulls until we think of something better to do.
START       return new SingleIndexedInt(0); END 
    }
  }
","  public IndexedInts getRow()
  {
    final IndexedInts row = selector.getRow();

    if (row.size() == 1) {
      if (nullAdjustment == 0) {
        return row;
      } else {
        return SingleIndexedInt.of(row.get(0) + nullAdjustment);
      }
    } else {
      // Can't handle non-singly-valued rows in expressions.
      // Treat them as nulls until we think of something better to do.
      return SingleIndexedInt.of(0);
    }
  }
"
381,These look like they are for debugging.  could we make them debug logs instead?,"    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
        super.channelRegistered(ctx);
        LOG.info(""channelRegistered {}"", ctx);
    }
","    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
        super.channelRegistered(ctx);
        LOG.info(""channelRegistered {}"", ctx);
START     } END 
","    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {
        super.channelRegistered(ctx);
        LOG.debug(""channelRegistered {}"", ctx);
    }
"
382,"Shouldn't this be at line 134 ? Replacing ``.getClass()`` check instead of ``obj == null`` check ? Like in ``User`` object ? I know it will return ``false`` for ``null`` anyway, but this will also return false if you compare ``Member`` and ``RichMember`` which we wanted to be comparable. In ``User`` object you just continue with params comparison when you compare ``User`` and ``Candidate`` or ``RichUser``. I believe implementation should be at least equivalent in both ``Member`` and ``User`` objects.","	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof Member)) {
			return false;
		}
		if (!getClass().equals(obj.getClass())) {
			return false;
		}
		Member other = (Member) obj;
		return getId() == other.getId();
	}
","	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
START 		if (!(obj instanceof Member)) { END 
			return false;
		}
		if (!getClass().equals(obj.getClass())) {
			return false;
		}
		Member other = (Member) obj;
		return getId() == other.getId();
	}
","	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (!(obj instanceof Member)) {
			return false;
		}
		Member other = (Member) obj;
		return getId() == other.getId();
	}
"
383,Style-nit:  You can just return Collections.unmodifiableList ... here and avoid assignment back to l.,"  public List<RefRight> getAllRights(final ApprovalCategory.Id id) {
    List<RefRight> l = new ArrayList<RefRight>();
    l.addAll(getLocalRights(id));
    l.addAll(getInheritedRights(id));
    Collections.sort(l, RefRight.REF_PATTERN_ORDER);
    l = Collections.unmodifiableList(RefControl.filterMostSpecific(l));
    return l;
  }
","  public List<RefRight> getAllRights(final ApprovalCategory.Id id) {
    List<RefRight> l = new ArrayList<RefRight>();
    l.addAll(getLocalRights(id));
    l.addAll(getInheritedRights(id));
    Collections.sort(l, RefRight.REF_PATTERN_ORDER);
START     l = Collections.unmodifiableList(RefControl.filterMostSpecific(l)); END 
    return l;
  }
","  public List<RefRight> getAllRights(final ApprovalCategory.Id id) {
    List<RefRight> l = new ArrayList<RefRight>();
    l.addAll(getLocalRights(id));
    l.addAll(getInheritedRights(id));
    Collections.sort(l, RefRight.REF_PATTERN_ORDER);
    return Collections.unmodifiableList(RefControl.filterMostSpecific(l));
  }
"
384,is this needed?,"    public void checkSelectFilter(final String label,
                                  final String value) {
        selectInputs.computeIfPresent(label,
                                      (key, values) -> {
                                          values.forEach(i -> {
                                              if ((i.getValue().equals(value)) && i.getChecked() == false) {
                                                  i.setChecked(true);
                                              }
                                          });
                                          return values;
                                      });
    }
","    public void checkSelectFilter(final String label,
                                  final String value) {
        selectInputs.computeIfPresent(label,
                                      (key, values) -> {
                                          values.forEach(i -> {
START                                               if ((i.getValue().equals(value)) && i.getChecked() == false) { END 
                                                  i.setChecked(true);
                                              }
                                          });
                                          return values;
                                      });
    }
","    public void checkSelectFilter(final String label,
                                  final String value) {
        selectInputs.computeIfPresent(label,
                                      (key, values) -> {
                                          values.forEach(i -> {
                                              if (i.getValue().equals(value) && i.getChecked() == false) {
                                                  i.setChecked(true);
                                              }
                                          });
                                          return values;
                                      });
    }
"
385,"Instead remove synchronized from the setter, and make the variable volatile","    public synchronized Marshaller<Key> getKeyMarshaller() {
        return keyMarshaller;
    }
","START     public synchronized Marshaller<Key> getKeyMarshaller() { END 
        return keyMarshaller;
    }
","    public Marshaller<Key> getKeyMarshaller() {
        return keyMarshaller;
    }
"
386,"An `int` type can or should never be null, maybe you want to use an `Integer` type which can be null. On other places you are comparing this with value `0`, so maybe only a wrong written condition?","    public void loadMyStep(int id) {
        try {
            if (!Objects.equals(id, null)) {
                setMySchritt(this.serviceManager.getTaskService().getById(id));
            }
        } catch (DAOException e) {
            Helper.setFehlerMeldung(""Error retrieving task with ID '"" + id + ""'; "", e.getMessage());
        }
    }
","    public void loadMyStep(int id) {
        try {
START             if (!Objects.equals(id, null)) { END 
                setMySchritt(this.serviceManager.getTaskService().getById(id));
            }
        } catch (DAOException e) {
            Helper.setFehlerMeldung(""Error retrieving task with ID '"" + id + ""'; "", e.getMessage());
        }
    }
","    public void loadMyStep(int id) {
        try {
            setMySchritt(this.serviceManager.getTaskService().getById(id));
        } catch (DAOException e) {
            Helper.setFehlerMeldung(""Error retrieving task with ID '"" + id + ""'; "", e.getMessage());
        }
    }
"
387,Is a bit surprising that it gets one InputStream and one Resource.,"  private void addBootstrap3And4Style(
      String bootstrap3FileName, InputStream bootstrap3Data, Resource bootstrap4resource) {
    try (InputStream bootstrap4Data = bootstrap4resource.getInputStream()) {
      String bootstrap4FileName = bootstrap4resource.getFilename();
      LOG.debug(""Adding matching bootstrap 4 theme with name {}"", bootstrap4FileName);
      styleService.addStyle(
          bootstrap3FileName,
          bootstrap3FileName,
          bootstrap3Data,
          bootstrap4FileName,
          bootstrap4Data);
    } catch (IOException e) {
      LOG.error(""error adding new bootstrap 4 theme"", e);
    }
  }
","  private void addBootstrap3And4Style(
START       String bootstrap3FileName, InputStream bootstrap3Data, Resource bootstrap4resource) { END 
    try (InputStream bootstrap4Data = bootstrap4resource.getInputStream()) {
      String bootstrap4FileName = bootstrap4resource.getFilename();
      LOG.debug(""Adding matching bootstrap 4 theme with name {}"", bootstrap4FileName);
      styleService.addStyle(
          bootstrap3FileName,
          bootstrap3FileName,
          bootstrap3Data,
          bootstrap4FileName,
          bootstrap4Data);
    } catch (IOException e) {
      LOG.error(""error adding new bootstrap 4 theme"", e);
    }
  }
","  private void addBootstrap3And4Style(
      String bootstrap3FileName, InputStream bootstrap3Data, Resource bootstrap4resource) {
    try (InputStream bootstrap4Data = bootstrap4resource.getInputStream()) {
      String bootstrap4FileName = bootstrap4resource.getFilename();
      LOG.debug(""Adding matching bootstrap 4 theme with name {}"", bootstrap4FileName);
      styleService.addStyle(
          bootstrap3FileName,
          bootstrap3FileName,
          bootstrap3Data,
          bootstrap4FileName,
          bootstrap4Data);
    } catch (Exception e) {
      LOG.error(""error adding new bootstrap 4 theme"", e);
    }
  }
"
388,please use a logging framework instead of System.out for messages. preferably slf4j.,"  public void init() throws DBException {
    synchronized(RocksDBClient.class) {
      if(rocksDb == null) {
        rocksDbDir = Paths.get(getProperties().getProperty(PROPERTY_ROCKSDB_DIR));
        System.out.println(""RocksDB data dir: "" + rocksDbDir);

        try {
          rocksDb = initRocksDB();
        } catch (final IOException | RocksDBException e) {
          throw new DBException(e);
        }
      }

      references++;
    }
  }
","  public void init() throws DBException {
    synchronized(RocksDBClient.class) {
      if(rocksDb == null) {
        rocksDbDir = Paths.get(getProperties().getProperty(PROPERTY_ROCKSDB_DIR));
START         System.out.println(""RocksDB data dir: "" + rocksDbDir); END 

        try {
          rocksDb = initRocksDB();
        } catch (final IOException | RocksDBException e) {
          throw new DBException(e);
        }
      }

      references++;
    }
  }
","  public void init() throws DBException {
    synchronized(RocksDBClient.class) {
      if(rocksDb == null) {
        rocksDbDir = Paths.get(getProperties().getProperty(PROPERTY_ROCKSDB_DIR));
        LOGGER.info(""RocksDB data dir: "" + rocksDbDir);

        try {
          rocksDb = initRocksDB();
        } catch (final IOException | RocksDBException e) {
          throw new DBException(e);
        }
      }

      references++;
    }
  }
"
389,"We don't need impala for hdi35, it's Cloudera only.","  protected void registerExtraDatabaseTypes( Properties configuration ) throws KettlePluginException {
    /*String hiveSimbaDriverName = configuration.getProperty( ""hive2.simba.driver"", ""com.simba.hive.jdbc41.HS2Driver"" );
      JDBC_POSSIBLE_DRIVER_MAP.put( ""hive2Simba"", hiveSimbaDriverName );*/

    String impalaSimbaDriverName =
      configuration.getProperty( ""impala.simba.driver"", ""com.cloudera.impala.jdbc41.Driver"" );
    JDBC_POSSIBLE_DRIVER_MAP.put( ""ImpalaSimba"", impalaSimbaDriverName );
  }
","  protected void registerExtraDatabaseTypes( Properties configuration ) throws KettlePluginException {
    /*String hiveSimbaDriverName = configuration.getProperty( ""hive2.simba.driver"", ""com.simba.hive.jdbc41.HS2Driver"" );
      JDBC_POSSIBLE_DRIVER_MAP.put( ""hive2Simba"", hiveSimbaDriverName );*/

START     String impalaSimbaDriverName = END 
      configuration.getProperty( ""impala.simba.driver"", ""com.cloudera.impala.jdbc41.Driver"" );
    JDBC_POSSIBLE_DRIVER_MAP.put( ""ImpalaSimba"", impalaSimbaDriverName );
  }
","  protected void registerExtraDatabaseTypes( Properties configuration ) throws KettlePluginException {
    /*String hiveSimbaDriverName = configuration.getProperty( ""hive2.simba.driver"", ""com.simba.hive.jdbc41.HS2Driver"" );
      JDBC_POSSIBLE_DRIVER_MAP.put( ""hive2Simba"", hiveSimbaDriverName );*/

    /*String impalaSimbaDriverName =
      configuration.getProperty( ""impala.simba.driver"", ""com.cloudera.impala.jdbc41.Driver"" );
    JDBC_POSSIBLE_DRIVER_MAP.put( ""ImpalaSimba"", impalaSimbaDriverName );*/
  }
"
390,nit: make this static,"    void addEntriesAndRotateLogs(EntryLogger entryLogger, int numOfRotations)
            throws IOException {
        EntryLogManagerBase entryLogManager = (EntryLogManagerBase) entryLogger.getEntryLogManager();
        entryLogManager.setCurrentLogForLedgerAndAddToRotate(EntryLogger.UNASSIGNED_LEDGERID, null);
        Random rand = new Random();
        for (int i = 0; i < numOfRotations; i++) {
            addEntries(entryLogger, 10);
            entryLogManager.setCurrentLogForLedgerAndAddToRotate(EntryLogger.UNASSIGNED_LEDGERID, null);
        }
        addEntries(entryLogger, 10);
    }
","START     void addEntriesAndRotateLogs(EntryLogger entryLogger, int numOfRotations) END 
            throws IOException {
        EntryLogManagerBase entryLogManager = (EntryLogManagerBase) entryLogger.getEntryLogManager();
        entryLogManager.setCurrentLogForLedgerAndAddToRotate(EntryLogger.UNASSIGNED_LEDGERID, null);
        Random rand = new Random();
        for (int i = 0; i < numOfRotations; i++) {
            addEntries(entryLogger, 10);
            entryLogManager.setCurrentLogForLedgerAndAddToRotate(EntryLogger.UNASSIGNED_LEDGERID, null);
        }
        addEntries(entryLogger, 10);
    }
","    void addEntriesAndRotateLogs(EntryLogger entryLogger, int numOfRotations)
            throws IOException {
        EntryLogManagerBase entryLogManager = (EntryLogManagerBase) entryLogger.getEntryLogManager();
        entryLogManager.setCurrentLogForLedgerAndAddToRotate(EntryLogger.UNASSIGNED_LEDGERID, null);
        for (int i = 0; i < numOfRotations; i++) {
            addEntries(entryLogger, 10);
            entryLogManager.setCurrentLogForLedgerAndAddToRotate(EntryLogger.UNASSIGNED_LEDGERID, null);
        }
        addEntries(entryLogger, 10);
    }
"
391,"We're trying to kill off the entire compat package - please don't add new dependencies to it.

You can use common-lang's StringUtils.isEmpty(str)","    public static ArrayList<Guid> getGuidListFromString(String str) {
        if (StringHelper.isNullOrEmpty(str)) {
            return new ArrayList<Guid>();
        }
        return getGuidListFromStringArray(Arrays.asList(str.split(SEPARATOR)));
    }
","    public static ArrayList<Guid> getGuidListFromString(String str) {
START         if (StringHelper.isNullOrEmpty(str)) { END 
            return new ArrayList<Guid>();
        }
        return getGuidListFromStringArray(Arrays.asList(str.split(SEPARATOR)));
    }
","    public static ArrayList<Guid> getGuidListFromString(String str) {
        if (StringUtils.isEmpty(str)) {
            return new ArrayList<Guid>();
        }
        return getGuidListFromStringArray(Arrays.asList(str.split(SEPARATOR)));
    }
"
392,do you still need the requestePermissionName and responsePermissionFlag?,"    public FileMockContext(Context context) {
        mContext = context;
        // default
        requestedPermissionName = ""android.permission.INTERNET"";
        responsePermissionFlag = PackageManager.PERMISSION_GRANTED;
        permissionMap.put(requestedPermissionName,responsePermissionFlag);
    }
","    public FileMockContext(Context context) {
        mContext = context;
        // default
START         requestedPermissionName = ""android.permission.INTERNET""; END 
        responsePermissionFlag = PackageManager.PERMISSION_GRANTED;
        permissionMap.put(requestedPermissionName,responsePermissionFlag);
    }
","    public FileMockContext(Context context) {
        mContext = context;
        // default
        String requestedPermissionName = ""android.permission.INTERNET"";
        int responsePermissionFlag = PackageManager.PERMISSION_GRANTED;
        permissionMap.put(requestedPermissionName,responsePermissionFlag);
    }
"
393,No need for intermediate `blob` variable,"    public static MultipartInput buildMultipartInput(Object input, String content) throws IOException {
        MultipartInput mpinput = new MultipartInput();
        mpinput.setRequest(content);
        if (input instanceof Blob) {
            Blob blob = (Blob) input;
            mpinput.setBlob(blob);
        } else if (input instanceof Blobs) {
            mpinput.setBlobs((Blobs) input);
        } else {
            throw new IllegalArgumentException(""Unsupported binary input object: "" + input);
        }
        return mpinput;
    }
","    public static MultipartInput buildMultipartInput(Object input, String content) throws IOException {
        MultipartInput mpinput = new MultipartInput();
        mpinput.setRequest(content);
        if (input instanceof Blob) {
            Blob blob = (Blob) input;
START             mpinput.setBlob(blob); END 
        } else if (input instanceof Blobs) {
            mpinput.setBlobs((Blobs) input);
        } else {
            throw new IllegalArgumentException(""Unsupported binary input object: "" + input);
        }
        return mpinput;
    }
","    public static MultipartInput buildMultipartInput(Object input, String content) throws IOException {
        MultipartInput mpinput = new MultipartInput();
        mpinput.setRequest(content);
        if (input instanceof Blob) {
            mpinput.setBlob((Blob) input);
        } else if (input instanceof Blobs) {
            mpinput.setBlobs((Blobs) input);
        } else {
            throw new IllegalArgumentException(""Unsupported binary input object: "" + input);
        }
        return mpinput;
    }
"
394,Just do `return availabilities(episodes)` here. Same for the rest of them.,"        private ImmutableListMultimap<String, Availability> getAvailabilities(List<Episode> episodes) {
            ImmutableListMultimap<String, Availability> availabilities;
            try {
                availabilities = availabilities(episodes);
            } catch (GlycerinException e) {
                throw Throwables.propagate(e);
            }
            return availabilities;
        }
","        private ImmutableListMultimap<String, Availability> getAvailabilities(List<Episode> episodes) {
            ImmutableListMultimap<String, Availability> availabilities;
            try {
START                 availabilities = availabilities(episodes); END 
            } catch (GlycerinException e) {
                throw Throwables.propagate(e);
            }
            return availabilities;
        }
","        private ImmutableListMultimap<String, Availability> getAvailabilities(List<Episode> episodes) {
            ImmutableListMultimap<String, Availability> availabilities;
            try {
                return availabilities(episodes);
            } catch (GlycerinException e) {
                throw Throwables.propagate(e);
            }
        }
"
395,"nice. Maybe we can have a `isWhitespaceOrComment` method on the category and change this to:

`return getCategory(kind).isWhitespaceOrComment()`","    public static boolean isWhitespaceOrComment(int kind) {
        switch (getCategory(kind)) {
            case WHITESPACE:
            case COMMENT:
                return true;
            default:
                return false;
        }
    }
","    public static boolean isWhitespaceOrComment(int kind) {
START         switch (getCategory(kind)) { END 
            case WHITESPACE:
            case COMMENT:
                return true;
            default:
                return false;
        }
    }
","    public static boolean isWhitespaceOrComment(int kind) {
        return getCategory(kind).isWhitespaceOrComment();
    }
"
396,Unwanted final?,"    public List<String> getRuleChainVisits() {
        if (xPathRuleQueryNeedsInitialization()) {
            initXPathRuleQuery();

            for (final String nodeName : xpathRuleQuery.getRuleChainVisits()) {
                super.addRuleChainVisit(nodeName);
            }
        }
        return super.getRuleChainVisits();
    }
","    public List<String> getRuleChainVisits() {
        if (xPathRuleQueryNeedsInitialization()) {
            initXPathRuleQuery();

START             for (final String nodeName : xpathRuleQuery.getRuleChainVisits()) { END 
                super.addRuleChainVisit(nodeName);
            }
        }
        return super.getRuleChainVisits();
    }
","    public List<String> getRuleChainVisits() {
        if (xPathRuleQueryNeedsInitialization()) {
            initXPathRuleQuery();

            for (String nodeName : xpathRuleQuery.getRuleChainVisits()) {
                super.addRuleChainVisit(nodeName);
            }
        }
        return super.getRuleChainVisits();
    }
"
397,cut at &&,"    private boolean appliesToEvent(ITmfEvent event) {
        String eventName = event.getType().getName();
        String eventHandlerName = fName;

        // test for correct name
        if (eventName.equals(eventHandlerName)) {
            return true;
        }

        // test for the wildcard at the end
        if ((eventHandlerName.endsWith(TmfXmlStrings.WILDCARD) && eventName.startsWith(eventHandlerName.replace(TmfXmlStrings.WILDCARD, TmfXmlStrings.NULL)))) {
            return true;
        }
        return false;
    }
","    private boolean appliesToEvent(ITmfEvent event) {
        String eventName = event.getType().getName();
        String eventHandlerName = fName;

        // test for correct name
        if (eventName.equals(eventHandlerName)) {
            return true;
        }

        // test for the wildcard at the end
START         if ((eventHandlerName.endsWith(TmfXmlStrings.WILDCARD) && eventName.startsWith(eventHandlerName.replace(TmfXmlStrings.WILDCARD, TmfXmlStrings.NULL)))) { END 
            return true;
        }
        return false;
    }
","    private boolean appliesToEvent(ITmfEvent event) {
        String eventName = event.getType().getName();

        /* test for full name */
        if (eventName.equals(fName)) {
            return true;
        }

        /* test for the wildcard at the end */
        if ((fName.endsWith(TmfXmlStrings.WILDCARD) && eventName.startsWith(fName.replace(TmfXmlStrings.WILDCARD, TmfXmlStrings.NULL)))) {
            return true;
        }
        return false;
    }
"
398,Maybe we should derive this from Prefs.getMediaWikiBaseUri() or require the client to pass in a default protocol. I think I prefer the latter to avoid complicating this nice and simple model type.,"        @NonNull public String server() {
            // A protocol-relative URL can be returned from the API.
            // Protocol-relative URLs need to guarantee to be accessible via https, so we assume
            // https in this case.
            if (server.startsWith(""//"")) {
                server = ""https:"" + server;
            }
            return server;
        }
","        @NonNull public String server() {
            // A protocol-relative URL can be returned from the API.
            // Protocol-relative URLs need to guarantee to be accessible via https, so we assume
            // https in this case.
            if (server.startsWith(""//"")) {
                server = START  ""https:"" + END  server;
            }
            return server;
        }
","        @NonNull public String server() {
            return server;
        }
"
399,"Here I would make this view, or any view, as ""stupid"" as possible. 

The `if` here could be in presenter and as could this variable `cardByOrganizationalUnitIdentifier`.
This way you see what the component does by looking at the presenter and the functionality can be tested with the unit test.","    public void init(OrganizationalUnitsScreen presenter) {
        this.presenter = presenter;
        if (!presenter.canCreateOrganizationalUnit()) {
            createOrganizationalUnit.setHidden(true);
        } else {
            createOrganizationalUnit.setTextContent(ts.format(LibraryConstants.CreateOrganizationalUnit,
                                                              translationUtils.getOrganizationalUnitAliasInSingular()));
        }
        title.setTextContent(translationUtils.getOrganizationalUnitAliasInPlural());
        filterName.setAttribute(""placeholder"",
                                ts.getTranslation(LibraryConstants.FilterByName));
        cardByOrganizationalUnitIdentifier = new HashMap<>();
    }
","    public void init(OrganizationalUnitsScreen presenter) {
        this.presenter = presenter;
        if (!presenter.canCreateOrganizationalUnit()) {
            createOrganizationalUnit.setHidden(true);
        } else {
            createOrganizationalUnit.setTextContent(ts.format(LibraryConstants.CreateOrganizationalUnit,
                                                              translationUtils.getOrganizationalUnitAliasInSingular()));
        }
        title.setTextContent(translationUtils.getOrganizationalUnitAliasInPlural());
        filterName.setAttribute(""placeholder"",
                                ts.getTranslation(LibraryConstants.FilterByName));
START         cardByOrganizationalUnitIdentifier = new HashMap<>(); END 
    }
","    public void init(OrganizationalUnitsScreen presenter) {
        this.presenter = presenter;
        createOrganizationalUnit.setTextContent(ts.format(LibraryConstants.CreateOrganizationalUnit,
                                                          translationUtils.getOrganizationalUnitAliasInSingular()));
        title.setTextContent(translationUtils.getOrganizationalUnitAliasInPlural());
        filterName.setAttribute(""placeholder"",
                                ts.getTranslation(LibraryConstants.FilterByName));
    }
"
400,Can we use .equals() instead of .compareTo?,"    private CertificateDTO addCertByAlias(List<CertificateDTO> toList, List<CertificateDTO> fromList, String alias){
        for(CertificateDTO cert : fromList){
            if(StringUtils.isNotEmpty(cert.getAlias()) && StringUtils.isNotEmpty(alias) && cert.getAlias().compareTo(alias)==0){
                toList.add(cert);
                fromList.remove(cert);
                return cert;
            }
        }
        return null;
    }
","    private CertificateDTO addCertByAlias(List<CertificateDTO> toList, List<CertificateDTO> fromList, String alias){
        for(CertificateDTO cert : fromList){
START             if(StringUtils.isNotEmpty(cert.getAlias()) && StringUtils.isNotEmpty(alias) && cert.getAlias().compareTo(alias)==0){ END 
                toList.add(cert);
                fromList.remove(cert);
                return cert;
            }
        }
        return null;
    }
","    private CertificateDTO addCertByAlias(List<CertificateDTO> toList, List<CertificateDTO> fromList, String alias){
        for(CertificateDTO cert : fromList){
            if (StringUtils.isNotEmpty(cert.getAlias()) && StringUtils.isNotEmpty(alias)
                && cert.getAlias().equals(alias)) {
                toList.add(0, cert);
                fromList.remove(cert);
                return cert;
            }
        }
        return null;
    }
"
401,"pls replace with
 strings != null && strings.isEmpty()","    public static ArrayList<Guid> getGuidListFromStringArray(List<String> strings) {
        ArrayList<Guid> guidList = new ArrayList<Guid>();
        if (CollectionUtils.isEmpty(strings)) {
            for (String guidString : strings) {
                guidList.add(Guid.createGuidFromString(guidString));
            }
        }
        return guidList;
    }
","    public static ArrayList<Guid> getGuidListFromStringArray(List<String> strings) {
        ArrayList<Guid> guidList = new ArrayList<Guid>();
START         if (CollectionUtils.isEmpty(strings)) { END 
            for (String guidString : strings) {
                guidList.add(Guid.createGuidFromString(guidString));
            }
        }
        return guidList;
    }
","    public static ArrayList<Guid> getGuidListFromStringArray(List<String> strings) {
        ArrayList<Guid> guidList = new ArrayList<Guid>();
        if (strings != null && !strings.isEmpty()) {
            for (String guidString : strings) {
                guidList.add(Guid.createGuidFromString(guidString));
            }
        }
        return guidList;
    }
"
402,"Should be an iterator assertion, e.g:
```
assertThat(Arrays.asList(ITEMS).iterator()).hasNext();
```","  public void withAssertions_assertThat_iterator_Test() {
    assertThat(Arrays.asList(ITEMS).iterator()).toIterable().contains(ITEMS[0]);
  }
","  public void withAssertions_assertThat_iterator_Test() {
START     assertThat(Arrays.asList(ITEMS).iterator()).toIterable().contains(ITEMS[0]); END 
  }
","  public void withAssertions_assertThat_iterator_Test() {
    assertThat(Arrays.asList(ITEMS).iterator()).hasNext();
  }
"
403,I dont think this try/catch is necessary to just log this message. Why don't you move the message to processLogData,"    public LogEntry deserializeLogData(ILogData logData) throws Exception{
        LogEntry logEntry;
        try {
            logEntry = logData.getLogEntry(runtime);
        } catch (Exception e) {
            log.error(""Cannot deserialize log entry"" + logData.getGlobalAddress(), e);
            throw e;
        }

        return logEntry;
    }
","    public LogEntry deserializeLogData(ILogData logData) throws Exception{
        LogEntry logEntry;
        try {
            logEntry = logData.getLogEntry(runtime);
        } catch (Exception e) {
            log.error(""Cannot deserialize log entry"" + logData.getGlobalAddress(), e);
START             throw e; END 
        }

        return logEntry;
    }
","    public LogEntry deserializeLogData(ILogData logData) throws Exception{
        return logData.getLogEntry(runtime);
    }
"
404,The result of this call is unused. I don't think it should be here.,"  public QueryMetrics<Query<?>> makeMetrics(SegmentMetadataQuery query)
  {
    query.withAnalysisTypes(getFinalAnalysisTypes(query));
    return queryMetricsFactory.makeMetrics(query);
  }
","  public QueryMetrics<Query<?>> makeMetrics(SegmentMetadataQuery query)
  {
START     query.withAnalysisTypes(getFinalAnalysisTypes(query)); END 
    return queryMetricsFactory.makeMetrics(query);
  }
","  public QueryMetrics<Query<?>> makeMetrics(SegmentMetadataQuery query)
  {
    return queryMetricsFactory.makeMetrics(query);
  }
"
405,"This isn't really a debug statement, more of an info or trace.","    private static void checkAssertion(SamlAssertionWrapper assertion, String confirmMethod)
        throws WSSecurityException {
        if (OpenSAMLUtil.isMethodHolderOfKey(confirmMethod)) {
            if (assertion.getSubjectKeyInfo() == null) {
                LOG.debug(""There is no Subject KeyInfo to match the holder-of-key subject conf method"");
                throw new WSSecurityException(ErrorCode.FAILED_CHECK, ""noKeyInSAMLToken"");
            }
            // The assertion must have been signed for HOK
            if (!assertion.isSigned()) {
                LOG.debug(""A holder-of-key assertion must be signed"");
                throw new WSSecurityException(ErrorCode.FAILED_CHECK, ""invalidSAMLsecurity"");
            }
        }

    }
","    private static void checkAssertion(SamlAssertionWrapper assertion, String confirmMethod)
        throws WSSecurityException {
        if (OpenSAMLUtil.isMethodHolderOfKey(confirmMethod)) {
            if (assertion.getSubjectKeyInfo() == null) {
START                 LOG.debug(""There is no Subject KeyInfo to match the holder-of-key subject conf method""); END 
                throw new WSSecurityException(ErrorCode.FAILED_CHECK, ""noKeyInSAMLToken"");
            }
            // The assertion must have been signed for HOK
            if (!assertion.isSigned()) {
                LOG.debug(""A holder-of-key assertion must be signed"");
                throw new WSSecurityException(ErrorCode.FAILED_CHECK, ""invalidSAMLsecurity"");
            }
        }

    }
","    private static void checkAssertion(SamlAssertionWrapper assertion, String confirmMethod)
        throws WSSecurityException {
        if (OpenSAMLUtil.isMethodHolderOfKey(confirmMethod)) {
            if (assertion.getSubjectKeyInfo() == null) {
                LOG.info(""There is no Subject KeyInfo to match the holder-of-key subject conf method"");
                throw new WSSecurityException(ErrorCode.FAILED_CHECK, ""noKeyInSAMLToken"");
            }
            // The assertion must have been signed for HOK
            if (!assertion.isSigned()) {
                LOG.info(""A holder-of-key assertion must be signed"");
                throw new WSSecurityException(ErrorCode.FAILED_CHECK, ""invalidSAMLsecurity"");
            }
        }

    }
"
406,you can remove `String.format` here too,"  public void checkChangedColumn() throws Exception {
    test(String.format(""ALTER session SET `%s` = %d;"", SLICE_TARGET,
      ExecConstants.SLICE_TARGET_DEFAULT));
    testBuilder()
        .sqlQuery(""SELECT status FROM sys.options WHERE name = '%s' AND type = 'SESSION'"", SLICE_TARGET)
        .unOrdered()
        .baselineColumns(""status"")
        .baselineValues(""DEFAULT"")
        .build()
        .run();
  }
","  public void checkChangedColumn() throws Exception {
START     test(String.format(""ALTER session SET `%s` = %d;"", SLICE_TARGET, END 
      ExecConstants.SLICE_TARGET_DEFAULT));
    testBuilder()
        .sqlQuery(""SELECT status FROM sys.options WHERE name = '%s' AND type = 'SESSION'"", SLICE_TARGET)
        .unOrdered()
        .baselineColumns(""status"")
        .baselineValues(""DEFAULT"")
        .build()
        .run();
  }
","  public void checkChangedColumn() throws Exception {
    test(""ALTER session SET `%s` = %d;"", SLICE_TARGET,
      ExecConstants.SLICE_TARGET_DEFAULT);
    testBuilder()
        .sqlQuery(""SELECT status FROM sys.options WHERE name = '%s' AND type = 'SESSION'"", SLICE_TARGET)
        .unOrdered()
        .baselineColumns(""status"")
        .baselineValues(""DEFAULT"")
        .build()
        .run();
  }
"
407,"remove ""this.""","	public void tearDown() throws Exception {
		this.mTranslateSpecialChar = null;
		this.mTestStr.clear();
		this.mVerifyStr.clear();
	}
","	public void tearDown() throws Exception {
START 		this.mTranslateSpecialChar = null; END 
		this.mTestStr.clear();
		this.mVerifyStr.clear();
	}
","	public void tearDown() throws Exception {
		mTranslateSpecialChar = null;
		mTestStr.clear();
		mVerifyStr.clear();
	}
"
408,I'd like to keep formatting/mark up out of our controllers. Maybe we could put the `queryText` into its model attribute and use it in `searchResults.jsp`,"    private String search(SearchRequest searchRequest, Model model, HttpServletRequest request) {
        SearchResultResponse resultResponse = doSearch(searchRequest, model, request);
        String queryText = formatQueryText(request);

        model.addAttribute(""resultType"", ""searchResults"");
        model.addAttribute(""pageSubtitle"", ""Search results for <span class=\""query-request\"">\""""
                + queryText + ""\""</span>"");

        return ""searchResults"";
    }
","    private String search(SearchRequest searchRequest, Model model, HttpServletRequest request) {
        SearchResultResponse resultResponse = doSearch(searchRequest, model, request);
        String queryText = formatQueryText(request);

        model.addAttribute(""resultType"", ""searchResults"");
START         model.addAttribute(""pageSubtitle"", ""Search results for <span class=\""query-request\"">\"""" END 
                + queryText + ""\""</span>"");

        return ""searchResults"";
    }
","    private String search(SearchRequest searchRequest, Model model, HttpServletRequest request) {
        SearchResultResponse resultResponse = doSearch(searchRequest, model, request);
        String queryText = formatQueryText(request);

        model.addAttribute(""resultType"", ""searchResults"");
        model.addAttribute(""pageSubtitle"", queryText);

        return ""searchResults"";
    }
"
409,I prefer to leave this as package-private to avoid a synthetic accessor.,"	private FetchV0Request(@NonNull Set<ObjectId> wantIds, int depth,
			@NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit,
			@NonNull Set<String> clientCapabilities) {
		super(wantIds, depth, clientShallowCommits, filterBlobLimit,
				clientCapabilities);
	}
","START 	private FetchV0Request(@NonNull Set<ObjectId> wantIds, int depth, END 
			@NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit,
			@NonNull Set<String> clientCapabilities) {
		super(wantIds, depth, clientShallowCommits, filterBlobLimit,
				clientCapabilities);
	}
","	FetchV0Request(@NonNull Set<ObjectId> wantIds, int depth,
			@NonNull Set<ObjectId> clientShallowCommits, long filterBlobLimit,
			@NonNull Set<String> clientCapabilities) {
		super(wantIds, depth, clientShallowCommits, filterBlobLimit,
				clientCapabilities);
	}
"
410,"I'd inline this variable:

`return new WeightedReservoirSampleStateStrategy(WeightedDoubleReservoirSample.deserialize(input));`","    public static WeightedReservoirSampleStateStrategy deserialize(SliceInput input)
    {
        WeightedDoubleReservoirSample reservoir = WeightedDoubleReservoirSample.deserialize(input);

        return new WeightedReservoirSampleStateStrategy(reservoir);
    }
","    public static WeightedReservoirSampleStateStrategy deserialize(SliceInput input)
    {
START         WeightedDoubleReservoirSample reservoir = WeightedDoubleReservoirSample.deserialize(input); END 

        return new WeightedReservoirSampleStateStrategy(reservoir);
    }
","    public static WeightedReservoirSampleStateStrategy deserialize(SliceInput input)
    {
        return new WeightedReservoirSampleStateStrategy(WeightedDoubleReservoirSample.deserialize(input));
    }
"
411,"Isn't this an anti-pattern described by https://github.com/google/guava/wiki/Why-we-deprecated-Throwables.propagate

Shall we move away from using a deprecated method in general?","  private void cleanup(File execDir) {
    if (execDir != null) {
      try {
        FileUtils.deleteDirectory(execDir);
      } catch (IOException e) {
        Throwables.propagate(e);
      }
    }
  }
","  private void cleanup(File execDir) {
    if (execDir != null) {
      try {
        FileUtils.deleteDirectory(execDir);
      } catch (IOException e) {
START         Throwables.propagate(e); END 
      }
    }
  }
","  private void cleanup(File execDir) {
    if (execDir != null) {
      try {
        FileUtils.deleteDirectory(execDir);
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
"
412,delete this line as the call to `super.isEqualTo(expected);` should be the only required assertion,"  public SELF isEqualTo(String stringTemplate, Object ... args){
    String expected = String.format(stringTemplate, args);
    this.comparables.assertEqual(info, actual, expected);
    return super.isEqualTo(expected);
  }
","  public SELF isEqualTo(String stringTemplate, Object ... args){
    String expected = String.format(stringTemplate, args);
START     this.comparables.assertEqual(info, actual, expected); END 
    return super.isEqualTo(expected);
  }
","  public SELF isEqualTo(String stringTemplate, Object ... args){
    String expected = String.format(stringTemplate, args);
    return super.isEqualTo(expected);
  }
"
413,can be inlined i think,"    public String getText() {
        if (""textarea"".equals(getWrappedElement().getTagName())) {
            return getWrappedElement().getText();
        }

        Optional<String> enteredText = Optional.of(getWrappedElement().getAttribute(""value""));
        return enteredText.orElse("""");
    }
","    public String getText() {
        if (""textarea"".equals(getWrappedElement().getTagName())) {
            return getWrappedElement().getText();
        }

START         Optional<String> enteredText = Optional.of(getWrappedElement().getAttribute(""value"")); END 
        return enteredText.orElse("""");
    }
","    public String getText() {
        if (""textarea"".equals(getWrappedElement().getTagName())) {
            return getWrappedElement().getText();
        }

        return Optional.of(getWrappedElement().getAttribute(""value"")).orElse("""");
    }
"
414,you shouldn't need to cast to double here,"    public double getTotalPopulationWeight()
    {
        return (double) reservoir.getTotalPopulationCount();
    }
","    public double getTotalPopulationWeight()
    {
START         return (double) reservoir.getTotalPopulationCount(); END 
    }
","    public double getTotalPopulationWeight()
    {
        return reservoir.getTotalPopulationCount();
    }
"
415,Please synchronize it.,"	public void draw(Batch batch, float parentAlpha) {
		batch.setShader(shader);
		if (alpha == 0.0f) {
			super.setVisible(false);
		} else {
			super.setVisible(true);
		}

		if (lookData instanceof DroneVideoLookData) {
			lookData.draw(batch, alpha);
		}

		if (isLookVisible() && this.getDrawable() != null) {
			super.draw(batch, this.alpha);
		}
		batch.setShader(null);
	}
","START 	public void draw(Batch batch, float parentAlpha) { END 
		batch.setShader(shader);
		if (alpha == 0.0f) {
			super.setVisible(false);
		} else {
			super.setVisible(true);
		}

		if (lookData instanceof DroneVideoLookData) {
			lookData.draw(batch, alpha);
		}

		if (isLookVisible() && this.getDrawable() != null) {
			super.draw(batch, this.alpha);
		}
		batch.setShader(null);
	}
","	public synchronized void draw(Batch batch, float parentAlpha) {
		batch.setShader(shader);
		if (alpha == 0.0f) {
			super.setVisible(false);
		} else {
			super.setVisible(true);
		}

		if (lookData instanceof DroneVideoLookData) {
			lookData.draw(batch, alpha);
		}

		if (isLookVisible() && this.getDrawable() != null) {
			super.draw(batch, this.alpha);
		}
		batch.setShader(null);
	}
"
416,"Isn't this redundant with `principal.isAdministrator()`, knowing that `UserManager#makePrincipal` goes through `NuxeoPrincipalImpl#setVirtualGroups` and `NuxeoPrincipalImpl#updateAllGroups`?

See https://github.com/nuxeo/nuxeo/blob/master/nuxeo-services/nuxeo-platform-usermanager-api/src/main/java/org/nuxeo/ecm/platform/usermanager/NuxeoPrincipalImpl.java#L367.","    protected boolean canSearchUsersAndGroups(NuxeoPrincipal principal) {
        if (principal.isAdministrator() || principal.isMemberOf(POWER_USERS_GROUP)) {
            return true;
        }
        UserManager um = Framework.getService(UserManager.class);
        List<String> adminGroups = um.getAdministratorsGroups();
        return adminGroups.stream().anyMatch(principal::isMemberOf);
    }
","    protected boolean canSearchUsersAndGroups(NuxeoPrincipal principal) {
        if (principal.isAdministrator() || principal.isMemberOf(POWER_USERS_GROUP)) {
            return true;
        }
        UserManager um = Framework.getService(UserManager.class);
        List<String> adminGroups = um.getAdministratorsGroups();
START         return adminGroups.stream().anyMatch(principal::isMemberOf); END 
    }
","    protected boolean canSearchUsersAndGroups(NuxeoPrincipal principal) {
        return principal.isAdministrator() || principal.isMemberOf(POWER_USERS_GROUP);
    }
"
417,minor: `this` not required anywhere.,"  void setSucceeded() {
    this.succeeded = true;
    this.done = true;
  }
","  void setSucceeded() {
START     this.succeeded = true; END 
    this.done = true;
  }
","  void setSucceeded() {
    succeeded = true;
    done = true;
  }
"
418,Might not work with controlled models,"	public void addPapyrusTable(Table tableInstance) {
		getResource().getContents().add(tableInstance);
	}
","	public void addPapyrusTable(Table tableInstance) {
START 		getResource().getContents().add(tableInstance); END 
	}
","	public void addPapyrusTable(Table tableInstance) {
		if (getResource() != null) {
			getResource().getContents().add(tableInstance);
		}
	}
"
419,Done,"    public <T> ReportedConfigurations add(ReportedConfigurationType type, T actual, T expected, boolean inSync) {
        String actualValue = actual != null ? actual.toString() : ""null"";
        String expectedValue = expected != null ? expected.toString() : ""null"";
        reportedConfigurationList.add(new ReportedConfiguration(type, actualValue, expectedValue, inSync));
        return this;
    }
","    public <T> ReportedConfigurations add(ReportedConfigurationType type, T actual, T expected, boolean inSync) {
        String actualValue = actual != null ? actual.toString() : ""null"";
START         String expectedValue = expected != null ? expected.toString() : ""null""; END 
        reportedConfigurationList.add(new ReportedConfiguration(type, actualValue, expectedValue, inSync));
        return this;
    }
","    public <T> ReportedConfigurations add(ReportedConfigurationType type, T actual, T expected, boolean inSync) {
        String actualValue = actual == null ? null : actual.toString();
        String expectedValue = expected == null ? null : expected.toString();
        reportedConfigurationList.add(new ReportedConfiguration(type, actualValue, expectedValue, inSync));
        return this;
    }
"
420,"For the case when `table` is null, the string will be formed incorrectly - `Table=` should be appended only if `table != null`","  public String toString() {
    StringBuilder sb = new StringBuilder(""MaprDBJsonRecordReader[Table="");
    if (table != null) {
      sb.append(table.getPath());
    }
    if (reader != null) {
      sb.append("", Document ID="")
          .append(IdCodec.asString(reader.getId()));
    }
    sb.append("", reader="")
        .append(reader)
        .append(']');
    return sb.toString();
  }
","  public String toString() {
    StringBuilder sb = new StringBuilder(""MaprDBJsonRecordReader[Table="");
START     if (table != null) { END 
      sb.append(table.getPath());
    }
    if (reader != null) {
      sb.append("", Document ID="")
          .append(IdCodec.asString(reader.getId()));
    }
    sb.append("", reader="")
        .append(reader)
        .append(']');
    return sb.toString();
  }
","  public String toString() {
    StringBuilder sb = new StringBuilder(""MaprDBJsonRecordReader[Table="")
        .append(table != null ? table.getPath() : null);
    if (reader != null) {
      sb.append("", Document ID="")
          .append(IdCodec.asString(reader.getId()));
    }
    sb.append("", reader="")
        .append(reader)
        .append(']');
    return sb.toString();
  }
"
421,"You can import `OPTIONAL`, `BINARY`, `UTF8`.","    private static Statistics stringColumnStats(String minimum, String maximum)
    {
        Statistics.Builder builder = Statistics.getBuilderForReading(new PrimitiveType(Type.Repetition.OPTIONAL, PrimitiveType.PrimitiveTypeName.BINARY, ""testFile"", OriginalType.UTF8));
        builder.withMin(minimum.getBytes())
               .withMax(maximum.getBytes())
               .withNumNulls(0);
        return builder.build();
    }
","    private static Statistics stringColumnStats(String minimum, String maximum)
    {
START         Statistics.Builder builder = Statistics.getBuilderForReading(new PrimitiveType(Type.Repetition.OPTIONAL, PrimitiveType.PrimitiveTypeName.BINARY, ""testFile"", OriginalType.UTF8)); END 
        builder.withMin(minimum.getBytes())
               .withMax(maximum.getBytes())
               .withNumNulls(0);
        return builder.build();
    }
","    private static Statistics stringColumnStats(String minimum, String maximum)
    {
        Statistics.Builder builder = Statistics.getBuilderForReading(new PrimitiveType(OPTIONAL, BINARY, ""testFile"", UTF8));
        builder.withMin(minimum.getBytes())
               .withMax(maximum.getBytes())
               .withNumNulls(0);
        return builder.build();
    }
"
422,"Does this belong in `SentryOptions`? In other SDKs we have it more as a POJO type of class.
Perhaps these methods could be pulled out into an internal helper class.","    private static Dsn resolveDsn(Lookup lookup, @Nullable String dsn) {
        try {
            if (Util.isNullOrEmpty(dsn)) {
                dsn = Dsn.dsnFrom(lookup);
            }

            return new Dsn(dsn);
        } catch (Exception e) {
            logger.error(""Error creating valid DSN from: '{}'."", dsn, e);
            throw e;
        }
    }
","START     private static Dsn resolveDsn(Lookup lookup, @Nullable String dsn) { END 
        try {
            if (Util.isNullOrEmpty(dsn)) {
                dsn = Dsn.dsnFrom(lookup);
            }

            return new Dsn(dsn);
        } catch (Exception e) {
            logger.error(""Error creating valid DSN from: '{}'."", dsn, e);
            throw e;
        }
    }
","    private static String resolveDsn(Lookup lookup, @Nullable String dsn) {
        try {
            if (Util.isNullOrEmpty(dsn)) {
                dsn = Dsn.dsnFrom(lookup);
            }

            return dsn;
        } catch (Exception e) {
            logger.error(""Error creating valid DSN from: '{}'."", dsn, e);
            throw e;
        }
    }
"
423,"This code should be:

```
this.channel.close();
```","    public void reset(WritableByteChannel channel) throws IOException {
        this.channel = channel;
    }
","    public void reset(WritableByteChannel channel) throws IOException {
START         this.channel = channel; END 
    }
","    public void reset(WritableByteChannel channel) throws IOException {
        this.channel.close();
        this.channel = channel;
    }
"
424,You should do the close before calling `super.stop`,"    public void stop(ComponentContext context) throws InterruptedException {
        super.stop(context);
        providers.values().forEach(KeyValueStoreProvider::close);
    }
","    public void stop(ComponentContext context) throws InterruptedException {
START         super.stop(context); END 
        providers.values().forEach(KeyValueStoreProvider::close);
    }
","    public void stop(ComponentContext context) throws InterruptedException {
        providers.values().forEach(KeyValueStoreProvider::close);
        super.stop(context);
    }
"
425,What does this list of exceptions bring to the test? Can't we replace it with `throws Exception`?,"  void foo1()
    throws InvalidKeyException, InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchPaddingException, UnsupportedEncodingException, IllegalBlockSizeException,
    BadPaddingException {
    byte[] bytes = ""111"".getBytes(""UTF-8"");
    random.nextBytes(bytes);
    IvParameterSpec iv = new IvParameterSpec(bytes); // Compliant
  }
","  void foo1()
START     throws InvalidKeyException, InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchPaddingException, UnsupportedEncodingException, IllegalBlockSizeException, END 
    BadPaddingException {
    byte[] bytes = ""111"".getBytes(""UTF-8"");
    random.nextBytes(bytes);
    IvParameterSpec iv = new IvParameterSpec(bytes); // Compliant
  }
","  void foo1()
    throws Exception {
    byte[] bytes = ""111"".getBytes(""UTF-8"");
    random.nextBytes(bytes);
    IvParameterSpec iv = new IvParameterSpec(bytes); // Compliant
  }
"
426,"I'm pretty sure removing the change to this line will help fix the test failure problem.

I don't think a subdeployment has this attachment, and in any case a subdeployment never has a management name that is different from deploymentUnit.getName(). A user can't assign a management name to a subdeployment as it's an internal part of the top level deployment, not something independently added to the server config.","    private static PathAddress createDeploymentAddressPrefix(DeploymentUnit deploymentUnit) {
        if (deploymentUnit.getParent() == null) {
            return PathAddress.pathAddress(DEPLOYMENT, deploymentUnit.getAttachment(Attachments.MANAGEMENT_NAME));
        } else {
            return createDeploymentAddressPrefix(deploymentUnit.getParent()).append(SUBDEPLOYMENT, deploymentUnit.getAttachment(Attachments.MANAGEMENT_NAME));
        }
    }
","    private static PathAddress createDeploymentAddressPrefix(DeploymentUnit deploymentUnit) {
        if (deploymentUnit.getParent() == null) {
            return PathAddress.pathAddress(DEPLOYMENT, deploymentUnit.getAttachment(Attachments.MANAGEMENT_NAME));
        } else {
START             return createDeploymentAddressPrefix(deploymentUnit.getParent()).append(SUBDEPLOYMENT, deploymentUnit.getAttachment(Attachments.MANAGEMENT_NAME)); END 
        }
    }
","    private static PathAddress createDeploymentAddressPrefix(DeploymentUnit deploymentUnit) {
        if (deploymentUnit.getParent() == null) {
            return PathAddress.pathAddress(DEPLOYMENT, deploymentUnit.getAttachment(Attachments.MANAGEMENT_NAME));
        } else {
            return createDeploymentAddressPrefix(deploymentUnit.getParent()).append(SUBDEPLOYMENT, deploymentUnit.getName());
        }
    }
"
427,More likely meaningless access changes,"    void addUnloadedPlayer(String id, EntityData.PlayerStore unloadedPlayer) {
        unloadedPlayers.put(id, unloadedPlayer);
    }
","START     void addUnloadedPlayer(String id, EntityData.PlayerStore unloadedPlayer) { END 
        unloadedPlayers.put(id, unloadedPlayer);
    }
","    public void addUnloadedPlayer(String id, EntityData.PlayerStore unloadedPlayer) {
        unloadedPlayers.put(id, unloadedPlayer);
    }
"
428,"I would always call `stop` regardless of the mode (and make sure that `stop` is a no-op if it wasn't started). That way, as we implement other modes, we don't have to update that piece of code.","    public void stop() {
        if (isStarted.compareAndSet(true, false)) {
            stopQueue();
            dispatcher.stop();
        }

        if (config.getPersistentQueueMode() == PersistentQueueMode.STICKY_POLLING) {
            reaper.stop();
        }
    }
","    public void stop() {
        if (isStarted.compareAndSet(true, false)) {
            stopQueue();
            dispatcher.stop();
        }

START         if (config.getPersistentQueueMode() == PersistentQueueMode.STICKY_POLLING) { END 
            reaper.stop();
        }
    }
","    public void stop() {
        if (isStarted.compareAndSet(true, false)) {
            stopQueue();
            dispatcher.stop();
        }

        reaper.stop();
    }
"
429,Why not just always call the update and have the update either apply the change if it is different or ignore it,"    public static synchronized void setupRetentionPolicyMgr(int numThreads) {
        if (s_retentionPolicyMgr == null) {
            s_retentionPolicyMgr = new RetentionPolicyMgr(numThreads);
        } else if (s_retentionPolicyMgr.getRetentionThreadPoolSize() != numThreads) {
            s_retentionPolicyMgr.updateThreadPoolSize(numThreads);
        }
    }
","    public static synchronized void setupRetentionPolicyMgr(int numThreads) {
        if (s_retentionPolicyMgr == null) {
            s_retentionPolicyMgr = new RetentionPolicyMgr(numThreads);
        } else if (s_retentionPolicyMgr.getRetentionThreadPoolSize() != numThreads) {
START             s_retentionPolicyMgr.updateThreadPoolSize(numThreads); END 
        }
    }
","    public static synchronized void setupRetentionPolicyMgr(int numThreads) {
        if (s_retentionPolicyMgr == null) {
            s_retentionPolicyMgr = new RetentionPolicyMgr(numThreads);
        } else {
            s_retentionPolicyMgr.updateThreadPoolSize(numThreads);
        }
    }
"
430,Why can't you just return value here?,"  public String toString()
  {
    return String.valueOf(value);
  }
","  public String toString()
  {
START     return String.valueOf(value); END 
  }
","  public String toString()
  {
    return value;
  }
"
431,Change this to `log`,"	public List<Concept> getPossibleValues() {
		try {
			return Context.getConceptService().getConceptsByName("""");
		}
		catch (Exception e) {
			logger.error(""Error"", e);
		}
		//pass
		return Collections.emptyList();
	}
","	public List<Concept> getPossibleValues() {
		try {
			return Context.getConceptService().getConceptsByName("""");
		}
		catch (Exception e) {
START 			logger.error(""Error"", e); END 
		}
		//pass
		return Collections.emptyList();
	}
","	public List<Concept> getPossibleValues() {
		try {
			return Context.getConceptService().getConceptsByName("""");
		}
		catch (Exception e) {
			log.error(""Error"", e);
		}
		//pass
		return Collections.emptyList();
	}
"
432,Do everything in the CertificateManagerServiceImpl . Use the certificate class just for sending to/from information on the View.,"    public String getIssuerName() {
        issuerName = StringUtils.isEmpty(x509Cert.getIssuerDN().getName()) ? EMPTY_FIELD
            : x509Cert.getIssuerDN().getName();
        return issuerName;
    }
","    public String getIssuerName() {
START         issuerName = StringUtils.isEmpty(x509Cert.getIssuerDN().getName()) ? EMPTY_FIELD END 
            : x509Cert.getIssuerDN().getName();
        return issuerName;
    }
","    public String getIssuerName() {
        return issuerName;
    }
"
433,I am not able to see this constructor being used? There is no need to chain the constructors.,"        TestShardConsumerSubscriber(RecordsPublisher recordsPublisher, ExecutorService executorService, int bufferSize,
                ShardConsumer shardConsumer, int readTimeoutsToIgnoreBeforeWarning) {
            super(recordsPublisher, executorService, bufferSize, shardConsumer, readTimeoutsToIgnoreBeforeWarning);
            this.recordsPublisher = recordsPublisher;
            this.executorService = executorService;
            this.bufferSize = bufferSize;
            this.shardConsumer = shardConsumer;
        }
","START         TestShardConsumerSubscriber(RecordsPublisher recordsPublisher, ExecutorService executorService, int bufferSize, END 
                ShardConsumer shardConsumer, int readTimeoutsToIgnoreBeforeWarning) {
            super(recordsPublisher, executorService, bufferSize, shardConsumer, readTimeoutsToIgnoreBeforeWarning);
            this.recordsPublisher = recordsPublisher;
            this.executorService = executorService;
            this.bufferSize = bufferSize;
            this.shardConsumer = shardConsumer;
        }
","        TestShardConsumerSubscriber(RecordsPublisher recordsPublisher, ExecutorService executorService, int bufferSize,
                ShardConsumer shardConsumer,
                // Setup test expectations
                int readTimeoutsToIgnoreBeforeWarning) {
            super(recordsPublisher, executorService, bufferSize, shardConsumer, readTimeoutsToIgnoreBeforeWarning);
        }
"
434,This should be handled in item.getLabel(),"        public String getText(final Object element) {
            Item item = (Item) element;
            String label = item.getLabel();
            if (label == null || label.trim().length() == 0) {
                label = item.getViewpoint().getName();
            }
            return label;
        }
","        public String getText(final Object element) {
            Item item = (Item) element;
           START   String label = item.getLabel();
            if (label == null || label.trim().length() == 0) {
                label = item.getViewpoint().getName();
            } END 
            return label;
        }
","        public String getText(final Object element) {
            Item item = (Item) element;
            return item.getLabel();
        }
"
435,"Please recheck the condition here, having `success=true` and `log(""..failed.."")` in the same block seems wrong.","	public boolean flush () {
		final boolean[] success = {false};
		ObjCRuntime.autoreleasepool(new Runnable() {
			@Override
			public void run() {
				if (!nsDictionary.writeToFileAtomically(file.getAbsolutePath(), false)) {
					Gdx.app.debug(""IOSPreferences"", ""Failed to write NSDictionary to file "" + file);
					success[0] = true;
				}
			}
		});
		return success[0];
	}
","	public boolean flush () {
		final boolean[] success = {false};
		ObjCRuntime.autoreleasepool(new Runnable() {
			@Override
			public void run() {
				if (!nsDictionary.writeToFileAtomically(file.getAbsolutePath(), false)) {
					Gdx.app.debug(""IOSPreferences"", ""Failed to write NSDictionary to file "" + file);
START 					success[0] = true; END 
				}
			}
		});
		return success[0];
	}
","	public boolean flush () {
		final boolean[] success = {false};
		ObjCRuntime.autoreleasepool(new Runnable() {
			@Override
			public void run() {
				if (nsDictionary.writeToFileAtomically(file.getAbsolutePath(), false)) {
					success[0] = true;
				} else {
					Gdx.app.debug(""IOSPreferences"", ""Failed to write NSDictionary to file "" + file);
				}
			}
		});
		return success[0];
	}
"
436,"This isn't necessary, new FileOutputStream(file) will create the file if it doesn't exist yet.","	private void createFile(File parentDir, String name, String content)
			throws IOException {
		File file = new File(parentDir, name);
		file.createNewFile();
		FileOutputStream fos = null;
		try {
			fos = new FileOutputStream(file);
			fos.write(content.getBytes(""UTF-8""));
		} finally {
			if (fos != null)
				fos.close();
		}
	}
","	private void createFile(File parentDir, String name, String content)
			throws IOException {
		File file = new File(parentDir, name);
START 		file.createNewFile(); END 
		FileOutputStream fos = null;
		try {
			fos = new FileOutputStream(file);
			fos.write(content.getBytes(""UTF-8""));
		} finally {
			if (fos != null)
				fos.close();
		}
	}
","	private void createFile(File parentDir, String name, String content)
			throws IOException {
		File file = new File(parentDir, name);
		FileOutputStream fos = new FileOutputStream(file);
		try {
			fos.write(content.getBytes(""UTF-8""));
		} finally {
			fos.close();
		}
	}
"
437,"The SERVERS_ROOT grouping node is defined as nt:unstructured in the cnd, so the third arg (tko:servers type) throws an exception when the create is attempted.  Changing the third arg to null will create it without issue.","    public KomodoObject komodoServersNode(UnitOfWork transaction) throws KException {
        ArgCheck.isNotNull( transaction, ""transaction"" ); //$NON-NLS-1$
        ArgCheck.isTrue( ( transaction.getState() == org.komodo.spi.repository.Repository.UnitOfWork.State.NOT_STARTED ),
        ""transaction state is not NOT_STARTED"" ); //$NON-NLS-1$

        komodoEnvironment(transaction);
        return create(transaction, SERVERS_ROOT, Environment.SERVERS);
    }
","    public KomodoObject komodoServersNode(UnitOfWork transaction) throws KException {
        ArgCheck.isNotNull( transaction, ""transaction"" ); //$NON-NLS-1$
        ArgCheck.isTrue( ( transaction.getState() == org.komodo.spi.repository.Repository.UnitOfWork.State.NOT_STARTED ),
        ""transaction state is not NOT_STARTED"" ); //$NON-NLS-1$

        komodoEnvironment(transaction);
START         return create(transaction, SERVERS_ROOT, Environment.SERVERS); END 
    }
","    public KomodoObject komodoServersNode(UnitOfWork transaction) throws KException {
        ArgCheck.isNotNull( transaction, ""transaction"" ); //$NON-NLS-1$
        ArgCheck.isTrue( ( transaction.getState() == org.komodo.spi.repository.Repository.UnitOfWork.State.NOT_STARTED ),
        ""transaction state is not NOT_STARTED"" ); //$NON-NLS-1$

        komodoEnvironment(transaction);
        return create(transaction, SERVERS_ROOT, null);
    }
"
438,No longer used! rip this field out,"    public DefaultEquivalenceResultBuilder(
            ScoreCombiner<T> combiner,
            EquivalenceFilter<T> filter,
            List<EquivalenceExtractor<T>> extractors
    ) {
        this.combiner = combiner;
        this.filter = filter;
        this.extractors = extractors;

        this.multipleCandidateExtractor = MultipleCandidateExtractor.create();
    }
","    public DefaultEquivalenceResultBuilder(
            ScoreCombiner<T> combiner,
            EquivalenceFilter<T> filter,
            List<EquivalenceExtractor<T>> extractors
    ) {
        this.combiner = combiner;
        this.filter = filter;
        this.extractors = extractors;

START         this.multipleCandidateExtractor = MultipleCandidateExtractor.create(); END 
    }
","    public DefaultEquivalenceResultBuilder(
            ScoreCombiner<T> combiner,
            EquivalenceFilter<T> filter,
            List<EquivalenceExtractor<T>> extractors
    ) {
        this.combiner = combiner;
        this.filter = filter;
        this.extractors = extractors;

    }
"
439,Should ```if``` condition be: ```if ( !isNanosecondPrecisionSupported() )``` ?,"		public ParametersBuilder add(int hour, int minute, int second, int nanosecond, String offset, ZoneId defaultTimeZone) {
			if ( isNanosecondPrecisionSupported() ) {
				nanosecond = 0;
			}
			return add( defaultTimeZone, hour, minute, second, nanosecond, offset, 1970, 1, 1 );
		}
","		public ParametersBuilder add(int hour, int minute, int second, int nanosecond, String offset, ZoneId defaultTimeZone) {
			if ( isNanosecondPrecisionSupported() ) {
START 				nanosecond = 0; END 
			}
			return add( defaultTimeZone, hour, minute, second, nanosecond, offset, 1970, 1, 1 );
		}
","		public ParametersBuilder add(int hour, int minute, int second, int nanosecond, String offset, ZoneId defaultTimeZone) {
			if ( !isNanosecondPrecisionSupported() ) {
				nanosecond = 0;
			}
			return add( defaultTimeZone, hour, minute, second, nanosecond, offset, 1970, 1, 1 );
		}
"
440,"@eviltak, you mentioned removing the need for the class parameter by checking on the type of the default value? Can you please do that?","        public void setUp() {
            setting = new SettingImpl<>(Integer.class, SETTING_ID,
                    50, new RangedNumberValidator<>(0, 100, false, false));

            eventResult = -1;

            setting.subscribe(propertyChangeEvent -> eventResult = (int) propertyChangeEvent.getNewValue());
        }
","        public void setUp() {
START             setting = new SettingImpl<>(Integer.class, SETTING_ID, END 
                    50, new RangedNumberValidator<>(0, 100, false, false));

            eventResult = -1;

            setting.subscribe(propertyChangeEvent -> eventResult = (int) propertyChangeEvent.getNewValue());
        }
","        public void setUp() {
            setting = new SettingImpl<>(SETTING_ID,
                    50, new RangedNumberValidator<>(0, 100, false, false));

            eventResult = -1;

            setting.subscribe(propertyChangeEvent -> eventResult = (int) propertyChangeEvent.getNewValue());
        }
"
441,"Instead of `check(Rule...` and `check(Context...` (which may be enriched with others in the future, simply have a `DefinitionTransformer` pass that does nothing but this check, or use the `AbstractReflectiveVisitor`.","    private void check(Rule rule) {
        if (rule.att().contains(""unblock""))
            return;
        resetVars();
        gatherVars(rule.body());
        gatherVars(rule.requires());
        gatherVars(rule.ensures());
        check(rule.body());
        check(rule.requires());
        check(rule.ensures());
    }
","START     private void check(Rule rule) { END 
        if (rule.att().contains(""unblock""))
            return;
        resetVars();
        gatherVars(rule.body());
        gatherVars(rule.requires());
        gatherVars(rule.ensures());
        check(rule.body());
        check(rule.requires());
        check(rule.ensures());
    }
","    private void check(Rule rule) {
        resetVars();
        gatherVars(rule.body());
        check(rule.body(), true);
        check(rule.requires(), false);
        check(rule.ensures(), false);
    }
"
442,"It is better to use

``` java
participantStatus.name()
```

since it cannot be overridden whereas toString() can.","    public void writeTo(ParticipantStatus participantStatus, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
        entityStream.write(participantStatus.toString().getBytes());
    }
","    public void writeTo(ParticipantStatus participantStatus, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
START         entityStream.write(participantStatus.toString().getBytes()); END 
    }
","    public void writeTo(ParticipantStatus participantStatus, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException {
        entityStream.write(participantStatus.name().getBytes());
    }
"
443,I'd move this above super.stop() for safety.  but not the fgBundle... line,"    public void stop(BundleContext context) throws Exception {
	    shutdownActiveLaunches();
		plugin = null;
		super.stop(context);
        fgBundleContext = null;
		if (fMemoryRetrievalFactory != null) {
			Platform.getAdapterManager().unregisterAdapters(fMemoryRetrievalFactory, IDMContext.class);
		}
	}
","    public void stop(BundleContext context) throws Exception {
	    shutdownActiveLaunches();
		plugin = null;
		super.stop(context);
        fgBundleContext = null;
START 		if (fMemoryRetrievalFactory != null) { END 
			Platform.getAdapterManager().unregisterAdapters(fMemoryRetrievalFactory, IDMContext.class);
		}
	}
","    public void stop(BundleContext context) throws Exception {
	    shutdownActiveLaunches();
		plugin = null;
		
		if (fMemoryRetrievalFactory != null) {
			Platform.getAdapterManager().unregisterAdapters(fMemoryRetrievalFactory, IDMContext.class);
		}
		
		super.stop(context);
        fgBundleContext = null;
	}
"
444,"It's unsafe to store lists directly (whoever has the reference can still modify the list afterwards). Perhaps it'd be worth making fEventList final, and have this method do a .clear() and shallow-copy the list contents over.","    public void setEventList(List<ITimeEvent> eventList) {
        fEventList = eventList;
    }
","    public void setEventList(List<ITimeEvent> eventList) {
START         fEventList = eventList; END 
    }
","    public void setEventList(List<ITimeEvent> eventList) {
        fEventList = new ArrayList<ITimeEvent>(eventList);
    }
"
445,there is a `getInt` variant,"        public static HostInfo fromBytes(byte[] bytes) throws JSONException
        {
            final JSONObject obj = new JSONObject(new String(bytes, StandardCharsets.UTF_8));
            return new HostInfo(obj.getString(HOST_IP), obj.getString(GROUP), (int)obj.getLong(LOCAL_SITES_COUNT));
        }
","        public static HostInfo fromBytes(byte[] bytes) throws JSONException
        {
            final JSONObject obj = new JSONObject(new String(bytes, StandardCharsets.UTF_8));
START             return new HostInfo(obj.getString(HOST_IP), obj.getString(GROUP), (int)obj.getLong(LOCAL_SITES_COUNT)); END 
        }
","        public static HostInfo fromBytes(byte[] bytes) throws JSONException
        {
            final JSONObject obj = new JSONObject(new String(bytes, StandardCharsets.UTF_8));
            return new HostInfo(obj.getString(HOST_IP), obj.getString(GROUP), obj.getInt(LOCAL_SITES_COUNT));
        }
"
446,it has to be otherway round,"  public void addContent(HttpContent httpContent)
      throws RestServiceException {
    if (!isOpen()) {
      nettyMetrics.multipartRequestAlreadyClosedError.inc();
      throw new RestServiceException(""The request has been closed and is not accepting content"",
          RestServiceErrorCode.RequestChannelClosed);
    } else {
      rawRequestContents.add(httpContent);
      ReferenceCountUtil.retain(httpContent);
    }
  }
","  public void addContent(HttpContent httpContent)
      throws RestServiceException {
    if (!isOpen()) {
      nettyMetrics.multipartRequestAlreadyClosedError.inc();
      throw new RestServiceException(""The request has been closed and is not accepting content"",
          RestServiceErrorCode.RequestChannelClosed);
    } else {
      rawRequestContents.add(httpContent);
START       ReferenceCountUtil.retain(httpContent); END 
    }
  }
","  public void addContent(HttpContent httpContent)
      throws RestServiceException {
    if (!isOpen()) {
      nettyMetrics.multipartRequestAlreadyClosedError.inc();
      throw new RestServiceException(""The request has been closed and is not accepting content"",
          RestServiceErrorCode.RequestChannelClosed);
    } else {
      rawRequestContents.add(ReferenceCountUtil.retain(httpContent));
    }
  }
"
447,No need to assign to a temporary variable.,"    private String extractConnectionKey(final iOSVariant iOSVariant) {
        final StringBuilder sb = new StringBuilder()
                .append(iOSVariant.getVariantID())
                .append(iOSVariant.isProduction() ? ""-prod"" : ""-dev"");

        return  sb.toString();
    }
","    private String extractConnectionKey(final iOSVariant iOSVariant) {
START         final StringBuilder sb = new StringBuilder() END 
                .append(iOSVariant.getVariantID())
                .append(iOSVariant.isProduction() ? ""-prod"" : ""-dev"");

        return  sb.toString();
    }
","    private String extractConnectionKey(final iOSVariant iOSVariant) {
        return new StringBuilder()
                .append(iOSVariant.getVariantID())
                .append(iOSVariant.isProduction() ? ""-prod"" : ""-dev"")
                .toString();
    }
"
448,zeer matig geschreven methode maar bon ...,"	public void execute() {
		if (!hasLightGrenade) {
			if (hasPowerFailure)
				player.endTurn();
			return;
		}
		
		// The square the player stepped on has a light grenade and should
		// always cause a decrease of at least three actions at this point.
		player.skipNumberOfActions(3 + (hasPowerFailure ? 1 : 0));
	}
","START 	public void execute() { END 
		if (!hasLightGrenade) {
			if (hasPowerFailure)
				player.endTurn();
			return;
		}
		
		// The square the player stepped on has a light grenade and should
		// always cause a decrease of at least three actions at this point.
		player.skipNumberOfActions(3 + (hasPowerFailure ? 1 : 0));
	}
","	public void execute() {
		if (!hasLightGrenade) {
			if (hasPowerFailure)
				player.endTurn();
		}
		else {
			// The square the player stepped on has a light grenade and should
			// always cause a decrease of at least three actions at this point.
			player.skipNumberOfActions(3 + (hasPowerFailure ? 1 : 0));
		}
	}
"
449,[minor] I think we use `return name` (i.e. no `this`) elsewhere in jclouds?,"   public String getName() {
      return this.name;
   }
","   public String getName() {
START       return this.name; END 
   }
","   public String getName() {
      return name;
   }
"
450,"This too should call this(...) somehow, it's becoming clunky","    public GetDeviceListQueryParameters() {
        privateStorageType = StorageType.UNKNOWN;
        checkStatus = false;
    }
","    public GetDeviceListQueryParameters() {
        privateStorageType = StorageType.UNKNOWN;
START         checkStatus = false; END 
    }
","    public GetDeviceListQueryParameters() {
        this(null, StorageType.UNKNOWN, false, null);
    }
"
451,This method seems to be doing the same thing as the previous line.,"  public void testImportWithoutPadding() throws IOException {
    if(failWithoutExtraArgs){
      thrown.expect(IOException.class);
      thrown.expectMessage(""Failure during job; return status 1"");
      NumericTypesTestUtils.configureJunitToExpectFailure(thrown);
    }
    ArgumentArrayBuilder builder = getArgsBuilder();
    String[] args = builder.build();
    runImport(args);
    if (!failWithoutExtraArgs) {
      verify();
    }
  }
","  public void testImportWithoutPadding() throws IOException {
    if(failWithoutExtraArgs){
      thrown.expect(IOException.class);
      thrown.expectMessage(""Failure during job; return status 1"");
START       NumericTypesTestUtils.configureJunitToExpectFailure(thrown); END 
    }
    ArgumentArrayBuilder builder = getArgsBuilder();
    String[] args = builder.build();
    runImport(args);
    if (!failWithoutExtraArgs) {
      verify();
    }
  }
","  public void testImportWithoutPadding() throws IOException {
    if(failWithoutExtraArgs){
      NumericTypesTestUtils.configureJunitToExpectFailure(thrown);
    }
    ArgumentArrayBuilder builder = getArgsBuilder();
    String[] args = builder.build();
    runImport(args);
    if (!failWithoutExtraArgs) {
      verify();
    }
  }
"
452,just one more nit: put this outside of this method since the method `addReferencesToBlobs` doesn't indicate `complete`,"    void addReferencesToBlobs(PortAndAssignment pna, BlobChangingCallback cb)
        throws IOException, KeyNotFoundException, AuthorizationException {
        List<LocalResource> localResourceList = getLocalResources(pna);
        if (!localResourceList.isEmpty()) {
            getBlobs(localResourceList, pna, cb);
        }
        pna.complete();
    }
","    void addReferencesToBlobs(PortAndAssignment pna, BlobChangingCallback cb)
        throws IOException, KeyNotFoundException, AuthorizationException {
        List<LocalResource> localResourceList = getLocalResources(pna);
        if (!localResourceList.isEmpty()) {
            getBlobs(localResourceList, pna, cb);
        }
START         pna.complete(); END 
    }
","    void addReferencesToBlobs(PortAndAssignment pna, BlobChangingCallback cb)
        throws IOException, KeyNotFoundException, AuthorizationException {
        List<LocalResource> localResourceList = getLocalResources(pna);
        if (!localResourceList.isEmpty()) {
            getBlobs(localResourceList, pna, cb);
        }
    }
"
453,"@ivandalbosco No need to change order if we don't rely on visitor for finding ""try""","  public void visitFunctionDeclaration(FunctionDeclarationTree tree) {
    super.visitFunctionDeclaration(tree);
    checkFunction(tree);
  }
","  public void visitFunctionDeclaration(FunctionDeclarationTree tree) {
    super.visitFunctionDeclaration(tree);
START     checkFunction(tree); END 
  }
","  public void visitFunctionDeclaration(FunctionDeclarationTree tree) {
    checkFunction(tree);
    super.visitFunctionDeclaration(tree);
  }
"
454,Can we surround the return in parenthesis,"    private boolean isBufferFilled() {
        int available = fileBuffer.size();
        return available > 0 && available >= Math.min(MIN_BYTES_READ_IN, this.fileBytesLeft);
    }
","    private boolean isBufferFilled() {
        int available = fileBuffer.size();
START         return available > 0 && available >= Math.min(MIN_BYTES_READ_IN, this.fileBytesLeft); END 
    }
","    private boolean isBufferFilled() {
        int available = fileBuffer.size();
        return available > 0 && available >= MIN_BYTES_READ_IN;
    }
"
455,"the previous code had pretty bad readability. The new one is better, but not much. Maybe we can be a little more expressive than `--remainingRetries >=0`?","        public boolean consumeRetry() {
            return --remainingRetries >= 0;
        }
","        public boolean consumeRetry() {
START             return --remainingRetries >= 0; END 
        }
","        boolean consumeRetry() {
            return --remainingRetries >= 0;
        }
"
456,❗️ This prevents a user from assigning a custom display name to `Token.INVALID_TYPE`. Adding this as a restriction doesn't seem to provide any benefit to the user.,"	public String getDisplayName(int tokenType) {
		if (tokenType >= Token.MIN_USER_TOKEN_TYPE && tokenType < displayNames.length) {
			String displayName = displayNames[tokenType];
			if (displayName != null) {
				return displayName;
			}
		}

		String literalName = getLiteralName(tokenType);
		if (literalName != null) {
			return literalName;
		}

		String symbolicName = getSymbolicName(tokenType);
		if (symbolicName != null) {
			return symbolicName;
		}

		return Integer.toString(tokenType);
	}
","	public String getDisplayName(int tokenType) {
START 		if (tokenType >= Token.MIN_USER_TOKEN_TYPE && tokenType < displayNames.length) { END 
			String displayName = displayNames[tokenType];
			if (displayName != null) {
				return displayName;
			}
		}

		String literalName = getLiteralName(tokenType);
		if (literalName != null) {
			return literalName;
		}

		String symbolicName = getSymbolicName(tokenType);
		if (symbolicName != null) {
			return symbolicName;
		}

		return Integer.toString(tokenType);
	}
","	public String getDisplayName(int tokenType) {
		if (tokenType >= 0 && tokenType < displayNames.length) {
			String displayName = displayNames[tokenType];
			if (displayName != null) {
				return displayName;
			}
		}

		String literalName = getLiteralName(tokenType);
		if (literalName != null) {
			return literalName;
		}

		String symbolicName = getSymbolicName(tokenType);
		if (symbolicName != null) {
			return symbolicName;
		}

		return Integer.toString(tokenType);
	}
"
457,"Nit: while you're at it, this ""this."" is not necessary, I think.","    private boolean hasPersistentPower() {
        final PackageManager pm = this.getPackageManager();
        return (pm != null
                && (pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)
                    || pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)));
    }
","    private boolean hasPersistentPower() {
        final PackageManager pm = START  this.getPackageManager(); END 
        return (pm != null
                && (pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)
                    || pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)));
    }
","    private boolean hasPersistentPower() {
        // Cars and TVsets are always connected to the persistent power source
        final PackageManager pm = getPackageManager();
        return (pm != null
                && (pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)
                    || pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)));
    }
"
458,if these Boolean methods can never be null why not have the return type be boolean instead of Boolean ?,"	public Boolean attachStdin() {
		return (attachStdin != null) ? attachStdin : Boolean.FALSE;
	}
","	public Boolean attachStdin() {
START 		return (attachStdin != null) ? attachStdin : Boolean.FALSE; END 
	}
","	public boolean attachStdin() {
		return attachStdin;
	}
"
459,"by switching to """".eqauls(dcc.getDirectory())
you don't need the null check","	private boolean validatePage() {
		if (dcc.getDirectory() == null || dcc.getDirectory().equals("""")) { //$NON-NLS-1$
			setErrorMessage(""Destination not selected!"");
			return false;
		}
				
		if(0 == systemTree.getCheckedElements().length){
			setErrorMessage(""Nothing selected for FMU generation!"");
			return false;
		}
		
		if (!isSomeLibrarySelected()){
			setErrorMessage(""No libraries selected to include"");
			return false;
		}

		setErrorMessage(null);
		return true;
	}
","	private boolean validatePage() {
		if START (dcc.getDirectory() == null || dcc.getDirectory().equals("""")) { END  //$NON-NLS-1$
			setErrorMessage(""Destination not selected!"");
			return false;
		}
				
		if(0 == systemTree.getCheckedElements().length){
			setErrorMessage(""Nothing selected for FMU generation!"");
			return false;
		}
		
		if (!isSomeLibrarySelected()){
			setErrorMessage(""No libraries selected to include"");
			return false;
		}

		setErrorMessage(null);
		return true;
	}
","	private boolean validatePage() {
		if ("""".equals(dcc.getDirectory())){ //$NON-NLS-1$
			setErrorMessage(""Destination not selected!"");
			return false;
		}
				
		if(0 == systemTree.getCheckedElements().length){
			setErrorMessage(""Nothing selected for FMU generation!"");
			return false;
		}
		
		if (!isSomeLibrarySelected()){
			setErrorMessage(""No libraries selected to include"");
			return false;
		}

		setErrorMessage(null);
		return true;
	}
"
460,Please add {},"    public boolean StorageDomainRemoved(storage_domain_static storageDomain) {
        storage_server_connections connection =
                DbFacade.getInstance().getStorageServerConnectionDAO().get(storageDomain.getstorage());

        if (connection != null)
            DbFacade.getInstance().getStorageServerConnectionDAO().remove(connection.getid());

        return true;
    }
","    public boolean StorageDomainRemoved(storage_domain_static storageDomain) {
        storage_server_connections connection =
                DbFacade.getInstance().getStorageServerConnectionDAO().get(storageDomain.getstorage());
START  END 
        if (connection != null)
            DbFacade.getInstance().getStorageServerConnectionDAO().remove(connection.getid());

        return true;
    }
","    public boolean StorageDomainRemoved(storage_domain_static storageDomain) {
        storage_server_connections connection =
                DbFacade.getInstance().getStorageServerConnectionDAO().get(storageDomain.getstorage());

        if (connection != null) {
            DbFacade.getInstance().getStorageServerConnectionDAO().remove(connection.getid());
        }

        return true;
    }
"
461,StringUtils,"  public void open() throws IOException
  {
    writer = CompressionFactory.getDoubleSerializer(
        ioPeon,
        String.format(""%s.double_column"", filenameBase),
        byteOrder,
        compression
    );
    writer.open();
  }
","  public void open() throws IOException
  {
    writer = CompressionFactory.getDoubleSerializer(
        ioPeon,
START         String.format(""%s.double_column"", filenameBase), END 
        byteOrder,
        compression
    );
    writer.open();
  }
","  public void open() throws IOException
  {
    writer = CompressionFactory.getDoubleSerializer(
        ioPeon,
        StringUtils.format(""%s.double_column"", filenameBase),
        byteOrder,
        compression
    );
    writer.open();
  }
"
462,duplicately here,"    public LeaderElectorImp(Map conf, List<String> servers, CuratorFramework zk, String leaderlockPath, String id, AtomicReference<LeaderLatch> leaderLatch,
                            AtomicReference<LeaderLatchListener> leaderLatchListener) {
        this.conf = conf;
        this.servers = servers;
        this.zk = zk;
        this.leaderLatch = leaderLatch;
        this.id = id;
        this.leaderLatch = leaderLatch;
        this.leaderLatchListener = leaderLatchListener;
    }
","    public LeaderElectorImp(Map conf, List<String> servers, CuratorFramework zk, String leaderlockPath, String id, AtomicReference<LeaderLatch> leaderLatch,
                            AtomicReference<LeaderLatchListener> leaderLatchListener) {
        this.conf = conf;
        this.servers = servers;
        this.zk = zk;
        this.leaderLatch = leaderLatch;
        this.id = id;
START         this.leaderLatch = leaderLatch; END 
        this.leaderLatchListener = leaderLatchListener;
    }
","    public LeaderElectorImp(Map conf, List<String> servers, CuratorFramework zk, String leaderlockPath, String id, AtomicReference<LeaderLatch> leaderLatch,
            AtomicReference<LeaderLatchListener> leaderLatchListener) {
        this.conf = conf;
        this.servers = servers;
        this.zk = zk;
        this.leaderlockPath = leaderlockPath;
        this.id = id;
        this.leaderLatch = leaderLatch;
        this.leaderLatchListener = leaderLatchListener;
    }
"
463,What's the reason we need to make this `protected`?,"	protected Class<?> loadRepositoryInterface(RepositoryConfiguration<?> configuration, ResourceLoader loader) {

		String repositoryInterface = configuration.getRepositoryInterface();
		ClassLoader classLoader = loader.getClassLoader();

		try {
			return org.springframework.util.ClassUtils.forName(repositoryInterface, classLoader);
		} catch (ClassNotFoundException | LinkageError e) {
			LOGGER.warn(String.format(CLASS_LOADING_ERROR, getModuleName(), repositoryInterface, classLoader), e);
		}

		return null;
	}
","START 	protected Class<?> loadRepositoryInterface(RepositoryConfiguration<?> configuration, ResourceLoader loader) { END 

		String repositoryInterface = configuration.getRepositoryInterface();
		ClassLoader classLoader = loader.getClassLoader();

		try {
			return org.springframework.util.ClassUtils.forName(repositoryInterface, classLoader);
		} catch (ClassNotFoundException | LinkageError e) {
			LOGGER.warn(String.format(CLASS_LOADING_ERROR, getModuleName(), repositoryInterface, classLoader), e);
		}

		return null;
	}
","	private Class<?> loadRepositoryInterface(RepositoryConfiguration<?> configuration, ResourceLoader loader) {

		String repositoryInterface = configuration.getRepositoryInterface();
		ClassLoader classLoader = loader.getClassLoader();

		try {
			return org.springframework.util.ClassUtils.forName(repositoryInterface, classLoader);
		} catch (ClassNotFoundException | LinkageError e) {
			LOGGER.warn(String.format(CLASS_LOADING_ERROR, getModuleName(), repositoryInterface, classLoader), e);
		}

		return null;
	}
"
464,"Well, I think now this should be moved to the `onInit()` raise error ASAP.","	protected void doStart() {
		Assert.state(this.outputChannel != null || StringUtils.hasText(this.outputChannelName),
				""'outputChannel' or 'outputChannelName' is required"");
	}
","	protected void doStart() {
		Assert.state(this.outputChannel != null || StringUtils.hasText(this.outputChannelName),
START 				""'outputChannel' or 'outputChannelName' is required""); END 
	}
","	protected void doStart() {
	}
"
465,"```
return session.createDocument(documentModel);
```","    protected DocumentModel createDocument(boolean withBlobContent) {
        DocumentModel documentModel = session.createDocumentModel(""/"", ""MyFile"", ""File"");
        if (withBlobContent) {
            documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, (Serializable) Blobs.createBlob(FILE_CONTENT));
        }
        documentModel = session.createDocument(documentModel);

        return documentModel;
    }
","    protected DocumentModel createDocument(boolean withBlobContent) {
        DocumentModel documentModel = session.createDocumentModel(""/"", ""MyFile"", ""File"");
        if (withBlobContent) {
            documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, (Serializable) Blobs.createBlob(FILE_CONTENT));
        }
START         documentModel = session.createDocument(documentModel);

        return documentModel; END 
    }
","    protected DocumentModel createDocument(boolean withBlobContent) {
        DocumentModel documentModel = session.createDocumentModel(""/"", ""MyFile"", ""File"");
        if (withBlobContent) {
            documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, (Serializable) Blobs.createBlob(FILE_CONTENT));
        }
        return session.createDocument(documentModel);
    }
"
466,Static import of `Reflection2.getInvokableParameters`?,"   private boolean checkPresentOrNullable(Invocation invocation, String paramKey, int argIndex, Object arg) {
      if (arg == null && !Reflection2.getInvokableParameters(invocation.getInvokable()).get(argIndex).isAnnotationPresent(Nullable.class))
         throw new NullPointerException(format(""param{%s} for invocation %s.%s"", paramKey, invocation.getInvokable()
               .getOwnerType().getRawType().getSimpleName(), invocation.getInvokable().getName()));
      return true;
   }
","   private boolean checkPresentOrNullable(Invocation invocation, String paramKey, int argIndex, Object arg) {
START       if (arg == null && !Reflection2.getInvokableParameters(invocation.getInvokable()).get(argIndex).isAnnotationPresent(Nullable.class)) END 
         throw new NullPointerException(format(""param{%s} for invocation %s.%s"", paramKey, invocation.getInvokable()
               .getOwnerType().getRawType().getSimpleName(), invocation.getInvokable().getName()));
      return true;
   }
","   private boolean checkPresentOrNullable(Invocation invocation, String paramKey, int argIndex, Object arg) {
      if (arg == null && !getInvokableParameters(invocation.getInvokable()).get(argIndex).isAnnotationPresent(Nullable.class))
         throw new NullPointerException(format(""param{%s} for invocation %s.%s"", paramKey, invocation.getInvokable()
               .getOwnerType().getRawType().getSimpleName(), invocation.getInvokable().getName()));
      return true;
   }
"
467,is it allowed to flush the events on the device after the user opt out in gdpr?,"    public void optOutTracking() {
        getAnalyticsMessages().emptyTrackingQueues(new AnalyticsMessages.MixpanelDescription(mToken));
        if (getPeople().isIdentified()) {
            getPeople().deleteUser();
            getPeople().clearCharges();
        }
        mPersistentIdentity.clearPreferences();
        synchronized (mEventTimings) {
            mEventTimings.clear();
            mPersistentIdentity.clearTimeEvents();
        }
        mPersistentIdentity.clearReferrerProperties();
        mPersistentIdentity.setOptOutTracking(true);
    }
","START     public void optOutTracking() { END 
        getAnalyticsMessages().emptyTrackingQueues(new AnalyticsMessages.MixpanelDescription(mToken));
        if (getPeople().isIdentified()) {
            getPeople().deleteUser();
            getPeople().clearCharges();
        }
        mPersistentIdentity.clearPreferences();
        synchronized (mEventTimings) {
            mEventTimings.clear();
            mPersistentIdentity.clearTimeEvents();
        }
        mPersistentIdentity.clearReferrerProperties();
        mPersistentIdentity.setOptOutTracking(true);
    }
","    public void optOutTracking() {
        getAnalyticsMessages().emptyTrackingQueues(new AnalyticsMessages.MixpanelDescription(mToken));
        if (getPeople().isIdentified()) {
            getPeople().deleteUser();
            getPeople().clearCharges();
        }
        mPersistentIdentity.clearPreferences();
        synchronized (mEventTimings) {
            mEventTimings.clear();
            mPersistentIdentity.clearTimeEvents();
        }
        mPersistentIdentity.clearReferrerProperties();
        mPersistentIdentity.setOptOutTracking(true, mToken);
    }
"
468,why the fully qualified package name here?,"    protected org.robolectric.bytecode.ShadowMap createShadowMap() {
        return super.createShadowMap()
                .newBuilder()
                .addShadowClass(ShadowCrashlytics.class)
                .addShadowClass(ShadowMapView.class)
                .addShadowClass(ShadowGLMatrix.class)
                .build();
    }
","START     protected org.robolectric.bytecode.ShadowMap createShadowMap() { END 
        return super.createShadowMap()
                .newBuilder()
                .addShadowClass(ShadowCrashlytics.class)
                .addShadowClass(ShadowMapView.class)
                .addShadowClass(ShadowGLMatrix.class)
                .build();
    }
","    protected ShadowMap createShadowMap() {
        return super.createShadowMap()
                .newBuilder()
                .addShadowClass(ShadowCrashlytics.class)
                .addShadowClass(ShadowMapView.class)
                .addShadowClass(ShadowGLMatrix.class)
                .build();
    }
"
469,"What does ""column name"" refer to? The plan IR shouldn't have any references to column names, but should be using column handles, instead.","        public static String serialize(ColumnStatisticMetadata value)
        {
            return value.getStatisticType().name() + "":"" + value.getColumnName();
        }
","        public static String serialize(ColumnStatisticMetadata value)
        {
            return value.getStatisticType().name() + "":"" + value.getColumnName();
START         } END 
","        static String serialize(ColumnStatisticMetadata value)
        {
            return value.getStatisticType().name() + "":"" + value.getColumnName();
        }
"
470,There seems to be a `!` missing.,"    private static void deleteFileIfExists(File to) throws IOException {
        boolean fileDoesNotExist = to.exists();
        if (fileDoesNotExist) {
            return;
        }

        boolean deleteOk = to.delete();
        if (deleteOk) {
            return;
        }

        throw new IOException(""Unable to delete file: "" + to.getAbsolutePath());
    }
","    private static void deleteFileIfExists(File to) throws IOException {
START         boolean fileDoesNotExist = to.exists(); END 
        if (fileDoesNotExist) {
            return;
        }

        boolean deleteOk = to.delete();
        if (deleteOk) {
            return;
        }

        throw new IOException(""Unable to delete file: "" + to.getAbsolutePath());
    }
","    private static void deleteFileIfExists(File to) throws IOException {
        boolean fileDoesNotExist = !to.exists();
        if (fileDoesNotExist) {
            return;
        }

        boolean deleteOk = to.delete();
        if (deleteOk) {
            return;
        }

        throw new IOException(""Unable to delete file: "" + to.getAbsolutePath());
    }
"
471,You can just inline `key` and `value` IMO.,"            public Map.Entry<K, Collection<V>> next() {
                final Map.Entry<K, Collection<V>> entry = super.next();
                final K key = entry.getKey();
                final Collection<V> value = entry.getValue();
                return new UnmodifiableMapEntry<>(key, value);
            }
","            public Map.Entry<K, Collection<V>> next() {
                final Map.Entry<K, Collection<V>> entry = super.next();
                final K key = entry.getKey();
                final Collection<V> value = entry.getValue();
START                 return new UnmodifiableMapEntry<>(key, value); END 
            }
","            public Map.Entry<K, Collection<V>> next() {
                final Map.Entry<K, Collection<V>> entry = super.next();
                return new UnmodifiableMapEntry<>(entry.getKey(), entry.getValue());
            }
"
472,"I believe, we should call get on the future:

```
des.submit(call).get()
```","   public void basicInvocation(Runnable call) throws Exception {
      DistributedExecutorService des = createDES(getCache());
      des.submit(call);
   }
","   public void basicInvocation(Runnable call) throws Exception {
      DistributedExecutorService des = createDES(getCache());
START       des.submit(call); END 
   }
","   public void basicInvocation(Runnable call) throws Exception {
      DistributedExecutorService des = createDES(getCache());
      des.submit(call).get();
   }
"
473,"The position adjustment and restore should be wrapped in a try/finally, because we don't want the buffer to be left in an invalid state if an exception is thrown.","  public void aggregate(ByteBuffer buf, int position)
  {
    final int oldPosition = buf.position();
    buf.position(position);
    bufferAdd(buf);
    buf.position(oldPosition);
  }
","  public void aggregate(ByteBuffer buf, int position)
  {
    final int oldPosition = buf.position();
    buf.position(position);
    bufferAdd(buf);
START     buf.position(oldPosition); END 
  }
","  public void aggregate(ByteBuffer buf, int position)
  {
    final int oldPosition = buf.position();
    try {
      buf.position(position);
      bufferAdd(buf);
    }
    finally {
      buf.position(oldPosition);
    }
  }
"
474,nit: add braces for each if/else statement,"	public List<Put> getJobPuts() {
		if (jobHistoryListener != null)
			return jobHistoryListener.getJobPuts();
		else
			return null;
	}
","	public List<Put> getJobPuts() {
START 		if (jobHistoryListener != null) END 
			return jobHistoryListener.getJobPuts();
		else
			return null;
	}
","	public List<Put> getJobPuts() {
		if (jobHistoryListener != null) {
			return jobHistoryListener.getJobPuts();
		} else {
			return null;
		}
	}
"
475,"This is not correct. The expression can be like this: `foo#{bar.value}.baz`. With meaning to evaluate a template part and concatenate it with the rest as strings.
See `ParserContext` JavaDocs.

Also that doesn't make sense to deprecate private method.

The point was to log `warn` that templating is deprecated. Nothing more we can do from the context of variable.","	private boolean isTemplate(String expression) {
		return expression.startsWith(PARSER_CONTEXT.getExpressionPrefix()) && expression.endsWith(PARSER_CONTEXT.getExpressionSuffix());
	}
","	private boolean isTemplate(String expression) {
START 		return expression.startsWith(PARSER_CONTEXT.getExpressionPrefix()) && expression.endsWith(PARSER_CONTEXT.getExpressionSuffix()); END 
	}
","	private boolean isTemplate(String expression) {
		return expression.contains(PARSER_CONTEXT.getExpressionPrefix()) && expression.contains(PARSER_CONTEXT.getExpressionSuffix());
	}
"
476,can't these be null?,"    public String toString() {
      return Objects.toStringHelper(this)
          .omitNullValues()
          .add(""revision"", revision.getName())
          .add(""oldRevision"", oldRevision.getName())
          .add(""path"", path)
          .toString();
    }
","    public String toString() {
      return Objects.toStringHelper(this)
          .omitNullValues()
          .add(""revision"", revision.getName())
START           .add(""oldRevision"", oldRevision.getName()) END 
          .add(""path"", path)
          .toString();
    }
","    public String toString() {
      return Objects.toStringHelper(this)
          .omitNullValues()
          .add(""revision"", revision.getName())
          .add(""oldRevision"", oldRevision != null ? oldRevision.getName() : null)
          .add(""path"", path)
          .toString();
    }
"
477,"The `find` method will throw an exception if not found, so the assertion below is redundant. Use `tryFind` if you want to be explicit or just remove the assertion.","   public void testListImages() {
      List<ImageSummary> listImages = api().listImages();
      assertNotNull(listImages);

      ImageSummary taggedImage = Iterables.find(listImages, new Predicate<ImageSummary>() {
         @Override
         public boolean apply(ImageSummary input) {
            return input.repoTags().contains(""jclouds:testTag"");
         }
      });
      assertNotNull(taggedImage);
   }
","   public void testListImages() {
      List<ImageSummary> listImages = api().listImages();
      assertNotNull(listImages);

      ImageSummary taggedImage = Iterables.find(listImages, new Predicate<ImageSummary>() {
         @Override
         public boolean apply(ImageSummary input) {
            return input.repoTags().contains(""jclouds:testTag"");
         }
START       }); END 
      assertNotNull(taggedImage);
   }
","   public void testListImages() {
      List<ImageSummary> listImages = api().listImages();
      assertNotNull(listImages);

      Iterables.find(listImages, new Predicate<ImageSummary>() {
         @Override
         public boolean apply(ImageSummary input) {
            return input.repoTags().contains(""jclouds:testTag"");
         }
      });
   }
"
478,No need to have above methods as `static`. `private void` is fine.,"  private static void resetJsonReaderEscapeAnyChar() {
    client.alterSession(ExecConstants.JSON_READER_ESCAPE_ANY_CHAR, false);
  }
","  private static void resetJsonReaderEscapeAnyChar() {
START     client.alterSession(ExecConstants.JSON_READER_ESCAPE_ANY_CHAR, false); END 
  }
","  private void resetJsonReaderEscapeAnyChar() {
    client.alterSession(ExecConstants.JSON_READER_ESCAPE_ANY_CHAR, false);
  }
"
479,"Ah, yeah, there are some limitations to the linter. Thanks for taking care of it.","    private int getNumberOfPartitionsForTopic(final String topic) throws ExecutionException, InterruptedException {
        try (AdminClient adminClient = createAdminClient()) {
            final TopicDescription topicDescription = adminClient.describeTopics(Collections.singleton(topic))
                .values()
                .get(topic)
                .get();

            return topicDescription.partitions().size();
        }
    }
","    private int getNumberOfPartitionsForTopic(final String topic) throws ExecutionException, InterruptedException {
START         try (AdminClient adminClient = createAdminClient()) { END 
            final TopicDescription topicDescription = adminClient.describeTopics(Collections.singleton(topic))
                .values()
                .get(topic)
                .get();

            return topicDescription.partitions().size();
        }
    }
","    private int getNumberOfPartitionsForTopic(final String topic) throws Exception {
        try (final AdminClient adminClient = createAdminClient()) {
            final TopicDescription topicDescription = adminClient.describeTopics(Collections.singleton(topic))
                                                                 .values()
                                                                 .get(topic)
                                                                 .get();

            return topicDescription.partitions().size();
        }
    }
"
480,Need to remove this leftover debug output,"        public List<String> getHeaders(String name) {
            MultivaluedMap<String, String> headers = requestContext.getMutableHeaders();
            System.out.println(headers.get(name));
            return headers.get(name);

        }
","        public List<String> getHeaders(String name) {
            MultivaluedMap<String, String> headers = requestContext.getMutableHeaders();
START             System.out.println(headers.get(name)); END 
            return headers.get(name);

        }
","        public List<String> getHeaders(String name) {
            MultivaluedMap<String, String> headers = requestContext.getMutableHeaders();
            return headers.get(name);
        }
"
481,Nit: You don't really need the synchronized here.,"    public boolean startWork(String id) {
        synchronized (mLock) {
            return startWork(id, null);
        }
    }
","    public boolean startWork(String id) {
        START  synchronized (mLock) END  {
            return startWork(id, null);
        }
    }
","    public boolean startWork(String id) {
        return startWork(id, null);
    }
"
482,"Add a TODO to use the response, if there aren't any side-effects?","    public WhoisResources performUpdates(final UpdateContext updateContext, final Origin origin, final Collection<Update> updates, final Keyword keyword, final HttpServletRequest request) {
        loggerContext.log(""msg-in.txt"", new UpdateLogCallback(updates));

        final UpdateResponse updateResponse = updateRequestHandler.handle(new UpdateRequest(origin, keyword, updates), updateContext);

        return performUpdates(request, updateContext, updates);
    }
","    public WhoisResources performUpdates(final UpdateContext updateContext, final Origin origin, final Collection<Update> updates, final Keyword keyword, final HttpServletRequest request) {
        loggerContext.log(""msg-in.txt"", new UpdateLogCallback(updates));

START         final UpdateResponse updateResponse = updateRequestHandler.handle(new UpdateRequest(origin, keyword, updates), updateContext); END 

        return performUpdates(request, updateContext, updates);
    }
","    public WhoisResources performUpdates(final UpdateContext updateContext, final Origin origin, final Collection<Update> updates, final Keyword keyword, final HttpServletRequest request) {
        loggerContext.log(""msg-in.txt"", new UpdateLogCallback(updates));

        // todo: [TK] use response?
        updateRequestHandler.handle(new UpdateRequest(origin, keyword, updates), updateContext);

        return performUpdates(request, updateContext, updates);
    }
"
483,This needs to be changed to support locked stream syntax now.,"   private V computeInternal(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction, boolean computeIfPresent, Metadata metadata, long flags) {
      assertKeyNotNull(key);
      assertFunctionNotNull(remappingFunction);
      InvocationContext ctx = getInvocationContextWithImplicitTransaction(false, 1);
      ComputeCommand command = commandsFactory.buildComputeCommand(key, remappingFunction, computeIfPresent, metadata, flags);
      ctx.setLockOwner(command.getKeyLockOwner());
      return (V) executeCommandAndCommitIfNeeded(ctx, command);
   }
","   private V computeInternal(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction, boolean computeIfPresent, Metadata metadata, long flags) {
      assertKeyNotNull(key);
      assertFunctionNotNull(remappingFunction);
      InvocationContext ctx = getInvocationContextWithImplicitTransaction(false, 1);
      ComputeCommand command = commandsFactory.buildComputeCommand(key, remappingFunction, computeIfPresent, metadata, flags);
START       ctx.setLockOwner(command.getKeyLockOwner()); END 
      return (V) executeCommandAndCommitIfNeeded(ctx, command);
   }
","   private V computeInternal(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction, boolean computeIfPresent, Metadata metadata, long flags) {
      return computeInternal(key, remappingFunction, computeIfPresent, metadata, flags, getInvocationContextWithImplicitTransaction(false, 1));
   }
"
484,Put it inside the if.,"	protected void addMappingsToConcepts(List<Object> explicitItems) {
		log(""Adding mappings to Concepts"");
		if (MetadataSharing.getInstance().isAddLocalMappings()) {
			ConceptPubSubService pubsubService = Context.getService(ConceptPubSubService.class);
			for (Object explicitItem : explicitItems) {
				if (explicitItem instanceof Concept) {
					//MetadataSharing.getInstance().getConceptMapper().addSystemConceptMap((Concept) explicitItem);
					pubsubService.addLocalMappingToConcept((Concept) explicitItem);
				}
			}
		}
	}
","	protected void addMappingsToConcepts(List<Object> explicitItems) {
START 		log(""Adding mappings to Concepts""); END 
		if (MetadataSharing.getInstance().isAddLocalMappings()) {
			ConceptPubSubService pubsubService = Context.getService(ConceptPubSubService.class);
			for (Object explicitItem : explicitItems) {
				if (explicitItem instanceof Concept) {
					//MetadataSharing.getInstance().getConceptMapper().addSystemConceptMap((Concept) explicitItem);
					pubsubService.addLocalMappingToConcept((Concept) explicitItem);
				}
			}
		}
	}
","	protected void addMappingsToConcepts(List<Object> explicitItems) {
		if (MetadataSharing.getInstance().isAddLocalMappings()) {
			log(""Adding mappings to Concepts"");
			ConceptPubSubService pubsubService = Context.getService(ConceptPubSubService.class);
			for (Object explicitItem : explicitItems) {
				if (explicitItem instanceof Concept) {
					pubsubService.addLocalMappingToConcept((Concept) explicitItem);
				}
			}
		}
	}
"
485,"Nit: You should be able to do ""if (art.equals(artId))""","   public Artifact getRequirementFromArtifactId(ArtifactId artId) {
      for (Artifact art : directRequirements) {
         if (art.getId().equals(artId.getId())) {
            return art;
         }
      }
      return null;
   }
","   public Artifact getRequirementFromArtifactId(ArtifactId artId) {
START       for (Artifact art : directRequirements) { END 
         if (art.getId().equals(artId.getId())) {
            return art;
         }
      }
      return null;
   }
","   public Artifact getRequirementFromArtifactId(ArtifactId artId) {
      for (Artifact art : directRequirements) {
         if (art.equals(artId)) {
            return art;
         }
      }
      return null;
   }
"
486,"Great place for a lambda ;)
```java
          return Iterators.iterator( config -> new Data<ENTITY>()
            {
                @Override
                public CharReadable stream()
                {
                    return last = factory.apply( config );
                }

                @Override
                public Decorator<ENTITY> decorator()
                {
                    return decorator;
                }
            } );
```","        public Iterator<DataFactory<ENTITY>> iterator()
        {
            return Iterators.iterator( new DataFactory<ENTITY>()
            {
                @Override
                public Data<ENTITY> create( Configuration config )
                {
                    return new Data<ENTITY>()
                    {

                        @Override
                        public CharReadable stream()
                        {
                            return last = factory.apply( config );
                        }

                        @Override
                        public Decorator<ENTITY> decorator()
                        {
                            return decorator;
                        }
                    };
                }
            } );
        }
","        public Iterator<DataFactory<ENTITY>> iterator()
        {
START             return Iterators.iterator( new DataFactory<ENTITY>() END 
            {
                @Override
                public Data<ENTITY> create( Configuration config )
                {
                    return new Data<ENTITY>()
                    {

                        @Override
                        public CharReadable stream()
                        {
                            return last = factory.apply( config );
                        }

                        @Override
                        public Decorator<ENTITY> decorator()
                        {
                            return decorator;
                        }
                    };
                }
            } );
        }
","        public Iterator<DataFactory<ENTITY>> iterator()
        {
            return Iterators.iterator( config -> new Data<ENTITY>()
            {
                @Override
                public CharReadable stream()
                {
                    return last = factory.apply( config );
                }

                @Override
                public Decorator<ENTITY> decorator()
                {
                    return decorator;
                }
            } );
        }
"
487,May be the `BoundStatement` part also should be part of the timer execution?,"    public void insertLocator(Locator locator) throws IOException {
        Session session = DatastaxIO.getSession();

        // get shard this locator would belong to
        long shard = (long) Util.getShard(locator.toString());

        // bound values and execute
        BoundStatement bs = putValue.bind(shard, locator.toString(), """");
        Timer.Context timer = Instrumentation.getWriteTimerContext(CassandraModel.CF_METRICS_LOCATOR_NAME);
        try {
            session.execute(bs);
        } finally {
            timer.stop();
        }
    }
","    public void insertLocator(Locator locator) throws IOException {
        Session session = DatastaxIO.getSession();

        // get shard this locator would belong to
        long shard = (long) Util.getShard(locator.toString());

        // bound values and execute
        BoundStatement bs = putValue.bind(shard, locator.toString(), """");
        Timer.Context timer = Instrumentation.getWriteTimerContext(CassandraModel.CF_METRICS_LOCATOR_NAME);
        try {
START             session.execute(bs); END 
        } finally {
            timer.stop();
        }
    }
","    public void insertLocator(Locator locator) throws IOException {
        Session session = DatastaxIO.getSession();

        // get shard this locator would belong to
        long shard = (long) Util.getShard(locator.toString());

        Timer.Context timer = Instrumentation.getWriteTimerContext(CassandraModel.CF_METRICS_LOCATOR_NAME);
        try {
            // bound values and execute
            BoundStatement bs = putValue.bind(shard, locator.toString(), """");
            session.execute(bs);
        } finally {
            timer.stop();
        }
    }
"
488,why 2 operations ? only one flatmap is sufficient no ?,"  private Set<Type> interfacesWithSubstitution(Symbol.TypeSymbol symbol, TypeSubstitution substitution) {
    return symbol.interfaces().stream()
      .map(interfaceType -> applySubstitution(interfaceType, substitution))
      .flatMap(substitutedInterfaceType -> supertypes(substitutedInterfaceType).stream())
      .collect(Collectors.toSet());
  }
","  private Set<Type> interfacesWithSubstitution(Symbol.TypeSymbol symbol, TypeSubstitution substitution) {
    return symbol.interfaces().stream()
START       .map(interfaceType -> applySubstitution(interfaceType, substitution)) END 
      .flatMap(substitutedInterfaceType -> supertypes(substitutedInterfaceType).stream())
      .collect(Collectors.toSet());
  }
","  private Set<Type> interfacesWithSubstitution(Symbol.TypeSymbol symbol, TypeSubstitution substitution) {
    return symbol.interfaces().stream()
      .flatMap(interfaceType -> supertypes(applySubstitution(interfaceType, substitution)).stream())
      .collect(Collectors.toSet());
  }
"
489,fluent chaining would be nice,"  public void setAdvancedRecentChangesCheckbox() {
    selectTab(PreferencesPageObject.tabNames.UNDER);
    waitForElementClickableByElement(useAdvancedRecentChangesCheckbox);
  useAdvancedRecentChangesCheckbox.click();
    PageObjectLogging.log(""Use_advanced_recent_changes_checkbox"", ""Use_advanced_recent_changes_checkbox clicked"", true);
  }
","START   public void setAdvancedRecentChangesCheckbox() { END 
    selectTab(PreferencesPageObject.tabNames.UNDER);
    waitForElementClickableByElement(useAdvancedRecentChangesCheckbox);
  useAdvancedRecentChangesCheckbox.click();
    PageObjectLogging.log(""Use_advanced_recent_changes_checkbox"", ""Use_advanced_recent_changes_checkbox clicked"", true);
  }
","  public PreferencesPageObject setAdvancedRecentChangesCheckbox() {
    selectTab(PreferencesPageObject.tabNames.UNDER);
    waitForElementClickableByElement(useAdvancedRecentChangesCheckbox);
  useAdvancedRecentChangesCheckbox.click();
    PageObjectLogging.log(""Use_advanced_recent_changes_checkbox"", ""Use_advanced_recent_changes_checkbox clicked"", true);

  return this;
  }
"
490,"Just curious, why do we need to change the access qualifier to protected?","    protected StringUtils() {
    }
","START     protected StringUtils() { END 
    }
","    private StringUtils() {
    }
"
491,use `?`: `int readCount = recordsToRead > 0 ? ...`,"  public int readBatch() throws Exception {
    ColumnReader<?> firstColumnStatus = readState.getFirstColumnReader();
    int currBatchNumRecords = readState.batchSizerMgr().getCurrentRecordsPerBatch();
    long recordsToRead = Math.min(currBatchNumRecords, readState.getRemainingValuesToRead());
    int readCount = 0;

    if (recordsToRead > 0) {
      readCount = readRecords(firstColumnStatus, recordsToRead);
    }
    readState.fillNullVectors(readCount);
    return readCount;
  }
","  public int readBatch() throws Exception {
    ColumnReader<?> firstColumnStatus = readState.getFirstColumnReader();
    int currBatchNumRecords = readState.batchSizerMgr().getCurrentRecordsPerBatch();
    long recordsToRead = Math.min(currBatchNumRecords, readState.getRemainingValuesToRead());
START     int readCount = 0; END 

    if (recordsToRead > 0) {
      readCount = readRecords(firstColumnStatus, recordsToRead);
    }
    readState.fillNullVectors(readCount);
    return readCount;
  }
","  public int readBatch() throws Exception {
    ColumnReader<?> firstColumnStatus = readState.getFirstColumnReader();
    int currBatchNumRecords = readState.batchSizerMgr().getCurrentRecordsPerBatch();
    long recordsToRead = Math.min(currBatchNumRecords, readState.getRemainingValuesToRead());
    int readCount = recordsToRead > 0 ? readRecords(firstColumnStatus, recordsToRead) : 0;
    readState.fillNullVectors(readCount);

    return readCount;
  }
"
492,initialize projects,"  public List<Project> getProjects() {
    List<Project> projects;
    try {
      projects = projectLoader.fetchAllActiveProjects();
      for (Project proj : projects) {
        loadAllProjectFlows(proj);
      }
    } catch (ProjectManagerException e) {
      throw new RuntimeException(""Could not load projects from store."", e);
    }
    return projects;
  }
","  public List<Project> getProjects() {
START     List<Project> projects; END 
    try {
      projects = projectLoader.fetchAllActiveProjects();
      for (Project proj : projects) {
        loadAllProjectFlows(proj);
      }
    } catch (ProjectManagerException e) {
      throw new RuntimeException(""Could not load projects from store."", e);
    }
    return projects;
  }
","  public List<Project> getProjects() {
    List<Project> projects;
    try {
      projects = projectLoader.fetchAllActiveProjects();
    } catch (ProjectManagerException e) {
      throw new RuntimeException(""Could not load projects from store."", e);
    }
    return projects;
  }
"
493,"I would have replace ArrayList with List.
```
if (dataToEncode instanceof List) {
      List arrayToDecode = (List)dataToEncode;
      List returnValueArray = new ArrayList(arrayToDecode.size());
      for (Object arrayEntry : arrayToDecode) {
        returnValueArray.add(encodeObject(arrayEntry));
      }
```","  public static Object encodeObject(Object dataToEncode) {
    Object returnValue = dataToEncode;
    if (dataToEncode instanceof byte[]) {
      returnValue = SafeEncoder.encode((byte[]) dataToEncode);
    } else if (dataToEncode instanceof ArrayList) {
      ArrayList arrayToDecode = (ArrayList)dataToEncode;
      ArrayList returnValueArray = new ArrayList(arrayToDecode.size());
      for (Object arrayEntry : arrayToDecode) {
        returnValueArray.add(encodeObject(arrayEntry));
      }
      returnValue = returnValueArray;
    }
    return returnValue;
  }
","  public static Object encodeObject(Object dataToEncode) {
    Object returnValue = dataToEncode;
    if (dataToEncode instanceof byte[]) {
      returnValue = SafeEncoder.encode((byte[]) dataToEncode);
START     } else if (dataToEncode instanceof ArrayList) {
      ArrayList arrayToDecode = (ArrayList)dataToEncode;
      ArrayList returnValueArray = new ArrayList(arrayToDecode.size());
      for (Object arrayEntry : arrayToDecode) {
        returnValueArray.add(encodeObject(arrayEntry));
      } END 
      returnValue = returnValueArray;
    }
    return returnValue;
  }
","  public static Object encodeObject(Object dataToEncode) {
    if (dataToEncode instanceof byte[]) {
      return SafeEncoder.encode((byte[]) dataToEncode);
    } 
    
    if (dataToEncode instanceof List) {
      List arrayToDecode = (List)dataToEncode;
      List returnValueArray = new ArrayList(arrayToDecode.size());
      for (Object arrayEntry : arrayToDecode) {
        // recursive call and add to list
        returnValueArray.add(encodeObject(arrayEntry)); 
      }
      return returnValueArray;
    }
    
    return dataToEncode;
  }
"
494,This ctor has to invoke the other one with similar logic as I described above. DRY - in other words.,"	public MongoDbMetadataStore(MongoDbFactory factory, String collectionName) {
		template = new MongoTemplate(factory);
		this.collectionName = (StringUtils.hasText(collectionName)) ? collectionName
				: DEFAULT_COLLECTION_NAME;
	}
","	public MongoDbMetadataStore(MongoDbFactory factory, String collectionName) {
		template = new MongoTemplate(factory);
		this.collectionName = (StringUtils.hasText(collectionName)) ? collectionName
				: DEFAULT_COLLECTION_NAME;
START 	} END 
","	public MongoDbMetadataStore(MongoDbFactory factory, String collectionName) {
		this(new MongoTemplate(factory), collectionName);
	}
"
495,Why not this::refresh ?,"    private void scheduleJobs(long regularInterval, long initialInterval) {
        executor.scheduleWithFixedDelay(() -> refresh(),
                initialInterval,
                regularInterval,
                TimeUnit.MINUTES);
    }
","    private void scheduleJobs(long regularInterval, long initialInterval) {
        START executor.scheduleWithFixedDelay(() -> refresh(), END 
                initialInterval,
                regularInterval,
                TimeUnit.MINUTES);
    }
","    private void scheduleJobs(long regularInterval, long initialInterval) {
        executor.scheduleWithFixedDelay(this::refresh,
                initialInterval,
                regularInterval,
                TimeUnit.MINUTES);
    }
"
496,shouldn't this be synchronized as well?,"  public void accept(FluxSink<T> fluxSink) {
    FluxSinkRecorderDelegate<T> previousDelegate = this.delegate;
    synchronized (this) {
      delegate = new DirectDelegate<>(fluxSink);
      previousDelegate.accept(fluxSink);
    }
  }
","  public void accept(FluxSink<T> fluxSink) {
START     FluxSinkRecorderDelegate<T> previousDelegate = this.delegate; END 
    synchronized (this) {
      delegate = new DirectDelegate<>(fluxSink);
      previousDelegate.accept(fluxSink);
    }
  }
","  public synchronized void accept(FluxSink<T> fluxSink) {
    FluxSinkRecorderDelegate<T> previousDelegate = this.delegate;
    delegate = new DirectDelegate<>(fluxSink);
    previousDelegate.accept(fluxSink);

  }
"
497,doc,"  public void shutdownBlobStore(PartitionId id){
    DiskManager diskManager = partitionToDiskManager.get(id);
    if(diskManager != null){
      diskManager.shutdownBlobStore(id);
    }
  }
","START   public void shutdownBlobStore(PartitionId id){ END 
    DiskManager diskManager = partitionToDiskManager.get(id);
    if(diskManager != null){
      diskManager.shutdownBlobStore(id);
    }
  }
","  public boolean shutdownBlobStore(PartitionId id) {
    DiskManager diskManager = partitionToDiskManager.get(id);
    return diskManager != null && diskManager.shutdownBlobStore(id);
  }
"
498,Multi-catch?,"  public Class<?> getImplementationClass(CodeGenerator<?> cg) throws ClassTransformationException {
    try {
      return compileClass( cg );
    } catch (CompileException | ClassNotFoundException e) {
      throw new ClassTransformationException(e);
    } catch (IOException e) {
      throw new ClassTransformationException(e);
    }
  }
","  public Class<?> getImplementationClass(CodeGenerator<?> cg) throws ClassTransformationException {
    try {
      return compileClass( cg );
    } catch (CompileException | ClassNotFoundException e) {
      throw new ClassTransformationException(e);
    } catch (IOException e) {
      throw new ClassTransformationException(e);
START     } END 
  }
","  public Class<?> getImplementationClass(CodeGenerator<?> cg) throws ClassTransformationException {
    try {
      return compileClass(cg);
    } catch (CompileException | ClassNotFoundException|IOException e) {
      throw new ClassTransformationException(e);
    }
  }
"
499,GSON initializes classes with reflection and not the constructor. The default definition should be set at the field declaration.,"    public Meteor(ItemStack catalystStack, List<MeteorComponent> components, float explosionStrength, int radius) {
        this.catalystStack = catalystStack;
        this.components = components;
        this.explosionStrength = explosionStrength;
        this.radius = radius;

        int weight = 0;
        for (MeteorComponent component : components)
            weight += component.getWeight();
        this.maxWeight = weight;
        this.cost = 1000000;
    }
","    public Meteor(ItemStack catalystStack, List<MeteorComponent> components, float explosionStrength, int radius) {
        this.catalystStack = catalystStack;
        this.components = components;
        this.explosionStrength = explosionStrength;
        this.radius = radius;

        int weight = 0;
        for (MeteorComponent component : components)
            weight += component.getWeight();
        this.maxWeight = weight;
START         this.cost = 1000000; END 
    }
","    public Meteor(ItemStack catalystStack, List<MeteorComponent> components, float explosionStrength, int radius) {
        this.catalystStack = catalystStack;
        this.components = components;
        this.explosionStrength = explosionStrength;
        this.radius = radius;

        int weight = 0;
        for (MeteorComponent component : components)
            weight += component.getWeight();
        this.maxWeight = weight;
    }
"
500,Is response guaranteed to be non-null at this point?,"    private byte[] getParticipantObjectQueryForResponse(PRPAIN201306UV02 response) throws JAXBException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        if (response.getControlActProcess() != null && response.getControlActProcess().getQueryByParameter() != null) {
            getMarshaller().marshal(response.getControlActProcess().getQueryByParameter(), baos);
        }
        return baos.toByteArray();
    }
","    private byte[] getParticipantObjectQueryForResponse(PRPAIN201306UV02 response) throws JAXBException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
START         if (response.getControlActProcess() != null && response.getControlActProcess().getQueryByParameter() != null) { END 
            getMarshaller().marshal(response.getControlActProcess().getQueryByParameter(), baos);
        }
        return baos.toByteArray();
    }
","    private byte[] getParticipantObjectQueryForResponse(PRPAIN201306UV02 response) throws JAXBException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        if (response != null && response.getControlActProcess() != null
            && response.getControlActProcess().getQueryByParameter() != null) {
            getMarshaller().marshal(response.getControlActProcess().getQueryByParameter(), baos);
        }
        return baos.toByteArray();
    }
"
501,"This is an expected exception, if there is no matching row in the database, can we ignore it instead?","    public List<RpslObject> getByKeys(final ObjectType type, final Collection<CIString> searchKeys) {
        final List<RpslObject> result = new ArrayList<>(searchKeys.size());

        for (final CIString searchKey : searchKeys) {
            try {
                result.add(getByKey(type, searchKey));
            } catch (EmptyResultDataAccessException ignored) {
                LOGGER.debug(""EmptyResultDataAccessException {} in {} class "", ignored.getMessage(), ignored.getClass().getName());
            }
        }

        return result;
    }
","    public List<RpslObject> getByKeys(final ObjectType type, final Collection<CIString> searchKeys) {
        final List<RpslObject> result = new ArrayList<>(searchKeys.size());

        for (final CIString searchKey : searchKeys) {
            try {
                result.add(getByKey(type, searchKey));
            } catch (EmptyResultDataAccessException ignored) {
START                 LOGGER.debug(""EmptyResultDataAccessException {} in {} class "", ignored.getMessage(), ignored.getClass().getName()); END 
            }
        }

        return result;
    }
","    public List<RpslObject> getByKeys(final ObjectType type, final Collection<CIString> searchKeys) {
        final List<RpslObject> result = new ArrayList<>(searchKeys.size());

        for (final CIString searchKey : searchKeys) {
            try {
                result.add(getByKey(type, searchKey));
            } catch (EmptyResultDataAccessException ignored) {
            }
        }

        return result;
    }
"
502,"I don't think it's necessary to cast the returned collection to an ArrayList, since the assertions below are only checking the collection's total size.","    public void testParseCommodityCodeList() {
        byte[] content = commodityCodeUpdateService.getFileContent(DATA_FILE_PATH);
        ArrayList<CommodityCode> someCommodityCodes = (ArrayList<CommodityCode>) commodityCodeUpdateService.parseCommodityCodeList(content);
        assertNotEquals(content.length, 0);
        assertEquals(NUMBER_OF_RECORDS_IN_DATA_FILE, someCommodityCodes.size());
    }
","    public void testParseCommodityCodeList() {
        byte[] content = commodityCodeUpdateService.getFileContent(DATA_FILE_PATH);
START         ArrayList<CommodityCode> someCommodityCodes = (ArrayList<CommodityCode>) commodityCodeUpdateService.parseCommodityCodeList(content); END 
        assertNotEquals(content.length, 0);
        assertEquals(NUMBER_OF_RECORDS_IN_DATA_FILE, someCommodityCodes.size());
    }
","    public void testParseCommodityCodeList() {
        byte[] content = commodityCodeUpdateService.getFileContent(DATA_FILE_PATH);
        Collection<CommodityCode> someCommodityCodes = commodityCodeUpdateService.parseCommodityCodeList(content);
        assertNotEquals(content.length, 0);
        assertEquals(NUMBER_OF_RECORDS_IN_DATA_FILE, someCommodityCodes.size());
    }
"
503,`getLeapYearsBefore(...)` should not be public.,"    public static long getLeapYearsBefore(final long prolepticYear) {
        long yearBefore = prolepticYear - 1;

        return (yearBefore / 4) - (yearBefore / 100) + (yearBefore / 400);
    }
","START     public static long getLeapYearsBefore(final long prolepticYear) { END 
        long yearBefore = prolepticYear - 1;

        return (yearBefore / 4) - (yearBefore / 100) + (yearBefore / 400);
    }
","    static long getLeapYearsBefore(final long prolepticYear) {
        long yearBefore = prolepticYear - 1;

        return (yearBefore / 4) - (yearBefore / 100) + (yearBefore / 400);
    }
"
504,Is the cast needed? There is only one `time(x)` method,"    public void time()
            throws Exception
    {
        TimeStat stat = new TimeStat(ticker);
        stat.time((Callable<Void>) () -> {
            ticker.increment(10, TimeUnit.MILLISECONDS);
            return null;
        });

        TimeDistribution allTime = stat.getAllTime();
        assertEquals(allTime.getCount(), 1.0);
        assertEquals(allTime.getMin(), 0.010);
        assertEquals(allTime.getMax(), 0.010);
    }
","    public void time()
            throws Exception
    {
        TimeStat stat = new TimeStat(ticker);
START         stat.time((Callable<Void>) () -> { END 
            ticker.increment(10, TimeUnit.MILLISECONDS);
            return null;
        });

        TimeDistribution allTime = stat.getAllTime();
        assertEquals(allTime.getCount(), 1.0);
        assertEquals(allTime.getMin(), 0.010);
        assertEquals(allTime.getMax(), 0.010);
    }
","    public void time()
            throws Exception
    {
        TimeStat stat = new TimeStat(ticker);
        stat.time(() -> {
            ticker.increment(10, TimeUnit.MILLISECONDS);
            return null;
        });

        TimeDistribution allTime = stat.getAllTime();
        assertEquals(allTime.getCount(), 1.0);
        assertEquals(allTime.getMin(), 0.010);
        assertEquals(allTime.getMax(), 0.010);
    }
"
505,"Maybe group this with wherever getTextMaxAngle is defined, just to make it easier to find related methods?

Also, does this need to be public? Probably better if it is protected or private.","    public boolean hasTextMaxAngle() throws MBFormatException {
        return parse.isPropertyDefined(layout, ""text-max-angle"");
    }
","    public boolean hasTextMaxAngle() throws MBFormatException {
        return parse.isPropertyDefined(layout, ""text-max-angle"");
START     } END 
","    private boolean hasTextMaxAngle() throws MBFormatException {
        return parse.isPropertyDefined(layout, ""text-max-angle"");
    }
"
506,"I would suggest :

```java
return LOGGERS.computeIfAbsent(key.getName(), name -> new FailsafeLogger(LOGGER_ADAPTER.getLogger(name)));
```
for a better readability.
Note parameter for `getLogger` has been changed from `key` to `name`.","    public static Logger getLogger(Class<?> key) {
        return LOGGERS.computeIfAbsent(key.getName(), name -> new FailsafeLogger(LOGGER_ADAPTER.getLogger(key)));
    }
","    public static Logger getLogger(Class<?> key) {
START         return LOGGERS.computeIfAbsent(key.getName(), name -> new FailsafeLogger(LOGGER_ADAPTER.getLogger(key))); END 
    }
","    public static Logger getLogger(Class<?> key) {
        return LOGGERS.computeIfAbsent(key.getName(), name -> new FailsafeLogger(LOGGER_ADAPTER.getLogger(name)));
    }
"
507,"Why not just
return else if isVmPriorityValueLegal(vmPriority, reasons);
Instead of this whole else block?","    public boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority, MacPool macPool) {
        if (!verifyMacPool(reasons, nicsCount, macPool)) {
            return false;
        } else if (!isVmPriorityValueLegal(vmPriority, reasons)) {
            return false;
        }
        return true;
    }
","    public boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority, MacPool macPool) {
        if (!verifyMacPool(reasons, nicsCount, macPool)) {
            return false;
        } START  else if (!isVmPriorityValueLegal(vmPriority, reasons)) {
            return false;
        }
        return true; END 
    }
","    public boolean verifyAddVm(List<String> reasons, int nicsCount, int vmPriority, MacPool macPool) {
        return !verifyMacPool(reasons, nicsCount, macPool) && isVmPriorityValueLegal(vmPriority, reasons);
    }
"
508,"!this.spaceName.equals("""") -> !this.spaceName.isEmpty()","	public boolean isTrue(State state, String[] params) {
		
		if ((this.spaceName != null && !this.spaceName.equals("""")) && !this.spaceName.equals(params[1])) {
			return false;
		}
		ObjectInstance space = state.getObject(params[1]);
		return SpaceFactory.getOnOff(space);
	}
","	public boolean isTrue(State state, String[] params) {
		
START 		if ((this.spaceName != null && !this.spaceName.equals("""")) && !this.spaceName.equals(params[1])) { END 
			return false;
		}
		ObjectInstance space = state.getObject(params[1]);
		return SpaceFactory.getOnOff(space);
	}
","	public boolean isTrue(State state, String[] params) {
		
		if ((this.spaceName != null && !this.spaceName.isEmpty()) && !this.spaceName.equals(params[1])) {
			return false;
		}
		ObjectInstance space = state.getObject(params[1]);
		return SpaceFactory.getOnOff(space);
	}
"
509,I think `functionSymbol.is(Symbol.Kind.FUNCTION)` shouldn't be necessary,"    public void visitFunctionDef(FunctionDef functionDef) {
      FunctionSymbol functionSymbol = ((FunctionDefImpl) functionDef).functionSymbol();
      ParameterList parameters = functionDef.parameters();
      if (functionSymbol != null && functionSymbol.is(Symbol.Kind.FUNCTION) && parameters != null) {
        FunctionSymbolImpl functionSymbolImpl = (FunctionSymbolImpl) functionSymbol;
        functionSymbolImpl.setParametersWithType(parameters);
      }
      super.visitFunctionDef(functionDef);
    }
","    public void visitFunctionDef(FunctionDef functionDef) {
      FunctionSymbol functionSymbol = ((FunctionDefImpl) functionDef).functionSymbol();
      ParameterList parameters = functionDef.parameters();
START       if (functionSymbol != null && functionSymbol.is(Symbol.Kind.FUNCTION) && parameters != null) { END 
        FunctionSymbolImpl functionSymbolImpl = (FunctionSymbolImpl) functionSymbol;
        functionSymbolImpl.setParametersWithType(parameters);
      }
      super.visitFunctionDef(functionDef);
    }
","    public void visitFunctionDef(FunctionDef functionDef) {
      FunctionSymbol functionSymbol = ((FunctionDefImpl) functionDef).functionSymbol();
      ParameterList parameters = functionDef.parameters();
      if (functionSymbol != null && parameters != null) {
        FunctionSymbolImpl functionSymbolImpl = (FunctionSymbolImpl) functionSymbol;
        functionSymbolImpl.setParametersWithType(parameters);
      }
      super.visitFunctionDef(functionDef);
    }
"
510,Make this final,"    public SavedStateRegistry<Bundle> getBundleSavedStateRegistry() {
        return mSavedStateRegistry;
    }
","    START  public SavedStateRegistry<Bundle> END  getBundleSavedStateRegistry() {
        return mSavedStateRegistry;
    }
","    public final SavedStateRegistry<Bundle> getBundleSavedStateRegistry() {
        return mSavedStateRegistry;
    }
"
511,What does the `n` variable do here?,"	public static ZonedDateTime parse(String dateString) {

		int n = 0;
		for (DateTimeFormatter df : DATE_TIME_FORMATTERS) {

			try {
				return toZonedDateTime(df.parse(dateString));
			} catch (DateTimeParseException dte) {
				// we ignore wrong formats
				n++;
				continue;
			}

		}

		if (IS_NUMERIC_P.matcher(dateString)
			.matches()) {
			long ldate = Long.parseLong(dateString);
			return Instant.ofEpochMilli(ldate)
				.atZone(UTC_ZONE_ID);
		}

		return null;
	}
","	public static ZonedDateTime parse(String dateString) {

		int n = 0;
		for (DateTimeFormatter df : DATE_TIME_FORMATTERS) {

			try {
				return toZonedDateTime(df.parse(dateString));
			} catch (DateTimeParseException dte) {
				// we ignore wrong formats
START 				n++; END 
				continue;
			}

		}

		if (IS_NUMERIC_P.matcher(dateString)
			.matches()) {
			long ldate = Long.parseLong(dateString);
			return Instant.ofEpochMilli(ldate)
				.atZone(UTC_ZONE_ID);
		}

		return null;
	}
","	public static ZonedDateTime parse(String dateString) {

		for (DateTimeFormatter df : DATE_TIME_FORMATTERS) {
			try {
				return toZonedDateTime(df.parse(dateString));
			} catch (DateTimeParseException dte) {
				// we ignore wrong formats
				continue;
			}

		}

		if (IS_NUMERIC_P.matcher(dateString)
			.matches()) {
			long ldate = Long.parseLong(dateString);
			return Instant.ofEpochMilli(ldate)
				.atZone(UTC_ZONE_ID);
		}

		return null;
	}
"
512,"Copy/Paste error: should be ShapeContainerStyle. This causes errors in tests:

java.lang.ClassCastException: org.eclipse.sirius.diagram.business.internal.metamodel.spec.ShapeContainerStyleSpec cannot be cast to org.eclipse.sirius.diagram.FlatContainerStyle
 at org.eclipse.sirius.diagram.ui.business.internal.query.ColorStyleQuery.getFillColor(ColorStyleQuery.java:105)","    public Optional<RGBValues> getFillColor() {
        RGBValues rgbValues = null;
        if (style instanceof NodeStyle) {
            rgbValues = new NodeStyleQuery((NodeStyle) style).getBackgroundColor().get();
        } else if (style instanceof FlatContainerStyle) {
            rgbValues = ((FlatContainerStyle) style).getBackgroundColor();
        } else if (style instanceof ShapeContainerStyle) {
            rgbValues = ((FlatContainerStyle) style).getBackgroundColor();
        }

        return Optional.ofNullable(rgbValues);
    }
","    public Optional<RGBValues> getFillColor() {
        RGBValues rgbValues = null;
        if (style instanceof NodeStyle) {
            rgbValues = new NodeStyleQuery((NodeStyle) style).getBackgroundColor().get();
        } else if (style instanceof FlatContainerStyle) {
            rgbValues = ((FlatContainerStyle) style).getBackgroundColor();
        } else if (style instanceof ShapeContainerStyle) {
            rgbValues = START ((FlatContainerStyle) style).getBackgroundColor(); END 
        }

        return Optional.ofNullable(rgbValues);
    }
","    public Optional<RGBValues> getFillColor() {
        RGBValues rgbValues = null;
        if (style instanceof NodeStyle) {
            rgbValues = new NodeStyleQuery((NodeStyle) style).getBackgroundColor().get();
        } else if (style instanceof FlatContainerStyle) {
            rgbValues = ((FlatContainerStyle) style).getBackgroundColor();
        } else if (style instanceof ShapeContainerStyle) {
            rgbValues = ((ShapeContainerStyle) style).getBackgroundColor();
        }

        return Optional.ofNullable(rgbValues);
    }
"
513,There is no need to flush here,"   public void indexMembers() throws InterruptedException {
      MassIndexer mi = Search.getFullTextEntityManager(em).createIndexer(Member.class);
      mi.startAndWait();
      Search.getFullTextEntityManager(em).flushToIndexes();
   }
","   public void indexMembers() throws InterruptedException {
      MassIndexer mi = Search.getFullTextEntityManager(em).createIndexer(Member.class);
      mi.startAndWait();
START       Search.getFullTextEntityManager(em).flushToIndexes(); END 
   }
","   public void indexMembers() throws InterruptedException {
      MassIndexer mi = Search.getFullTextEntityManager(em).createIndexer(Member.class);
      mi.startAndWait();
   }
"
514,Is it possible to declare the function with `throws UnsupportedTypeException` instead of the try-catch? (Other functions do similarly.) Will JUnit still fail reasonably if it does throw?,"	public void testGetPublicKeyPairNullInput1() {
		try{
			KeyGenUtils.getPublicKeyPair(null, truePublicKeys[0]);
		} catch (UnsupportedTypeException e) {
			fail(""UnsupportedTypeException thrown"");
		}
	}
","	public void testGetPublicKeyPairNullInput1() {
		try{
			KeyGenUtils.getPublicKeyPair(null, truePublicKeys[0]);
		} catch (UnsupportedTypeException e) {
START 			fail(""UnsupportedTypeException thrown""); END 
		}
	}
","    public void testGetPublicKeyPairNullInput1() {
        KeyGenUtils.getPublicKeyPair(null, truePublicKeys[0]);
    }
"
515,"Another minor note, any reason not to merge this into a single check?

`if(values == null || values.isEmpty()) return true ;`","    private boolean containsNullOrEmpty(List<String> values) {
    	//return values != null && ( values.contains(null) || values.contains("""") );
    	if(values == null) return true ;
    	if(values.isEmpty()) return true ;
    	for(String str : values) {
            if(StringUtils.isBlank(str)) return true ;
        }
        return false;
    }
","    private boolean containsNullOrEmpty(List<String> values) {
    	//return values != null && ( values.contains(null) || values.contains("""") );
    	if(values == null) return true ;
START     	if(values.isEmpty()) return true ; END 
    	for(String str : values) {
            if(StringUtils.isBlank(str)) return true ;
        }
        return false;
    }
","    private boolean containsNullOrEmpty(List<String> values) {
    	if(values == null || values.isEmpty()) return true ;
    	for(String str : values) {
            if(StringUtils.isBlank(str)) return true ;
        }
        return false;
    }
"
516,+NonNull for return type,"    public static <T> Flowable<T> fromOptional(@NonNull Optional<T> optional) {
        ObjectHelper.requireNonNull(optional, ""optional is null"");
        return optional.map(Flowable::just).orElseGet(Flowable::empty);
    }
","START     public static <T> Flowable<T> fromOptional(@NonNull Optional<T> optional) { END 
        ObjectHelper.requireNonNull(optional, ""optional is null"");
        return optional.map(Flowable::just).orElseGet(Flowable::empty);
    }
","    public static <T> Flowable<@NonNull T> fromOptional(@NonNull Optional<T> optional) {
        ObjectHelper.requireNonNull(optional, ""optional is null"");
        return optional.map(Flowable::just).orElseGet(Flowable::empty);
    }
"
517,Unused,"    private static Map<AbstractProject,DependencyChange> getDependencyChanges(Run<?,?> run) {
        AbstractBuild<?,?> build = null;
        if(run instanceof AbstractBuild)
            return ((AbstractBuild) run).getDependencyChanges((AbstractBuild)run);
        //jenkins workflow plugin etc.
        else 
            return Maps.newHashMap();
    }
","    private static Map<AbstractProject,DependencyChange> getDependencyChanges(Run<?,?> run) {
START         AbstractBuild<?,?> build = null; END 
        if(run instanceof AbstractBuild)
            return ((AbstractBuild) run).getDependencyChanges((AbstractBuild)run);
        //jenkins workflow plugin etc.
        else 
            return Maps.newHashMap();
    }
","    private static Map<AbstractProject,DependencyChange> getDependencyChanges(Run<?,?> run) {
        if(run instanceof AbstractBuild)
            return ((AbstractBuild) run).getDependencyChanges((AbstractBuild)run);
        //jenkins workflow plugin etc.
        else 
            return Maps.newHashMap();
    }
"
518,Same regarding cast,"   public void onRemoved(Iterable<CacheEntryEvent<? extends K, ? extends V>> events) throws CacheEntryListenerException {

      for (Object event1 : events) {
         CacheEntryEvent event = (CacheEntryEvent) event1;
         Assert.assertEquals(EventType.REMOVED, event.getEventType());
         this.removed.incrementAndGet();
         event.getKey();
         if (event.isOldValueAvailable()) {
            event.getOldValue();
         }
      }

   }
","   public void onRemoved(Iterable<CacheEntryEvent<? extends K, ? extends V>> events) throws CacheEntryListenerException {

START       for (Object event1 : events) { END 
         CacheEntryEvent event = (CacheEntryEvent) event1;
         Assert.assertEquals(EventType.REMOVED, event.getEventType());
         this.removed.incrementAndGet();
         event.getKey();
         if (event.isOldValueAvailable()) {
            event.getOldValue();
         }
      }

   }
","   public void onRemoved(Iterable<CacheEntryEvent<? extends K, ? extends V>> events) throws CacheEntryListenerException {

      for (CacheEntryEvent<? extends K, ? extends V> event : events) {
         Assert.assertEquals(EventType.REMOVED, event.getEventType());
         this.removed.incrementAndGet();
         if (event.isOldValueAvailable()) {
            event.getOldValue();
         }
      }

   }
"
519,But the attribute actually is required. So we'd be reporting incorrect metadata to work around a test fixture problem?,"        Attribute(String name, ModelType type, CapabilityReferenceRecorder reference) {
            this.definition = new SimpleAttributeDefinitionBuilder(name, type, true)
                    .setCapabilityReference(reference)
                    .setFlags(Flag.RESTART_RESOURCE_SERVICES)
                    .build();
        }
","        Attribute(String name, ModelType type, CapabilityReferenceRecorder reference) {
START             this.definition = new SimpleAttributeDefinitionBuilder(name, type, true) END 
                    .setCapabilityReference(reference)
                    .setFlags(Flag.RESTART_RESOURCE_SERVICES)
                    .build();
        }
","        Attribute(String name, ModelType type, CapabilityReferenceRecorder reference) {
            this.definition = new SimpleAttributeDefinitionBuilder(name, type)
                    .setCapabilityReference(reference)
                    .setFlags(Flag.RESTART_RESOURCE_SERVICES)
                    .build();
        }
"
520,I think we have to (should) stay with Java 6 syntax here.,"		Page<Book> getDefaultPageable(Pageable pageable) {

			if (pageable != null) {
				return new PageImpl<>(Collections.singletonList(new Book()), pageable, 1);
			}

			return new PageImpl<>(Collections.emptyList(), pageable, 0);
		}
","		Page<Book> getDefaultPageable(Pageable pageable) {

			if (pageable != null) {
START 				return new PageImpl<>(Collections.singletonList(new Book()), pageable, 1); END 
			}

			return new PageImpl<>(Collections.emptyList(), pageable, 0);
		}
","		Page<Book> getDefaultPageable(Pageable pageable) {

			if (pageable != null) {
				return new PageImpl<Book>(Collections.singletonList(new Book()), pageable, 1);
			}

			return new PageImpl<Book>(Collections.emptyList(), pageable, 0);
		}
"
521,combine the two lines and return the String,"	public String getEmbedMapID(){
		String mapID = mapFrame.getAttribute(""data-mapid"");
		return mapID;
	}
","	public String getEmbedMapID(){
		String mapID = mapFrame.getAttribute(""data-mapid"");
START 		return mapID; END 
	}
","	public String getEmbedMapID() {
		return mapFrame.getAttribute(""data-mapid"");
	}
"
522,"""Account"" instead of ""Accoun""","	public AttributeDefinition getAttributeDefinition() {
		AttributeDefinition attr = new AttributeDefinition();
		attr.setNamespace(AttributesManager.NS_FACILITY_ATTR_DEF);
		attr.setFriendlyName(""accountExpirationTime"");
		attr.setDisplayName(""Accoun expiration."");
		attr.setType(Integer.class.getName());
		attr.setDescription(""Account expiration."");
		return attr;
	}
","	public AttributeDefinition getAttributeDefinition() {
		AttributeDefinition attr = new AttributeDefinition();
		attr.setNamespace(AttributesManager.NS_FACILITY_ATTR_DEF);
		attr.setFriendlyName(""accountExpirationTime"");
START 		attr.setDisplayName(""Accoun expiration.""); END 
		attr.setType(Integer.class.getName());
		attr.setDescription(""Account expiration."");
		return attr;
	}
","	public AttributeDefinition getAttributeDefinition() {
		AttributeDefinition attr = new AttributeDefinition();
		attr.setNamespace(AttributesManager.NS_FACILITY_ATTR_DEF);
		attr.setFriendlyName(""accountExpirationTime"");
		attr.setDisplayName(""Account expiration."");
		attr.setType(Integer.class.getName());
		attr.setDescription(""Account expiration."");
		return attr;
	}
"
523,disk.setVm(new VM()); should be inside of this /if/,"    private Disk clone(Disk parent) {
        Disk disk = new Disk();
        disk.setId(parent.getId());
        disk.setVm(new VM());
        if (parent.isSetVm()) {
            disk.getVm().setId(parent.getVm().getId());
        }
        return disk;
    }
","    private Disk clone(Disk parent) {
        Disk disk = new Disk();
        disk.setId(parent.getId());
START         disk.setVm(new VM()); END 
        if (parent.isSetVm()) {
            disk.getVm().setId(parent.getVm().getId());
        }
        return disk;
    }
","    private Disk clone(Disk parent) {
        Disk disk = new Disk();
        disk.setId(parent.getId());
        if (parent.isSetVm()) {
            disk.setVm(new VM());
            disk.getVm().setId(parent.getVm().getId());
        }
        return disk;
    }
"
524,not synchronized,"		public boolean shouldRun() {
			final boolean shouldRun = pendingPartitions.size() > 0;
			return shouldRun;
		}
","		public boolean shouldRun() {
			final boolean shouldRun = START  pendingPartitions.size() END  > 0;
			return shouldRun;
		}
","		public boolean shouldRun() {
			synchronized (pendingPartitions) {
				final boolean shouldRun = pendingPartitions.size() > 0;
				return shouldRun;
			}
		}
"
525,"What is the reason for the longer version?

EDIT: ok, did no see it was from hibernate. You could use `String.join` from Java 8 though.","   public static String join(String[] array) {
      StringBuilder sb = new StringBuilder();
      boolean first = true;
      for (String s : array) {
         if (first) {
            first = false;
         } else {
            sb.append('.');
         }
         sb.append(s);
      }
      return sb.toString();
   }
","   public static String join(String[] array) {
      StringBuilder sb = new StringBuilder();
      boolean first = true;
      for (String s : array) {
         if (first) {
            first = false;
         } else {
            sb.append('.');
         }
         sb.append(s);
      }
START       return sb.toString(); END 
   }
","   public static String join(String[] array) {
      return join(Arrays.asList(array));
   }
"
526,I imagine the ```synchronized``` keyword is going to move up to init and then this will become private. Is there any situation where we want this to be locked externally?,"    public synchronized void lock() {
        hasBeenInitialized = true;
        internalMap = ImmutableMap.copyOf(internalMap);
    }
","START     public synchronized void lock() { END 
        hasBeenInitialized = true;
        internalMap = ImmutableMap.copyOf(internalMap);
    }
","    private void lock() {
        hasBeenInitialized = true;
        internalMap = ImmutableMap.copyOf(internalMap);
    }
"
527,"![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') ""get"" returns a string, there's no need to call ""toString()"". [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3AS1858)","	private String findHostId(String hostName) throws DotDataException {
		String hostId = null;
		DotConnect dc = new DotConnect();
		dc.setSQL(SELECT_HOSTID_BY_NAME_QUERY);
		dc.addParam(hostName);
		List<Map<String,String>> result = dc.loadResults();
		
		if(!result.isEmpty()){
			hostId = result.get(0).get(""identifier"").toString();
		}
		
		return hostId;
	}
","	private String findHostId(String hostName) throws DotDataException {
		String hostId = null;
		DotConnect dc = new DotConnect();
		dc.setSQL(SELECT_HOSTID_BY_NAME_QUERY);
		dc.addParam(hostName);
		List<Map<String,String>> result = dc.loadResults();
		
		if(!result.isEmpty()){
START 			hostId = result.get(0).get(""identifier"").toString(); END 
		}
		
		return hostId;
	}
","    private String findHostId(String hostName) throws DotDataException {
        String hostId = null;
        DotConnect dc = new DotConnect();
        dc.setSQL(SELECT_HOSTID_BY_NAME_QUERY);
        dc.addParam(hostName);
        List<Map<String, String>> result = dc.loadResults();

        if (!result.isEmpty()) {
            hostId = result.get(0).get(""identifier"");
        }

        return hostId;
    }
"
528,Should this just call the StateCallback.onClosed() method? And should the onClosed() method aslo have the request canceling?,"    public void notifyCameraDeviceClose() {
        synchronized (mExecutingCaptureConfigCallbacks) {
            for (CaptureConfigCaptureCallback callback : mExecutingCaptureConfigCallbacks) {
                callback.onRequestCancelled();
            }
            mExecutingCaptureConfigCallbacks.clear();
        }
        notifySurfaceDetached();
    }
","START     public void notifyCameraDeviceClose() { END 
        synchronized (mExecutingCaptureConfigCallbacks) {
            for (CaptureConfigCaptureCallback callback : mExecutingCaptureConfigCallbacks) {
                callback.onRequestCancelled();
            }
            mExecutingCaptureConfigCallbacks.clear();
        }
        notifySurfaceDetached();
    }
","    public void notifyCameraDeviceClose() {
        notifySurfaceDetached();
    }
"
529,shouldn't we set token to null now? If a token is succesfully closed and the link has been deleted we shouldn't keep references to it.,"	public boolean commit() {
		if (os != null) {
			unlock();
			throw new IllegalStateException(MessageFormat.format(JGitText.get().lockOnNotClosed, ref));
		}

		saveStatInformation();
		try {
			FileUtils.rename(lck, ref, StandardCopyOption.ATOMIC_MOVE);
			haveLck = false;
			token.close();
			return true;
		} catch (IOException e) {
			unlock();
			return false;
		}
	}
","	public boolean commit() {
		if (os != null) {
			unlock();
			throw new IllegalStateException(MessageFormat.format(JGitText.get().lockOnNotClosed, ref));
		}

		saveStatInformation();
		try {
			FileUtils.rename(lck, ref, StandardCopyOption.ATOMIC_MOVE);
			haveLck = false;
START 			token.close(); END 
			return true;
		} catch (IOException e) {
			unlock();
			return false;
		}
	}
","	public boolean commit() {
		if (os != null) {
			unlock();
			throw new IllegalStateException(MessageFormat.format(JGitText.get().lockOnNotClosed, ref));
		}

		saveStatInformation();
		try {
			FileUtils.rename(lck, ref, StandardCopyOption.ATOMIC_MOVE);
			haveLck = false;
			token.close();
			token = null;
			return true;
		} catch (IOException e) {
			unlock();
			return false;
		}
	}
"
530,You don't need these properties because they actually don't exist nor apply,"	public DelegatingResourceDescription getRepresentationDescription(Representation rep) {
		DelegatingResourceDescription delegatingResourceDescription = new DelegatingResourceDescription();
		delegatingResourceDescription.addProperty(""fulfillerStatus"");
		delegatingResourceDescription.addProperty(""fulfillerComment"");
		delegatingResourceDescription.addProperty(""uuid"");
		delegatingResourceDescription.addLink(""full"", "".?v="" + RestConstants.REPRESENTATION_FULL);
		delegatingResourceDescription.addSelfLink();
		return delegatingResourceDescription;
	}
","	public DelegatingResourceDescription getRepresentationDescription(Representation rep) {
		DelegatingResourceDescription delegatingResourceDescription = new DelegatingResourceDescription();
		delegatingResourceDescription.addProperty(""fulfillerStatus"");
		delegatingResourceDescription.addProperty(""fulfillerComment"");
START 		delegatingResourceDescription.addProperty(""uuid""); END 
		delegatingResourceDescription.addLink(""full"", "".?v="" + RestConstants.REPRESENTATION_FULL);
		delegatingResourceDescription.addSelfLink();
		return delegatingResourceDescription;
	}
","	public DelegatingResourceDescription getRepresentationDescription(Representation rep) {
		DelegatingResourceDescription delegatingResourceDescription = new DelegatingResourceDescription();
		delegatingResourceDescription.addProperty(""fulfillerStatus"");
		delegatingResourceDescription.addProperty(""fulfillerComment"");
		return delegatingResourceDescription;
	}
"
531,I don't think we ever use this method again,"    public gov.hhs.fha.nhinc.common.connectionmanagerinfo.UDDIUpdateManagerForceRefreshResponseType forceRefreshFileFromUDDIServer(
        gov.hhs.fha.nhinc.common.connectionmanagerinfo.UDDIUpdateManagerForceRefreshRequestType uddiUpdateManagerForceRefreshRequest) {
        LOG.info(""forceRefreshFileFromUDDIServer"");
        UDDIUpdateManagerHelper helper = new UDDIUpdateManagerHelper();
        return helper.forceRefreshFileFromUDDIServer(uddiUpdateManagerForceRefreshRequest);
    }
","    public gov.hhs.fha.nhinc.common.connectionmanagerinfo.UDDIUpdateManagerForceRefreshResponseType forceRefreshFileFromUDDIServer(
START         gov.hhs.fha.nhinc.common.connectionmanagerinfo.UDDIUpdateManagerForceRefreshRequestType uddiUpdateManagerForceRefreshRequest) { END 
        LOG.info(""forceRefreshFileFromUDDIServer"");
        UDDIUpdateManagerHelper helper = new UDDIUpdateManagerHelper();
        return helper.forceRefreshFileFromUDDIServer(uddiUpdateManagerForceRefreshRequest);
    }
","    public gov.hhs.fha.nhinc.common.connectionmanagerinfo.UDDIUpdateManagerForceRefreshResponseType forceRefreshFileFromUDDIServer(
        gov.hhs.fha.nhinc.common.connectionmanagerinfo.UDDIUpdateManagerForceRefreshRequestType uddiUpdateManagerForceRefreshRequest) {
        LOG.trace(""forceRefreshFileFromUDDIServer"");
        UDDIUpdateManagerHelper helper = new UDDIUpdateManagerHelper();
        return helper.forceRefreshFileFromUDDIServer(uddiUpdateManagerForceRefreshRequest);
    }
"
532,synchronization issue here.,"  void remove(Closeable hook) {
    if (closeHooks != null) {
      closeHooks.remove(hook);
    }
  }
","START   void remove(Closeable hook) { END 
    if (closeHooks != null) {
      closeHooks.remove(hook);
    }
  }
","  synchronized void remove(Closeable hook) {
    if (closeHooks != null) {
      closeHooks.remove(hook);
    }
  }
"
533,return the condition 's value directly?,"    private boolean isInTimeRange(ITmfTimestamp traceStartTime, ITmfTimestamp traceEndTime) {
        if (traceStartTime.compareTo(fEndTimeRange) <= 0 && traceEndTime.compareTo(fStartTimeRange) >= 0) {
            return true;
        }
        return false;
    }
","    private boolean isInTimeRange(ITmfTimestamp traceStartTime, ITmfTimestamp traceEndTime) {
        START  if END  (traceStartTime.compareTo(fEndTimeRange) <= 0 && traceEndTime.compareTo(fStartTimeRange) >= 0) {
            return true;
        }
        return false;
    }
","    private boolean isInTimeRange(ITmfTimestamp traceStartTime, ITmfTimestamp traceEndTime) {
        return traceStartTime.compareTo(fEndTimeRange) <= 0 && traceEndTime.compareTo(fStartTimeRange) >= 0;
    }
"
534,missing semicolon;,"    public void testMakingAttachment()
    {
        testMakingAttachmentFile(""attachment.txt"",""normal text file"")        
    }
","    public void testMakingAttachment()
    {
START         testMakingAttachmentFile(""attachment.txt"",""normal text file"")         END 
    }
","    public void testMakingAttachment()
    {
        testMakingAttachmentFile(""attachment.txt"",""normal text file"");
    }
"
535,"shrinkAttempts should be greaterThan(1) (equal to 2), or did I misunderstand that?","    @Test public void givesAllArgsAChanceToShrink() {
        assertThat(testResult(GivesAllArgsAChanceToShrink.class), failureCountIs(2));
        assertThat(Others.shrinkAttempts, greaterThan(0));
    }
","    @Test public void givesAllArgsAChanceToShrink() {
        assertThat(testResult(GivesAllArgsAChanceToShrink.class), failureCountIs(2));
START         assertThat(Others.shrinkAttempts, greaterThan(0)); END 
    }
","    @Test public void givesAllArgsAChanceToShrink() {
        assertThat(testResult(GivesAllArgsAChanceToShrink.class), failureCountIs(2));
        assertThat(Others.shrinkAttempts, greaterThan(1));
    }
"
536,why is this needed?,"  private void waitForStatus(final long jobId, final Status status)
      throws InterruptedException, TimeoutException {
    CommonUtils.waitFor(""Waiting for job status"", () -> {
      try {
        return mJobMaster.getStatus(jobId).getStatus() == status;
      } catch (Exception e) {
        Throwables.propagate(e);
      }
      return null;
    }, WaitForOptions.defaults().setInterval(10).setTimeoutMs(10 * Constants.SECOND_MS));
  }
","  private void waitForStatus(final long jobId, final Status status)
      throws InterruptedException, TimeoutException {
    CommonUtils.waitFor(""Waiting for job status"", () -> {
      try {
        return mJobMaster.getStatus(jobId).getStatus() == status;
      } catch (Exception e) {
        Throwables.propagate(e);
      }
      return null;
START     }, WaitForOptions.defaults().setInterval(10).setTimeoutMs(10 * Constants.SECOND_MS)); END 
  }
","  private void waitForStatus(final long jobId, final Status status)
      throws InterruptedException, TimeoutException {
    CommonUtils.waitFor(""Waiting for job status"", () -> {
      try {
        return mJobMaster.getStatus(jobId).getStatus() == status;
      } catch (Exception e) {
        Throwables.propagate(e);
      }
      return null;
    }, WaitForOptions.defaults().setTimeoutMs(10 * Constants.SECOND_MS));
  }
"
537,"Since the message operator is now only supported if the secondary index is enabled, we should check for this before creating the predicate (the same way as it is done for the file operator):

  if (args.index == ChangeIndex.DISABLED) {
      throw error(""secondary index must be enabled for message:"" + text);
  }","  public Predicate<ChangeData> message(String text) {
    return new MessagePredicate(args.dbProvider, args.repoManager, args.index, text);
  }
","  public Predicate<ChangeData> message(String text) {
START     return new MessagePredicate(args.dbProvider, args.repoManager, args.index, text); END 
  }
","  public Predicate<ChangeData> message(String text) {
    return new MessagePredicate(args.dbProvider, args.index, text);
  }
"
538,Other setters in this class are void.,"  public boolean setBranchSameAsAccess(boolean branchSameAsAccess) {
    return this.branchSameAsAccess = branchSameAsAccess;
  }
","  public START  boolean setBranchSameAsAccess(boolean END  branchSameAsAccess) {
    return this.branchSameAsAccess = branchSameAsAccess;
  }
","  public void setBranchSameAsAccess(boolean branchSameAsAccess) {
    this.branchSameAsAccess = branchSameAsAccess;
  }
"
539,"For an edge with:
```
toll=yes
toll:hgv=yes
```

This would result in `Toll.HGV` and not `Toll.ALL`","    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingManager.Access access, long relationFlags) {
        if (readerWay.hasTag(""toll"", ""yes""))
            tollEnc.setEnum(false, edgeFlags, Toll.ALL);
        if (readerWay.hasTag(""toll:hgv"", ""yes""))
            tollEnc.setEnum(false, edgeFlags, Toll.HGV);
        return edgeFlags;
    }
","    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingManager.Access access, long relationFlags) {
        if (readerWay.hasTag(""toll"", ""yes""))
            tollEnc.setEnum(false, edgeFlags, Toll.ALL);
        if (readerWay.hasTag(""toll:hgv"", ""yes""))
START             tollEnc.setEnum(false, edgeFlags, Toll.HGV); END 
        return edgeFlags;
    }
","    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingManager.Access access, long relationFlags) {
        if (readerWay.hasTag(""toll"", ""yes""))
            tollEnc.setEnum(false, edgeFlags, Toll.ALL);
        else if (readerWay.hasTag(""toll:hgv"", ""yes""))
            tollEnc.setEnum(false, edgeFlags, Toll.HGV);
        return edgeFlags;
    }
"
540,Fix your formatter settings please or disable it :wink:,"        @Override public boolean isPlayer()
        {
            return false;
        }
","START         @Override public boolean isPlayer() END 
        {
            return false;
        }
","        public boolean isPlayer()
        {
            return false;
        }
"
541,"It doesn't really matter, but could be:

```java
return new byte[] {
            (byte) (val >>> 24),
            (byte) (val >>> 16),
            (byte) (val >>> 8),
            (byte) val
};
```","        byte[] byteArrayFromInt(int val) {
            byte[] b = new byte[4];
            b[3] = (byte) (val);
            b[2] = (byte) (val >>> 8);
            b[1] = (byte) (val >>> 16);
            b[0] = (byte) (val >>> 24);
            return b;
        }
","        byte[] byteArrayFromInt(int val) {
            byte[] b = new byte[4];
            b[3] = (byte) (val);
            b[2] = (byte) (val >>> 8);
            b[1] = (byte) (val >>> 16);
            b[0] = (byte) (val >>> 24);
START             return b; END 
        }
","        byte[] byteArrayFromInt(int val) {
            return new byte[] {
                  (byte) (val >>> 24),
                  (byte) (val >>> 16),
                  (byte) (val >>> 8),
                  (byte) (val)
            };
        }
"
542,"not useful, you are not using this method outside of the AbstractEEFLifecycleManager","	protected int getFontStyle(String fontStyleExpression, EAttribute eAttribute, FontData defaultFontData, StyledText text) {
		int fontStyle = defaultFontData.getStyle();
		if (fontStyleExpression != null && !fontStyleExpression.isEmpty()) {
			Eval eval = new Eval(interpreter, variableManager);
			String fontStyleValue = eval.get(eAttribute, fontStyleExpression, String.class);
			fontStyle = getFontStyle(fontStyleValue, fontStyle, text);
		}
		return fontStyle;
	}
","START 	protected int END  getFontStyle(String fontStyleExpression, EAttribute eAttribute, FontData defaultFontData, StyledText text) {
		int fontStyle = defaultFontData.getStyle();
		if (fontStyleExpression != null && !fontStyleExpression.isEmpty()) {
			Eval eval = new Eval(interpreter, variableManager);
			String fontStyleValue = eval.get(eAttribute, fontStyleExpression, String.class);
			fontStyle = getFontStyle(fontStyleValue, fontStyle, text);
		}
		return fontStyle;
	}
","	private int getFontStyle(String fontStyleExpression, EAttribute eAttribute, FontData defaultFontData, StyledText text) {
		int fontStyle = defaultFontData.getStyle();
		if (fontStyleExpression != null && !fontStyleExpression.isEmpty()) {
			Eval eval = new Eval(interpreter, variableManager);
			String fontStyleValue = eval.get(eAttribute, fontStyleExpression, String.class);
			fontStyle = getFontStyle(fontStyleValue, fontStyle, text);
		}
		return fontStyle;
	}
"
543,We could the variable declaration and just use `return decoratorClass.getConstructor().newInstance();`,"    private static HandlerDecorator buildDecorator(Class<? extends HandlerDecorator> decoratorClass) {
        HandlerDecorator decorator;
        try {
            decorator = decoratorClass.getConstructor().newInstance();
        } catch (ReflectiveOperationException e) {
            throw new IllegalStateException(""Decorator class "" + decoratorClass + ""cannot be instantiated"", e);
        }
        return decorator;
    }
","    private static HandlerDecorator buildDecorator(Class<? extends HandlerDecorator> decoratorClass) {
        HandlerDecorator decorator;
        try {
START             decorator = decoratorClass.getConstructor().newInstance(); END 
        } catch (ReflectiveOperationException e) {
            throw new IllegalStateException(""Decorator class "" + decoratorClass + ""cannot be instantiated"", e);
        }
        return decorator;
    }
","    private static HandlerDecorator buildDecorator(Class<? extends HandlerDecorator> decoratorClass) {
        try {
            return decoratorClass.getConstructor().newInstance();
        } catch (ReflectiveOperationException e) {
            throw new IllegalStateException(""Decorator class "" + decoratorClass + ""cannot be instantiated"", e);
        }
    }
"
544,Modifier 'private' is redundant for Enum constructor - needs to be removed.,"    private XML(String identifier) {
        this.identifier = identifier;
    }
","START     private XML(String identifier) { END 
        this.identifier = identifier;
    }
","    XML(String identifier) {
        this.identifier = identifier;
    }
"
545,Why do we need `+` here?,"    public CompareToBuilder append(final boolean lhs, final boolean rhs) {
        if (comparison != 0) {
            return this;
        }
        if (lhs == rhs) {
            return this;
        }
        if (lhs) {
            comparison = +1;
        } else {
            comparison = -1;
        }
        return this;
    }
","    public CompareToBuilder append(final boolean lhs, final boolean rhs) {
        if (comparison != 0) {
            return this;
        }
        if (lhs == rhs) {
            return this;
        }
        if (lhs) {
START             comparison = +1; END 
        } else {
            comparison = -1;
        }
        return this;
    }
","    public CompareToBuilder append(final boolean lhs, final boolean rhs) {
        if (comparison != 0) {
            return this;
        }
        if (lhs == rhs) {
            return this;
        }
        if (lhs) {
            comparison = 1;
        } else {
            comparison = -1;
        }
        return this;
    }
"
546,pretty sure this was right before... This looks like it might have an impact on performance. Why was this change made?,"    private JavaSymbolicObject expandMacro(JavaSymbolicObject node) {
        JavaSymbolicObject expandedNode = (JavaSymbolicObject) node.accept(this);
        while (!node.equals(expandedNode)) {
            node = expandedNode;
            expandedNode = (JavaSymbolicObject) node.accept(this);
        }

        return node;
    }
","START     private JavaSymbolicObject expandMacro(JavaSymbolicObject node) { END 
        JavaSymbolicObject expandedNode = (JavaSymbolicObject) node.accept(this);
        while (!node.equals(expandedNode)) {
            node = expandedNode;
            expandedNode = (JavaSymbolicObject) node.accept(this);
        }

        return node;
    }
","    private JavaSymbolicObject expandMacro(JavaSymbolicObject node) {
        JavaSymbolicObject expandedNode = (JavaSymbolicObject) node.accept(this);
        // while some macro rule has applied, making the term references different
        while (node != expandedNode) {
            node = expandedNode;
            expandedNode = (JavaSymbolicObject) node.accept(this);
        }

        return node;
    }
"
547,"The variable 's' is not used. If you're doing this for the bounds check, you can just do 'SymbolKind.forValue(_v)' and discard the return value.

(Does your IDE show a warning for the unused variable? If not, you may want to turn that on. In general, please try to avoid introducing new warnings if they can be avoided. (Sometimes, it cannot be avoided; for example, Server2ClientProtocolExtension derives from LanguageClientImpl which is technically not public API, and the API tooling gives me a warning about that, but there's nothing we can do about it except suppress it.))","	public ExtendedSymbolKindType(int _v) {
		try {
			SymbolKind s = SymbolKind.forValue(_v);
			value = _v;
			isProtocolSymbol = true;
		} catch (IllegalArgumentException e) {
			try {
				CquerySymbolKind c = CquerySymbolKind.forValue(_v);
				value = _v;
				isProtocolSymbol = false;
			} catch (IllegalArgumentException y) {
				throw new IllegalArgumentException(""Illegal value for SymbolKind"");
			}
		}
	}
","	public ExtendedSymbolKindType(int _v) {
		try {
START 			SymbolKind s = SymbolKind.forValue(_v); END 
			value = _v;
			isProtocolSymbol = true;
		} catch (IllegalArgumentException e) {
			try {
				CquerySymbolKind c = CquerySymbolKind.forValue(_v);
				value = _v;
				isProtocolSymbol = false;
			} catch (IllegalArgumentException y) {
				throw new IllegalArgumentException(""Illegal value for SymbolKind"");
			}
		}
	}
","	public ExtendedSymbolKindType(int _v) {
		try {
			SymbolKind.forValue(_v);
			value = _v;
			isProtocolSymbol = true;
		} catch (IllegalArgumentException e) {
			try {
				CquerySymbolKind.forValue(_v);
				value = _v;
				isProtocolSymbol = false;
			} catch (IllegalArgumentException y) {
				throw new IllegalArgumentException(""Illegal value for SymbolKind""); //$NON-NLS-1$
			}
		}
	}
"
548,"But returning true here will result in the OR to yield always true, meaning that when an instance's type does not match the type of a type filter it will always be included, no matter what the result of the unconditional filters would be.","	private boolean applyTypedFilter(Instance instance) {
		// Loop through all the type filters
		for (String type : this.typeFilters.keySet()) {
			if (checkType(instance.getDefinition(), type)) {
				// instance equals type name
				for (Filter innerFilter : this.typeFilters.get(type)) {
					if (innerFilter.match(instance))
						return true;
				}
				// So, instance matches type and but does not match filter
				return false;
			}
		}
		// it reaches here that means Instance does not match any type of
		// type filters. Method should return true.
		return true;
	}
","	private boolean applyTypedFilter(Instance instance) {
		// Loop through all the type filters
		for (String type : this.typeFilters.keySet()) {
			if (checkType(instance.getDefinition(), type)) {
				// instance equals type name
				for (Filter innerFilter : this.typeFilters.get(type)) {
					if (innerFilter.match(instance))
						return true;
				}
				// So, instance matches type and but does not match filter
				return false;
			}
		}
		// it reaches here that means Instance does not match any type of
		// type filters. Method should return true.
START 		return true; END 
	}
","	private boolean applyTypedFilter(Instance instance) {
		// Loop through all the type filters
		for (String type : this.typeFilters.keySet()) {
			if (checkType(instance.getDefinition(), type)) {
				// instance equals type name
				for (Filter innerFilter : this.typeFilters.get(type)) {
					if (innerFilter.match(instance))
						return true;
				}
				// So, instance matches type and but does not match filter
				return false;
			}
		}
		// it reaches here that means Instance does not match any type of
		// type filters. Method should return false for lazy evaluation.
		return false;
	}
"
549,synchronized should be before void. Seems you didn't run `mvn clean package` after making this change else the compiler would have caught it. See travis error here https://travis-ci.org/openmrs/openmrs-core/builds/320193916#L2148,"	public void synchronized setServiceContext(ServiceContext ctx) {
		setContext(ctx);
	}
","START 	public void synchronized setServiceContext(ServiceContext ctx) { END 
		setContext(ctx);
	}
","	public synchronized void setServiceContext(ServiceContext ctx) {
		setContext(ctx);
	}
"
550,"Not strictly necessary, since the .get() will throw if there's no extracted content.","    public void testNoAvailabilitiesSetsActivelyPublishedToFalse() throws IOException {
        
        LoveFilmDataRow row = rowFromFile(""battle-royale-no-availability.csv"");
        
        Optional<Content> extracted = extractor.extract(row);
        
        assertTrue(extracted.isPresent());
        Content content = extracted.get();
        
        Film film = (Film) content;
        
        assertFalse(film.isActivelyPublished());
    }
","    public void testNoAvailabilitiesSetsActivelyPublishedToFalse() throws IOException {
        
        LoveFilmDataRow row = rowFromFile(""battle-royale-no-availability.csv"");
        
        Optional<Content> extracted = extractor.extract(row);
        
START         assertTrue(extracted.isPresent()); END 
        Content content = extracted.get();
        
        Film film = (Film) content;
        
        assertFalse(film.isActivelyPublished());
    }
","    public void testNoAvailabilitiesSetsActivelyPublishedToFalse() throws IOException {
        
        LoveFilmDataRow row = rowFromFile(""battle-royale-no-availability.csv"");
        
        Optional<Content> extracted = extractor.extract(row);
        
        Content content = extracted.get();
        
        Film film = (Film) content;
        
        assertFalse(film.isActivelyPublished());
    }
"
551,"You can use just ""map"" here, it is defined in the base class.","    public ClusterFeatures list() {
        ClusterFeatures features = new ClusterFeatures();
        Set<AdditionalFeature> addlFeatures = BackendClusterFeatureHelper.getClusterFeatures(this, version);
        addlFeatures.forEach(clusterFeature -> {
            org.ovirt.engine.api.model.ClusterFeature feature =
                    addLinks(ClusterFeaturesMapper.map(clusterFeature, null));
            features.getClusterFeatures().add(feature);
        });
        return features;
    }
","    public ClusterFeatures list() {
        ClusterFeatures features = new ClusterFeatures();
        Set<AdditionalFeature> addlFeatures = BackendClusterFeatureHelper.getClusterFeatures(this, version);
        addlFeatures.forEach(clusterFeature -> {
            org.ovirt.engine.api.model.ClusterFeature feature =
                    START addLinks(ClusterFeaturesMapper.map(clusterFeature, END  null));
            features.getClusterFeatures().add(feature);
        });
        return features;
    }
","    public ClusterFeatures list() {
        ClusterFeatures features = new ClusterFeatures();
        Set<AdditionalFeature> addlFeatures = BackendClusterFeatureHelper.getClusterFeatures(this, version);
        addlFeatures.forEach(clusterFeature -> {
            org.ovirt.engine.api.model.ClusterFeature feature =
                    addLinks(map(clusterFeature, null));
            features.getClusterFeatures().add(feature);
        });
        return features;
    }
"
552,nit: remove,"    public QueryInfo updateQueryInfo(Optional<StageInfo> stageInfo)
    {
        QueryInfo queryInfo = getQueryInfo(stageInfo);
        if (queryInfo.isFinalQueryInfo()) {
            session.getSessionLogger().log(() -> ""Marking query finally done"");
            queryInfo.setSessionLogEntries(session.getSessionLogger().getEntries());
            finalQueryInfo.compareAndSet(Optional.empty(), Optional.of(queryInfo));
        }
        return queryInfo;
    }
","    public QueryInfo updateQueryInfo(Optional<StageInfo> stageInfo)
    {
        QueryInfo queryInfo = getQueryInfo(stageInfo);
        if (queryInfo.isFinalQueryInfo()) {
START             session.getSessionLogger().log(() -> ""Marking query finally done""); END 
            queryInfo.setSessionLogEntries(session.getSessionLogger().getEntries());
            finalQueryInfo.compareAndSet(Optional.empty(), Optional.of(queryInfo));
        }
        return queryInfo;
    }
","    public QueryInfo updateQueryInfo(Optional<StageInfo> stageInfo)
    {
        QueryInfo queryInfo = getQueryInfo(stageInfo);
        if (queryInfo.isFinalQueryInfo()) {
            queryInfo.setSessionLogEntries(session.getSessionLogger().getEntries());
            finalQueryInfo.compareAndSet(Optional.empty(), Optional.of(queryInfo));
        }
        return queryInfo;
    }
"
553,You would better use newText.isEmpty() here.,"	public Object execute(ExecutionEvent event) {
		InputDialog dialog = new InputDialog(Display.getCurrent()
				.getActiveShell(), Messages.PerfSaveSession_title,
				Messages.PerfSaveSession_msg, """", new IInputValidator() { //$NON-NLS-1$

			@Override
			public String isValid(String newText) {
				if ("""".equals(newText)) { //$NON-NLS-1$
					return Messages.PerfSaveSession_invalid_filename_msg;
				}
				return null;
			}
		});

		if (dialog.open() == Window.OK) {
			saveData(dialog.getValue());
		}

		return null;
	}
","	public Object execute(ExecutionEvent event) {
		InputDialog dialog = new InputDialog(Display.getCurrent()
				.getActiveShell(), Messages.PerfSaveSession_title,
				Messages.PerfSaveSession_msg, """", new IInputValidator() { //$NON-NLS-1$

			@Override
			public String isValid(String newText) {
START 				if ("""".equals(newText)) { //$NON-NLS-1$ END 
					return Messages.PerfSaveSession_invalid_filename_msg;
				}
				return null;
			}
		});

		if (dialog.open() == Window.OK) {
			saveData(dialog.getValue());
		}

		return null;
	}
","	public Object execute(ExecutionEvent event) {
		InputDialog dialog = new InputDialog(Display.getCurrent()
				.getActiveShell(), Messages.PerfSaveSession_title,
				Messages.PerfSaveSession_msg, """", new IInputValidator() { //$NON-NLS-1$

			@Override
			public String isValid(String newText) {
				if (newText.isEmpty()) {
					return Messages.PerfSaveSession_invalid_filename_msg;
				}
				return null;
			}
		});

		if (dialog.open() == Window.OK) {
			saveData(dialog.getValue());
		}

		return null;
	}
"
554,`ambSubscribers.clear();` should be out of the loop.,"        public void unsubscribeOthers(AmbSubscriber<T> notThis) {
            for (AmbSubscriber<T> other : ambSubscribers) {
                if (other != notThis) {
                    other.unsubscribe();
                }
                ambSubscribers.clear();
            }
        }
","        public void unsubscribeOthers(AmbSubscriber<T> notThis) {
            for (AmbSubscriber<T> other : ambSubscribers) {
                if (other != notThis) {
                    other.unsubscribe();
                }
START                 ambSubscribers.clear(); END 
            }
        }
","        public void unsubscribeOthers(AmbSubscriber<T> notThis) {
            for (AmbSubscriber<T> other : ambSubscribers) {
                if (other != notThis) {
                    other.unsubscribe();
                }
            }
            ambSubscribers.clear();
        }
"
555,"Maybe it would be nice to not make the chain configurable by a field in general but to have something more spring like. (Like in case of spring Filters)

They implemented it with a List in which you can add filter at various places and they delegate to each other. You can add new filters in between like filters.add(0,new MyFilter(...));

WDYT?","	protected IPageStore newPersistentStore()
	{
		StoreSettings storeSettings = application.getStoreSettings();
		Bytes maxSizePerSession = storeSettings.getMaxSizePerSession();
		File fileStoreFolder = storeSettings.getFileStoreFolder();

		if (storeSettings.isEncrypted()) {
			return new SerializingPageStore(new CryptingPageStore(new DiskPageStore(application.getName(), fileStoreFolder, maxSizePerSession)), getSerializer());
		} else {
			return new DiskPageStore(application.getName(), fileStoreFolder, maxSizePerSession, getSerializer());
		}
	}
","	protected IPageStore newPersistentStore()
	{
		StoreSettings storeSettings = application.getStoreSettings();
		Bytes maxSizePerSession = storeSettings.getMaxSizePerSession();
		File fileStoreFolder = storeSettings.getFileStoreFolder();

START 		if (storeSettings.isEncrypted()) { END 
			return new SerializingPageStore(new CryptingPageStore(new DiskPageStore(application.getName(), fileStoreFolder, maxSizePerSession)), getSerializer());
		} else {
			return new DiskPageStore(application.getName(), fileStoreFolder, maxSizePerSession, getSerializer());
		}
	}
","	protected IPageStore newPersistentStore()
	{
		StoreSettings storeSettings = application.getStoreSettings();
		Bytes maxSizePerSession = storeSettings.getMaxSizePerSession();
		File fileStoreFolder = storeSettings.getFileStoreFolder();

		return new DiskPageStore(application.getName(), fileStoreFolder, maxSizePerSession);
	}
"
556,"@azizmb9494 It looks like the Amazon implementation is slightly different here than the Google implementation.  Sometimes this can happen if the Gradle copy script doesn't execute properly when you're building the Google variant.  Could you try re-building this project again using any of the Google build variants (oba, agencyx, agencyy) to re-generate the Amazon code, and then push that new version here?","    public void onInfoWindowClick(Marker marker) {
        // Stop any callbacks to refresh the vehicle marker popup balloons
        mCustomInfoWindowAdapter.cancelUpdates();

        // Show trip details screen for the vehicle associated with this marker
        ObaTripStatus status = mMarkerData.getStatusFromMarker(marker);

        String focusedStopId = mController.getFocusedStopId();
        if (mController != null && mController.getFocusedStopId != null) {
            TripDetailsActivity.start(mActivity, status.getActiveTripId(), focusedStopId);
        } else {
            TripDetailsActivity.start(mActivity, status.getActiveTripId());
        }
    }
","    public void onInfoWindowClick(Marker marker) {
        // Stop any callbacks to refresh the vehicle marker popup balloons
        mCustomInfoWindowAdapter.cancelUpdates();

        // Show trip details screen for the vehicle associated with this marker
        ObaTripStatus status = mMarkerData.getStatusFromMarker(marker);

START         String focusedStopId = mController.getFocusedStopId(); END 
        if (mController != null && mController.getFocusedStopId != null) {
            TripDetailsActivity.start(mActivity, status.getActiveTripId(), focusedStopId);
        } else {
            TripDetailsActivity.start(mActivity, status.getActiveTripId());
        }
    }
","    public void onInfoWindowClick(Marker marker) {
        // Stop any callbacks to refresh the vehicle marker popup balloons
        mCustomInfoWindowAdapter.cancelUpdates();

        // Show trip details screen for the vehicle associated with this marker
        ObaTripStatus status = mMarkerData.getStatusFromMarker(marker);

        if (mController != null && mController.getFocusedStopId() != null) {
            TripDetailsActivity.start(mActivity, status.getActiveTripId(), mController.getFocusedStopId());
        } else {
            TripDetailsActivity.start(mActivity, status.getActiveTripId());
        }
    }
"
557,"Use `this(factory, null, false, false, 1)`. Then if someone add/remove a new parameter to the ""main"" constructor he/she needs to make a decision what to do with this one.","    public ElevationModule(ElevationGridCoverageFactory factory) {
        gridCoverageFactory = factory;
        cachedElevationsFile = null;
        readCachedElevations = false;
        writeCachedElevations = false;
        elevationUnitMultiplier = 1;
    }
","    public ElevationModule(ElevationGridCoverageFactory factory) {
START         gridCoverageFactory = factory; END 
        cachedElevationsFile = null;
        readCachedElevations = false;
        writeCachedElevations = false;
        elevationUnitMultiplier = 1;
    }
","    public ElevationModule(ElevationGridCoverageFactory factory) {
        this(
            factory,
            null,
            false,
            false,
            1,
            true,
            false
        );
    }
"
558,"I'm not sure, but do we need to use the natural logarithmic here or are you just after logarithmic behaviour in general? In the latter case, it would be more efficient to use `log2`, I suppose. Then you could write this as `(int) (Math.log2(searchRatio) / nbrDim) + extraLevels`","    public int maxDepth( Envelope referenceEnvelope, Envelope range, int nbrDim, int maxLevel )
    {
        double searchRatio = range.getArea() / referenceEnvelope.getArea();
        final int i = (int) (Math.log( searchRatio ) / Math.log( Math.pow( 2, nbrDim ) )) + extraLevels;
        return i;
    }
","    public int maxDepth( Envelope referenceEnvelope, Envelope range, int nbrDim, int maxLevel )
    {
        double searchRatio = range.getArea() / referenceEnvelope.getArea();
START         final int i = (int) (Math.log( searchRatio ) / Math.log( Math.pow( 2, nbrDim ) )) + extraLevels; END 
        return i;
    }
","    public int maxDepth( Envelope referenceEnvelope, Envelope range, int nbrDim, int maxLevel )
    {
        double searchRatio = range.getArea() / referenceEnvelope.getArea();
        return (int) (Math.log( searchRatio ) / Math.log( Math.pow( 2, nbrDim ) )) + extraLevels;
    }
"
559,Its the _Matcher_ that gets reused multiple times - the list probably doesn't.,"        public StatementsMatcher(List<Statement> statements) {
            Collections.copy(statements, unmatched);
        }
","        public StatementsMatcher(List<Statement> statements) {
START             Collections.copy(statements, unmatched); END 
        }
","        public StatementsMatcher(List<Statement> statements) {
            unmatched = new ArrayList<>();
            // Make a local copy of statements, because it's probably mutable
            // and we don't want to change it upon a later removeAll call.
            Collections.copy(statements, unmatched);
        }
"
560,What if groups is empty at this point ?,"    public void addNewAuthorization() {
        if (groups.get(0).getRule() != null) {
            groups.add(0, new AuthorizationGroupBean());
        }
    }
","    public void addNewAuthorization() {
START         if (groups.get(0).getRule() != null) { END 
            groups.add(0, new AuthorizationGroupBean());
        }
    }
","    public void addNewAuthorization() {
        if ((!groups.isEmpty() && groups.get(0).getRule() != null) || groups.isEmpty()) {
            groups.add(0, new AuthorizationGroupBean());
        }
    }
"
561,`new HashSet<>(list).size() == list.size();`,"  public static boolean allUnique(List<String> argListNames) {
    return argListNames.stream().allMatch(new HashSet<>()::add);
  }
","  public static boolean allUnique(List<String> argListNames) {
START     return argListNames.stream().allMatch(new HashSet<>()::add); END 
  }
","  public static boolean allUnique(List<String> argListNames) {
    return argListNames.size() == new HashSet<>(argListNames).size();
  }
"
562,"Shouldn't requestLayout be called on the perspSwitcherToolbar Control directly, instead of the Shell?","	private void fixSize() {
		perspSwitcherToolbar.pack();
		perspSwitcherToolbar.getParent().pack();
		perspSwitcherToolbar.getShell().requestLayout();
	}
","	private void fixSize() {
		perspSwitcherToolbar.pack();
		perspSwitcherToolbar.getParent().pack();
START 		perspSwitcherToolbar.getShell().requestLayout(); END 
	}
","	private void fixSize() {
		perspSwitcherToolbar.pack();
		perspSwitcherToolbar.getParent().pack();
		perspSwitcherToolbar.requestLayout();
	}
"
563,"nit: switch statement would be more natural here

```
            switch (withNulls) {
                case ALL:
                    return NULL_VALUES;
                case PARTIAL:
                    return IntStream.range(0, ROWS).mapToObj(i -> i % 2 == 0 ? createValue() : null).collect(toList());
                default:
                    return IntStream.range(0, ROWS).mapToObj(i -> createValue()).collect(toList());
            }
```","        protected final List<?> createValues()
        {
            if (withNulls == Nulls.ALL) {
                return NULL_VALUES;
            }

            if (withNulls == Nulls.PARTIAL) {
                return IntStream.range(0, ROWS).mapToObj(i -> i % 2 == 0 ? createValue() : null).collect(toList());
            }
            return IntStream.range(0, ROWS).mapToObj(i -> createValue()).collect(toList());
        }
","        protected final List<?> createValues()
        {
START             if (withNulls == Nulls.ALL) { END 
                return NULL_VALUES;
            }

            if (withNulls == Nulls.PARTIAL) {
                return IntStream.range(0, ROWS).mapToObj(i -> i % 2 == 0 ? createValue() : null).collect(toList());
            }
            return IntStream.range(0, ROWS).mapToObj(i -> createValue()).collect(toList());
        }
","        protected final List<?> createValues()
        {
            switch (withNulls) {
                case ALL:
                    return NULL_VALUES;
                case PARTIAL:
                    return IntStream.range(0, ROWS).mapToObj(i -> i % 2 == 0 ? createValue() : null).collect(toList());
                default:
                    return IntStream.range(0, ROWS).mapToObj(i -> createValue()).collect(toList());
            }
        }
"
564,"did you mean-
for (Object item : items) {
 identicalItems.add(item);
}
setItems(identicalItems);

- Cause now the loop is redundant and you reset the old items when you set the comparator.","    protected void setComparator(Comparator comparator) {
        this.comparator = comparator;
        Iterable items = getItems();
        if (items == null) {
            return;
        }
        Iterable identicalItems = (comparator == null) ? new ArrayList() : new TreeSet(comparator);
        for (Object item : items) {
            setItems(identicalItems);
        }
    }
","    protected void setComparator(Comparator comparator) {
        this.comparator = comparator;
        Iterable items = getItems();
        if (items == null) {
            return;
        }
        Iterable identicalItems = (comparator == null) ? new ArrayList() : new TreeSet(comparator);
        for (Object item : items) {
START             setItems(identicalItems); END 
        }
    }
","    protected void setComparator(Comparator comparator) {
        if (comparator == this.comparator) {
            return;
        }
        this.comparator = comparator;

        Iterable items = getItems();
        if (items == null) {
            return;
        }

        Collection identicalItems = (comparator == null) ? new ArrayList() : new TreeSet(comparator);
        for (Object item : items) {
            identicalItems.add(item);
        }
        setItems(identicalItems);
    }
"
565,"Use isEmpty() or alternatively, don't have to check size, the for loop will not run if it is empty.","    public void notifySurfaceDetached() {
        // Release active image reader in detached listener
        super.notifySurfaceDetached();

        // Release inactive image readers
        if (mImageReaderToReleaseList.size() > 0) {
            for (ImageReaderProxy imageReader : mImageReaderToReleaseList) {
                Surface surface = imageReader.getSurface();
                if (surface != null) {
                    surface.release();
                }
                imageReader.close();
            }

            mImageReaderToReleaseList.clear();
        }

    }
","    public void notifySurfaceDetached() {
        // Release active image reader in detached listener
        super.notifySurfaceDetached();

        // Release inactive image readers
        START  if (mImageReaderToReleaseList.size() > 0) { END 
            for (ImageReaderProxy imageReader : mImageReaderToReleaseList) {
                Surface surface = imageReader.getSurface();
                if (surface != null) {
                    surface.release();
                }
                imageReader.close();
            }

            mImageReaderToReleaseList.clear();
        }

    }
","    public void notifySurfaceDetached() {
        // Release active image reader in detached listener
        super.notifySurfaceDetached();

        // Release inactive image readers
        if (!mImageReaderToReleaseList.isEmpty()) {
            for (ImageReaderProxy imageReader : mImageReaderToReleaseList) {
                // There will be the stric mode erro under API Level 23. Add surface
                // release to dereference.
                Surface surface = imageReader.getSurface();
                if (surface != null) {
                    surface.release();
                }

                imageReader.close();
            }

            mImageReaderToReleaseList.clear();
        }

    }
"
566,Ternary if?,"	private T findUniqueResult() {

		if (collection.size() == 1) {
			return collection.iterator().next();
		}
		return uniqueResult;
	}
","	private T findUniqueResult() {

START 		if (collection.size() == 1) { END 
			return collection.iterator().next();
		}
		return uniqueResult;
	}
","	private T findUniqueResult() {
		return collection.size() == 1 ? collection.iterator().next() : null;
	}
"
567,If you are going to do this do you need to @sychronize? If not indicate it is not threadsafe...,"    public MetadataMap getMetadata() {
        if (metadata == null) {
            metadata = new MetadataMap();
        }
        return metadata;
    }
","    public MetadataMap getMetadata() {
        if (metadata == null) {
START             metadata = new MetadataMap(); END 
        }
        return metadata;
    }
","    public synchronized MetadataMap getMetadata() {
        if (metadata == null) {
            metadata = new MetadataMap();
        }
        return metadata;
    }
"
568,`currentXXMemoryValue` is a weird name; maybe we can just inline these two variables. Or use `currentUserMemory.get()` below.,"    public void updateMemoryUsage(long deltaUserMemoryInBytes, long deltaTotalMemoryInBytes)
    {
        long currentUserMemoryValue = currentUserMemory.addAndGet(deltaUserMemoryInBytes);
        long currentTotalMemoryValue = currentTotalMemory.addAndGet(deltaTotalMemoryInBytes);
        peakUserMemory.updateAndGet(currentPeakValue -> Math.max(currentUserMemoryValue, currentPeakValue));
        peakTotalMemory.updateAndGet(currentPeakValue -> Math.max(currentTotalMemoryValue, currentPeakValue));
    }
","    public void updateMemoryUsage(long deltaUserMemoryInBytes, long deltaTotalMemoryInBytes)
    {
START         long currentUserMemoryValue = currentUserMemory.addAndGet(deltaUserMemoryInBytes); END 
        long currentTotalMemoryValue = currentTotalMemory.addAndGet(deltaTotalMemoryInBytes);
        peakUserMemory.updateAndGet(currentPeakValue -> Math.max(currentUserMemoryValue, currentPeakValue));
        peakTotalMemory.updateAndGet(currentPeakValue -> Math.max(currentTotalMemoryValue, currentPeakValue));
    }
","    public void updateMemoryUsage(long deltaUserMemoryInBytes, long deltaTotalMemoryInBytes)
    {
        currentUserMemory.addAndGet(deltaUserMemoryInBytes);
        currentTotalMemory.addAndGet(deltaTotalMemoryInBytes);
        peakUserMemory.updateAndGet(currentPeakValue -> Math.max(currentUserMemory.get(), currentPeakValue));
        peakTotalMemory.updateAndGet(currentPeakValue -> Math.max(currentTotalMemory.get(), currentPeakValue));
    }
"
569,"> this [](start = 15, length = 4)

no this. please","    public final Date getExtendedExpiresOn() {
        return this.mExtendedExpiresOn;
    }
","    public final Date getExtendedExpiresOn() {
START         return this.mExtendedExpiresOn; END 
    }
","    public final Date getExtendedExpiresOn() {
        return mExtendedExpiresOn;
    }
"
570,this constructor can directly call the below one,"    public FileInfo(FileSystem srcFs, Path sourcePath, String subDir) {
      this.srcFs = srcFs;
      this.sourcePath = sourcePath;
      this.cmPath = null;
      this.checkSum = null;
      this.useSourcePath = true;
      this.subDir = subDir;
    }
","    public FileInfo(FileSystem srcFs, Path sourcePath, String subDir) {
      this.srcFs = srcFs;
      this.sourcePath = sourcePath;
START       this.cmPath = null; END 
      this.checkSum = null;
      this.useSourcePath = true;
      this.subDir = subDir;
    }
","    public FileInfo(FileSystem srcFs, Path sourcePath, String subDir) {
      this(srcFs, sourcePath, null, null, true, subDir);
    }
"
571,"Hi, since existing object ids start with 1 and you define voId/groupId=0 by default, then you can safely use something like: `session.isVoAdmin(voId) || session.isGroupAdmin(groupId)` in the first IF.","	public boolean isAuthorized() {
		if (session.isVoAdmin(voId)) {
			return true;
		} else {
			return group != null && session.isGroupAdmin(groupId);
		}
	}
","	public boolean isAuthorized() {
		if (session.isVoAdmin(voId)) {
			return true;
		} else {
START 			return group != null && session.isGroupAdmin(groupId); END 
		}
	}
","	public boolean isAuthorized() {
		return (session.isVoAdmin(voId) || session.isGroupAdmin(groupId));
	}
"
572,"`""creator""` and `""lastModifier""` should be added to `STANDARD_ALIASES` instead of creating the aliases here","  public String propertyForUserName(Criteria criteria, boolean creator) {
    criteria.createAlias(""creator"", ""creator"");
    criteria.createAlias(""lastModifier"", ""lastModifier"");
    return creator ? ""creator.loginName"" : ""lastModifier.loginName"";
  }
","  public String propertyForUserName(Criteria criteria, boolean creator) {
    criteria.createAlias(""creator"", ""creator"");
START     criteria.createAlias(""lastModifier"", ""lastModifier""); END 
    return creator ? ""creator.loginName"" : ""lastModifier.loginName"";
  }
","  public String propertyForUserName(Criteria criteria, boolean creator) {
    return creator ? ""creator.loginName"" : ""lastModifier.loginName"";
  }
"
573,use final,"	public List<RadiologyReport> getRadiologyReportsByRadiologyOrderAndRadiologyReportStatus(RadiologyOrder radiologyOrder,
			RadiologyReportStatus radiologyReportStatus) {
		
		List<RadiologyReport> result = sessionFactory.getCurrentSession()
				.createCriteria(RadiologyReport.class)
				.add(Restrictions.eq(""radiologyOrder"", radiologyOrder))
				.add(Restrictions.eq(""reportStatus"", radiologyReportStatus))
				.list();
		return result == null ? new ArrayList<RadiologyReport>() : result;
	}
","	public List<RadiologyReport> getRadiologyReportsByRadiologyOrderAndRadiologyReportStatus(RadiologyOrder radiologyOrder,
			RadiologyReportStatus radiologyReportStatus) {
		
START 		List<RadiologyReport> result = sessionFactory.getCurrentSession() END 
				.createCriteria(RadiologyReport.class)
				.add(Restrictions.eq(""radiologyOrder"", radiologyOrder))
				.add(Restrictions.eq(""reportStatus"", radiologyReportStatus))
				.list();
		return result == null ? new ArrayList<RadiologyReport>() : result;
	}
","	public List<RadiologyReport> getRadiologyReportsByRadiologyOrderAndRadiologyReportStatus(RadiologyOrder radiologyOrder,
			RadiologyReportStatus radiologyReportStatus) {
		
		final List<RadiologyReport> result = sessionFactory.getCurrentSession()
				.createCriteria(RadiologyReport.class)
				.add(Restrictions.eq(""radiologyOrder"", radiologyOrder))
				.add(Restrictions.eq(""reportStatus"", radiologyReportStatus))
				.list();
		return result == null ? new ArrayList<RadiologyReport>() : result;
	}
"
574,just double checking that this is really the intent? change looks odd..,"    public static Boolean notExists(
            EvaluationContext ctx,
            List tests,
            Object target) {

        for (Object test : tests) {
            Boolean r = applyUnaryTest(ctx, test, target);
            if (r != null && r) return false;
        }

        return true;
    }
","    public static Boolean notExists(
            EvaluationContext ctx,
            List tests,
            Object target) {

        for (Object test : tests) {
            Boolean r = applyUnaryTest(ctx, test, target);
START             if (r != null && r) return false; END 
        }

        return true;
    }
","    public static Boolean notExists(
            EvaluationContext ctx,
            List tests,
            Object target) {

        for (Object test : tests) {
            Boolean r = applyUnaryTest(ctx, test, target);
            if (r == null || r) return false;
        }

        return true;
    }
"
575,"the ofNullable makes no sense because you called profile.getId() on it at the beginning of the method: if it was null we wouldn't have arrived here in the code.
The profile parameter is meant to be non-null.","    public Optional<U> generate(final WebContext context, final U profile) {
        init();

        final U linkedProfile = profileService.findByLinkedId(profile.getId());

        if (linkedProfile != null) {
            return Optional.of(linkedProfile);
        } else {
            if (failIfLinkedUserNotFound) {
                throw new TechnicalException(""No linked account found for: "" + profile);
            } else {
                // fallback to the original account
                return Optional.ofNullable(profile);
            }
        }
    }
","    public Optional<U> generate(final WebContext context, final U profile) {
        init();

        final U linkedProfile = profileService.findByLinkedId(profile.getId());

        if (linkedProfile != null) {
            return Optional.of(linkedProfile);
        } else {
            if (failIfLinkedUserNotFound) {
                throw new TechnicalException(""No linked account found for: "" + profile);
            } else {
                // fallback to the original account
START                 return Optional.ofNullable(profile); END 
            }
        }
    }
","    public U generate(final WebContext context, final U profile) {
        init();

        final U linkedProfile = profileService.findByLinkedId(profile.getId());

        if (linkedProfile != null) {
            return linkedProfile;
        } else {
            if (failIfLinkedUserNotFound) {
                throw new TechnicalException(""No linked account found for: "" + profile);
            } else {
                // fallback to the original account
                return profile;
            }
        }
    }
"
576,"There is no need to do check for null, right? I mean you could just write something like  return ""SslSession(alpn="" + alpn +...","    public String toString() {
        return ""SslSession(alpn="" + (alpn == null ? ""null"" : alpn) +
            "", npn="" + (npn == null ? ""null"" : npn) +
            "", version="" + (version == null ? ""null"" : version) +
            "", cipher="" + (cipher == null ? ""null"" : cipher) +
            "", establishedTime="" + Long.toString(establishedTime) +
            "", peerCert="" + (peerCert == null ? ""null"" : peerCert.toString()) + "")"";
    }
","    public String toString() {
START         return ""SslSession(alpn="" + (alpn == null ? ""null"" : alpn) + END 
            "", npn="" + (npn == null ? ""null"" : npn) +
            "", version="" + (version == null ? ""null"" : version) +
            "", cipher="" + (cipher == null ? ""null"" : cipher) +
            "", establishedTime="" + Long.toString(establishedTime) +
            "", peerCert="" + (peerCert == null ? ""null"" : peerCert.toString()) + "")"";
    }
","    public String toString() {
        return ""SslSession(alpn="" + alpn +
            "", npn="" + npn +
            "", version="" + version +
            "", cipher="" + cipher +
            "", establishedTime="" + Long.toString(establishedTime) +
            "", peerCert="" + peerCert + "")"";
    }
"
577,I would move this down to 2508 where it's used.,"	/* package */void openFirstTimeWindow() {
		final boolean showProgress = PrefUtil.getAPIPreferenceStore().getBoolean(
				IWorkbenchPreferenceConstants.SHOW_PROGRESS_ON_STARTUP);

		if (!showProgress) {
			doOpenFirstTimeWindow();
		} else {
			// We don't know how many plug-ins will be loaded,
			// assume we are loading a tenth of the installed plug-ins.
			// (The Eclipse SDK loads 7 of 86 plug-ins at startup as of
			// 2005-5-20)
			final int expectedProgressCount = Math.max(1, WorkbenchPlugin.getDefault().getBundleCount());

			runStartupWithProgress(expectedProgressCount, () -> doOpenFirstTimeWindow());
		}
	}
","	/* package */void openFirstTimeWindow() {
		final boolean showProgress = PrefUtil.getAPIPreferenceStore().getBoolean(
				IWorkbenchPreferenceConstants.SHOW_PROGRESS_ON_STARTUP);

		if (!showProgress) {
			doOpenFirstTimeWindow();
		} else {
			// We don't know how many plug-ins will be loaded,
			// assume we are loading a tenth of the installed plug-ins.
			// (The Eclipse SDK loads 7 of 86 plug-ins at startup as of
			// 2005-5-20)
START 			final int expectedProgressCount = Math.max(1, WorkbenchPlugin.getDefault().getBundleCount()); END 

			runStartupWithProgress(expectedProgressCount, () -> doOpenFirstTimeWindow());
		}
	}
","	/* package */void openFirstTimeWindow() {
		final boolean showProgress = PrefUtil.getAPIPreferenceStore().getBoolean(
				IWorkbenchPreferenceConstants.SHOW_PROGRESS_ON_STARTUP);

		if (!showProgress) {
			doOpenFirstTimeWindow();
		} else {
			// We don't know how many plug-ins will be loaded,
			// assume we are loading a tenth of the installed plug-ins.
			// (The Eclipse SDK loads 7 of 86 plug-ins at startup as of
			// 2005-5-20)
			runStartupWithProgress(() -> doOpenFirstTimeWindow());
		}
	}
"
578,change to package-private access,"    public String getY() {
        return y;
    }
","START     public String getY() { END 
        return y;
    }
","    String getY() {
        return y;
    }
"
579,"this just calls abortBuild with a null editor, so why not just delete the if and call abortBuild(build,editor)","	public void run() {
		Object selection = getStructuredSelection().getFirstElement();
		if (selection instanceof IBuild) {
			IBuild build = (IBuild) selection;
			if (editor != null) {
				abortBuild(build, editor);
			} else {
				abortBuild(build);
			}
		} else if (selection instanceof IBuildPlan) {
			IBuildPlan buildPlan = (IBuildPlan) selection;
			abortBuild(buildPlan.getLastBuild());
		}
	}
","	public void run() {
		Object selection = getStructuredSelection().getFirstElement();
		if (selection instanceof IBuild) {
			IBuild build = (IBuild) selection;
			if (editor != null) {
				abortBuild(build, editor);
			} else {
START 				abortBuild(build); END 
			}
		} else if (selection instanceof IBuildPlan) {
			IBuildPlan buildPlan = (IBuildPlan) selection;
			abortBuild(buildPlan.getLastBuild());
		}
	}
","	public void run() {
		Object selection = getStructuredSelection().getFirstElement();
		if (selection instanceof IBuild) {
			IBuild build = (IBuild) selection;
			abortBuild(build);
		} else if (selection instanceof IBuildPlan) {
			IBuildPlan buildPlan = (IBuildPlan) selection;
			abortBuild(buildPlan.getLastBuild());
		}
	}
"
580,Why was this changed? The logic looks the same.,"    private boolean hasNotAllowedTwoEmptyLinesBefore(DetailAST token) {
        boolean result = false;
        if (!allowMultipleEmptyLines) {
            result = hasEmptyLineBefore(token) && isPrePreviousLineEmpty(token);
        }
        return result;
    }
","    private boolean hasNotAllowedTwoEmptyLinesBefore(DetailAST token) {
        boolean result = false;
        if (!allowMultipleEmptyLines) {
START             result = hasEmptyLineBefore(token) && isPrePreviousLineEmpty(token); END 
        }
        return result;
    }
","    private boolean hasNotAllowedTwoEmptyLinesBefore(DetailAST token) {
        return !allowMultipleEmptyLines && hasEmptyLineBefore(token)
                && isPrePreviousLineEmpty(token);
    }
"
581,"Rewrite this as a single boolean expression:

``` java
return AuthScheme.NEGOTIATE... && getServiceUri().getScheme()..... && ....
```","    public boolean matches(String type, URI uri, String realm)
    {
        //Realm is not used as for now
        boolean match = true;
        match &= AuthScheme.NEGOTIATE.toString().equalsIgnoreCase(type);
        match &= getServiceUri().getScheme().equalsIgnoreCase(uri.getScheme());
        match &= getServiceUri().getHost().equalsIgnoreCase(uri.getHost());
        return match;
    }
","    public boolean matches(String type, URI uri, String realm)
    {
        //Realm is not used as for now
START         boolean match = true; END 
        match &= AuthScheme.NEGOTIATE.toString().equalsIgnoreCase(type);
        match &= getServiceUri().getScheme().equalsIgnoreCase(uri.getScheme());
        match &= getServiceUri().getHost().equalsIgnoreCase(uri.getHost());
        return match;
    }
","    public boolean matches(String type, URI uri, String realm)
    {
        // The class matches all requests for Negotiate scheme.Realm is not used as for now
        return NEGOTIATE.equalsIgnoreCase(type);
    }
"
582,"How about `validator != null && validator.validate( isPrimitive, in )`","    public static boolean isStringAssignable(TypeKind kind, boolean isPrimitive, String in) {
        NumberFormatValidator validator = VALIDATORS.get( kind );
        return validator != null ? validator.validate( isPrimitive, in ) : false;
    }
","    public static boolean isStringAssignable(TypeKind kind, boolean isPrimitive, String in) {
        NumberFormatValidator validator = VALIDATORS.get( kind );
START         return validator != null ? validator.validate( isPrimitive, in ) : false; END 
    }
","    public static boolean isStringAssignable(TypeKind kind, boolean isPrimitive, String in) {
        NumberFormatValidator validator = VALIDATORS.get( kind );
        return validator != null && validator.validate( isPrimitive, in );
    }
"
583,No point in Hashtable if you are protecting the map yourself anyway by your own synchronized methods.,"  private LockManager() {
    locks = new Hashtable<URI, LockProvider>();
  }
","  private LockManager() {
START     locks = new Hashtable<URI, LockProvider>(); END 
  }
","  private LockManager() {
    locks = new HashMap<URI, LockProvider>();
  }
"
584,Do we want this to throw a TimeoutException?  My thinking is if you couldn't acquire the lock we just return without running next interceptor and make it a noop like method defines.,"   public final Object visitEvictCommand(InvocationContext ctx, EvictCommand command) throws Throwable {
      if (!passivation) {
         //if we don't have passivation then it is a simple remove from DataContainer. The CDL already locks the key in
         //commit entries (EntryWrappingInterceptor)
         return invokeNextInterceptor(ctx, command);
      }
      final Object key = command.getKey();
      try {
         cdl.lock(key, true);
         return invokeNextInterceptor(ctx, command);
      } finally {
         cdl.unlock(key);
      }
   }
","   public final Object visitEvictCommand(InvocationContext ctx, EvictCommand command) throws Throwable {
      if (!passivation) {
         //if we don't have passivation then it is a simple remove from DataContainer. The CDL already locks the key in
         //commit entries (EntryWrappingInterceptor)
         return invokeNextInterceptor(ctx, command);
      }
      final Object key = command.getKey();
      try {
START          cdl.lock(key, true); END 
         return invokeNextInterceptor(ctx, command);
      } finally {
         cdl.unlock(key);
      }
   }
","   public final Object visitEvictCommand(InvocationContext ctx, EvictCommand command) throws Throwable {
      if (!passivation) {
         //if we don't have passivation then it is a simple remove from DataContainer. The CDL already locks the key in
         //commit entries (EntryWrappingInterceptor)
         return invokeNextInterceptor(ctx, command);
      }
      final Object key = command.getKey();
      if (!cdl.lock(key, true)) {
         return null; //no-op
      }
      try {
         return invokeNextInterceptor(ctx, command);
      } finally {
         cdl.unlock(key);
      }
   }
"
585,Does this method need to be synchronized?,"    boolean hasInflightBatches(TopicPartition topicPartition) {
        return topicPartitionBookkeeper.contains(topicPartition)
                && !topicPartitionBookkeeper.getPartition(topicPartition).inflightBatchesBySequence.isEmpty();
    }
","START     boolean hasInflightBatches(TopicPartition topicPartition) { END 
        return topicPartitionBookkeeper.contains(topicPartition)
                && !topicPartitionBookkeeper.getPartition(topicPartition).inflightBatchesBySequence.isEmpty();
    }
","    synchronized boolean hasInflightBatches(TopicPartition topicPartition) {
        return topicPartitionBookkeeper.contains(topicPartition)
                && !topicPartitionBookkeeper.getPartition(topicPartition).inflightBatchesBySequence.isEmpty();
    }
"
586,"Question  (matter of choise) - don't you prefer to set it anyway?
if serverList is null or empty, 
setReurnValue will contain a null or empty list -what's the problem with that?","    protected void executeQueryCommand() {
        List<GlusterServerService> serviceList = null;

        if(getParameters().getServiceType() == null) {
            serviceList = getGlusterServerServiceDao().getByClusterId(getParameters().getId());
        } else {
            serviceList = getGlusterServerServiceDao().getByClusterIdAndServiceType(getParameters().getId(), getParameters().getServiceType());
        }

        if(serviceList != null && serviceList.size() > 0) {
            getQueryReturnValue().setReturnValue(serviceList);
        }
    }
","    protected void executeQueryCommand() {
        List<GlusterServerService> serviceList = null;

        if(getParameters().getServiceType() == null) {
            serviceList = getGlusterServerServiceDao().getByClusterId(getParameters().getId());
        } else {
            serviceList = getGlusterServerServiceDao().getByClusterIdAndServiceType(getParameters().getId(), getParameters().getServiceType());
        }

START         if(serviceList != null && serviceList.size() > 0) { END 
            getQueryReturnValue().setReturnValue(serviceList);
        }
    }
","    protected void executeQueryCommand() {
        List<GlusterServerService> serviceList = null;

        if(getParameters().getServiceType() == null) {
            serviceList = getGlusterServerServiceDao().getByClusterId(getParameters().getId());
        } else {
            serviceList = getGlusterServerServiceDao().getByClusterIdAndServiceType(getParameters().getId(), getParameters().getServiceType());
        }

        getQueryReturnValue().setReturnValue(serviceList);
    }
"
587,Why package-visible?,"	ViewerSorter createSorterInstance() throws CoreException {
		Object contributed = element.createExecutableExtension(ATT_CLASS);
		if (contributed instanceof ViewerSorter) {
			return (ViewerSorter) contributed;
		}
		if (contributed instanceof ViewerComparator) {
			return new WrappedViewerComparator((ViewerComparator) contributed);
		}
		throw new ClassCastException(""Class contributed by "" + element.getNamespaceIdentifier() + //$NON-NLS-1$
				"" to "" + INavigatorContentExtPtConstants.TAG_NAVIGATOR_CONTENT + //$NON-NLS-1$
				""/"" + INavigatorContentExtPtConstants.TAG_COMMON_SORTER //$NON-NLS-1$
				+ "" is not an instance of "" + ViewerComparator.class.getName() + "": "" + contributed.getClass().getName() //$NON-NLS-1$ //$NON-NLS-2$
		);
	}
","START 	ViewerSorter createSorterInstance() throws CoreException { END 
		Object contributed = element.createExecutableExtension(ATT_CLASS);
		if (contributed instanceof ViewerSorter) {
			return (ViewerSorter) contributed;
		}
		if (contributed instanceof ViewerComparator) {
			return new WrappedViewerComparator((ViewerComparator) contributed);
		}
		throw new ClassCastException(""Class contributed by "" + element.getNamespaceIdentifier() + //$NON-NLS-1$
				"" to "" + INavigatorContentExtPtConstants.TAG_NAVIGATOR_CONTENT + //$NON-NLS-1$
				""/"" + INavigatorContentExtPtConstants.TAG_COMMON_SORTER //$NON-NLS-1$
				+ "" is not an instance of "" + ViewerComparator.class.getName() + "": "" + contributed.getClass().getName() //$NON-NLS-1$ //$NON-NLS-2$
		);
	}
","	private ViewerSorter createSorterInstance() throws CoreException {
		Object contributed = element.createExecutableExtension(ATT_CLASS);
		if (contributed instanceof ViewerSorter) {
			return (ViewerSorter) contributed;
		}
		if (contributed instanceof ViewerComparator) {
			return new WrappedViewerComparator((ViewerComparator) contributed);
		}
		throw new ClassCastException(""Class contributed by "" + element.getNamespaceIdentifier() + //$NON-NLS-1$
				"" to "" + INavigatorContentExtPtConstants.TAG_NAVIGATOR_CONTENT + //$NON-NLS-1$
				""/"" + INavigatorContentExtPtConstants.TAG_COMMON_SORTER //$NON-NLS-1$
				+ "" is not an instance of "" + ViewerComparator.class.getName() + "": "" + contributed.getClass().getName() //$NON-NLS-1$ //$NON-NLS-2$
		);
	}
"
588,This debug message is not very useful,"	public <X> X unwrap(Long value, Class<X> type, WrapperOptions options) {
		log.debug( "" unwrap !"" );
		byte[] bytes = ByteBuffer.allocate( Long.SIZE ).putLong( value ).array();
		return (X) new BsonBinary( bytes );
	}
","	public <X> X unwrap(Long value, Class<X> type, WrapperOptions options) {
START 		log.debug( "" unwrap !"" ); END 
		byte[] bytes = ByteBuffer.allocate( Long.SIZE ).putLong( value ).array();
		return (X) new BsonBinary( bytes );
	}
","	public <X> X unwrap(Long value, Class<X> type, WrapperOptions options) {
		byte[] bytes = ByteBuffer.allocate( Long.SIZE ).putLong( value ).array();
		return (X) new BsonBinary( bytes );
	}
"
589,Please add `@Experimental` and `@since 2.1.7 - experimental` to all of them.,"    public final <R> R as(@NonNull CompletableConverter<? extends R> converter) {
        try {
            return ObjectHelper.requireNonNull(converter, ""converter is null"").apply(this);
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            throw ExceptionHelper.wrapOrThrow(ex);
        }
    }
","START     public final <R> R as(@NonNull CompletableConverter<? extends R> converter) { END 
        try {
            return ObjectHelper.requireNonNull(converter, ""converter is null"").apply(this);
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            throw ExceptionHelper.wrapOrThrow(ex);
        }
    }
","    public final <R> R as(@NonNull CompletableConverter<? extends R> converter) {
        return ObjectHelper.requireNonNull(converter, ""converter is null"").apply(this);
    }
"
590,Is this a find/replace artifact?  Semantically it should probably still be explicitly set to 0.  (I imagine you've only initialized it to please the IDE/checkstyle).,"        public Object instantiateItem(ViewGroup collection, int position) {
            int resId = PAGE_READING_LISTS;
            switch (position) {
                case PAGE_READING_LISTS:
                    resId = R.id.list_of_lists_page;
                    break;
                case PAGE_LIST_DETAIL:
                    resId = R.id.list_detail_page;
                    break;
                default:
            }
            return getView().findViewById(resId);
        }
","        public Object instantiateItem(ViewGroup collection, int position) {
START             int resId = PAGE_READING_LISTS; END 
            switch (position) {
                case PAGE_READING_LISTS:
                    resId = R.id.list_of_lists_page;
                    break;
                case PAGE_LIST_DETAIL:
                    resId = R.id.list_detail_page;
                    break;
                default:
            }
            return getView().findViewById(resId);
        }
","        public Object instantiateItem(ViewGroup collection, int position) {
            int resId;
            switch (position) {
                case PAGE_LIST_DETAIL:
                    resId = R.id.list_detail_page;
                    break;
                case PAGE_READING_LISTS:
                default:
                    resId = R.id.list_of_lists_page;
                    break;
            }
            return getView().findViewById(resId);
        }
"
591,remove `this.`,"    public void initialize(URI uri, Configuration configuration)
            throws IOException
    {
        this.dataTier.initialize(uri, configuration);
    }
","    public void initialize(URI uri, Configuration configuration)
            throws IOException
    {
START         this.dataTier.initialize(uri, configuration); END 
    }
","    public void initialize(URI uri, Configuration configuration)
            throws IOException
    {
        dataTier.initialize(uri, configuration);
    }
"
592,`System.exit(getConf(args));`,"  public static void main(String[] args) {
    int status = getConf(args);
    System.exit(status);
  }
","  public static void main(String[] args) {
START     int status = getConf(args); END 
    System.exit(status);
  }
","  public static void main(String[] args) {
    System.exit(getConf(args));
  }
"
593,done,"	public void processBean(CRResolvableBean bean, IndexWriter writer) throws CRException {

		System.out.println(writer.numDocs());
		

	}
","	public void processBean(CRResolvableBean bean, IndexWriter writer) throws CRException {

START 		System.out.println(writer.numDocs()); END 
		

	}
","	public void processBean(CRResolvableBean bean, IndexWriter writer) throws CRException {

	}
"
594,This is changing behaviour. I'd do that separately.,"    public List<@NonNull ITimeGraphEntry> getChildren() {
        return Collections.<@NonNull ITimeGraphEntry>emptyList();
    }
","    public List<@NonNull ITimeGraphEntry> getChildren() {
START         return Collections.<@NonNull ITimeGraphEntry>emptyList(); END 
    }
","    public List<@NonNull ITimeGraphEntry> getChildren() {
        return null;
    }
"
595,"this logic should be part of `Message`. it's also unnecessary to check all headers, just the first one should suffice.","    public void addNewMailNotification(Account account, LocalMessage message, int previousUnreadMessageCount) {
        boolean hasHighPriority = false;

        for (String iter : message.getHeader(""X-Priority"")) {
            if (iter.contains(context.getString(R.string.x_priority)))
                hasHighPriority = true;
        }
        newMailNotifications.addNewMailNotification(account, message, previousUnreadMessageCount, hasHighPriority);
    }
","    public void addNewMailNotification(Account account, LocalMessage message, int previousUnreadMessageCount) {
        boolean hasHighPriority = false;

START         for (String iter : message.getHeader(""X-Priority"")) { END 
            if (iter.contains(context.getString(R.string.x_priority)))
                hasHighPriority = true;
        }
        newMailNotifications.addNewMailNotification(account, message, previousUnreadMessageCount, hasHighPriority);
    }
","    public void addNewMailNotification(Account account, LocalMessage message, int previousUnreadMessageCount) {
        newMailNotifications.addNewMailNotification(account, message, previousUnreadMessageCount);
    }
"
596,"I'm not sure if this change is intentional, but it shouldn't make a difference with TmfCommonXLineChartViewer because of its use of asyncExec().

However since updateContent() is abstract here, it would seem that clearContent() should be called first.","    public void loadTrace(ITmfTrace trace) {
        super.loadTrace(trace);
        updateContent();
        clearContent();
    }
","    public void loadTrace(ITmfTrace trace) {
        super.loadTrace(trace);
        updateContent();
START         clearContent(); END 
    }
","    public void loadTrace(ITmfTrace trace) {
        super.loadTrace(trace);
        clearContent();
        updateContent();
    }
"
597,Seems like it is useful for this method to return a list of Hadoop jobs that were killed by this method and caller can print them out.,"  public static void killAllSpawnedHadoopJobs(String logFilePath, Logger log) {
    Set<String> allSpawnedJobs = findApplicationIdFromLog(logFilePath, log);
    log.info(""applicationIds to kill: "" + allSpawnedJobs);
  
    for (String appId : allSpawnedJobs) {
      try {
        killJobOnCluster(appId, log);
      } catch (Throwable t) {
        log.warn(""something happened while trying to kill this job: "" + appId, t);
      }
    }
  }
","START   public static void killAllSpawnedHadoopJobs(String logFilePath, Logger log) { END 
    Set<String> allSpawnedJobs = findApplicationIdFromLog(logFilePath, log);
    log.info(""applicationIds to kill: "" + allSpawnedJobs);
  
    for (String appId : allSpawnedJobs) {
      try {
        killJobOnCluster(appId, log);
      } catch (Throwable t) {
        log.warn(""something happened while trying to kill this job: "" + appId, t);
      }
    }
  }
","  public static Set<String> killAllSpawnedHadoopJobs(String logFilePath, Logger log) {
    Set<String> allSpawnedJobs = findApplicationIdFromLog(logFilePath, log);
    log.info(""applicationIds to kill: "" + allSpawnedJobs);

    for (String appId : allSpawnedJobs) {
      try {
        killJobOnCluster(appId, log);
      } catch (Throwable t) {
        log.warn(""something happened while trying to kill this job: "" + appId, t);
      }
    }

    return allSpawnedJobs;
  }
"
598,is this because of the inheritance?,"    public boolean equals(Object o) {
      if (o == null) {
        return false;
      }

      if (this == o) {
        return true;
      }
      if (!(this.getClass().equals(o.getClass()))) {
        return false;
      }
      SitePropertySource that = (SitePropertySource) o;
      return Objects.equal(mFilename, that.mFilename);
    }
","    public boolean equals(Object o) {
      if (o == null) {
        return false;
      }

      if (this == o) {
        return true;
      }
START       if (!(this.getClass().equals(o.getClass()))) { END 
        return false;
      }
      SitePropertySource that = (SitePropertySource) o;
      return Objects.equal(mFilename, that.mFilename);
    }
","    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }

      if (o == null || this.getClass() != o.getClass()) {
        return false;
      }
      SitePropertySource that = (SitePropertySource) o;
      return Objects.equal(mFilename, that.mFilename);
    }
"
599,Do we need to change some of these other tests? We're still using `initialUpdateResponse` above in `assignFromUser` and below.,"    public void testFetchSkipsBlackedOutNodes() {
        buildFetcher();

        assignFromUser(singleton(tp0));
        subscriptions.seek(tp0, 0);
        client.updateMetadata(initialUpdateResponseWithLeaderEpoch);
        Node node = initialUpdateResponse.brokers().iterator().next();

        client.blackout(node, 500);
        assertEquals(0, fetcher.sendFetches());

        time.sleep(500);
        assertEquals(1, fetcher.sendFetches());
    }
","    public void testFetchSkipsBlackedOutNodes() {
        buildFetcher();

        assignFromUser(singleton(tp0));
        subscriptions.seek(tp0, 0);
START         client.updateMetadata(initialUpdateResponseWithLeaderEpoch); END 
        Node node = initialUpdateResponse.brokers().iterator().next();

        client.blackout(node, 500);
        assertEquals(0, fetcher.sendFetches());

        time.sleep(500);
        assertEquals(1, fetcher.sendFetches());
    }
","    public void testFetchSkipsBlackedOutNodes() {
        buildFetcher();

        assignFromUser(singleton(tp0));
        subscriptions.seek(tp0, 0);
        Node node = initialUpdateResponse.brokers().iterator().next();

        client.blackout(node, 500);
        assertEquals(0, fetcher.sendFetches());

        time.sleep(500);
        assertEquals(1, fetcher.sendFetches());
    }
"
600,nit: you can merge both lines above as `checkNotNull` will return the given argument,"    public DefaultByteBufHolder(ByteBuf data) {
        ObjectUtil.checkNotNull(data, ""data"");
        this.data = data;
    }
","    public DefaultByteBufHolder(ByteBuf data) {
        ObjectUtil.checkNotNull(data, ""data"");
START         this.data = data; END 
    }
","    public DefaultByteBufHolder(ByteBuf data) {
        this.data = ObjectUtil.checkNotNull(data, ""data"");
    }
"
601,"I think it would be clearer if the connections.remove was outside of this block as I don't think it will be throwing IOException, unless you think the notifyAll always done even with a problem on the linkedlist.remove() but if that is the case perhaps the conn.close() should be in it's own try block?","    public synchronized void removeConnection(Socket conn)
    {
        try {
            connections.remove(conn);
            conn.close();
        } catch (IOException ioe) {
            tsLogger.i18NLogger.warn_could_not_close_transaction_listener_connection(conn, ioe);
        } finally {
            notifyAll();
        }
    }
","    public synchronized void removeConnection(Socket conn)
    {
        try {
START             connections.remove(conn); END 
            conn.close();
        } catch (IOException ioe) {
            tsLogger.i18NLogger.warn_could_not_close_transaction_listener_connection(conn, ioe);
        } finally {
            notifyAll();
        }
    }
","    public synchronized void removeConnection(Socket conn)
    {
        connections.remove(conn);
        try {
            conn.close();
        } catch (IOException ioe) {
            tsLogger.i18NLogger.warn_could_not_close_transaction_listener_connection(conn, ioe);
        } finally {
            notifyAll();
        }
    }
"
602,You're getting the display name and using it todo a search my userId. Either there is a bug in the UserProxy or this code is wrong.,"	public List<CourseGroup> getLecturing() {
		String userId = proxy.getCurrentUser().getDisplayName();
		List <CourseGroupDAO> groupDaos = dao.findLecturingCourseGroups(userId);
		List<CourseGroup> groups = new ArrayList<CourseGroup>(groupDaos.size());
		for(CourseGroupDAO groupDao : groupDaos) {
			groups.add(new CourseGroupImpl(groupDao, this));
		}
		return groups;
	}
","	public List<CourseGroup> getLecturing() {
START 		String userId = proxy.getCurrentUser().getDisplayName(); END 
		List <CourseGroupDAO> groupDaos = dao.findLecturingCourseGroups(userId);
		List<CourseGroup> groups = new ArrayList<CourseGroup>(groupDaos.size());
		for(CourseGroupDAO groupDao : groupDaos) {
			groups.add(new CourseGroupImpl(groupDao, this));
		}
		return groups;
	}
","	public List<CourseGroup> getLecturing() {
		String userId = proxy.getCurrentUser().getId();
		List <CourseGroupDAO> groupDaos = dao.findLecturingCourseGroups(userId);
		List<CourseGroup> groups = new ArrayList<CourseGroup>(groupDaos.size());
		for(CourseGroupDAO groupDao : groupDaos) {
			groups.add(new CourseGroupImpl(groupDao, this));
		}
		return groups;
	}
"
603,Seems at this point you could just pass in the selectedItem instead of both.,"	protected SLDGenerator(Item item, Item selectedItem, Integer ribbon, SLDConfig config) {
		this.item = item;
		this.ribbon = ribbon;
        if (config instanceof ShorelineConfig) {
            ShorelineConfig slc = (ShorelineConfig)config;
            slc.finalize(item, selectedItem);
            this.config = slc;
        } else {
            this.config = config;
        }
	}
","	protected SLDGenerator(Item item, Item selectedItem, Integer ribbon, SLDConfig config) {
		this.item = item;
		this.ribbon = ribbon;
        if (config instanceof ShorelineConfig) {
            ShorelineConfig slc = (ShorelineConfig)config;
START             slc.finalize(item, selectedItem); END 
            this.config = slc;
        } else {
            this.config = config;
        }
	}
","	protected SLDGenerator(Item item, Item selectedItem, Integer ribbon, SLDConfig config) {
		this.item = item;
		this.ribbon = ribbon;
        if (config instanceof ShorelineConfig) {
            ShorelineConfig slc = (ShorelineConfig)config;
            slc.finalize(selectedItem);
            this.config = slc;
        } else {
            this.config = config;
        }
	}
"
604,consider replacing 96-97 with just one try block (see line 455),"	public static void copy(File source, File dest) throws IOException {
		try (InputStream in = new FileInputStream(source)) {
			try (OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) {
				transferData(in, out);
			}
		}
	}
","	public static void copy(File source, File dest) throws IOException {
START 		try (InputStream in = new FileInputStream(source)) { END 
			try (OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) {
				transferData(in, out);
			}
		}
	}
","	public static void copy(File source, File dest) throws IOException {
		try (InputStream in = new FileInputStream(source);
				OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) {
			transferData(in, out);
		}
	}
"
605,set() already take care of this so you could simply return the result of set().,"    public XWikiAttachment setAttachment(XWikiAttachment attachment)
    {
        attachment.setDoc(this);

        XWikiAttachmentList list = this.attachmentList;
        XWikiAttachment currentAttachment = list.getByFilename(attachment.getFilename());
        list.set(attachment);
        return currentAttachment;
    }
","    public XWikiAttachment setAttachment(XWikiAttachment attachment)
    {
        attachment.setDoc(this);

        XWikiAttachmentList list = this.attachmentList;
START         XWikiAttachment currentAttachment = list.getByFilename(attachment.getFilename()); END 
        list.set(attachment);
        return currentAttachment;
    }
","    public XWikiAttachment setAttachment(XWikiAttachment attachment)
    {
        return this.attachmentList.set(attachment);
    }
"
606,"could you call this(property, flags, data, null) ?","    public PropertyValue(MAPIProperty property, long flags, byte[] data) {
      this.property = property;
      this.flags = flags;
      this.data = data;
      this.actualType = property.usualType;
    }
","    public PropertyValue(MAPIProperty property, long flags, byte[] data) {
START       this.property = property; END 
      this.flags = flags;
      this.data = data;
      this.actualType = property.usualType;
    }
","    public PropertyValue(MAPIProperty property, long flags, byte[] data) {
        this(property, flags, data, property.usualType);
    }
"
607,"Again, parameter names","	public boolean charTyped(char p_charTyped_1_, int p_charTyped_2_) {
		if (super.charTyped(p_charTyped_1_, p_charTyped_2_) || !canEdit) {
			return true;
		} else if (SharedConstants.isAllowedCharacter(p_charTyped_1_)) {
			this.insertTextIntoPage(Character.toString(p_charTyped_1_));
			return true;
		} else {
			return false;
		}
	}
","START 	public boolean charTyped(char p_charTyped_1_, int p_charTyped_2_) { END 
		if (super.charTyped(p_charTyped_1_, p_charTyped_2_) || !canEdit) {
			return true;
		} else if (SharedConstants.isAllowedCharacter(p_charTyped_1_)) {
			this.insertTextIntoPage(Character.toString(p_charTyped_1_));
			return true;
		} else {
			return false;
		}
	}
","	public boolean charTyped(char p_charTyped_1_, int p_charTyped_2_) 
	{
		if (super.charTyped(p_charTyped_1_, p_charTyped_2_) || !canEdit) 
			return true;
		else if (SharedConstants.isAllowedCharacter(p_charTyped_1_)) 
		{
			this.insertTextIntoPage(Character.toString(p_charTyped_1_));
			return true;
		} else
			return false;
		
	}
"
608,Could be great to return an empty map instead of null,"    Map<String, String> getAPITypeParameters() throws BonitaHomeNotSetException, ServerAPIException {
        Map<String, String> parameters;
        try {
            parameters = APITypeManager.getAPITypeParameters();
        } catch (IOException e) {
            throw new ServerAPIException(e);
        }
        return parameters;
    }
","    Map<String, String> getAPITypeParameters() throws BonitaHomeNotSetException, ServerAPIException {
        Map<String, String> parameters;
        try {
            parameters = APITypeManager.getAPITypeParameters();
        } catch (IOException e) {
            throw new ServerAPIException(e);
        }
START         return parameters; END 
    }
","    protected Map<String, String> getAPITypeParameters() throws BonitaHomeNotSetException, ServerAPIException {
        try {
            return APITypeManager.getAPITypeParameters();
        } catch (IOException e) {
            throw new ServerAPIException(e);
        }
    }
"
609,Move the `requireNonNull` checks to a separate line. Calling them inline looks messy.,"    public static Driver createDriver(DriverContext driverContext, List<Operator> operators)
    {
        Driver driver = new Driver(requireNonNull(driverContext, ""driverContext is null""), requireNonNull(operators, ""operators is null""));
        driver.initialize();
        return driver;
    }
","    public static Driver createDriver(DriverContext driverContext, List<Operator> operators)
    {
START         Driver driver = new Driver(requireNonNull(driverContext, ""driverContext is null""), requireNonNull(operators, ""operators is null"")); END 
        driver.initialize();
        return driver;
    }
","    public static Driver createDriver(DriverContext driverContext, List<Operator> operators)
    {
        requireNonNull(driverContext, ""driverContext is null"");
        requireNonNull(operators, ""operators is null"");
        Driver driver = new Driver(driverContext, operators);
        driver.initialize();
        return driver;
    }
"
610,This already happens inorg.eclipse.mylyn.commons.core.ExtensionPointReader.handleResult(IStatus),"	public static AbstractTaskContextStore loadTaskContextStore() {
		ExtensionPointReader<AbstractTaskContextStore> reader = new ExtensionPointReader<AbstractTaskContextStore>(
				ITasksCoreConstants.ID_PLUGIN, ""contextStore"", ""contextStore"", AbstractTaskContextStore.class); //$NON-NLS-1$ //$NON-NLS-2$
		IStatus status = reader.read();
		if (!status.isOK()) {
			StatusHandler.log(status);
		}
		AbstractTaskContextStore contextStore = reader.getItem();
		if (contextStore != null) {
			return contextStore;
		}
		return new DefaultTaskContextStore();
	}
","	public static AbstractTaskContextStore loadTaskContextStore() {
		ExtensionPointReader<AbstractTaskContextStore> reader = new ExtensionPointReader<AbstractTaskContextStore>(
				ITasksCoreConstants.ID_PLUGIN, ""contextStore"", ""contextStore"", AbstractTaskContextStore.class); //$NON-NLS-1$ //$NON-NLS-2$
		IStatus status = reader.read();
		if (!status.isOK()) {
START 			StatusHandler.log(status); END 
		}
		AbstractTaskContextStore contextStore = reader.getItem();
		if (contextStore != null) {
			return contextStore;
		}
		return new DefaultTaskContextStore();
	}
","	public static AbstractTaskContextStore loadTaskContextStore() {
		ExtensionPointReader<AbstractTaskContextStore> reader = new ExtensionPointReader<AbstractTaskContextStore>(
				ITasksCoreConstants.ID_PLUGIN, ""contextStore"", ""contextStore"", AbstractTaskContextStore.class); //$NON-NLS-1$ //$NON-NLS-2$
		reader.read();
		AbstractTaskContextStore contextStore = reader.getItem();
		if (contextStore != null) {
			return contextStore;
		}
		return new DefaultTaskContextStore();
	}
"
611,"That's not how you use a StringBuffer though.

`buffer.append(message).append(""\n"");`

PS: Wrong ping.","    public void sendMessage(String message) {
        buffer.append(message + ""\n"");
    }
","    public void sendMessage(String message) {
START         buffer.append(message + ""\n""); END 
    }
","    public void sendMessage(String message) {
        buffer.append(message).append(""\n"");
    }
"
612,"This is a reason why I got 2 receivers.. 

The variant information is added to PushMessageInformation in the `MetricCollector#updateExistingMetric`: https://github.com/matzew/aerogear-unifiedpush-server/blob/AGPUSH-1374/push/sender/src/main/java/org/jboss/aerogear/unifiedpush/message/MetricsCollector.java#L66

Since it is already added in the `NotificationDispatcher`, it re-adds ""existing"" variant metric.

By removing this line it starts to work correctly","    private void updateStatusOfPushMessageInformation(final PushMessageInformation pushMessageInformation, final String variantID, final int receivers, final Boolean deliveryStatus, final String reason) {
        final VariantMetricInformation variantMetricInformation = new VariantMetricInformation();
        variantMetricInformation.setPushMessageInformation(pushMessageInformation);
        variantMetricInformation.setVariantID(variantID);
        variantMetricInformation.setReceivers(receivers);
        variantMetricInformation.setDeliveryStatus(deliveryStatus);
        variantMetricInformation.setReason(reason);

        pushMessageInformation.getVariantInformations().add(variantMetricInformation);

        dispatchVariantMetricEvent.fire(variantMetricInformation);
    }
","    private void updateStatusOfPushMessageInformation(final PushMessageInformation pushMessageInformation, final String variantID, final int receivers, final Boolean deliveryStatus, final String reason) {
        final VariantMetricInformation variantMetricInformation = new VariantMetricInformation();
        variantMetricInformation.setPushMessageInformation(pushMessageInformation);
        variantMetricInformation.setVariantID(variantID);
        variantMetricInformation.setReceivers(receivers);
        variantMetricInformation.setDeliveryStatus(deliveryStatus);
        variantMetricInformation.setReason(reason);

START         pushMessageInformation.getVariantInformations().add(variantMetricInformation); END 

        dispatchVariantMetricEvent.fire(variantMetricInformation);
    }
","    private void updateStatusOfPushMessageInformation(final PushMessageInformation pushMessageInformation, final String variantID, final int receivers, final Boolean deliveryStatus, final String reason) {
        final VariantMetricInformation variantMetricInformation = new VariantMetricInformation();
        variantMetricInformation.setPushMessageInformation(pushMessageInformation);
        variantMetricInformation.setVariantID(variantID);
        variantMetricInformation.setReceivers(receivers);
        variantMetricInformation.setDeliveryStatus(deliveryStatus);
        variantMetricInformation.setReason(reason);

        dispatchVariantMetricEvent.fire(variantMetricInformation);
    }
"
613,private,"   public void createActions() {
      setGoalOrderAction = new SetGoalOrderAction((GoalArtifact) editor.getAwa(), this);
      RemovedFromGoalHandler handler = new RemovedFromGoalHandler() {

         @Override
         public void removedFromGoal(Collection<? extends Artifact> removed) {
            worldComposite.removeItems(removed);
            worldComposite.getXViewer().remove(removed);
            worldComposite.getXViewer().refresh(goalArtifact);
         }

      };
      removeFromGoalAction = new RemoveFromGoalAction((GoalArtifact) editor.getAwa(), this, handler);
   }
","START    public void createActions() { END 
      setGoalOrderAction = new SetGoalOrderAction((GoalArtifact) editor.getAwa(), this);
      RemovedFromGoalHandler handler = new RemovedFromGoalHandler() {

         @Override
         public void removedFromGoal(Collection<? extends Artifact> removed) {
            worldComposite.removeItems(removed);
            worldComposite.getXViewer().remove(removed);
            worldComposite.getXViewer().refresh(goalArtifact);
         }

      };
      removeFromGoalAction = new RemoveFromGoalAction((GoalArtifact) editor.getAwa(), this, handler);
   }
","   private void createActions() {
      setGoalOrderAction = new SetGoalOrderAction((GoalArtifact) editor.getAwa(), this);
      RemovedFromGoalHandler handler = new RemovedFromGoalHandler() {

         @Override
         public void removedFromGoal(Collection<? extends Artifact> removed) {
            worldComposite.removeItems(removed);
            worldComposite.getXViewer().remove(removed);
            worldComposite.getXViewer().refresh(goalArtifact);
         }

      };
      removeFromGoalAction = new RemoveFromGoalAction((GoalArtifact) editor.getAwa(), this, handler);
   }
"
614,Move this to `OkHttpClientTestRule.ensureAllConnectionsReleased()`,"  @After public void tearDown() throws Exception {
    if (socksProxy != null) {
      socksProxy.shutdown();
    }
    if (cache != null) {
      cache.delete();
    }

    client.connectionPool().evictAll();
    if (client.connectionPool().connectionCount() > 0) {
      // Minimise test flakiness due to possible race conditions with connections closing.
      // Some number of tests will report here, but not fail due to this delay.
      System.out.println(""Delaying to avoid flakes"");
      Thread.sleep(500L);
      System.out.println(""After delay: "" + client.connectionPool().connectionCount());
    }
  }
","  @After public void tearDown() throws Exception {
    if (socksProxy != null) {
      socksProxy.shutdown();
    }
    if (cache != null) {
      cache.delete();
    }

    client.connectionPool().evictAll();
START     if (client.connectionPool().connectionCount() > 0) { END 
      // Minimise test flakiness due to possible race conditions with connections closing.
      // Some number of tests will report here, but not fail due to this delay.
      System.out.println(""Delaying to avoid flakes"");
      Thread.sleep(500L);
      System.out.println(""After delay: "" + client.connectionPool().connectionCount());
    }
  }
","  @After public void tearDown() throws Exception {
    if (socksProxy != null) {
      socksProxy.shutdown();
    }
    if (cache != null) {
      cache.delete();
    }
  }
"
615,Or `Arrays.toString`,"	public void addQueueNames(String... queueNames) {
		try {
			addQueues(Arrays.stream(queueNames));
		}
		catch (AmqpIOException e) {
			throw new AmqpIOException(""Failed to add "" + queueNames, e.getCause());
		}
		super.addQueueNames(queueNames);
	}
","	public void addQueueNames(String... queueNames) {
		try {
			addQueues(Arrays.stream(queueNames));
		}
		catch (AmqpIOException e) {
START 			throw new AmqpIOException(""Failed to add "" + queueNames, e.getCause()); END 
		}
		super.addQueueNames(queueNames);
	}
","	public void addQueueNames(String... queueNames) {
		try {
			addQueues(Arrays.stream(queueNames));
		}
		catch (AmqpIOException e) {
			throw new AmqpIOException(""Failed to add "" + Arrays.asList(queueNames), e.getCause());
		}
		super.addQueueNames(queueNames);
	}
"
616,"This kind of breaks the really clean streak of ""new Client()"" calls with no arguments. Could we make it adhere to this pattern?","    protected void buildScript(int age) {

        // hard-coded list of card types to load when continuing the feed
        if (age == 0) {
            init();
        }

        addPendingClient(new BecauseYouReadClient());
        addPendingClient(new ContinueReadingClient());
        addPendingClient(new AggregatedFeedContentClient());
        addPendingClient(new IntegerListClient());
        addPendingClient(new MostReadClient());
        addPendingClient(new RandomClient(new RandomCard(getContext(), getSite())));

    }
","    protected void buildScript(int age) {

        // hard-coded list of card types to load when continuing the feed
        if (age == 0) {
            init();
        }

        addPendingClient(new BecauseYouReadClient());
        addPendingClient(new ContinueReadingClient());
        addPendingClient(new AggregatedFeedContentClient());
        addPendingClient(new IntegerListClient());
        addPendingClient(new MostReadClient());
START         addPendingClient(new RandomClient(new RandomCard(getContext(), getSite()))); END 

    }
","    protected void buildScript(int age) {

        // hard-coded list of card types to load when continuing the feed
        if (age == 0) {
            init();
        }

        addPendingClient(new BecauseYouReadClient());
        addPendingClient(new ContinueReadingClient());
        addPendingClient(new AggregatedFeedContentClient());
        addPendingClient(new IntegerListClient());
        addPendingClient(new MostReadClient());
        addPendingClient(new RandomClient());

    }
"
617,debugging logging? if not the level should be `log` not `error`,"    private UpdateAccountResponse updateAccount(URL updateAccountUrl, String requestBody) throws Exception {
        RealmLog.debug(""Network request (updateAccount): "" + updateAccountUrl);
        Request request = newAuthRequest(updateAccountUrl)
                .post(RequestBody.create(JSON, requestBody))
                .build();
        RealmLog.error(updateAccountUrl.toString());
        RealmLog.error(requestBody);
        Call call = client.newCall(request);
        Response response = call.execute();
        return UpdateAccountResponse.from(response);
    }
","    private UpdateAccountResponse updateAccount(URL updateAccountUrl, String requestBody) throws Exception {
        RealmLog.debug(""Network request (updateAccount): "" + updateAccountUrl);
        Request request = newAuthRequest(updateAccountUrl)
                .post(RequestBody.create(JSON, requestBody))
                .build();
START         RealmLog.error(updateAccountUrl.toString()); END 
        RealmLog.error(requestBody);
        Call call = client.newCall(request);
        Response response = call.execute();
        return UpdateAccountResponse.from(response);
    }
","    private UpdateAccountResponse updateAccount(URL updateAccountUrl, String requestBody) throws Exception {
        RealmLog.debug(""Network request (updateAccount): "" + updateAccountUrl);
        Request request = newAuthRequest(updateAccountUrl)
                .post(RequestBody.create(JSON, requestBody))
                .build();
        Call call = client.newCall(request);
        Response response = call.execute();
        return UpdateAccountResponse.from(response);
    }
"
618,does not need to be public in non-public class,"    public ListObjectStream(List<T> items) {
        this.items = items;
        this.i = 0;
    }
","START     public ListObjectStream(List<T> items) { END 
        this.items = items;
        this.i = 0;
    }
","    ListObjectStream(List<T> items) {
        this.items = items;
        this.i = 0;
    }
"
619,"Haha, fair enough.","    private void closeGroups(hdf5.Group[] groupArray) {
        for (int i = 0; i < groupArray.length; i++) {
            groupArray[i].deallocate();
        }
    }
","START     private void closeGroups(hdf5.Group[] groupArray) { END 
        for (int i = 0; i < groupArray.length; i++) {
            groupArray[i].deallocate();
        }
    }
","    private void closeGroups(hdf5.Group[] groupArray) {
        for (int i = groupArray.length - 1; i >= 0; i--) {
            groupArray[i].deallocate();
        }
    }
"
620,`marshallCollection` handles `null`,"   public void writeTo(ObjectOutput output) throws IOException {
      output.writeObject(ackTarget);
      if (ackTarget != null) {
         output.writeLong(id);
      }
      output.writeInt(topologyId);
      if (keys != null) {
         MarshallUtil.marshallCollection(keys, output);
      } else {
         assert segments != null;
         MarshallUtil.marshallIntCollection(segments, output);
      }
   }
","   public void writeTo(ObjectOutput output) throws IOException {
      output.writeObject(ackTarget);
      if (ackTarget != null) {
         output.writeLong(id);
      }
      output.writeInt(topologyId);
START       if (keys != null) { END 
         MarshallUtil.marshallCollection(keys, output);
      } else {
         assert segments != null;
         MarshallUtil.marshallIntCollection(segments, output);
      }
   }
","   public void writeTo(ObjectOutput output) throws IOException {
      output.writeObject(ackTarget);
      if (ackTarget != null) {
         output.writeLong(id);
      }
      output.writeInt(topologyId);
      MarshallUtil.marshallCollection(keys, output);
   }
"
621,Would be good to have a `null` case here for `annotationsEnabled`,"    public static ModelPlotConfig createRandomized() {
        return new ModelPlotConfig(randomBoolean(), randomAlphaOfLengthBetween(1, 30), randomBoolean());
    }
","    public static ModelPlotConfig createRandomized() {
START         return new ModelPlotConfig(randomBoolean(), randomAlphaOfLengthBetween(1, 30), randomBoolean()); END 
    }
","    public static ModelPlotConfig createRandomized() {
        return new ModelPlotConfig(randomBoolean(), randomAlphaOfLengthBetween(1, 30), randomBoolean() ? randomBoolean() : null);
    }
"
622,this function can be `private`,"  boolean deregisterHardDeleteMetric(String storeId) {
    String prefix = storeId + SEPERATOR;
    return registry.remove(MetricRegistry.name(PersistentIndex.class, prefix + ""CurrentHardDeleteProgress"")) && registry
        .remove(MetricRegistry.name(Log.class, prefix + ""PercentageHardDeleteCompleted"")) && registry.remove(
        MetricRegistry.name(PersistentIndex.class, prefix + ""HardDeleteThreadRunning"")) && registry.remove(
        MetricRegistry.name(PersistentIndex.class, prefix + ""HardDeleteCaughtUp""));
  }
","START   boolean deregisterHardDeleteMetric(String storeId) { END 
    String prefix = storeId + SEPERATOR;
    return registry.remove(MetricRegistry.name(PersistentIndex.class, prefix + ""CurrentHardDeleteProgress"")) && registry
        .remove(MetricRegistry.name(Log.class, prefix + ""PercentageHardDeleteCompleted"")) && registry.remove(
        MetricRegistry.name(PersistentIndex.class, prefix + ""HardDeleteThreadRunning"")) && registry.remove(
        MetricRegistry.name(PersistentIndex.class, prefix + ""HardDeleteCaughtUp""));
  }
","  private boolean deregisterHardDeleteMetric(String storeId) {
    String prefix = storeId + SEPERATOR;
    return registry.remove(MetricRegistry.name(PersistentIndex.class, prefix + ""CurrentHardDeleteProgress"")) && registry
        .remove(MetricRegistry.name(Log.class, prefix + ""PercentageHardDeleteCompleted"")) && registry.remove(
        MetricRegistry.name(PersistentIndex.class, prefix + ""HardDeleteThreadRunning"")) && registry.remove(
        MetricRegistry.name(PersistentIndex.class, prefix + ""HardDeleteCaughtUp""));
  }
"
623,no need for 'this',"    public void dispose() {
        this.runInControlledConcurrency(() -> {
            log.info(""IrsProxyData::disposing"");
            resetIrs();
            getSchedulUtil().deleteJob(storagePoolRefreshJobId);
            getSchedulUtil().deleteJob(domainRecoverOnHostJobId);
            _disposed = true;
        });
    }
","    public void dispose() {
START         this.runInControlledConcurrency(() -> { END 
            log.info(""IrsProxyData::disposing"");
            resetIrs();
            getSchedulUtil().deleteJob(storagePoolRefreshJobId);
            getSchedulUtil().deleteJob(domainRecoverOnHostJobId);
            _disposed = true;
        });
    }
","    public void dispose() {
        runInControlledConcurrency(() -> {
            log.info(""IrsProxyData::disposing"");
            resetIrs();
            getSchedulUtil().deleteJob(storagePoolRefreshJobId);
            getSchedulUtil().deleteJob(domainRecoverOnHostJobId);
            _disposed = true;
        });
    }
"
624,"This is also a regression, it no longer works for multiple repositories. Note that there is extra code below which handles multiple repositories.","	public boolean isEnabled() {
		return selectionMapsToSingleRepository();
	}
","	public boolean isEnabled() {
START 		return selectionMapsToSingleRepository(); END 
	}
","	public boolean isEnabled() {
		return true;
	}
"
625,When updating code can you replace plain asserts with those from the testing framework ?,"   private void eventuallyAssertEvictions(float expectedValue) {
      eventuallyAssertAttributeValue(""Evictions"", expectedValue);
      assert expectedValue == advanced.getStats().getEvictions();
   }
","   private void eventuallyAssertEvictions(float expectedValue) {
      eventuallyAssertAttributeValue(""Evictions"", expectedValue);
START       assert expectedValue == advanced.getStats().getEvictions(); END 
   }
","   private void eventuallyAssertEvictions(float expectedValue) {
      eventuallyAssertAttributeValue(""Evictions"", expectedValue);
      assertEquals(expectedValue, (float) advanced.getStats().getEvictions());
   }
"
626,These seem to be covered by `NUMBER_TYPES` already?,"    public static boolean isNumber(Class<?> clazz) {
        if ( clazz == null ) {
            return false;
        }
        else if ( clazz.isPrimitive() ) {
            return NUMBER_TYPES.contains( clazz );
        }
        else {
            return Number.class.isAssignableFrom( clazz );
        }
    }
","    public static boolean isNumber(Class<?> clazz) {
        if ( clazz == null ) {
            return false;
        }
        else if ( clazz.isPrimitive() ) {
            return NUMBER_TYPES.contains( clazz );
        }
        else {
START             return Number.class.isAssignableFrom( clazz ); END 
        }
    }
","    public static boolean isNumber(Class<?> clazz) {
        if ( clazz == null ) {
            return false;
        }
        else {
            return NUMBER_TYPES.contains( clazz );
        }
    }
"
627,Should be of type List<Object>.,"	public List<Connection> getTransitivelyConnectedElements(EObject element, EObject traceModel, int maximumDepth) {
		ArrayList<Object> accumulator = new ArrayList<>();
		return getTransitivelyConnectedElements(element, traceModel, accumulator, DEFAULT_INITIAL_TRANSITIVITY_DEPTH, maximumDepth);
	}
","	public List<Connection> getTransitivelyConnectedElements(EObject element, EObject traceModel, int maximumDepth) {
START 		ArrayList<Object> accumulator = new ArrayList<>(); END 
		return getTransitivelyConnectedElements(element, traceModel, accumulator, DEFAULT_INITIAL_TRANSITIVITY_DEPTH, maximumDepth);
	}
","	public List<Connection> getTransitivelyConnectedElements(EObject element, EObject traceModel, int maximumDepth) {
		List<Object> accumulator = new ArrayList<>();
		return getTransitivelyConnectedElements(element, traceModel, accumulator, DEFAULT_INITIAL_TRANSITIVITY_DEPTH, maximumDepth);
	}
"
628,a `do-while` will avoid checking 2 conditions (the while true and the CAS),"   public final CompletableFuture<Void> enterSynchronizationAsync(CompletableFuture<Void> releaseFuture) {
      while (true) {
         CompletableFuture<Void> currentFuture = synchronization.get();
         if (synchronization.compareAndSet(currentFuture, releaseFuture))
            return currentFuture;
      }
   }
","   public final CompletableFuture<Void> enterSynchronizationAsync(CompletableFuture<Void> releaseFuture) {
START       while (true) { END 
         CompletableFuture<Void> currentFuture = synchronization.get();
         if (synchronization.compareAndSet(currentFuture, releaseFuture))
            return currentFuture;
      }
   }
","   public final CompletableFuture<Void> enterSynchronizationAsync(CompletableFuture<Void> releaseFuture) {
      CompletableFuture<Void> currentFuture;
      do {
         currentFuture = synchronization.get();
      } while (!synchronization.compareAndSet(currentFuture, releaseFuture));
      return currentFuture;
   }
"
629,"Make `ReferenceCountingSegment` implement `ReferenceCounter`. Then this function can just be `return this;`

Which also means less inner classes and less lines of code to read in a delta 🙃","  public ReferenceCounter referenceCounter()
  {
    return new ReferenceCounter()
    {
      @Override
      public boolean increment()
      {
        return ReferenceCountingSegment.this.increment();
      }

      @Override
      public Closeable decrementOnceCloseable()
      {
        return ReferenceCountingSegment.this.decrementOnceCloseable();
      }

      @Override
      public void decrement()
      {
        ReferenceCountingSegment.this.decrement();
      }
    };
  }
","  public ReferenceCounter referenceCounter()
  {
START     return new ReferenceCounter()
    {
      @Override
      public boolean increment()
      {
        return ReferenceCountingSegment.this.increment();
      }

      @Override
      public Closeable decrementOnceCloseable()
      {
        return ReferenceCountingSegment.this.decrementOnceCloseable();
      }

      @Override
      public void decrement()
      {
        ReferenceCountingSegment.this.decrement();
      }
    }; END 
  }
","  public ReferenceCounter referenceCounter()
  {
    return this;
  }
"
630,"toArray copies the elements of the list into an array I think. Might depend on the implementation, but there are better ways to loop this. It also seems to lose type information.","    public void connectionDown() {
        for (Object listenerObject : coordinateListenerList.toArray()) {
            CoordinateListener coordinateListener = (CoordinateListener) listenerObject;
            coordinateListener.onCoordinateEvent(
                    CoordinateListener.Event.NO_CONNECTION_TO_STORAGE, ""down"");
        }
        isSynchronizedWithZooKeeper.set(false);
    }
","    public void connectionDown() {
START         for (Object listenerObject : coordinateListenerList.toArray()) { END 
            CoordinateListener coordinateListener = (CoordinateListener) listenerObject;
            coordinateListener.onCoordinateEvent(
                    CoordinateListener.Event.NO_CONNECTION_TO_STORAGE, ""down"");
        }
        isSynchronizedWithZooKeeper.set(false);
    }
","    public void connectionDown() {
        for (CoordinateListener coordinateListener : coordinateListenerList) {
            coordinateListener.onCoordinateEvent(
                    CoordinateListener.Event.NO_CONNECTION_TO_STORAGE, ""down"");
        }
        isSynchronizedWithZooKeeper.set(false);
    }
"
631,What is the initial size of this `HashMap`?,"  public void addLocation(long blockId, BlockLocation location) {
    mBlockLocations.computeIfAbsent(blockId, x -> new HashMap<>());
    mBlockLocations.get(blockId).put(location.getWorkerId(), location);
  }
","  public void addLocation(long blockId, BlockLocation location) {
START     mBlockLocations.computeIfAbsent(blockId, x -> new HashMap<>()); END 
    mBlockLocations.get(blockId).put(location.getWorkerId(), location);
  }
","  public void addLocation(long blockId, BlockLocation location) {
    mBlockLocations.computeIfAbsent(blockId, x -> new HashMap<>(4));
    mBlockLocations.get(blockId).put(location.getWorkerId(), location);
  }
"
632,You can re-use your `getHeader(...)` method - which I very much like - here?,"    public String getName() {
        return getHeader(Constants.BUNDLE_NAME) != null
                ? bundle.getHeaders().get(Constants.BUNDLE_NAME)
                : getSymbolicName();
    }
","    public String getName() {
        return getHeader(Constants.BUNDLE_NAME) != null
START                 ? bundle.getHeaders().get(Constants.BUNDLE_NAME) END 
                : getSymbolicName();
    }
","    public String getName() {
        return getHeader(Constants.BUNDLE_NAME) != null
                ? getHeader(Constants.BUNDLE_NAME)
                : getSymbolicName();
    }
"
633,"please use diamond operator, i.e. ""<>"", instead of type parameters. reduces clutter and makes code easier to maintain.","  public MojoParameterMetadataProvider(MavenProject project, Plugin plugin) {
    this.project = project;
    this.plugin = plugin;
    maven = (MavenImpl) MavenPlugin.getMaven();
    parameters = new HashMap<String, List<MojoParameter>>();
  }
","  public MojoParameterMetadataProvider(MavenProject project, Plugin plugin) {
    this.project = project;
    this.plugin = plugin;
    maven = (MavenImpl) MavenPlugin.getMaven();
START     parameters = new HashMap<String, List<MojoParameter>>(); END 
  }
","  public MojoParameterMetadataProvider(MavenProject project, Plugin plugin) {
    this.project = project;
    this.plugin = plugin;
    maven = (MavenImpl) MavenPlugin.getMaven();
    parameters = new HashMap<>();
  }
"
634,"Let's make this DRY.  

```
String url = mStep.getEmded().getOembed().getURL();
mMainWebView.loadUrl(url); 
mMainWebView.setTag(url);
```","      protected void onPostExecute(OEmbed embed) {
         if (embed != null) {
            // TODO: decide if this is ok. Most likely because the setStep
            // function isnt intensive
            if(!isCancelled()) {
               mMainWebView.loadUrl(mStep.getEmded().getOembed().getURL());
               mMainWebView.setTag(mStep.getEmded().getOembed().getURL());
            }
         }
      }
","      protected void onPostExecute(OEmbed embed) {
         if (embed != null) {
            // TODO: decide if this is ok. Most likely because the setStep
            // function isnt intensive
            if(!isCancelled()) {
               mMainWebView.loadUrl(mStep.getEmded().getOembed().getURL());
START                mMainWebView.setTag(mStep.getEmded().getOembed().getURL()); END 
            }
         }
      }
","      protected void onPostExecute(OEmbed embed) {
         if (embed != null) {
            // TODO: decide if this is ok. Most likely because the setStep
            // function isnt intensive
            if(!isCancelled()) {
               String url = mStep.getEmded().getOembed().getURL();
               mMainWebView.loadUrl(url);
               mMainWebView.setTag(url);
            }
         }
      }
"
635,"outputPositionCount variable is not used; remove it

`return positionCount;`","        public int read(int offset, int[] positions, int positionCount)
        {
            outputPositions = initializeOutputPositions(outputPositions, positions, positionCount);
            outputPositionCount = positionCount;
            return outputPositionCount;
        }
","        public int read(int offset, int[] positions, int positionCount)
        {
            outputPositions = initializeOutputPositions(outputPositions, positions, positionCount);
START             outputPositionCount = positionCount; END 
            return outputPositionCount;
        }
","        public int read(int offset, int[] positions, int positionCount)
        {
            outputPositions = initializeOutputPositions(outputPositions, positions, positionCount);
            return positionCount;
        }
"
636,This method should probably be `synchronized`.,"    public void start(BootstrapContext ctx)
            throws ResourceAdapterInternalException {
        if (engine == null) {
            engine = new ModeShapeEngine();
            engine.start();
        }
    }
","START     public void start(BootstrapContext ctx) END 
            throws ResourceAdapterInternalException {
        if (engine == null) {
            engine = new ModeShapeEngine();
            engine.start();
        }
    }
","    public synchronized void start(BootstrapContext ctx)
            throws ResourceAdapterInternalException {
        if (engine == null) {
            engine = new ModeShapeEngine();
            engine.start();
        }
    }
"
637,wouldn't it be preferred to store the value of each type in lower case instead of creating it each time this method invoked ?,"    public String getValue() {
        return name().toLowerCase();
    }
","    public String getValue() {
START         return name().toLowerCase(); END 
    }
","    public String getValue() {
        return value;
    }
"
638,should be made such that start and stop cannot be called at the same time,"  public boolean start()
  {
    if (!started.get()) {
      LOGGER.info(""started polling lookup [%s]"", id);
      started.set(pollingLookup.isOpen());
    }
    return started.get();
  }
","START   public boolean start() END 
  {
    if (!started.get()) {
      LOGGER.info(""started polling lookup [%s]"", id);
      started.set(pollingLookup.isOpen());
    }
    return started.get();
  }
","  public boolean start()
  {
    synchronized (started) {
      if (!started.get()) {
        LOGGER.info(""started polling lookup [%s]"", id);
        started.set(pollingLookup.isOpen());
      }
      return started.get();
    }
  }
"
639,This should be probably moved after following applyRemoveAllowReload.,"    public void tearDown(final ManagementClient managementClient, final String containerId) {
        // TODO: add {""allow-resource-service-restart"" => true} to ejbRemoteAddress write-attribute operation once WFLY-8793 / JBEAP-10955 is fixed
        //       and remove this reload
        try {
            ServerReload.reloadIfRequired(managementClient.getControllerClient());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        // TODO: remove this reload once WFLY-8821 / JBEAP-11074 is fixed
        try {
            ServerReload.executeReloadAndWaitForCompletion(managementClient.getControllerClient());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        applyRemoveAllowReload(managementClient.getControllerClient(), domainAddress, false);
        applyRemoveAllowReload(managementClient.getControllerClient(), realmAddress, false);
    }
","    public void tearDown(final ManagementClient managementClient, final String containerId) {
        // TODO: add {""allow-resource-service-restart"" => true} to ejbRemoteAddress write-attribute operation once WFLY-8793 / JBEAP-10955 is fixed
        //       and remove this reload
        try {
            ServerReload.reloadIfRequired(managementClient.getControllerClient());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        // TODO: remove this reload once WFLY-8821 / JBEAP-11074 is fixed
        try {
START             ServerReload.executeReloadAndWaitForCompletion(managementClient.getControllerClient()); END 
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        applyRemoveAllowReload(managementClient.getControllerClient(), domainAddress, false);
        applyRemoveAllowReload(managementClient.getControllerClient(), realmAddress, false);
    }
","    public void tearDown(final ManagementClient managementClient, final String containerId) {
        applyRemoveAllowReload(managementClient.getControllerClient(), domainAddress, false);
        applyRemoveAllowReload(managementClient.getControllerClient(), realmAddress, false);
    }
"
640,I think its OK to assume section != null here.,"		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result
					+ ((section == null) ? 0 : section.hashCode());
			result = prime * result
					+ ((subsection == null) ? 0 : subsection.hashCode());
			return result;
		}
","		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result
START 					+ ((section == null) ? 0 : section.hashCode()); END 
			result = prime * result
					+ ((subsection == null) ? 0 : subsection.hashCode());
			return result;
		}
","		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + section.hashCode();
			result = prime * result
					+ ((subsection == null) ? 0 : subsection.hashCode());
			return result;
		}
"
641,I think List is fine.,"  private List<ProjectInfo> list(final ListRequest request) throws RestApiException {
    ListProjects lp = listProvider.get();
    lp.setShowDescription(request.getDescription());
    lp.setLimit(request.getLimit());
    lp.setStart(request.getStart());
    lp.setMatchPrefix(request.getPrefix());

    Map<String, ProjectInfo> result = lp.apply();

    return ImmutableList.copyOf(result.values());
  }
","  private START  List<ProjectInfo> list(final END  ListRequest request) throws RestApiException {
    ListProjects lp = listProvider.get();
    lp.setShowDescription(request.getDescription());
    lp.setLimit(request.getLimit());
    lp.setStart(request.getStart());
    lp.setMatchPrefix(request.getPrefix());

    Map<String, ProjectInfo> result = lp.apply();

    return ImmutableList.copyOf(result.values());
  }
","  private List<ProjectInfo> list(final ListRequest request) throws RestApiException {
    ListProjects lp = listProvider.get();
    lp.setShowDescription(request.getDescription());
    lp.setLimit(request.getLimit());
    lp.setStart(request.getStart());
    lp.setMatchPrefix(request.getPrefix());

    return ImmutableList.copyOf(lp.apply().values());
  }
"
642,"replace with this 1 line:
assertEquals(oreArtifactTokens.OseeTypesFolder, item.getItemId());","   public void testGetItemId() {
      Long expected = CoreArtifactTokens.OseeTypesFolder.getId();
      Long actual = item.getItemId().getId();
      assertEquals(expected, actual);
   }
","   public void testGetItemId() {
START       Long expected = CoreArtifactTokens.OseeTypesFolder.getId(); END 
      Long actual = item.getItemId().getId();
      assertEquals(expected, actual);
   }
","   public void testGetItemId() {
      assertEquals(CoreArtifactTokens.OseeTypesFolder, item.getItemId());
   }
"
643,I would put this in on Pause,"    public void onDestroyView() {
        super.onDestroyView();
        ((PageActivity)getActivity()).getDrawerToggle().setDrawerIndicatorEnabled(true);
        app.getBus().unregister(this);
    }
","    public void onDestroyView() {
        super.onDestroyView();
START         ((PageActivity)getActivity()).getDrawerToggle().setDrawerIndicatorEnabled(true); END 
        app.getBus().unregister(this);
    }
","    public void onDestroyView() {
        super.onDestroyView();
        app.getBus().unregister(this);
    }
"
644,"Better to have a constuctor that takes a `HttpGroupScan` and the list of columns. That way, the `columns` member can be `final` and the class can be immutable.","  public GroupScan clone(List<SchemaPath> columns) {
    logger.debug(""HttpGroupScan clone {}"", columns);
    HttpGroupScan newScan = new HttpGroupScan(this);
    newScan.columns = columns;
    return newScan;
  }
","START   public GroupScan clone(List<SchemaPath> columns) { END 
    logger.debug(""HttpGroupScan clone {}"", columns);
    HttpGroupScan newScan = new HttpGroupScan(this);
    newScan.columns = columns;
    return newScan;
  }
","  public GroupScan clone(List<SchemaPath> columns) {
    return new HttpGroupScan(this, columns);
  }
"
645,`finally` here?,"    private void executeUpdate(String sql) {
        try {
            Statement statement = this.connection.createStatement();
            statement.executeUpdate(sql);

            statement.close();
        }
        catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
","    private void executeUpdate(String sql) {
        try {
            Statement statement = this.connection.createStatement();
            statement.executeUpdate(sql);

START             statement.close(); END 
        }
        catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
","    private void executeUpdate(String sql) {
        try (Statement statement = this.connection.createStatement()) {
            statement.executeUpdate(sql);
        }
        catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
"
646,"There is no need to resolve these paths on every iteration - you only need it resolved once. Moreover, you can resolve it once one level above, passing resolved parse transforms to this method.","    private void buildDependenciesMap(@NotNull Module module, @NotNull Collection<VirtualFile> erlangModules,
                                      @NotNull List<String> globalParseTransforms) {
      for (VirtualFile erlangModule : erlangModules) {
        Set<String> dependencies = ContainerUtil.newHashSet();
        ErlangFile erlangFile = getErlangFile(erlangModule);
        addDeclaredDependencies(module, erlangFile, dependencies);
        dependencies.addAll(resolvePathsFromNames(globalParseTransforms, module));
        myPathsToDependenciesMap.put(erlangModule.getPath(), ContainerUtil.newArrayList(dependencies));
      }
    }
","    private void buildDependenciesMap(@NotNull Module module, @NotNull Collection<VirtualFile> erlangModules,
                                      @NotNull List<String> globalParseTransforms) {
      for (VirtualFile erlangModule : erlangModules) {
        Set<String> dependencies = ContainerUtil.newHashSet();
        ErlangFile erlangFile = getErlangFile(erlangModule);
        addDeclaredDependencies(module, erlangFile, dependencies);
START         dependencies.addAll(resolvePathsFromNames(globalParseTransforms, module)); END 
        myPathsToDependenciesMap.put(erlangModule.getPath(), ContainerUtil.newArrayList(dependencies));
      }
    }
","    private void buildDependenciesMap(@NotNull Module module, @NotNull Collection<VirtualFile> erlangModules,
                                      @NotNull List<String> globalParseTransforms) {
      for (VirtualFile erlangModule : erlangModules) {
        Set<String> dependencies = ContainerUtil.newHashSet();
        ErlangFile erlangFile = getErlangFile(erlangModule);
        addDeclaredDependencies(module, erlangFile, dependencies);
        dependencies.addAll(globalParseTransforms);
        myPathsToDependenciesMap.put(erlangModule.getPath(), ContainerUtil.newArrayList(dependencies));
      }
    }
"
647,This line can be moved up to the @Before method too.,"  public void createFeaturesTest() throws IOException {

    String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""};

    AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster);

    List<String> features = new ArrayList<>();
    generator.createFeatures(features, tokens, 3, null);

    Assert.assertEquals(2, features.size());
    Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010""));
    Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101""));
    
  }
","  public void createFeaturesTest() throws IOException {

    String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""};

START     AdaptiveFeatureGenerator generator = new BrownBigramFeatureGenerator(brownCluster); END 

    List<String> features = new ArrayList<>();
    generator.createFeatures(features, tokens, 3, null);

    Assert.assertEquals(2, features.size());
    Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010""));
    Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101""));
    
  }
","  public void createFeaturesTest() throws IOException {

    String[] tokens = new String[] {""he"", ""went"", ""with"", ""you""};

    List<String> features = new ArrayList<>();
    generator.createFeatures(features, tokens, 3, null);

    Assert.assertEquals(2, features.size());
    Assert.assertTrue(features.contains(""pbrowncluster,browncluster=0101,0010""));
    Assert.assertTrue(features.contains(""pbrowncluster,browncluster=01010,00101""));
    
  }
"
648,assertThat(related).isEmpty();,"  public void getRelatedNoResult() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PatchSet.Id ps = push.to(git, ""refs/for/master"").getPatchSetId();
    List<ChangeAndCommit> related = getRelated(ps);
    assertThat(related.size()).isEqualTo(0);
  }
","  public void getRelatedNoResult() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PatchSet.Id ps = push.to(git, ""refs/for/master"").getPatchSetId();
    List<ChangeAndCommit> related = getRelated(ps);
START     assertThat(related.size()).isEqualTo(0); END 
  }
","  public void getRelatedNoResult() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PatchSet.Id ps = push.to(git, ""refs/for/master"").getPatchSetId();
    List<ChangeAndCommit> related = getRelated(ps);
    assertThat(related).isEmpty();
  }
"
649,"This should be moved to:
ProcessDownVmCommand","    protected void destroyVm() {
        boolean vmMigrating = getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null;
        setActionReturnValue(vmMigrating ? destroyMigratingVm() : destroyNonMigratingVm());
        managedBlockStorageCommandUtil.disconnectManagedBlockStorageDisks(getVm(), vmHandler, getVdsId());
    }
","    protected void destroyVm() {
        boolean vmMigrating = getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null;
        setActionReturnValue(vmMigrating ? destroyMigratingVm() : destroyNonMigratingVm());
        START  managedBlockStorageCommandUtil.disconnectManagedBlockStorageDisks(getVm(), vmHandler, getVdsId()); END 
    }
","    protected void destroyVm() {
        boolean vmMigrating = getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null;
        setActionReturnValue(vmMigrating ? destroyMigratingVm() : destroyNonMigratingVm());
    }
"
650,"You may be able to simplify this test case through JUnit4 annotations, with the `@Expected`","    public void testParseDateFailed() {
        try {
            CommonUtils.parseFromUtcTime(""this is obviously not a date"");
            fail(""Parsing date should never be successfull here"");
        } catch (ParseException e) {
        }
    }
","START     public void testParseDateFailed() { END 
        try {
            CommonUtils.parseFromUtcTime(""this is obviously not a date"");
            fail(""Parsing date should never be successfull here"");
        } catch (ParseException e) {
        }
    }
","    public void testParseDateFailed() throws ParseException {
        CommonUtils.parseFromUtcTime(""this is obviously not a date"");
    }
"
651,@vlsi performance issues with using foreach ??,"    public static String toString(int oid) {
        try {
            Field[] fields = Oid.class.getFields();
            for (int i = 0; i < fields.length; i++) {
                Field field = fields[i];
                if (field.getInt(null) == oid) {
                    return field.getName();
                }
            }
        } catch (IllegalAccessException e) {
            // never happens
        }
        return ""<unknown:"" + oid + "">"";
    }
","    public static String toString(int oid) {
        try {
            Field[] fields = Oid.class.getFields();
START             for (int i = 0; i < fields.length; i++) { END 
                Field field = fields[i];
                if (field.getInt(null) == oid) {
                    return field.getName();
                }
            }
        } catch (IllegalAccessException e) {
            // never happens
        }
        return ""<unknown:"" + oid + "">"";
    }
","    public static String toString(int oid) {
        try {
            Field[] fields = Oid.class.getFields();
            for (Field field : fields) {
                if (field.getInt(null) == oid) {
                    return field.getName();
                }
            }
        } catch (IllegalAccessException e) {
            // never happens
        }
        return ""<unknown:"" + oid + "">"";
    }
"
652,Are you sure you did the above line correctly? :),"	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) throws APIException {
		
		if (attributes == null || !attributes.isEmpty()) {
			throw new APIException(""Patient.no.attribute"", (Object[]) null);
		}
		
		return dao.getDuplicatePatientsByAttributes(attributes);
	}
","	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) throws APIException {
		
START 		if (attributes == null || !attributes.isEmpty()) { END 
			throw new APIException(""Patient.no.attribute"", (Object[]) null);
		}
		
		return dao.getDuplicatePatientsByAttributes(attributes);
	}
","	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) throws APIException {
		
		if (attributes == null || attributes.isEmpty()) {
			throw new APIException(""Patient.no.attribute"", (Object[]) null);
		}
		
		return dao.getDuplicatePatientsByAttributes(attributes);
	}
"
653,"likewise, this one can be static","    private int countOccurrencesInTopology(final String topologyString,
                                           final String searchPattern) {
        final Matcher matcher = Pattern.compile(searchPattern).matcher(topologyString);
        final List<String> repartitionTopicsFound = new ArrayList<>();

        while (matcher.find()) {
            repartitionTopicsFound.add(matcher.group());
        }

        return repartitionTopicsFound.size();
    }
","START     private int countOccurrencesInTopology(final String topologyString, END 
                                           final String searchPattern) {
        final Matcher matcher = Pattern.compile(searchPattern).matcher(topologyString);
        final List<String> repartitionTopicsFound = new ArrayList<>();

        while (matcher.find()) {
            repartitionTopicsFound.add(matcher.group());
        }

        return repartitionTopicsFound.size();
    }
","    private static int countOccurrencesInTopology(final String topologyString,
                                                  final String searchPattern) {
        final Matcher matcher = Pattern.compile(searchPattern).matcher(topologyString);
        final List<String> repartitionTopicsFound = new ArrayList<>();

        while (matcher.find()) {
            repartitionTopicsFound.add(matcher.group());
        }

        return repartitionTopicsFound.size();
    }
"
654,@tumijacob I don't think that these verifies are ever called since the method call above should throw.,"  public void testPasswordResetWithNoExistingUser_shouldThrow() {   
    String username= ""anyUser"";
    //mocks
    when(userRepository.findUser(anyString())).thenReturn(null);
    //Test
    passwordResetService.resetUserPassword(username);
    Assert.assertNotNull(userRepository.findUser(username));
    
    verify(userRepository).findUser(username);
    verify(passwordResetService).resetUserPassword(username);
  }
","  public void testPasswordResetWithNoExistingUser_shouldThrow() {   
    String username= ""anyUser"";
    //mocks
    when(userRepository.findUser(anyString())).thenReturn(null);
    //Test
    passwordResetService.resetUserPassword(username);
    Assert.assertNotNull(userRepository.findUser(username));
    
START     verify(userRepository).findUser(username); END 
    verify(passwordResetService).resetUserPassword(username);
  }
","  public void testPasswordResetWithNoExistingUser_shouldThrow() {
    String username = ""anyUser"";

    // mocks
    when(userRepository.findUser(anyString())).thenReturn(null);

    // Test
    passwordResetService.resetUserPassword(username);
  }
"
655,"Don't use printStackTrace() and instead write to the logger using log.error(""<Appropriate message>"",e);","    public void run() {
        log.info(Thread.currentThread().getName() + "" is starting DFS"");
        try {
            frontier.searchForScenarios(queue, flag);
        } catch (IOException e) {
            e.printStackTrace();
        }
        log.info(Thread.currentThread().getName() + "" is done with DFS"");
    }
","    public void run() {
        log.info(Thread.currentThread().getName() + "" is starting DFS"");
        try {
            frontier.searchForScenarios(queue, flag);
        } catch (IOException e) {
START             e.printStackTrace(); END 
        }
        log.info(Thread.currentThread().getName() + "" is done with DFS"");
    }
","    public void run() {
        log.info(Thread.currentThread().getName() + "" is starting DFS"");
        try {
            frontier.searchForScenarios(queue, flag);
        } catch (IOException e) {
            log.error("""", e);
        }
        log.info(Thread.currentThread().getName() + "" is done with DFS"");
    }
"
656,Can we return a copy of the graph instead of a reference? There's also no point in using a read lock when returning the reference. I'm mostly worried that callers may alter the graph in some way.,"    public BusinessServiceGraph getGraph() {
        m_rwLock.readLock().lock();
        try {
            return m_g;
        } finally {
            m_rwLock.readLock().unlock();
        }
    }
","    public BusinessServiceGraph getGraph() {
        m_rwLock.readLock().lock();
        try {
START             return m_g; END 
        } finally {
            m_rwLock.readLock().unlock();
        }
    }
","    public BusinessServiceGraph getGraph() {
        return m_g;
    }
"
657,"This is a relatively slow test (~15 seconds per parameterized run), so all the permutations may be overkill. Perhaps remove (SEGMENT, false), which will still give coverage of both lock granularities and both with/without the input format API.","  public static Iterable<Object[]> constructorFeeder()
  {
    return ImmutableList.of(
        new Object[]{LockGranularity.TIME_CHUNK, false},
        new Object[]{LockGranularity.TIME_CHUNK, true},
        new Object[]{LockGranularity.SEGMENT, false},
        new Object[]{LockGranularity.SEGMENT, true}
    );
  }
","  public static Iterable<Object[]> constructorFeeder()
  {
    return ImmutableList.of(
START         new Object[]{LockGranularity.TIME_CHUNK, false},
        new Object[]{LockGranularity.TIME_CHUNK, true},
        new Object[]{LockGranularity.SEGMENT, false},
        new Object[]{LockGranularity.SEGMENT, true} END 
    );
  }
","  public static Iterable<Object[]> constructorFeeder()
  {
    return ImmutableList.of(
        new Object[]{LockGranularity.TIME_CHUNK, false},
        new Object[]{LockGranularity.TIME_CHUNK, true},
        new Object[]{LockGranularity.SEGMENT, true}
    );
  }
"
658,Add `Preconditions.checkArgument` checks to verify that the passed `engine` and `buffer` are not `null`.,"    public static ByteBuffer handleBufferUnderflow(final SSLEngine engine, ByteBuffer buffer) {
        if (buffer.position() < buffer.limit()) {
            return buffer;
        }
        ByteBuffer replaceBuffer = enlargeBuffer(buffer, engine.getSession().getPacketBufferSize());
        buffer.flip();
        replaceBuffer.put(buffer);
        return replaceBuffer;
    }
","START     public static ByteBuffer handleBufferUnderflow(final SSLEngine engine, ByteBuffer buffer) { END 
        if (buffer.position() < buffer.limit()) {
            return buffer;
        }
        ByteBuffer replaceBuffer = enlargeBuffer(buffer, engine.getSession().getPacketBufferSize());
        buffer.flip();
        replaceBuffer.put(buffer);
        return replaceBuffer;
    }
","    public static ByteBuffer handleBufferUnderflow(final SSLEngine engine, ByteBuffer buffer) {
        if (engine == null || buffer == null) {
            return buffer;
        }
        if (buffer.position() < buffer.limit()) {
            return buffer;
        }
        ByteBuffer replaceBuffer = enlargeBuffer(buffer, engine.getSession().getPacketBufferSize());
        buffer.flip();
        replaceBuffer.put(buffer);
        return replaceBuffer;
    }
"
659,Let's static import the assertions inside `org.junit.Assert` so we don't need to prefix them with `Assert.`,"    public void givenIdenticalSimpleObjects_whenCompared_thenEqual() {
        JsonParser parser = new JsonParser();
        String string1 = ""{\""customer\"": {\""id\"": \""44521\"",\""fullName\"": \""Emily Jenkins\"", \""age\"": 27 }}"";
        String string2 = ""{\""customer\"": {\""id\"": \""44521\"", \""fullName\"": \""Emily Jenkins\"",\""age\"": 27}}"";

        Assert.assertTrue(parser.parse(string1)
            .isJsonObject());
        Assert.assertEquals(parser.parse(string1), parser.parse(string2));
    }
","    public void givenIdenticalSimpleObjects_whenCompared_thenEqual() {
        JsonParser parser = new JsonParser();
        String string1 = ""{\""customer\"": {\""id\"": \""44521\"",\""fullName\"": \""Emily Jenkins\"", \""age\"": 27 }}"";
        String string2 = ""{\""customer\"": {\""id\"": \""44521\"", \""fullName\"": \""Emily Jenkins\"",\""age\"": 27}}"";

        Assert.assertTrue(parser.parse(string1)
            .isJsonObject());
START         Assert.assertEquals(parser.parse(string1), parser.parse(string2)); END 
    }
","    public void givenIdenticalSimpleObjects_whenCompared_thenEqual() {
        JsonParser parser = new JsonParser();
        String string1 = ""{\""customer\"": {\""id\"": \""44521\"",\""fullName\"": \""Emily Jenkins\"", \""age\"": 27 }}"";
        String string2 = ""{\""customer\"": {\""id\"": \""44521\"", \""fullName\"": \""Emily Jenkins\"",\""age\"": 27}}"";

        assertTrue(parser.parse(string1)
            .isJsonObject());
        assertEquals(parser.parse(string1), parser.parse(string2));
    }
"
660,"```suggestion
        this(Score.valueOf(exactTitleMatchScore), Score.ONE);
```","    public TitleMatchingContainerScorer(double exactTitleMatchScore) {
        this.scorer = new ContentTitleScorer<>(
                NAME,
                Functions.<String>identity(),
                Score.valueOf(exactTitleMatchScore),
                Score.ONE
        );
    }
","    public TitleMatchingContainerScorer(double exactTitleMatchScore) {
START         this.scorer = new ContentTitleScorer<>( END 
                NAME,
                Functions.<String>identity(),
                Score.valueOf(exactTitleMatchScore),
                Score.ONE
        );
    }
","    public TitleMatchingContainerScorer(double exactTitleMatchScore) {
        this(Score.valueOf(exactTitleMatchScore), Score.ONE);
    }
"
661,Message seems to be unused. Remove this line?,"   public boolean shouldRetryRequest(HttpCommand command, HttpResponse response) {
      boolean retry = false;
      try {
         byte[] data = closeClientButKeepContentStream(response);
         String message = data != null ? new String(data) : null;
         switch (response.getStatusCode()) {
         case 500:
         case 503:
            retry = super.shouldRetryRequest(command, response);
            break;
         default:
            break;
         }
      } finally {
         releasePayload(response);
      }
      return retry;
   }
","   public boolean shouldRetryRequest(HttpCommand command, HttpResponse response) {
      boolean retry = false;
      try {
         byte[] data = closeClientButKeepContentStream(response);
START          String message = data != null ? new String(data) : null; END 
         switch (response.getStatusCode()) {
         case 500:
         case 503:
            retry = super.shouldRetryRequest(command, response);
            break;
         default:
            break;
         }
      } finally {
         releasePayload(response);
      }
      return retry;
   }
","   public boolean shouldRetryRequest(HttpCommand command, HttpResponse response) {
      boolean retry = false;
      try {
         byte[] data = closeClientButKeepContentStream(response);
         switch (response.getStatusCode()) {
         case 500:
         case 503:
            retry = super.shouldRetryRequest(command, response);
            break;
         default:
            break;
         }
      } finally {
         releasePayload(response);
      }
      return retry;
   }
"
662,"Don't we need to deal with an `else` variant as well?

On the other hand why `ChannelProxy` can't implement `AutorecoveringChannel` and delegate respectively?
Although I believe there is going to be some overhead since we may disable auto-recovery, but we still fill up this cache almost for nothing...","	public static void addRecoveryListenerIfNecessary(Channel channel) {
		if (channel instanceof ChannelProxy) {
			if (((ChannelProxy) channel).getTargetChannel() instanceof AutorecoveringChannel) {
				AutorecoveringChannel autorecoveringChannel = (AutorecoveringChannel) ((ChannelProxy) channel)
						.getTargetChannel();
				if (hasListener.putIfAbsent(autorecoveringChannel, Boolean.TRUE) == null) {
					autorecoveringChannel.addRecoveryListener(INSTANCE);
				}
			}
		}
	}
","	public static void addRecoveryListenerIfNecessary(Channel channel) {
		if (channel instanceof ChannelProxy) {
			if (((ChannelProxy) channel).getTargetChannel() instanceof AutorecoveringChannel) {
START 				AutorecoveringChannel autorecoveringChannel = (AutorecoveringChannel) ((ChannelProxy) channel) END 
						.getTargetChannel();
				if (hasListener.putIfAbsent(autorecoveringChannel, Boolean.TRUE) == null) {
					autorecoveringChannel.addRecoveryListener(INSTANCE);
				}
			}
		}
	}
","	public static void addRecoveryListenerIfNecessary(Channel channel) {
		AutorecoveringChannel autorecoveringChannel = null;
		if (channel instanceof ChannelProxy) {
			if (((ChannelProxy) channel).getTargetChannel() instanceof AutorecoveringChannel) {
				autorecoveringChannel = (AutorecoveringChannel) ((ChannelProxy) channel)
						.getTargetChannel();
			}
		}
		else if (channel instanceof AutorecoveringChannel) {
			autorecoveringChannel = (AutorecoveringChannel) channel;
		}
		if (autorecoveringChannel != null
				&& hasListener.putIfAbsent(autorecoveringChannel, Boolean.TRUE) == null) {
			autorecoveringChannel.addRecoveryListener(INSTANCE);
		}
	}
"
663,Was thinking about this.... could this call happen when other types are registered by Oven in DocumentTypes or was there a specific reason this occurs here?,"    public DelegatingTemplateEngine(final CompositeConfiguration config, final ContentStore db, final File destination, final File templatesPath) {
        super(config, db, destination, templatesPath);
        this.renderers = new TemplateEngines(config, db, destination, templatesPath);
        this.registerExtractorsForCustomTypes();
    }
","    public DelegatingTemplateEngine(final CompositeConfiguration config, final ContentStore db, final File destination, final File templatesPath) {
        super(config, db, destination, templatesPath);
        this.renderers = new TemplateEngines(config, db, destination, templatesPath);
START         this.registerExtractorsForCustomTypes(); END 
    }
","    public DelegatingTemplateEngine(final CompositeConfiguration config, final ContentStore db, final File destination, final File templatesPath) {
        super(config, db, destination, templatesPath);
        this.renderers = new TemplateEngines(config, db, destination, templatesPath);
    }
"
664,Nit: can be private,"    NavigableSet<Clustering> makeClusterings(boolean reversed)
    {
        int pos = 0;
        NavigableSet<Clustering> clusterings = new TreeSet<>(reversed ? metadata.comparator.reversed() : metadata.comparator);
        while (pos <= KEY_RANGE)
        {
            int skip = rand.nextInt(KEY_RANGE / 10) * (rand.nextInt(3) + 2 / 3); // increased chance of getting 0
            pos += skip;
            clusterings.add(clustering(pos));
        }
        return clusterings;
    }
","START     NavigableSet<Clustering> makeClusterings(boolean reversed) END 
    {
        int pos = 0;
        NavigableSet<Clustering> clusterings = new TreeSet<>(reversed ? metadata.comparator.reversed() : metadata.comparator);
        while (pos <= KEY_RANGE)
        {
            int skip = rand.nextInt(KEY_RANGE / 10) * (rand.nextInt(3) + 2 / 3); // increased chance of getting 0
            pos += skip;
            clusterings.add(clustering(pos));
        }
        return clusterings;
    }
","    private NavigableSet<Clustering> makeClusterings(boolean reversed)
    {
        int pos = 0;
        NavigableSet<Clustering> clusterings = new TreeSet<>(reversed ? metadata.comparator.reversed() : metadata.comparator);
        while (pos <= KEY_RANGE)
        {
            int skip = rand.nextInt(KEY_RANGE / 10) * (rand.nextInt(3) + 2 / 3); // increased chance of getting 0
            pos += skip;
            clusterings.add(clustering(pos));
        }
        return clusterings;
    }
"
665,"Each of the getters in a POJO like this should have the same return type as the private member variables they expose. In this case, I'd recommend having `extension`, `dateformat`, and `frequencyOverride` be `Optional<>`s (in both their member variable types and their getter types).

Our Jackson YAML deserialization should automatically take care of setting a missing field to an empty `Optional<>` in the resulting Java object.","    public Optional<String> getExtension() {
        return Optional.fromNullable(extension);
    }
","START     public Optional<String> getExtension() { END 
        return Optional.fromNullable(extension);
    }
","    public Optional<String> getExtension() {
        return extension;
    }
"
666,"Newline between @Test and public. There's only 4 instances like this in the libcore source, hundreds with it on its own line.","    @Test public void constructor_nullDelegate() {
        try {
            new ForwardingOs(null) {
            };
            fail();
        } catch (NullPointerException expected) {
        }
    }
","    @Test START  public void END  constructor_nullDelegate() {
        try {
            new ForwardingOs(null) {
            };
            fail();
        } catch (NullPointerException expected) {
        }
    }
","    public void constructor_nullDelegate() {
        try {
            new ForwardingOs(null) {};
            fail();
        } catch (NullPointerException expected) {
        }
    }
"
667,Remove this change please,"    public boolean visitEnter(FunctionParseNode node) throws SQLException {
        // TODO: Oracle supports nested aggregate function while other DBs don't. Should we?
        if (node.isAggregate()) {
            if (aggregateFunction != null) {
                throw new SQLFeatureNotSupportedException(""Nested aggregate functions are not supported"");
            }
            this.aggregateFunction = node;
            this.isAggregate = true;

        } else if(node.getClass().isAssignableFrom(ArrayIndexFunction.class)) {
        	this.isAggregate = true;
        }
        return true;
    }
","    public boolean visitEnter(FunctionParseNode node) throws SQLException {
        // TODO: Oracle supports nested aggregate function while other DBs don't. Should we?
        if (node.isAggregate()) {
            if (aggregateFunction != null) {
                throw new SQLFeatureNotSupportedException(""Nested aggregate functions are not supported"");
            }
            this.aggregateFunction = node;
            this.isAggregate = true;

START         } else if(node.getClass().isAssignableFrom(ArrayIndexFunction.class)) { END 
        	this.isAggregate = true;
        }
        return true;
    }
","    public boolean visitEnter(FunctionParseNode node) throws SQLException {
        // TODO: Oracle supports nested aggregate function while other DBs don't. Should we?
        if (node.isAggregate()) {
            if (aggregateFunction != null) {
                throw new SQLFeatureNotSupportedException(""Nested aggregate functions are not supported"");
            }
            this.aggregateFunction = node;
            this.isAggregate = true;

        }
        return true;
    }
"
668,"Probably `Objects.hash(baseDataSource, dimensions, metrics);`?","  public int hashCode()
  {
    return Objects.hash(baseDataSource + dimensions + metrics);
  }
","  public int hashCode()
  {
START     return Objects.hash(baseDataSource + dimensions + metrics); END 
  }
","  public int hashCode()
  {
    return Objects.hash(baseDataSource, dimensions, metrics);
  }
"
669,"`return asyncHttpClientMap.putIfAbsent(name, ahc) == null;","    public boolean registerIfNew(String name, AsyncHttpClient ahc) {
        AsyncHttpClient value = asyncHttpClientMap.putIfAbsent(name, ahc);
        if (value == null)
            return true;
        else
            return false;
    }
","    public boolean registerIfNew(String name, AsyncHttpClient ahc) {
        AsyncHttpClient value = asyncHttpClientMap.putIfAbsent(name, ahc);
        if (value == null)
            return true;
        else
            return false;
START     } END 
","    public boolean registerIfNew(String name, AsyncHttpClient ahc) {
        return asyncHttpClientMap.putIfAbsent(name, ahc)==null;
    }
"
670,You can replace the qualified name with import,"    public Node getContextNode()
    {
        return getLibraryNode() != null || getParent() == null ? this : org.raml.yagi.framework.util.NodeUtils.getContextNode(getParent());
    }
","    public Node getContextNode()
    {
START         return getLibraryNode() != null || getParent() == null ? this : org.raml.yagi.framework.util.NodeUtils.getContextNode(getParent()); END 
    }
","    public Node getContextNode()
    {
        return getLibraryNode() != null || getParent() == null ? this : NodeUtils.getContextNode(getParent());
    }
"
671,Do not move it to ImportHelper,"	private void getLazyRoutingConfig() {
		ImportHelper.loadRoutingFiles(app, new ImportHelper.LoadRoutingFilesCallback() {
			@Override
			public void onRoutingFilesLoaded() {
				notifyEvent(InitEvents.ROUTING_CONFIG_INITIALIZED);
			}
		});
	}
","	private void getLazyRoutingConfig() {
START 		ImportHelper.loadRoutingFiles(app, new ImportHelper.LoadRoutingFilesCallback() { END 
			@Override
			public void onRoutingFilesLoaded() {
				notifyEvent(InitEvents.ROUTING_CONFIG_INITIALIZED);
			}
		});
	}
","	private void getLazyRoutingConfig() {
		loadRoutingFiles(app, new LoadRoutingFilesCallback() {
			@Override
			public void onRoutingFilesLoaded() {
				notifyEvent(InitEvents.ROUTING_CONFIG_INITIALIZED);
			}
		});
	}
"
672,Doesn't need to be final.,"		public <T> T toObject(ParameterizedTypeReference<T> type) {

			Assert.notNull(type, ""Target type must not be null!"");
			final String url = traverseToFinalUrl(true);
			return operations.exchange(url, GET, prepareRequest(headers), type).getBody();
		}
","		public <T> T toObject(ParameterizedTypeReference<T> type) {

			Assert.notNull(type, ""Target type must not be null!"");
START 			final String url = traverseToFinalUrl(true); END 
			return operations.exchange(url, GET, prepareRequest(headers), type).getBody();
		}
","		public <T> T toObject(ParameterizedTypeReference<T> type) {

			Assert.notNull(type, ""Target type must not be null!"");
			return operations.exchange(traverseToFinalUrl(true), GET, prepareRequest(headers), type).getBody();
		}
"
673,please inline this variable,"    public ValidationResult validateMacAddress(List<? extends VmNic> vmNics) {
        for (VmNic iface : vmNics) {
            String str = iface.getMacAddress();
            if (str != null) {
                if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID,
                            String.format(""$IfaceName %1$s"", iface.getName()),
                            String.format(""$MacAddress %1$s"", iface.getMacAddress()));
                }
            }
        }

        return ValidationResult.VALID;
    }
","    public ValidationResult validateMacAddress(List<? extends VmNic> vmNics) {
        for (VmNic iface : vmNics) {
            String START  str = END  iface.getMacAddress();
            if (str != null) {
                if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID,
                            String.format(""$IfaceName %1$s"", iface.getName()),
                            String.format(""$MacAddress %1$s"", iface.getMacAddress()));
                }
            }
        }

        return ValidationResult.VALID;
    }
","    public ValidationResult validateMacAddress(List<? extends VmNic> vmNics) {
        for (VmNic iface : vmNics) {
            if (iface.getMacAddress() != null) {
                if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                    return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID,
                            String.format(""$IfaceName %1$s"", iface.getName()),
                            String.format(""$MacAddress %1$s"", iface.getMacAddress()));
                }
            }
        }

        return ValidationResult.VALID;
    }
"
674,`true` instead (it's a read-only operation).,"    public List<AuditLogWithHistory> getAuditLogsWithHistoryForId(final UUID accountId, final AuditLevel auditLevel, final InternalTenantContext context) throws AccountApiException {
        return transactionalSqlDao.execute(false, AccountApiException.class, new EntitySqlDaoTransactionWrapper<List<AuditLogWithHistory>>() {
            @Override
            public List<AuditLogWithHistory> inTransaction(final EntitySqlDaoWrapperFactory entitySqlDaoWrapperFactory) throws EntityPersistenceException, EventBusException {
                final AccountSqlDao transactional = entitySqlDaoWrapperFactory.become(AccountSqlDao.class);
                return auditDao.getAuditLogsWithHistoryForId(transactional, TableName.ACCOUNT, accountId, auditLevel, context);
            }
        });
    }
","    public List<AuditLogWithHistory> getAuditLogsWithHistoryForId(final UUID accountId, final AuditLevel auditLevel, final InternalTenantContext context) throws AccountApiException {
START         return transactionalSqlDao.execute(false, AccountApiException.class, new EntitySqlDaoTransactionWrapper<List<AuditLogWithHistory>>() { END 
            @Override
            public List<AuditLogWithHistory> inTransaction(final EntitySqlDaoWrapperFactory entitySqlDaoWrapperFactory) throws EntityPersistenceException, EventBusException {
                final AccountSqlDao transactional = entitySqlDaoWrapperFactory.become(AccountSqlDao.class);
                return auditDao.getAuditLogsWithHistoryForId(transactional, TableName.ACCOUNT, accountId, auditLevel, context);
            }
        });
    }
","    public List<AuditLogWithHistory> getAuditLogsWithHistoryForId(final UUID accountId, final AuditLevel auditLevel, final InternalTenantContext context) throws AccountApiException {
        return transactionalSqlDao.execute(true, AccountApiException.class, new EntitySqlDaoTransactionWrapper<List<AuditLogWithHistory>>() {
            @Override
            public List<AuditLogWithHistory> inTransaction(final EntitySqlDaoWrapperFactory entitySqlDaoWrapperFactory) {
                final AccountSqlDao transactional = entitySqlDaoWrapperFactory.become(AccountSqlDao.class);
                return auditDao.getAuditLogsWithHistoryForId(transactional, TableName.ACCOUNT, accountId, auditLevel, context);
            }
        });
    }
"
675,should this be return?,"        public void run() {
            while (true) {
                updateTraceEntry(fTimeAnalysisEntry, Long.MAX_VALUE,
                        fRange.getStartTime().toNanos(),
                        fRange.getEndTime().toNanos());
                synchronized (fProcessTraceThreads) {
                    if (fRestart) {
                        fRestart = false;
                    } else {
                        fProcessTraceThreads.remove(fTimeAnalysisEntry.getTrace());
                        break;
                    }
                }
            }
        }
","        public void run() {
            while (true) {
                updateTraceEntry(fTimeAnalysisEntry, Long.MAX_VALUE,
                        fRange.getStartTime().toNanos(),
                        fRange.getEndTime().toNanos());
                synchronized (fProcessTraceThreads) {
                    if (fRestart) {
                        fRestart = false;
                    } else {
                        fProcessTraceThreads.remove(fTimeAnalysisEntry.getTrace());
START                         break; END 
                    }
                }
            }
        }
","        public void run() {
            while (true) {
                updateTraceEntry(fTimeAnalysisEntry, Long.MAX_VALUE,
                        fRange.getStartTime().toNanos(),
                        fRange.getEndTime().toNanos());
                synchronized (fProcessTraceThreads) {
                    if (fRestart) {
                        fRestart = false;
                    } else {
                        fProcessTraceThreads.remove(fTimeAnalysisEntry.getTrace());
                        return;
                    }
                }
            }
        }
"
676,Wouldn't `Arrays.asList()` be enough here? `Arrays.stream` seems to have a lot of memory overhead.,"   public final Object visitInvalidateCommand(InvocationContext ctx, InvalidateCommand command) throws Throwable {
      try {
         if (hasSkipLocking(command)) {
            return invokeNextInterceptor(ctx, command);
         }
         lockAllAndRecord(ctx, Arrays.stream(command.getKeys()), getLockTimeoutMillis(command));
         return invokeNextInterceptor(ctx, command);
      } finally {
         if (!ctx.isInTxScope()) {
            lockManager.unlockAll(ctx);
         }
      }
   }
","   public final Object visitInvalidateCommand(InvocationContext ctx, InvalidateCommand command) throws Throwable {
      try {
         if (hasSkipLocking(command)) {
            return invokeNextInterceptor(ctx, command);
         }
START          lockAllAndRecord(ctx, Arrays.stream(command.getKeys()), getLockTimeoutMillis(command)); END 
         return invokeNextInterceptor(ctx, command);
      } finally {
         if (!ctx.isInTxScope()) {
            lockManager.unlockAll(ctx);
         }
      }
   }
","   public final Object visitInvalidateCommand(InvocationContext ctx, InvalidateCommand command) throws Throwable {
      try {
         if (hasSkipLocking(command)) {
            return invokeNextInterceptor(ctx, command);
         }
         lockAllAndRecord(ctx, Arrays.asList(command.getKeys()), getLockTimeoutMillis(command));
         return invokeNextInterceptor(ctx, command);
      } finally {
         if (!ctx.isInTxScope()) {
            lockManager.unlockAll(ctx);
         }
      }
   }
"
677,This seems esoteric.  What's wrong with -0.0 here?,"    public GeographyPointValue(double longitude, double latitude) {
        // Add 0.0 to avoid -0.0.
        m_latitude = latitude + 0.0;
        m_longitude = longitude + 0.0;

        if (m_latitude < -90.0 || m_latitude > 90.0) {
            throw new IllegalArgumentException(""Latitude out of range in GeographyPointValue constructor"");
        }

        if (m_longitude < -180.0 || m_longitude > 180.0) {
            throw new IllegalArgumentException(""Longitude out of range in GeographyPointValue constructor"");
        }
    }
","    public GeographyPointValue(double longitude, double latitude) {
        // Add 0.0 to avoid -0.0.
START         m_latitude = latitude + 0.0; END 
        m_longitude = longitude + 0.0;

        if (m_latitude < -90.0 || m_latitude > 90.0) {
            throw new IllegalArgumentException(""Latitude out of range in GeographyPointValue constructor"");
        }

        if (m_longitude < -180.0 || m_longitude > 180.0) {
            throw new IllegalArgumentException(""Longitude out of range in GeographyPointValue constructor"");
        }
    }
","    public GeographyPointValue(double longitude, double latitude) {
        m_latitude = latitude;
        m_longitude = longitude;

        if (m_latitude < -90.0 || m_latitude > 90.0) {
            throw new IllegalArgumentException(""Latitude out of range in GeographyPointValue constructor"");
        }

        if (m_longitude < -180.0 || m_longitude > 180.0) {
            throw new IllegalArgumentException(""Longitude out of range in GeographyPointValue constructor"");
        }
    }
"
678,should we not just always use Locale.English? Based on the formats we give it I'm not sure what effect other locales would actually ever have.,"	public final static AttachmentSizeFormatter getInstance() {
		try {
			return new AttachmentSizeFormatter();
		} catch (ClassCastException e) {
			return new AttachmentSizeFormatter(Locale.ENGLISH);
		}
	}
","	public final static AttachmentSizeFormatter getInstance() {
		try {
START 			return new AttachmentSizeFormatter(); END 
		} catch (ClassCastException e) {
			return new AttachmentSizeFormatter(Locale.ENGLISH);
		}
	}
","	public final static AttachmentSizeFormatter getInstance() {
		return new AttachmentSizeFormatter();
	}
"
679,You can just do an if statement here. :),"    private static void initOculus() {
        switch (LWJGLUtil.getPlatform()) {
            case LWJGLUtil.PLATFORM_WINDOWS:
                OculusVrHelper.loadNatives();
                break;
        }
    }
","    private static void initOculus() {
        switch (LWJGLUtil.getPlatform()) {
START             case LWJGLUtil.PLATFORM_WINDOWS: END 
                OculusVrHelper.loadNatives();
                break;
        }
    }
","    private static void initOculus() {
        if (LWJGLUtil.getPlatform() == LWJGLUtil.PLATFORM_WINDOWS) {
            OculusVrHelper.loadNatives();
        }
    }
"
680,Unused,"  private void copyTimestampsFromChangelog(Library library) {
    Date earliest = getEarliestChangeDate(library);
    Date latest = getLatestChangeDate(library);
    library.setCreationDate(earliest);
  }
","  private void copyTimestampsFromChangelog(Library library) {
    Date earliest = getEarliestChangeDate(library);
START     Date latest = getLatestChangeDate(library); END 
    library.setCreationDate(earliest);
  }
","  private void copyTimestampsFromChangelog(Library library) {
    Date earliest = getEarliestChangeDate(library);
    library.setCreationDate(earliest);
  }
"
681,"since this happens in every test as the first thing, this probably should be in setUp().

at least the SharedPreferences call should be moved there.

and i rather have the code duplication of having the two espresso clicks in each test, than this. before looking up what the method really does i suspected anything, but two clicks on ""next"" in it when reading the tests above.","		protected ProjectUploadController createProjectUploadController() {
			if (projectUploadController == null) {
				projectUploadController = mock(ProjectUploadController.class);
			}
			return projectUploadController;
		}
","		protected ProjectUploadController createProjectUploadController() {
			if (projectUploadController == null) {
START 				projectUploadController = mock(ProjectUploadController.class); END 
			}
			return projectUploadController;
		}
","		protected ProjectUploadController createProjectUploadController() {
			projectUploadController = mock(ProjectUploadController.class);
			return projectUploadController;
		}
"
682,"I think we can keep this ""final"".","	public long getFilterBlobLimit() {
		return filterSpec.getBlobLimit();
	}
","START 	public long getFilterBlobLimit() { END 
		return filterSpec.getBlobLimit();
	}
","	public final long getFilterBlobLimit() {
		return filterSpec.getBlobLimit();
	}
"
683,"You could set connectionFactory to default, and then create the connection in the return statement.","    public static IRemoteConnection createConnection(URI hostUri, String hostName) throws RemoteConnectionException {

        IRemoteConnection connection = null;
        IRemoteConnectionType connectionType = getConnectionType(hostUri);

        IConnectionFactory connectionFactory = CONNECTION_FACTORIES.get(connectionType.getId());
        // Create a new connection
        if (connectionFactory != null) {
            connection = connectionFactory.createConnection(hostUri, hostName);
        } else {
            connection = DEFAULT_CONNECTION_FACTORY.createConnection(hostUri, hostName);
        }

        return connection;
    }
","    public static IRemoteConnection createConnection(URI hostUri, String hostName) throws RemoteConnectionException {

        IRemoteConnection connection = null;
        IRemoteConnectionType connectionType = getConnectionType(hostUri);

        IConnectionFactory connectionFactory = CONNECTION_FACTORIES.get(connectionType.getId());
        // Create a new connection
        if (connectionFactory != null) {
            connection = connectionFactory.createConnection(hostUri, hostName);
        } else {
START             connection = DEFAULT_CONNECTION_FACTORY.createConnection(hostUri, hostName); END 
        }

        return connection;
    }
","    public static IRemoteConnection createConnection(URI hostUri, String hostName) throws RemoteConnectionException {

        IRemoteConnectionType connectionType = getConnectionType(hostUri);
        IConnectionFactory connectionFactory = CONNECTION_FACTORIES.get(connectionType.getId());
        if (connectionFactory == null) {
            connectionFactory = DEFAULT_CONNECTION_FACTORY;
        }
        // Create and return a new connection
        return connectionFactory.createConnection(hostUri, hostName);
    }
"
684,I'd do this in the previous patch already.,"    protected boolean canDoAction() {
        StorageServerConnectionExtension conn = getParameters().getStorageServerConnectionExtension();
        return validate(getConnectionExtensionValidator().isConnectionExtensionExists(conn.getId())) &&
                validate(getConnectionExtensionValidator().isConnectionDoesNotExistForHostAndTarget(conn.getHostId(),
                        conn.getIqn()));
    }
","    protected boolean canDoAction() {
        StorageServerConnectionExtension conn = getParameters().getStorageServerConnectionExtension();
        return validate(getConnectionExtensionValidator().isConnectionExtensionExists(conn.getId())) &&
START                 validate(getConnectionExtensionValidator().isConnectionDoesNotExistForHostAndTarget(conn.getHostId(), END 
                        conn.getIqn()));
    }
","    protected boolean canDoAction() {
        StorageServerConnectionExtension conn = getParameters().getStorageServerConnectionExtension();
        return validate(getConnectionExtensionValidator().isConnectionExtensionExists(conn.getId())) &&
                validate(getConnectionExtensionValidator().isConnectionDoesNotExistForHostAndTarget(conn));
    }
"
685,"I think this logic should reside elsewhere, a service or controller class. A DTO usually only has properties with getters and setters. Make sure as well to have a unit test for this logic.","	public void setObservationLevel(final String observationLevel) {
		final Integer datasetTypeId = DatasetTypeEnum.getIdByName(observationLevel);
		if(datasetTypeId > 0) {
			this.observationLevel = Integer.toString(datasetTypeId);
		}
		else {
			this.observationLevel = observationLevel;
		}
	}
","	public void setObservationLevel(final String observationLevel) {
		final Integer datasetTypeId = DatasetTypeEnum.getIdByName(observationLevel);
START 		if(datasetTypeId > 0) { END 
			this.observationLevel = Integer.toString(datasetTypeId);
		}
		else {
			this.observationLevel = observationLevel;
		}
	}
","	public void setObservationLevel(final String observationLevel) {
		this.observationLevel = observationLevel;
	}
"
686,won't exit the loop. You need to return here,"        protected IStatus run(IProgressMonitor monitor) {
            while (!monitor.isCanceled()) {
                try {
                    Thread.sleep(INDEXING_THREAD_SLEEP_VALUE);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            monitor.done();
            return Status.OK_STATUS;
        }
","        protected IStatus run(IProgressMonitor monitor) {
            while (!monitor.isCanceled()) {
                try {
                    Thread.sleep(INDEXING_THREAD_SLEEP_VALUE);
                } catch (InterruptedException e) {
START                     Thread.currentThread().interrupt(); END 
                }
            }
            monitor.done();
            return Status.OK_STATUS;
        }
","        protected IStatus run(IProgressMonitor monitor) {
            while (!monitor.isCanceled()) {
                try {
                    Thread.sleep(INDEXING_THREAD_SLEEP_VALUE);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return Status.OK_STATUS;
                }
            }
            monitor.done();
            return Status.OK_STATUS;
        }
"
687,Why can't we use id.equalIgnoreCase check instead of the other way around? This option is more flexible than hard code English locale,"    public void handleClose(CloseEvent event, List<DashboardPanel> panels) {
        String id = event.getComponent().getId();

        for (DashboardPanel panel : panels) {
            if (panel.getType().replace("" "", ""_"").toLowerCase(Locale.ENGLISH).equals(id)) {
                panel.close();
                break;
            }
        }
    }
","    public void handleClose(CloseEvent event, List<DashboardPanel> panels) {
        String id = event.getComponent().getId();

        for (DashboardPanel panel : panels) {
START             if (panel.getType().replace("" "", ""_"").toLowerCase(Locale.ENGLISH).equals(id)) { END 
                panel.close();
                break;
            }
        }
    }
","    public void handleClose(CloseEvent event, List<DashboardPanel> panels) {
        String id = event.getComponent().getId();

        for (DashboardPanel panel : panels) {
            if (id.equalsIgnoreCase(panel.getType().replace("" "", ""_""))) {
                panel.close();
                break;
            }
        }
    }
"
688,"so you do not need default constructor now, night?","    public LoggerServiceImpl() {
        actions.put(
            ""log-record"",
            new Runnable() {
                @Override
                public void run() {
                    logrecord();
                }
            }
        );
    }
","    public LoggerServiceImpl() {
        actions.put(
            ""log-record"",
            new Runnable() {
                @Override
                public void run() {
                    logrecord();
                }
            }
        );
START     } END 
","    public LoggerServiceImpl() {
    }
"
689,if rowsize is always positive the check for -1 is not necessary,"  public void setMaxRowSize(int rowSize) {
    if (maxRowSize == -1) {
      maxRowSize = rowSize;
    } else {
      if (maxRowSize < rowSize) {
        maxRowSize = rowSize;
      }
    }
  }
","  public void setMaxRowSize(int rowSize) {
START     if (maxRowSize == -1) { END 
      maxRowSize = rowSize;
    } else {
      if (maxRowSize < rowSize) {
        maxRowSize = rowSize;
      }
    }
  }
","  public void setMaxRowSize(int rowSize) {
    if (rowSize > maxRowSize) {
      maxRowSize = rowSize;
    }
  }
"
690,is this change no longer necessary?,"  public InodeLockList() {
    mInodes = new ArrayList<>();
    mLockModes = new ArrayList<>();
  }
","START   public InodeLockList() { END 
    mInodes = new ArrayList<>();
    mLockModes = new ArrayList<>();
  }
","  InodeLockList() {
    mInodes = new ArrayList<>();
    mLockModes = new ArrayList<>();
  }
"
691,"if most of you test cases runs for both version, why not go our usual route of parametrized args.","  public void testBuildBlobId() throws Exception {
    for (Short version : versions) {
      buildBlobIdAndAssert(version, referenceFlag, referenceDatacenterId, referenceAccountId, referenceContainerId,
          referencePartitionId);
    }
  }
","  public void testBuildBlobId() throws Exception {
START     for (Short version : versions) { END 
      buildBlobIdAndAssert(version, referenceFlag, referenceDatacenterId, referenceAccountId, referenceContainerId,
          referencePartitionId);
    }
  }
","  public void testBuildBlobId() throws Exception {
    buildBlobIdAndAssert(version, referenceFlag, referenceDatacenterId, referenceAccountId, referenceContainerId,
        referencePartitionId);
  }
"
692,curlies not needed,"	private String resolveRelativeModulePath(String url) {
		File f = new File(url);
		if (!f.isAbsolute())
			if (repo.isBare()) {
				url = new File(repo.getDirectory(), url).getAbsolutePath();
			} else {
				url = new File(repo.getWorkTree(), url).getAbsolutePath();
			}
		return url;
	}
","	private String resolveRelativeModulePath(String url) {
		File f = new File(url);
		if (!f.isAbsolute())
START 			if (repo.isBare()) { END 
				url = new File(repo.getDirectory(), url).getAbsolutePath();
			} else {
				url = new File(repo.getWorkTree(), url).getAbsolutePath();
			}
		return url;
	}
","	private String resolveRelativeModulePath(String url) {
		File f = new File(url);
		if (!f.isAbsolute())
			if (repo.isBare())
				url = new File(repo.getDirectory(), url).getAbsolutePath();
			else
				url = new File(repo.getWorkTree(), url).getAbsolutePath();
		return url;
	}
"
693,These are vary dangerous methods because they are public. This can lead to procedural programming where it is difficult to determine if the object is in a valid state. Can these be made private?,"    public void incSize(int by) {
        size += by;
    }
","START     public void incSize(int by) { END 
        size += by;
    }
","    private void incSize(int by) {
        size += by;
    }
"
694,AFAICT `handleRollbackFailure` and `handleCommitFailure` don't need to return a `CompletionStage`,"   public CompletionStage<Void> rollback(LocalTransaction localTransaction) {
      try {
         return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),
               (ignore, t) -> {
                  if (t != null) {
                     return handleRollbackFailure(t, localTransaction);
                  }
                  return CompletableFutures.completedNull();
               });

      } catch (Throwable e) {
         return handleRollbackFailure(e, localTransaction);
      }
   }
","   public CompletionStage<Void> rollback(LocalTransaction localTransaction) {
      try {
         return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),
               (ignore, t) -> {
                  if (t != null) {
                     return handleRollbackFailure(t, localTransaction);
START                   } END 
                  return CompletableFutures.completedNull();
               });

      } catch (Throwable e) {
         return handleRollbackFailure(e, localTransaction);
      }
   }
","   public CompletionStage<Void> rollback(LocalTransaction localTransaction) {
      return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),
            (ignore, t) -> {
               if (t != null) {
                  return handleRollbackFailure(t, localTransaction);
               }
               return CompletableFutures.completedNull();
            });
   }
"
695,"This seems ""lossy"" in that the attributes and text of the link are lost if there is no link target.  I'd prefer to see this emit as much as possible, and simply omit the href value if needed, e.g.

 if (hrefOrHashName == null) {
    hrefOrHashName = """";
 }

same with the other builders","	public void link(Attributes attributes, String hrefOrHashName, String text) {
		if (hrefOrHashName != null) {
			assertOpenBlock();
			try {
				currentBlock.write('""');
				writeAttributes(attributes);
				currentBlock.write(text);
				currentBlock.write('""');
				currentBlock.write(':');
				currentBlock.write(hrefOrHashName);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
","	public void link(Attributes attributes, String hrefOrHashName, String text) {
START 		if (hrefOrHashName != null) { END 
			assertOpenBlock();
			try {
				currentBlock.write('""');
				writeAttributes(attributes);
				currentBlock.write(text);
				currentBlock.write('""');
				currentBlock.write(':');
				currentBlock.write(hrefOrHashName);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
	}
","	public void link(Attributes attributes, String hrefOrHashName, String text) {
		assertOpenBlock();
		try {
			currentBlock.write('""');
			writeAttributes(attributes);
			currentBlock.write(text);
			currentBlock.write('""');
			currentBlock.write(':');
			if (hrefOrHashName != null) {
				currentBlock.write(hrefOrHashName);
			}
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
"
696,Redundant variable - inline.,"	protected IProblemLocation createProblemLocation(ProblemMarkerInfo info) {
		IProblemLocationFactory factory = CodanRuntime.getInstance().getProblemLocationFactory();
		IFile file = (IFile) info.file;
		return factory.createProblemLocation(file, info.startChar, info.endChar, info.lineNumber);
	}
","	protected IProblemLocation createProblemLocation(ProblemMarkerInfo info) {
		IProblemLocationFactory factory = CodanRuntime.getInstance().getProblemLocationFactory();
START 		IFile file = (IFile) info.file; END 
		return factory.createProblemLocation(file, info.startChar, info.endChar, info.lineNumber);
	}
","	protected IProblemLocation createProblemLocation(ProblemMarkerInfo info) {
		IProblemLocationFactory factory = CodanRuntime.getInstance().getProblemLocationFactory();
		return factory.createProblemLocation(
				(IFile) info.file, info.startChar, info.endChar, info.lineNumber);
	}
"
697,"Why have this check here? I don't see a code path that can result in `sender` being null, which the check implies could happen. If this check is necessary it needs locking to avoid a race condition.","    protected void unregisterSender() {
        if (sender != null)
            sender.unregister(context, parent.getPriorityClass());
    }
","    protected void unregisterSender() {
START         if (sender != null) END 
            sender.unregister(context, parent.getPriorityClass());
    }
","    protected void unregisterSender() {
        sender.unregister(context, parent.getPriorityClass());
    }
"
698,"Do we need to call this if the above `trySetBytes` call worked?  If not, move this inside of the `if`.","    public void addInput(Page page)
    {
        requireNonNull(page, ""page is null"");
        checkState(!isFinished(), ""Operator is already finished"");

        index.addPage(page);

        if (!localUserMemoryContext.trySetBytes((index.getEstimatedSize().toBytes()))) {
            index.compact();
        }

        localUserMemoryContext.setBytes(index.getEstimatedSize().toBytes());
        operatorContext.recordGeneratedOutput(page.getSizeInBytes(), page.getPositionCount());
    }
","    public void addInput(Page page)
    {
        requireNonNull(page, ""page is null"");
        checkState(!isFinished(), ""Operator is already finished"");

        index.addPage(page);

        if (!localUserMemoryContext.trySetBytes((index.getEstimatedSize().toBytes()))) {
            index.compact();
        }

START         localUserMemoryContext.setBytes(index.getEstimatedSize().toBytes()); END 
        operatorContext.recordGeneratedOutput(page.getSizeInBytes(), page.getPositionCount());
    }
","    public void addInput(Page page)
    {
        requireNonNull(page, ""page is null"");
        checkState(!isFinished(), ""Operator is already finished"");

        index.addPage(page);

        if (!localUserMemoryContext.trySetBytes((index.getEstimatedSize().toBytes()))) {
            index.compact();
            localUserMemoryContext.setBytes(index.getEstimatedSize().toBytes());
        }

        operatorContext.recordGeneratedOutput(page.getSizeInBytes(), page.getPositionCount());
    }
"
699,inline s?,"  public Comparable getSortKey() {
    String sourceProviderName = mySourceProvider == null ? """" : mySourceProvider.getName();
    final String s = getQualifiedNameSortKey() + ""-"" + (SdkConstants.FD_MAIN.equals(sourceProviderName) ? """" : sourceProviderName);
    return s;
  }
","  public Comparable getSortKey() {
    String sourceProviderName = mySourceProvider == null ? """" : mySourceProvider.getName();
START     final String s = getQualifiedNameSortKey() + ""-"" + (SdkConstants.FD_MAIN.equals(sourceProviderName) ? """" : sourceProviderName); END 
    return s;
  }
","  public Comparable getSortKey() {
    String sourceProviderName = mySourceProvider == null ? """" : mySourceProvider.getName();
    return getQualifiedNameSortKey() + ""-"" + (SdkConstants.FD_MAIN.equals(sourceProviderName) ? """" : sourceProviderName);
  }
"
700,"`"" "" + IJBossRuntimeConstants.SPACE`","	protected String getLaunchDebugCommand(JBossServer jbossServer) throws CoreException {
		String programArguments = getLaunchProgramArgs();
		String vmArguments = getLaunchVMArgs();
		String jar = getJar(jbossServer.getServer());
		String debugPort = getDebugPort();
		String debugArgs = ""-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address="" + debugPort + "" -Xdebug "";
		String command = ""java "" + debugArgs + vmArguments + "" -jar "" + jar + "" "" + IJBossRuntimeConstants.SPACE + programArguments + ""&"";
		return command;
	}
","	protected String getLaunchDebugCommand(JBossServer jbossServer) throws CoreException {
		String programArguments = getLaunchProgramArgs();
		String vmArguments = getLaunchVMArgs();
		String jar = getJar(jbossServer.getServer());
		String debugPort = getDebugPort();
		String debugArgs = ""-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address="" + debugPort + "" -Xdebug "";
START 		String command = ""java "" + debugArgs + vmArguments + "" -jar "" + jar + "" "" + IJBossRuntimeConstants.SPACE + programArguments + ""&""; END 
		return command;
	}
","	protected String getLaunchDebugCommand(JBossServer jbossServer) throws CoreException {
		String programArguments = getLaunchProgramArgs();
		String vmArguments = getLaunchVMArgs();
		String jar = getJar(jbossServer.getServer());
		String debugPort = getDebugPort();
		String debugArgs = ""-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address="" + debugPort + "" -Xdebug "";
		String command = ""java "" + debugArgs + vmArguments + "" -jar "" + jar + IJBossRuntimeConstants.SPACE + programArguments + ""&"";
		return command;
	}
"
701,you need to make sure that in case of edit you select the firewall type as it was configured on the cluster and not always select the default.,"    private void initFirewallType() {
        ListModel<FirewallType> firewallType = getFirewallType();

        firewallType.setItems(Arrays.asList(FirewallType.values()));
        firewallType.setIsChangeable(false);
        firewallType.setSelectedItem(FirewallType.FIREWALLD);
    }
","    private void initFirewallType() {
START         ListModel<FirewallType> firewallType = getFirewallType(); END 

        firewallType.setItems(Arrays.asList(FirewallType.values()));
        firewallType.setIsChangeable(false);
        firewallType.setSelectedItem(FirewallType.FIREWALLD);
    }
","    private void initFirewallType() {
        ListModel<FirewallType> firewallType = getFirewallType();

        firewallType.setItems(Arrays.asList(FirewallType.values()));
        firewallType.setIsChangeable(true);
        firewallType.setSelectedItem(FirewallType.FIREWALLD);
    }
"
702,"I'd remove this check. If you decide to keep it, consider separating conjuncts into separate calls and moving these into `appendValuesToBuffer`.

```
        verify(positionsOffset + batchSize - 1 < positions.length);
        verify(positions[positionsOffset] >= 0);
        verify(positions[positionsOffset + batchSize - 1] < decodedBlock.getPositionCount());
```","    public void copyValues()
    {
        if (batchSize == 0) {
            return;
        }

        verify(decodedBlock != null);

        int[] positions = getPositions();
        verify(positionsOffset + batchSize - 1 < positions.length && positions[positionsOffset] >= 0 &&
                positions[positionsOffset + batchSize - 1] < decodedBlock.getPositionCount());

        appendValuesToBuffer();
        appendNulls();
        bufferedPositionCount += batchSize;
    }
","    public void copyValues()
    {
        if (batchSize == 0) {
            return;
        }

        verify(decodedBlock != null);

        int[] positions = getPositions();
START         verify(positionsOffset + batchSize - 1 < positions.length && positions[positionsOffset] >= 0 && END 
                positions[positionsOffset + batchSize - 1] < decodedBlock.getPositionCount());

        appendValuesToBuffer();
        appendNulls();
        bufferedPositionCount += batchSize;
    }
","    public void copyValues()
    {
        if (batchSize == 0) {
            return;
        }

        appendValuesToBuffer();
        appendNulls();
        bufferedPositionCount += batchSize;
    }
"
703,Why the extra stepName here?,"	public StepContext getObject() throws Exception {
		org.springframework.batch.core.scope.context.StepContext stepContext = StepSynchronizationManager.getContext();

		String stepName = stepContext.getStepName();
		String jobName = stepContext.getStepExecution().getJobExecution().getJobInstance().getJobName();
		Properties properties = batchPropertyContext.getStepLevelProperties(jobName + ""."" + stepName + ""."" + stepName);

		return new StepContext(stepContext.getStepExecution(), properties);
	}
","	public StepContext getObject() throws Exception {
		org.springframework.batch.core.scope.context.StepContext stepContext = StepSynchronizationManager.getContext();

		String stepName = stepContext.getStepName();
		String jobName = stepContext.getStepExecution().getJobExecution().getJobInstance().getJobName();
START 		Properties properties = batchPropertyContext.getStepLevelProperties(jobName + ""."" + stepName + ""."" + stepName); END 

		return new StepContext(stepContext.getStepExecution(), properties);
	}
","	public StepContext getObject() throws Exception {
		org.springframework.batch.core.scope.context.StepContext stepContext = StepSynchronizationManager.getContext();

		String stepName = stepContext.getStepName();
		String jobName = stepContext.getStepExecution().getJobExecution().getJobInstance().getJobName();
		Properties properties = batchPropertyContext.getStepLevelProperties(jobName + ""."" + stepName);

		return new StepContext(stepContext.getStepExecution(), properties);
	}
"
704,"No reason to extract the variable.
The compilator is good here with optimization, but the source code is still this and maybe simplified.","	protected boolean hasInferredTypeHeader(MessageProperties properties) {
		boolean hasInferredTypeHeader = properties.getInferredArgumentType() != null;
		return hasInferredTypeHeader;
	}
","	protected boolean hasInferredTypeHeader(MessageProperties properties) {
		boolean hasInferredTypeHeader = properties.getInferredArgumentType() != null;
START 		return hasInferredTypeHeader; END 
	}
","	protected boolean hasInferredTypeHeader(MessageProperties properties) {
		return properties.getInferredArgumentType() != null;
	}
"
705,"nit: maybe use a different runnable hook, which would directly throw the exception you need for your test, instead of ""hardcoding"" the exception here?
We can imagine test cases which would involve setting the interrupted flag here, but without expecting this `InterruptedException` (for instance something which would try to get a `RemotingException` from the `proxy.fetch` call in `loadRemoteClass`).","    private void invokeClassLoadTestingHookIfNeeded() throws InterruptedException {
        // Testing support only.
        if (TESTING_CLASS_LOAD != null) {
            TESTING_CLASS_LOAD.run();
            if (Thread.currentThread().isInterrupted()) {
                // Otherwise the interrupt isn't recognized and the test doesn't work.
                throw new InterruptedException(""loading was interrupted."");
            }
        }
    }
","    private void invokeClassLoadTestingHookIfNeeded() throws InterruptedException {
        // Testing support only.
        if (TESTING_CLASS_LOAD != null) {
            TESTING_CLASS_LOAD.run();
START             if (Thread.currentThread().isInterrupted()) {
                // Otherwise the interrupt isn't recognized and the test doesn't work.
                throw new InterruptedException(""loading was interrupted."");
            } END 
        }
    }
","    private void invokeClassLoadTestingHookIfNeeded() throws InterruptedException {
        // Testing support only.
        if (TESTING_CLASS_LOAD != null) {
            TESTING_CLASS_LOAD.run();
        }
    }
"
706,Could be get(0) if using a SingletonList (see below) or even better if UNSET_EVENT_ID was 0...,"    public IEventDeclaration getEventDeclaration(int eventIndex) {
        if (eventIndex == EventDeclaration.UNSET_EVENT_ID) {
            return fEventUnsetId;
        }
        return fEvents.get(eventIndex);
    }
","    public IEventDeclaration getEventDeclaration(int eventIndex) {
        if (eventIndex == EventDeclaration.UNSET_EVENT_ID) {
START             return fEventUnsetId; END 
        }
        return fEvents.get(eventIndex);
    }
","    public IEventDeclaration getEventDeclaration(int eventIndex) {
        if (eventIndex == EventDeclaration.UNSET_EVENT_ID) {
            return fEvents.get(0);
        }
        return fEvents.get(eventIndex);
    }
"
707,@NielsCharlier fix resource leak with a try-with-resources block?,"    protected void loadProperties(Properties props) throws IOException {
        try {
            super.loadProperties(props);
        }
        catch(FileNotFoundException e) {
            //location was not found, create 
            if (configFile != null && copyOutTemplate) {
                OutputStream fout = configFile.out();
                props.store(fout, comments);
                fout.flush();
                fout.close();
            }
        }
    }
","    protected void loadProperties(Properties props) throws IOException {
        try {
            super.loadProperties(props);
        }
        catch(FileNotFoundException e) {
            //location was not found, create 
            if (configFile != null && copyOutTemplate) {
                OutputStream fout = configFile.out();
                props.store(fout, comments);
                fout.flush();
START                 fout.close(); END 
            }
        }
    }
","    protected void loadProperties(Properties props) throws IOException {
        try {
            super.loadProperties(props);
        }
        catch(FileNotFoundException e) {
            //location was not found, create 
            if (configFile != null && copyOutTemplate) {
                try (OutputStream fout = configFile.out()) {
                    props.store(fout, comments);                
                    fout.flush();
                }
            }
        }
    }
"
708,Missing generics,"    public Builder addRequestHandler(RequestHandler requestHandler) {
      if (requestHandler == null) {
        throw new IllegalArgumentException(""RequestHandler must not be null."");
      }
      if (requestHandlers == null) {
        requestHandlers = new ArrayList();
      }
      if (requestHandlers.contains(requestHandler)) {
        throw new IllegalStateException(""RequestHandler already registered."");
      }
      requestHandlers.add(requestHandler);
      return this;
    }
","    public Builder addRequestHandler(RequestHandler requestHandler) {
      if (requestHandler == null) {
        throw new IllegalArgumentException(""RequestHandler must not be null."");
      }
      if (requestHandlers == null) {
START         requestHandlers = new ArrayList(); END 
      }
      if (requestHandlers.contains(requestHandler)) {
        throw new IllegalStateException(""RequestHandler already registered."");
      }
      requestHandlers.add(requestHandler);
      return this;
    }
","    public Builder addRequestHandler(RequestHandler requestHandler) {
      if (requestHandler == null) {
        throw new IllegalArgumentException(""RequestHandler must not be null."");
      }
      if (requestHandlers == null) {
        requestHandlers = new ArrayList<RequestHandler>();
      }
      if (requestHandlers.contains(requestHandler)) {
        throw new IllegalStateException(""RequestHandler already registered."");
      }
      requestHandlers.add(requestHandler);
      return this;
    }
"
709,"![MINOR](https://sonarsource.github.io/sonar-github/severity-minor.png 'Severity: MINOR') Remove this use of ""ScriptException""; it is deprecated. [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3ACallToDeprecatedMethod)","	private Object eval(Bindings bindings, String expression)
	{
		try
		{
			return jsScriptEngine.eval(bindings, expression);
		}
		catch (javax.script.ScriptException t)
		{
			return new ScriptException(t.getCause());
		}
		catch (Throwable t)
		{
			return new ScriptException(t);
		}
	}
","	private Object eval(Bindings bindings, String expression)
	{
		try
		{
			return jsScriptEngine.eval(bindings, expression);
		}
		catch (javax.script.ScriptException t)
		{
START 			return new ScriptException(t.getCause()); END 
		}
		catch (Throwable t)
		{
			return new ScriptException(t);
		}
	}
","	private Object eval(Bindings bindings, String expression)
	{
		try
		{
			return jsScriptEngine.eval(bindings, expression);
		}
		catch (javax.script.ScriptException t)
		{
			return new ScriptException(t.getCause());
		}
		catch (Exception t)
		{
			return new ScriptException(t);
		}
	}
"
710,static import?,"    public void testWithParameters() throws IOException {
        try (Analyzer ws = newHomoglyphFilter()) {
            TokenStream ts = ws.tokenStream("""", input);
            BaseTokenStreamTestCase.assertTokenStreamContents(ts,
                    expected);
        }
    }
","    public void testWithParameters() throws IOException {
        try (Analyzer ws = newHomoglyphFilter()) {
            TokenStream ts = ws.tokenStream("""", input);
            START BaseTokenStreamTestCase.assertTokenStreamContents(ts, END 
                    expected);
        }
    }
","    public void testWithParameters() throws IOException {
        try (Analyzer ws = newHomoglyphFilter()) {
            TokenStream ts = ws.tokenStream("""", input);
            assertTokenStreamContents(ts,
                    expected);
        }
    }
"
711,Break after this line.,"  private static void editTree(TreeOperation op, Repository repo, RevWalk rw,
      RevCommit base, DirCacheEditor dce, ObjectInserter ins, String path,
      byte[] content) throws IOException, InvalidChangeOperationException {
    switch (op) {
      case DELETE_ENTRY:
        dce.add(new DeletePath(path));
        break;
      case CHANGE_ENTRY:
      case RESTORE_ENTRY:
        dce.add(getPathEdit(op, repo, rw, base, path, ins, content));
    }
    dce.finish();
  }
","  private static void editTree(TreeOperation op, Repository repo, RevWalk rw,
      RevCommit base, DirCacheEditor dce, ObjectInserter ins, String path,
      byte[] content) throws IOException, InvalidChangeOperationException {
    switch (op) {
      case DELETE_ENTRY:
        dce.add(new DeletePath(path));
        break;
      case CHANGE_ENTRY:
      case RESTORE_ENTRY:
START         dce.add(getPathEdit(op, repo, rw, base, path, ins, content)); END 
    }
    dce.finish();
  }
","  private static void editTree(TreeOperation op, Repository repo, RevWalk rw,
      RevCommit base, DirCacheEditor dce, ObjectInserter ins, String path,
      byte[] content) throws IOException, InvalidChangeOperationException {
    switch (op) {
      case DELETE_ENTRY:
        dce.add(new DeletePath(path));
        break;
      case CHANGE_ENTRY:
      case RESTORE_ENTRY:
        dce.add(getPathEdit(op, repo, rw, base, path, ins, content));
        break;
    }
    dce.finish();
  }
"
712,Are you switching to var in order to correctly determine the final type?,"    public RegisteredService findServiceBy(final long id) {
        var result = this.services.get(id, k -> this.serviceRegistry.findServiceById(id));
        return validateRegisteredService(result);
    }
","    public RegisteredService findServiceBy(final long id) {
START         var result = this.services.get(id, k -> this.serviceRegistry.findServiceById(id)); END 
        return validateRegisteredService(result);
    }
","    public RegisteredService findServiceBy(final long id) {
        val result = this.services.get(id, k -> this.serviceRegistry.findServiceById(id));
        return validateRegisteredService(result);
    }
"
713,"This means ``getIconSet`` will be called twice for the most common use case. I would add a private ``getMetaData(String iconName, IconSet iconSet)`` and call it from the rest of the ``getMetaData()`` methods.","    public Map<String, Object> getMetaData(String iconName) throws IconException
    {
        return this.getMetaData(iconName, getIconSet(iconName).getName());
    }
","    public Map<String, Object> getMetaData(String iconName) throws IconException
    {
START         return this.getMetaData(iconName, getIconSet(iconName).getName()); END 
    }
","    public Map<String, Object> getMetaData(String iconName) throws IconException
    {
        return this.getMetaData(iconName, getIconSet(iconName));
    }
"
714,![INFO](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/severity-info.png 'Severity: INFO') Do not forget to remove this deprecated code someday. [![rule](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/rule.png)](https://next.sonarqube.com/sonarqube/coding_rules#rule_key=squid%3AS1133),"  public QualityProfileDto selectByNameAndLanguage(String name, String language, DbSession session) {
    return mapper(session).selectByNameAndLanguage(name, language);
  }
","START   public QualityProfileDto selectByNameAndLanguage(String name, String language, DbSession session) { END 
    return mapper(session).selectByNameAndLanguage(name, language);
  }
","  public QualityProfileDto selectByNameAndLanguage(String name, String language, DbSession session) {
    return mapper(session).selectByNameAndLanguage(null, name, language);
  }
"
715,This is unintuitive - why not return the number of characters you need and allow the calling function to decide what to do with it?,"    private int addFieldToDescriptionMap(Map<String, Object> descriptionMap, String diskAlias, String fieldName,
            String fieldValue, int descriptionAvailableLength) {
        if ((descriptionAvailableLength -= getJsonFieldPotentialOverhead(fieldName, descriptionMap)) > 0) {
            // There's enough space for the field's overhead in the metadata + at least one character from its value.
            if (fieldValue.length() > descriptionAvailableLength) {
                fieldValue = fieldValue.substring(0, descriptionAvailableLength);
                auditLogNoSpaceToStoreEntireDiskField(diskAlias, fieldName, fieldValue);
            }
            descriptionMap.put(fieldName, fieldValue);
            return descriptionAvailableLength - fieldValue.length();
        }
        return 0;
    }
","    private int addFieldToDescriptionMap(Map<String, Object> descriptionMap, String diskAlias, String fieldName,
            String fieldValue, int descriptionAvailableLength) {
        if ((descriptionAvailableLength -= getJsonFieldPotentialOverhead(fieldName, descriptionMap)) > 0) {
            // There's enough space for the field's overhead in the metadata + at least one character from its value.
            if (fieldValue.length() > descriptionAvailableLength) {
                fieldValue = fieldValue.substring(0, descriptionAvailableLength);
                auditLogNoSpaceToStoreEntireDiskField(diskAlias, fieldName, fieldValue);
            }
            descriptionMap.put(fieldName, fieldValue);
            return descriptionAvailableLength - fieldValue.length();
        }
START         return 0; END 
    }
","    private int addFieldToDescriptionMap(Map<String, Object> descriptionMap, String diskAlias, String fieldName,
            String fieldValue, int descriptionAvailableLength) {
        if ((descriptionAvailableLength -= getJsonFieldPotentialOverhead(fieldName, descriptionMap)) > 0) {
            // There's enough space for the field's overhead in the metadata + at least one character from its value.
            if (fieldValue.length() > descriptionAvailableLength) {
                fieldValue = fieldValue.substring(0, descriptionAvailableLength);
            }
            descriptionMap.put(fieldName, fieldValue);
            return descriptionAvailableLength - fieldValue.length();
        }
        return descriptionAvailableLength;
    }
"
716,"I would probably catch throwables, because ClassDefNotFoundError..","    public static CompletableFuture<Void> runLaterChecked(CheckedRunnable workToEnqueue) {
        return runLater(() -> {
            try {
                workToEnqueue.run();
            } catch (Exception e) {
                throw new CompletionException(e);
            }
        });
    }
","    public static CompletableFuture<Void> runLaterChecked(CheckedRunnable workToEnqueue) {
        return runLater(() -> {
            try {
                workToEnqueue.run();
            } catch (Exception e) {
START                 throw new CompletionException(e); END 
            }
        });
    }
","    public static CompletableFuture<Void> runLaterChecked(CheckedRunnable workToEnqueue) {
        return runLater(() -> {
            try {
                workToEnqueue.run();
            } catch (Throwable t) {
                throw new CompletionException(t);
            }
        });
    }
"
717,minor: don't need `this.` in both lines,"  public void add(String str, StatsSnapshot statsSnapshot) {
    this.subMap = this.subMap == null ? new HashMap<>() : this.subMap;
    this.subMap.put(str, statsSnapshot);
  }
","  public void add(String str, StatsSnapshot statsSnapshot) {
START     this.subMap = this.subMap == null ? new HashMap<>() : this.subMap; END 
    this.subMap.put(str, statsSnapshot);
  }
","  public void add(String str, StatsSnapshot statsSnapshot) {
    subMap = subMap == null ? new HashMap<>() : subMap;
    subMap.put(str, statsSnapshot);
  }
"
718,Our standard convention is to prefix with `this` for instance members - `return this.context`,"		public Context currentContext() {
			return context;
		}
","		public Context currentContext() {
START 			return context; END 
		}
","		public Context currentContext() {
			return this.context;
		}
"
719,What if `organizationDiscoveryIntervalMillis` is less than 1000? Use `MILLISECONDS` instead,"    private void startDiscovery()
    {
        discoveryService.scheduleWithFixedDelay(() -> {
            try {
                // jitter to avoid overloading database and overloading the backup store
                SECONDS.sleep(ThreadLocalRandom.current().nextLong(1, organizationDiscoveryIntervalMillis / 1000));

                log.info(""Running shard organizer..."");
                submitJobs(discoverAndInitializeTablesToOrganize());
            }
            catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            catch (Throwable t) {
                log.error(t, ""Error running shard organizer"");
            }
        }, 0, organizationDiscoveryIntervalMillis, TimeUnit.MILLISECONDS);
    }
","    private void startDiscovery()
    {
        discoveryService.scheduleWithFixedDelay(() -> {
            try {
                // jitter to avoid overloading database and overloading the backup store
START                 SECONDS.sleep(ThreadLocalRandom.current().nextLong(1, organizationDiscoveryIntervalMillis / 1000)); END 

                log.info(""Running shard organizer..."");
                submitJobs(discoverAndInitializeTablesToOrganize());
            }
            catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            catch (Throwable t) {
                log.error(t, ""Error running shard organizer"");
            }
        }, 0, organizationDiscoveryIntervalMillis, TimeUnit.MILLISECONDS);
    }
","    private void startDiscovery()
    {
        discoveryService.scheduleWithFixedDelay(() -> {
            try {
                // jitter to avoid overloading database and overloading the backup store
                MILLISECONDS.sleep(ThreadLocalRandom.current().nextLong(1, organizationDiscoveryIntervalMillis));

                log.info(""Running shard organizer..."");
                submitJobs(discoverAndInitializeTablesToOrganize());
            }
            catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            catch (Throwable t) {
                log.error(t, ""Error running shard organizer"");
            }
        }, 0, organizationDiscoveryIntervalMillis, TimeUnit.MILLISECONDS);
    }
"
720,"It's possible that log levels can be manipulated dynamically, but that seems like such a thin use case that we don't need to worry about it.","    private CacheBuilder<CacheKey, TypeCodec<?>> defaultCacheBuilder() {
        CacheBuilder<CacheKey, TypeCodec<?>> builder = CacheBuilder.newBuilder()
            // 19 primitive codecs + collections thereof = 19*3 + 19*19 = 418 codecs,
            // so let's start with roughly 1/4 of that
            .initialCapacity(100)
            .weigher(new TypeCodecWeigher())
            .maximumWeight(1000);
        if (logger.isTraceEnabled())
            // do not bother adding a listener if it will be ineffective
            builder = builder.removalListener(new TypeCodecRemovalListener());
        return builder;
    }
","    private CacheBuilder<CacheKey, TypeCodec<?>> defaultCacheBuilder() {
        CacheBuilder<CacheKey, TypeCodec<?>> builder = CacheBuilder.newBuilder()
            // 19 primitive codecs + collections thereof = 19*3 + 19*19 = 418 codecs,
            // so let's start with roughly 1/4 of that
            .initialCapacity(100)
            .weigher(new TypeCodecWeigher())
            .maximumWeight(1000);
        if (logger.isTraceEnabled())
            // do not bother adding a listener if it will be ineffective
START             builder = builder.removalListener(new TypeCodecRemovalListener()); END 
        return builder;
    }
","    private CacheBuilder<CacheKey, TypeCodec<?>> defaultCacheBuilder() {
        CacheBuilder<CacheKey, TypeCodec<?>> builder = CacheBuilder.newBuilder()
            // 19 primitive codecs + collections thereof = 19*3 + 19*19 = 418 codecs,
            // so let's start with roughly 1/4 of that
            .initialCapacity(100)
            .maximumWeight(1000)
            .weigher(new TypeCodecWeigher());
        if (logger.isTraceEnabled())
            // do not bother adding a listener if it will be ineffective
            builder = builder.removalListener(new TypeCodecRemovalListener());
        return builder;
    }
"
721,"If you clear the list at the end of the scan, no need to clear it before.","  public void scanFile(JavaFileScannerContext context) {
    expectedLevel = 0;
    isBlockAlreadyReported = false;
    lastCheckedLine = 0;
    isInAnonymousClass.clear();
    this.context = context;
    scan(context.getTree());
    isInAnonymousClass.clear();
  }
","  public void scanFile(JavaFileScannerContext context) {
    expectedLevel = 0;
    isBlockAlreadyReported = false;
    lastCheckedLine = 0;
START     isInAnonymousClass.clear(); END 
    this.context = context;
    scan(context.getTree());
    isInAnonymousClass.clear();
  }
","  public void scanFile(JavaFileScannerContext context) {
    expectedLevel = 0;
    isBlockAlreadyReported = false;
    lastCheckedLine = 0;
    this.context = context;
    scan(context.getTree());
    isInAnonymousClass.clear();
  }
"
722,unused variable?,"    public static Project getByName(String name) {
        RuntimeEnvironment env = RuntimeEnvironment.getInstance();
        if (env.hasProjects()) {
            Project search = new Project(name);
            Project proj;
            if ((proj = env.getProjects().get(name)) != null) {
                    return (proj);
            }
        }
        return null;
    }
","    public static Project getByName(String name) {
        RuntimeEnvironment env = RuntimeEnvironment.getInstance();
        if (env.hasProjects()) {
START             Project search = new Project(name); END 
            Project proj;
            if ((proj = env.getProjects().get(name)) != null) {
                    return (proj);
            }
        }
        return null;
    }
","    public static Project getByName(String name) {
        RuntimeEnvironment env = RuntimeEnvironment.getInstance();
        if (env.hasProjects()) {
            Project proj;
            if ((proj = env.getProjects().get(name)) != null) {
                    return (proj);
            }
        }
        return null;
    }
"
723,"Instead of adding this injected ctor here, I would add a new class that extends ImportNetworksModel and has this ctor.
So the base class will have the general ctor and the children will have the injected ones with the explicit model type.

The way it is implemented now is a bit confusing.","    public ImportNetworksModel(final com.google.inject.Provider<CommonModel> commonModelProvider,
            NetworkListModel sourceListModel) {
        this(sourceListModel, commonModelProvider);
    }
","START     public ImportNetworksModel(final com.google.inject.Provider<CommonModel> commonModelProvider, END 
            NetworkListModel sourceListModel) {
        this(sourceListModel, commonModelProvider);
    }
","    public ImportNetworksModel(final com.google.inject.Provider<CommonModel> commonModelProvider,
            NetworkListModel sourceListModel) {
        super(sourceListModel, commonModelProvider);
    }
"
724,debug,"    void onNext(ClickEvent event) {
        GQuery.console.info(""next"");
        next();
    }
","    void onNext(ClickEvent event) {
START         GQuery.console.info(""next""); END 
        next();
    }
","    void onNext(ClickEvent event) {
        next();
    }
"
725,The Exception is never thrown.,"    public void testDestroy() throws Exception {
        final ManagedInstance managedInstance = mock(ManagedInstance.class);
        final Object control = mock(Object.class);
        final Consumer<Object> consumer = mock(Consumer.class);

        InstanceUtils.destroy(managedInstance, control, consumer);

        verify(consumer, times(1)).accept(eq(control));
        verify(managedInstance, times(1)).destroy(eq(control));
    }
","START     public void testDestroy() throws Exception { END 
        final ManagedInstance managedInstance = mock(ManagedInstance.class);
        final Object control = mock(Object.class);
        final Consumer<Object> consumer = mock(Consumer.class);

        InstanceUtils.destroy(managedInstance, control, consumer);

        verify(consumer, times(1)).accept(eq(control));
        verify(managedInstance, times(1)).destroy(eq(control));
    }
","    public void testDestroy() {
        final ManagedInstance managedInstance = mock(ManagedInstance.class);
        final Object control = mock(Object.class);
        final Consumer<Object> consumer = mock(Consumer.class);

        InstanceUtils.destroy(managedInstance, control, consumer);

        verify(consumer, times(1)).accept(eq(control));
        verify(managedInstance, times(1)).destroy(eq(control));
    }
"
726,"nit: Should be `public`. We're only using this inside of the package, but there is no reason to restrict it, and it should have the same visibility as the constructor, since it is just a shortcut for the ctor.","    static GlyphPair gp(String original, String mirror) {
        return new GlyphPair(original, mirror);
    }
","    START  static GlyphPair END  gp(String original, String mirror) {
        return new GlyphPair(original, mirror);
    }
","    public static GlyphPair gp(String original, String mirror) {
        return new GlyphPair(original, mirror);
    }
"
727,"i think, it is done in every test and can possibly be moved to setUp()","  public void testSimpleAnnounce() throws IOException
  {
    IndexerSQLMetadataStorageCoordinator coordinator = new IndexerSQLMetadataStorageCoordinator(
        mapper,
        tablesConfig,
        derbyConnector
    );
    coordinator.announceHistoricalSegments(segments);
    Assert.assertArrayEquals(
        mapper.writeValueAsString(defaultSegment).getBytes(""UTF-8""),
        derbyConnector.lookup(
            tablesConfig.getSegmentsTable(),
            ""id"",
            ""payload"",
            defaultSegment.getIdentifier()
        )
    );
  }
","  public void testSimpleAnnounce() throws IOException
  {
    IndexerSQLMetadataStorageCoordinator coordinator = new IndexerSQLMetadataStorageCoordinator(
        mapper,
        tablesConfig,
        derbyConnector
    );
START     coordinator.announceHistoricalSegments(segments); END 
    Assert.assertArrayEquals(
        mapper.writeValueAsString(defaultSegment).getBytes(""UTF-8""),
        derbyConnector.lookup(
            tablesConfig.getSegmentsTable(),
            ""id"",
            ""payload"",
            defaultSegment.getIdentifier()
        )
    );
  }
","  public void testSimpleAnnounce() throws IOException
  {
    coordinator.announceHistoricalSegments(segments);
    Assert.assertArrayEquals(
        mapper.writeValueAsString(defaultSegment).getBytes(""UTF-8""),
        derbyConnector.lookup(
            tablesConfig.getSegmentsTable(),
            ""id"",
            ""payload"",
            defaultSegment.getIdentifier()
        )
    );
  }
"
728,please dont remove explicit initialization,"	public static IDomain getFirstDomainOrCreate(IUser user) throws OpenShiftException {
		IDomain domain;
		domain = getFirstDomain(user);

		if (domain == null) {
			domain = user.createDomain(createRandomName());
		}

		return domain;
	}
","	public static IDomain getFirstDomainOrCreate(IUser user) throws OpenShiftException {
START 		IDomain domain; END 
		domain = getFirstDomain(user);

		if (domain == null) {
			domain = user.createDomain(createRandomName());
		}

		return domain;
	}
","	public static IDomain getFirstDomainOrCreate(IUser user) throws OpenShiftException {
		IDomain domain = null;
		domain = getFirstDomain(user);

		if (domain == null) {
			domain = user.createDomain(createRandomName());
		}

		return domain;
	}
"
729,why not use `Sets.newHashSet({value})` here like you are everywhere else?,"    public void testSetDependencies() {
        Assert.assertNotNull(this.c.getDependencies());
        final Set<String> dependencies = Sets.newHashSet();
        dependencies.add(""s3://netflix/jars/myJar.jar"");
        this.c.setDependencies(dependencies);
        Assert.assertEquals(dependencies, this.c.getDependencies());

        this.c.setDependencies(null);
        Assert.assertThat(this.c.getDependencies(), Matchers.empty());
    }
","    public void testSetDependencies() {
        Assert.assertNotNull(this.c.getDependencies());
START         final Set<String> dependencies = Sets.newHashSet(); END 
        dependencies.add(""s3://netflix/jars/myJar.jar"");
        this.c.setDependencies(dependencies);
        Assert.assertEquals(dependencies, this.c.getDependencies());

        this.c.setDependencies(null);
        Assert.assertThat(this.c.getDependencies(), Matchers.empty());
    }
","    public void testSetDependencies() {
        Assert.assertNotNull(this.c.getDependencies());
        final Set<String> dependencies = Sets.newHashSet(""s3://netflix/jars/myJar.jar"");
        this.c.setDependencies(dependencies);
        Assert.assertEquals(dependencies, this.c.getDependencies());

        this.c.setDependencies(null);
        Assert.assertThat(this.c.getDependencies(), Matchers.empty());
    }
"
730,These `<T>`s don't occur anywhere in the method signature.,"    public static <T> PredicateOperation predicate(Operator operator, ImmutableList<Expression<?>> args) {
        return new PredicateOperation(operator, args);
    }
","START     public static <T> PredicateOperation predicate(Operator operator, ImmutableList<Expression<?>> args) { END 
        return new PredicateOperation(operator, args);
    }
","    public static PredicateOperation predicate(Operator operator, ImmutableList<Expression<?>> args) {
        return new PredicateOperation(operator, args);
    }
"
731,"typo in the name of the invoked method, should be `Optional.empty()`","  private void usingIsEmpty() {
    Optional<Object> op = Optional.emtpy();
    if (!op.isEmpty()) {
      op.get(); // Compliant - dead code
    }
  }
","  private void usingIsEmpty() {
START     Optional<Object> op = Optional.emtpy(); END 
    if (!op.isEmpty()) {
      op.get(); // Compliant - dead code
    }
  }
","  private void usingIsEmpty() {
    Optional<Object> op = Optional.empty();
    if (!op.isEmpty()) {
      op.get(); // Compliant - dead code
    }
  }
"
732,"DB and table name need not be set always. shall use String.valueOf(entry.getDbName()) as it return ""null"" string if null.","  public void addNotificationEvent(NotificationEvent entry) throws MetaException {
    if (addNotificationEventModifier != null) {
      Boolean success = addNotificationEventModifier.apply(entry);
      if ((success != null) && !success) {
        throw new MetaException(""InjectableBehaviourObjectStore: Invalid addNotificationEvent operation on DB: ""
                + entry.getDbName() + "" table: "" + entry.getTableName() + "" event : "" + entry.getEventType());
      }
    } else {
      super.addNotificationEvent(entry);
    }
  }
","  public void addNotificationEvent(NotificationEvent entry) throws MetaException {
    if (addNotificationEventModifier != null) {
      Boolean success = addNotificationEventModifier.apply(entry);
      if ((success != null) && !success) {
        throw new MetaException(""InjectableBehaviourObjectStore: Invalid addNotificationEvent operation on DB: ""
START                 + entry.getDbName() + "" table: "" + entry.getTableName() + "" event : "" + entry.getEventType()); END 
      }
    } else {
      super.addNotificationEvent(entry);
    }
  }
","  public void addNotificationEvent(NotificationEvent entry) throws MetaException {
    if (addNotificationEventModifier != null) {
      Boolean success = addNotificationEventModifier.apply(entry);
      if ((success != null) && !success) {
        throw new MetaException(""InjectableBehaviourObjectStore: Invalid addNotificationEvent operation on DB: ""
                + entry.getDbName() + "" table: "" + entry.getTableName() + "" event : "" + entry.getEventType());
      }
    }
    super.addNotificationEvent(entry);
  }
"
733,if the profile isn't set you'll have NPE here.,"    public List<PermissionSubject> getPermissionCheckSubjects() {
        return Collections.singletonList(new PermissionSubject(getParameters().getProfile().getStorageDomainId(),
                VdcObjectType.Storage, getActionType().getActionGroup()));
    }
","    public List<PermissionSubject> getPermissionCheckSubjects() {
START         return Collections.singletonList(new PermissionSubject(getParameters().getProfile().getStorageDomainId(), END 
                VdcObjectType.Storage, getActionType().getActionGroup()));
    }
","    public List<PermissionSubject> getPermissionCheckSubjects() {
        return Collections.singletonList(new PermissionSubject(getParameters().getProfile() != null ? getParameters().getProfile()
                .getStorageDomainId()
                : null,
                VdcObjectType.Storage, getActionType().getActionGroup()));
    }
"
734,Won't we land here for expected network errors as well? Should this be in the catch block itself?,"    public void onError(Throwable t) {
        L.logRemoteErrorIfProd(t);
        Toast.makeText(context, t.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
    }
","    public void onError(Throwable t) {
START         L.logRemoteErrorIfProd(t); END 
        Toast.makeText(context, t.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
    }
","    public void onError(Throwable t) {
        Toast.makeText(context, t.getLocalizedMessage(), Toast.LENGTH_SHORT).show();
    }
"
735,"remove ""return payload"" in the catch.","  public static Object awaitLatch(Object payload, CountDownLatch latch) {
    try {
      latch.await();
    } catch (InterruptedException e) {
      currentThread().interrupt();
      return payload;
    }
    return payload;

  }
","  public static Object awaitLatch(Object payload, CountDownLatch latch) {
    try {
      latch.await();
    } catch (InterruptedException e) {
      currentThread().interrupt();
START       return payload; END 
    }
    return payload;

  }
","  public static Object awaitLatch(Object payload, CountDownLatch latch) {
    try {
      latch.await();
    } catch (InterruptedException e) {
      currentThread().interrupt();
    }
    return payload;

  }
"
736,"You want g.add(null, checkBox) and put the display name onto the CheckBox widget. This way it shows [x] Foo instead of Foo [x] and users get a bigger click target (the label text) to mash with the mouse.","  private CheckBox renderCheckBox(LabeledWidgetsGrid g,
      ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox();
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(getDisplayName(param), checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
  }
","  private CheckBox renderCheckBox(LabeledWidgetsGrid g,
      ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox();
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    START  g.add(getDisplayName(param), checkBox); END 
    saveEnabler.listenTo(checkBox);
    return checkBox;
  }
","  private CheckBox renderCheckBox(LabeledWidgetsGrid g,
      ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox(getDisplayName(param));
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(null, checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
  }
"
737,Can be removed.,"    public void completeTaskCmdExecutorTest() {
        Map<String, Object> variables = new HashMap<>();
        CompleteTaskCmd completeTaskCmd = new CompleteTaskCmd(""taskId"",
                                                              variables);

        assertThat(completeTaskCmdExecutor).isNotNull();

        assertThat(completeTaskCmdExecutor.getHandledType()).isEqualTo(CompleteTaskCmd.class);

        completeTaskCmdExecutor.execute(completeTaskCmd);

        verify(processEngine).completeTask(completeTaskCmd);

        verify(commandResults).send(ArgumentMatchers.<Message<CompleteTaskResults>>any());
    }
","    public void completeTaskCmdExecutorTest() {
        Map<String, Object> variables = new HashMap<>();
        CompleteTaskCmd completeTaskCmd = new CompleteTaskCmd(""taskId"",
                                                              variables);

START         assertThat(completeTaskCmdExecutor).isNotNull(); END 

        assertThat(completeTaskCmdExecutor.getHandledType()).isEqualTo(CompleteTaskCmd.class);

        completeTaskCmdExecutor.execute(completeTaskCmd);

        verify(processEngine).completeTask(completeTaskCmd);

        verify(commandResults).send(ArgumentMatchers.<Message<CompleteTaskResults>>any());
    }
","    public void completeTaskCmdExecutorTest() {
        Map<String, Object> variables = new HashMap<>();
        CompleteTaskCmd completeTaskCmd = new CompleteTaskCmd(""taskId"",
                                                              variables);

        assertThat(completeTaskCmdExecutor.getHandledType()).isEqualTo(CompleteTaskCmd.class);

        completeTaskCmdExecutor.execute(completeTaskCmd);

        verify(processEngine).completeTask(completeTaskCmd);

        verify(commandResults).send(ArgumentMatchers.<Message<CompleteTaskResults>>any());
    }
"
738,"```suggestion
        assertEquals(!set, orderIsBlank);
```
(same elsewhere)","    public void checkDeploymentOrder(boolean set) {
        boolean orderIsBlank = StringUtils.isBlank(deploymentOrder.getText());
        if (set) {
            assertFalse(orderIsBlank);
        } else {
            assertTrue(orderIsBlank);
        }
    }
","    public void checkDeploymentOrder(boolean set) {
        boolean orderIsBlank = StringUtils.isBlank(deploymentOrder.getText());
START         if (set) {
            assertFalse(orderIsBlank);
        } else {
            assertTrue(orderIsBlank);
        } END 
    }
","    public void checkDeploymentOrder(boolean set) {
        assertEquals(!set, StringUtils.isBlank(deploymentOrder.getText()));
    }
"
739,"call super.serialize() so it serializes the ethernet headers, the ip headers, the udp headers and finally the elasticdata","    public int serialize(ByteBuffer bb) {
        int start = bb.position();
        if (!cachedFlowStateEthernetHeader.isPresent()) {
            putFlowStateEthernetHeader();
        }
        bb.put(cachedFlowStateEthernetHeader.get());
        final ElasticData elasticData = getCore();
        if (elasticData.getLength() > 0) {
            putElasticData(bb, start, elasticData);
        }
        return FLOW_STATE_ETHERNET_OVERHEAD + getElasticDataLength();
    }
","START     public int serialize(ByteBuffer bb) { END 
        int start = bb.position();
        if (!cachedFlowStateEthernetHeader.isPresent()) {
            putFlowStateEthernetHeader();
        }
        bb.put(cachedFlowStateEthernetHeader.get());
        final ElasticData elasticData = getCore();
        if (elasticData.getLength() > 0) {
            putElasticData(bb, start, elasticData);
        }
        return FLOW_STATE_ETHERNET_OVERHEAD + getElasticDataLength();
    }
","    public int serialize(ByteBuffer bb) {
        int start = bb.position();
        if (cachedFlowStateEthernetHeader == null) {
            putFlowStateEthernetHeader();
        }
        bb.put(cachedFlowStateEthernetHeader);
        final ElasticData elasticData = getCore();
        if (elasticData.getLength() > 0) {
            putElasticData(bb, start, elasticData);
        }
        return FLOW_STATE_ETHERNET_OVERHEAD + getElasticDataLength();
    }
"
740,what's the point in calling the super.canDoAction() if it always return true ?,"    protected boolean canDoAction() {
        ProviderValidator validator = new ProviderValidator(getProvider());

        return validate(validator.providerIsSet()) && super.canDoAction();
    }
","    protected boolean canDoAction() {
        ProviderValidator validator = new ProviderValidator(getProvider());

START         return validate(validator.providerIsSet()) && super.canDoAction(); END 
    }
","    protected boolean canDoAction() {
        ProviderValidator validator = new ProviderValidator(getProvider());

        return validate(validator.providerIsSet());
    }
"
741,"There are two more calls to findElements in the AreaRender, both in methods only called from sychCTFState.
Shouldn't they also be updated? Or could the stacks be passed as parameter to these methods?","	private void synchCTFState(MArea areaModel) {
		List<MPartStack> stacks = findDirectStacks(areaModel);
		int count = 0;
		for (MPartStack stack : stacks) {
			if (stack.isToBeRendered())
				count++;
		}

		// If there's more than one stack visible we use a CTF
		if (count > 1)
			ensureCTF(areaModel);
		else
			ensureComposite(areaModel);
	}
","	private void synchCTFState(MArea areaModel) {
START 		List<MPartStack> stacks = findDirectStacks(areaModel); END 
		int count = 0;
		for (MPartStack stack : stacks) {
			if (stack.isToBeRendered())
				count++;
		}

		// If there's more than one stack visible we use a CTF
		if (count > 1)
			ensureCTF(areaModel);
		else
			ensureComposite(areaModel);
	}
","	private void synchCTFState(MArea areaModel) {
		List<MPartStack> stacks = findDirectStacks(areaModel);
		int count = 0;
		for (MPartStack stack : stacks) {
			if (stack.isToBeRendered())
				count++;
		}

		// If there's more than one stack visible we use a CTF
		if (count > 1)
			ensureCTF(areaModel, stacks);
		else
			ensureComposite(areaModel, stacks);
	}
"
742,"Seems that there is a bug in this logic, it will clear using putLong() only 1/8-th of the buffer capacity, instead of the buffer capacity without, at most, 7 bytes. The classic pattern of implementing such things is
```java
int i = 0;
for (; i <= usedFlagBufferCapacity - Long.BYTES; i += Long.BYTES) {
  usedFlagBuffer.putLong(i, 0L);
}
for (; i < usedFlagBufferCapacity; i++) {
  usedFlagBuffer.put(i, (byte) 0);
}","  public void reset()
  {
    // Clear the entire usedFlagBuffer
    final int usedFlagBufferCapacity = usedFlagBuffer.capacity();

    // putLong() instead of put() can boost the performance of clearing the buffer
    final int n = usedFlagBufferCapacity / Long.BYTES;
    for (int i = 0; i < n; i += Long.BYTES) {
      usedFlagBuffer.putLong(i, 0L);
    }

    for (int i = n; i < usedFlagBufferCapacity; i++) {
      usedFlagBuffer.put(i, (byte) 0);
    }
  }
","  public void reset()
  {
    // Clear the entire usedFlagBuffer
    final int usedFlagBufferCapacity = usedFlagBuffer.capacity();

    // putLong() instead of put() can boost the performance of clearing the buffer
    final int n = usedFlagBufferCapacity / Long.BYTES;
START     for (int i = 0; i < n; i += Long.BYTES) { END 
      usedFlagBuffer.putLong(i, 0L);
    }

    for (int i = n; i < usedFlagBufferCapacity; i++) {
      usedFlagBuffer.put(i, (byte) 0);
    }
  }
","  public void reset()
  {
    // Clear the entire usedFlagBuffer
    final int usedFlagBufferCapacity = usedFlagBuffer.capacity();

    // putLong() instead of put() can boost the performance of clearing the buffer
    final int n = (usedFlagBufferCapacity / Long.BYTES) * Long.BYTES;
    for (int i = 0; i < n; i += Long.BYTES) {
      usedFlagBuffer.putLong(i, 0L);
    }

    for (int i = n; i < usedFlagBufferCapacity; i++) {
      usedFlagBuffer.put(i, (byte) 0);
    }
  }
"
743,Isn't this check is redundant?,"    private void updateBrickSize() {
        long totalSize = 0;
        // Calculate and show the total size of all selected device so that user can get an idea of what will be his
        // brick
        // capacity.
        if (getStorageDevices().getSelectedItems() != null) {
            for (StorageDevice storageDevice : getStorageDevices().getSelectedItems()) {
                if (storageDevice.getCanCreateBrick()) {
                    totalSize += storageDevice.getSize();
                }
            }
        }

        Pair<SizeUnit, Double> convertedSize = SizeConverter.autoConvert(totalSize, SizeUnit.MB);
        setBrickSize(convertedSize);
    }
","    private void updateBrickSize() {
        long totalSize = 0;
        // Calculate and show the total size of all selected device so that user can get an idea of what will be his
        // brick
        // capacity.
        if (getStorageDevices().getSelectedItems() != null) {
            for (StorageDevice storageDevice : getStorageDevices().getSelectedItems()) {
START                 if (storageDevice.getCanCreateBrick()) { END 
                    totalSize += storageDevice.getSize();
                }
            }
        }

        Pair<SizeUnit, Double> convertedSize = SizeConverter.autoConvert(totalSize, SizeUnit.MB);
        setBrickSize(convertedSize);
    }
","    private void updateBrickSize() {
        long totalSize = 0;
        // Calculate and show the total size of all selected device so that user can get an idea of what will be his
        // brick
        // capacity.
        if (getStorageDevices().getSelectedItems() != null) {
            for (StorageDevice storageDevice : getStorageDevices().getSelectedItems()) {
                totalSize += storageDevice.getSize();
            }
        }

        Pair<SizeUnit, Double> convertedSize = SizeConverter.autoConvert(totalSize, SizeUnit.MB);
        setBrickSize(convertedSize);
    }
"
744,It would be a tiiny bit safer/nicer if you put the config -> servers conversion inside the load method.,"    public void start() throws Exception {
        logger.info(""Starting Gerrit-Trigger Plugin"");
        doXStreamRegistrations();
        logger.trace(""Loading configs"");
        load();
        if (servers == null) {
            servers = new ArrayList<GerritServer>();
            if (config != null) { //have loaded data in old format, so add a new server with the old config to the list.
                GerritServer defaultServer = new GerritServer(DEFAULT_SERVER_NAME);
                defaultServer.setConfig(config);
                servers.add(defaultServer);
            }
        }
        for (GerritServer s : servers) {
            s.start();
        }
    }
","    public void start() throws Exception {
        logger.info(""Starting Gerrit-Trigger Plugin"");
        doXStreamRegistrations();
        logger.trace(""Loading configs"");
        load();
START         if (servers == null) { END 
            servers = new ArrayList<GerritServer>();
            if (config != null) { //have loaded data in old format, so add a new server with the old config to the list.
                GerritServer defaultServer = new GerritServer(DEFAULT_SERVER_NAME);
                defaultServer.setConfig(config);
                servers.add(defaultServer);
            }
        }
        for (GerritServer s : servers) {
            s.start();
        }
    }
","    public void start() throws Exception {
        logger.info(""Starting Gerrit-Trigger Plugin"");
        doXStreamRegistrations();
        logger.trace(""Loading configs"");
        load();
        for (GerritServer s : servers) {
            s.start();
        }
    }
"
745,I thought all of these were changed to com.ichi2.anki JSON classes to avoid the try/catch since we just throw RuntimException anyway? #5550,"    private boolean isClozeType() {
        int noteModelType;
        try {
            noteModelType = getCurrentlySelectedModel().getInt(""type"");
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        return noteModelType == Consts.MODEL_CLOZE;
    }
","    private boolean isClozeType() {
        int noteModelType;
        try {
            noteModelType = getCurrentlySelectedModel().getInt(""type"");
START         } catch (JSONException e) { END 
            throw new RuntimeException(e);
        }
        return noteModelType == Consts.MODEL_CLOZE;
    }
","    private boolean isClozeType() {
        return getCurrentlySelectedModel().getInt(""type"") == Consts.MODEL_CLOZE;
    }
"
746,I believe we can avoid declaring this handle and directly invoke `execute` on the shared handle.,"    public void setUp() {
        final Handle h = this.dbRule.getSharedHandle();
        h.execute(""CREATE TABLE uniq (id INTEGER PRIMARY KEY)"");
    }
","    public void setUp() {
START         final Handle h = this.dbRule.getSharedHandle(); END 
        h.execute(""CREATE TABLE uniq (id INTEGER PRIMARY KEY)"");
    }
","    public void setUp() {
        this.dbRule.getSharedHandle().execute(""CREATE TABLE uniq (id INTEGER PRIMARY KEY)"");
    }
"
747,"No, need for close here as you use try-with-resource?","    public void simulateUsbUnplug() throws IOException, JadbException {
        try (InputStream stream = device.executeShell(""dumpsys"", ""battery"", ""unplug"")) {
            Stream.flushRead(stream);
            stream.close();
        }
    }
","    public void simulateUsbUnplug() throws IOException, JadbException {
        try (InputStream stream = device.executeShell(""dumpsys"", ""battery"", ""unplug"")) {
            Stream.flushRead(stream);
START             stream.close(); END 
        }
    }
","    public void simulateUsbUnplug() throws IOException, JadbException {
        try (InputStream stream = device.executeShell(""dumpsys"", ""battery"", ""unplug"")) {
            Stream.flushRead(stream);
        }
    }
"
748,this can be not enough on latest 3.3 version,"    private void createIndex()
    {
        try ( Transaction tx = db.beginTx() )
        {
            db.execute( ""CREATE INDEX ON "" + indexDefinition );
            tx.success();
        }
        try ( Transaction tx = db.beginTx() )
        {
            db.schema().awaitIndexesOnline( 1, TimeUnit.SECONDS );
            tx.success();
        }
    }
","    private void createIndex()
    {
        try ( Transaction tx = db.beginTx() )
        {
            db.execute( ""CREATE INDEX ON "" + indexDefinition );
            tx.success();
        }
        try ( Transaction tx = db.beginTx() )
        {
START             db.schema().awaitIndexesOnline( 1, TimeUnit.SECONDS ); END 
            tx.success();
        }
    }
","    private void createIndex()
    {
        try ( Transaction tx = db.beginTx() )
        {
            db.execute( ""CREATE INDEX ON "" + indexDefinition );
            tx.success();
        }
        try ( Transaction tx = db.beginTx() )
        {
            db.schema().awaitIndexesOnline( 5, TimeUnit.SECONDS );
            tx.success();
        }
    }
"
749,"Why is this needed?

Storing a context for later use is not a good idea in general.","	public int compareTo(ApplicationInfoEx other) {
		if (mContext == null)
			return TextUtils.join("", "", getApplicationName()).compareToIgnoreCase(
					TextUtils.join("", "", other.getApplicationName()));

		// Locale respecting sorter
		Collator collator = Collator.getInstance(Locale.getDefault());

		return collator.compare(TextUtils.join("", "", getApplicationName()),
				TextUtils.join("", "", other.getApplicationName()));
	}
","	public int compareTo(ApplicationInfoEx other) {
START 		if (mContext == null) END 
			return TextUtils.join("", "", getApplicationName()).compareToIgnoreCase(
					TextUtils.join("", "", other.getApplicationName()));

		// Locale respecting sorter
		Collator collator = Collator.getInstance(Locale.getDefault());

		return collator.compare(TextUtils.join("", "", getApplicationName()),
				TextUtils.join("", "", other.getApplicationName()));
	}
","	public int compareTo(ApplicationInfoEx other) {
		// Locale respecting sorter
		Collator collator = Collator.getInstance(Locale.getDefault());
		return collator.compare(TextUtils.join("", "", getApplicationName()),
				TextUtils.join("", "", other.getApplicationName()));
	}
"
750,"This should really just be versionCounter.set(0);.  This has a race condition that if generateNew method was invoked at the same time it could be possible that the CAS operation doesn't work properly because the get returned a value just before it was incremented but before the CAS occur, causing a missed reset.","   void resetCounter() {
      versionCounter.compareAndSet(versionCounter.get(), 0);
   }
","   void resetCounter() {
START       versionCounter.compareAndSet(versionCounter.get(), 0); END 
   }
","   void resetCounter() {
      versionCounter.set(0);
   }
"
751,"What about making the method implementation be:
    return cmd.getRefName().startsWith(NEW_DRAFT_CHANGE);  ?","  private boolean isDraft(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    if (refName.startsWith(NEW_DRAFT_CHANGE)) {
      return true;
    }
    return false;
  }
","  private boolean isDraft(final ReceiveCommand cmd) {
START     String refName = cmd.getRefName(); END 
    if (refName.startsWith(NEW_DRAFT_CHANGE)) {
      return true;
    }
    return false;
  }
","  private boolean isDraft(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(NEW_DRAFT_CHANGE);
  }
"
752,"no, you need to capture the autobuild state during setup and restore it during teardown","	public void tearDown() throws Exception {
		setAutoBuildEnabled(true);
		ValidationFramework.getDefault().suspendAllValidation(false);
		JobUtils.waitForIdle(100);
		ServerCreationTestUtils.deleteAllServersAndRuntimes();
		ProjectUtility.deleteAllProjects();
		ASMatrixTests.clearStateLocation();
		JobUtils.waitForIdle();
	}
","	public void tearDown() throws Exception {
START 		setAutoBuildEnabled(true); END 
		ValidationFramework.getDefault().suspendAllValidation(false);
		JobUtils.waitForIdle(100);
		ServerCreationTestUtils.deleteAllServersAndRuntimes();
		ProjectUtility.deleteAllProjects();
		ASMatrixTests.clearStateLocation();
		JobUtils.waitForIdle();
	}
","	public void tearDown() throws Exception {
		JobUtils.waitForIdle(100);
		ServerCreationTestUtils.deleteAllServersAndRuntimes();
		ProjectUtility.deleteAllProjects();
		ASMatrixTests.clearStateLocation();
		JobUtils.waitForIdle();
	}
"
753,I think this line means that StringComparator needs a getCacheKey method.,"  public byte[] getCacheKey()
  {
    byte[] previousStopBytes = previousStop == null ? new byte[]{} : StringUtils.toUtf8(previousStop);
    byte[] orderingBytes = StringUtils.toUtf8(ordering.toString());

    int totalLen = 2 + previousStopBytes.length + orderingBytes.length;

    return ByteBuffer.allocate(totalLen)
                     .put(CACHE_TYPE_ID)
                     .put(previousStopBytes)
                     .put(STRING_SEPARATOR)
                     .put(orderingBytes)
                     .array();
  }
","  public byte[] getCacheKey()
  {
    byte[] previousStopBytes = previousStop == null ? new byte[]{} : StringUtils.toUtf8(previousStop);
START     byte[] orderingBytes = StringUtils.toUtf8(ordering.toString()); END 

    int totalLen = 2 + previousStopBytes.length + orderingBytes.length;

    return ByteBuffer.allocate(totalLen)
                     .put(CACHE_TYPE_ID)
                     .put(previousStopBytes)
                     .put(STRING_SEPARATOR)
                     .put(orderingBytes)
                     .array();
  }
","  public byte[] getCacheKey()
  {
    byte[] previousStopBytes = previousStop == null ? new byte[]{} : StringUtils.toUtf8(previousStop);
    byte[] orderingBytes = ordering.getCacheKey();

    int totalLen = 2 + previousStopBytes.length + orderingBytes.length;

    return ByteBuffer.allocate(totalLen)
                     .put(CACHE_TYPE_ID)
                     .put(previousStopBytes)
                     .put(STRING_SEPARATOR)
                     .put(orderingBytes)
                     .array();
  }
"
754,Technically setting closed = false isn't needed since this is the default for a boolean,"  public KafkaRecordSupplier(
      Map<String, Object> consumerProperties,
      ObjectMapper sortingMapper
  )
  {
    this.consumerProperties = consumerProperties;
    this.sortingMapper = sortingMapper;
    this.consumer = getKafkaConsumer();
    this.closed = false;
    this.records = new LinkedBlockingQueue<>();
  }
","  public KafkaRecordSupplier(
      Map<String, Object> consumerProperties,
      ObjectMapper sortingMapper
  )
  {
    this.consumerProperties = consumerProperties;
    this.sortingMapper = sortingMapper;
    this.consumer = getKafkaConsumer();
START     this.closed = false; END 
    this.records = new LinkedBlockingQueue<>();
  }
","  public KafkaRecordSupplier(
      Map<String, Object> consumerProperties,
      ObjectMapper sortingMapper
  )
  {
    this.consumerProperties = consumerProperties;
    this.sortingMapper = sortingMapper;
    this.consumer = getKafkaConsumer();
  }
"
755,Looks like creating `Instant` here may be also omitted.,"    public void eval() {
      // Get the timestamp in milliseconds
      long timestamp = inputDate.value;

      // Get the interval in milliseconds
      long groupByInterval = interval.value;

      java.time.Instant instant = java.time.Instant.ofEpochMilli(timestamp - (timestamp % groupByInterval));
      out.value = instant.toEpochMilli();
    }
","    public void eval() {
      // Get the timestamp in milliseconds
      long timestamp = inputDate.value;

      // Get the interval in milliseconds
      long groupByInterval = interval.value;

START       java.time.Instant instant = java.time.Instant.ofEpochMilli(timestamp - (timestamp % groupByInterval)); END 
      out.value = instant.toEpochMilli();
    }
","    public void eval() {
      // Get the timestamp in milliseconds
      long timestamp = inputDate.value;

      // Get the interval in milliseconds
      long groupByInterval = interval.value;

      out.value = (timestamp - (timestamp % groupByInterval));
    }
"
756,"Since `forEach` doesn't use these values, maybe we can avoid sending them back to the caller by simply returning `null`.","    public V process(Map.Entry<K, V> entry) {
        action.accept(entry.getKey(), entry.getValue());
        return entry.getValue();
    }
","    public V process(Map.Entry<K, V> entry) {
        action.accept(entry.getKey(), entry.getValue());
START         return entry.getValue(); END 
    }
","    public V process(Map.Entry<K, V> entry) {
        action.accept(entry.getKey(), entry.getValue());
        return null;
    }
"
757,Please implement a mock version of the RegExpCache using a normal HashMap.,"  private ProjectControl user(AccountGroup.Id... memberOf) {
    RefControl.Factory refControlFactory = new RefControl.Factory() {
      @Override
      public RefControl create(final ProjectControl projectControl, final String ref) {
        return new RefControl(systemConfig, projectControl, ref, null);
      }
    };
    return new ProjectControl(Collections.<AccountGroup.Id> emptySet(),
        Collections.<AccountGroup.Id> emptySet(), refControlFactory,
        new MockUser(memberOf), newProjectState());
  }
","  private ProjectControl user(AccountGroup.Id... memberOf) {
    RefControl.Factory refControlFactory = new RefControl.Factory() {
      @Override
      public RefControl create(final ProjectControl projectControl, final String ref) {
START         return new RefControl(systemConfig, projectControl, ref, null); END 
      }
    };
    return new ProjectControl(Collections.<AccountGroup.Id> emptySet(),
        Collections.<AccountGroup.Id> emptySet(), refControlFactory,
        new MockUser(memberOf), newProjectState());
  }
","  private ProjectControl user(AccountGroup.Id... memberOf) {
    RefControl.Factory refControlFactory = new RefControl.Factory() {
      @Override
      public RefControl create(final ProjectControl projectControl, final String ref) {
        return new RefControl(systemConfig, projectControl, ref);
      }
    };
    return new ProjectControl(systemConfig,
        Collections.<AccountGroup.Id> emptySet(),
        Collections.<AccountGroup.Id> emptySet(), refControlFactory,
        new MockUser(memberOf), newProjectState());
  }
"
758,Pattern does not match the arguments,"    private boolean executeBatch( BoltConnection connection )
    {
        Thread currentThread = Thread.currentThread();
        String originalName = currentThread.getName();
        String newName = String.format( ""%s [%s] "", originalName, connection.remoteAddress(), connector );

        currentThread.setName( newName );
        try
        {
            return connection.processNextBatch();
        }
        finally
        {
            currentThread.setName( originalName );
        }
    }
","    private boolean executeBatch( BoltConnection connection )
    {
        Thread currentThread = Thread.currentThread();
        String originalName = currentThread.getName();
START         String newName = String.format( ""%s [%s] "", originalName, connection.remoteAddress(), connector ); END 

        currentThread.setName( newName );
        try
        {
            return connection.processNextBatch();
        }
        finally
        {
            currentThread.setName( originalName );
        }
    }
","    private boolean executeBatch( BoltConnection connection )
    {
        Thread currentThread = Thread.currentThread();
        String originalName = currentThread.getName();
        String newName = String.format( ""%s [%s] "", originalName, connection.remoteAddress() );

        currentThread.setName( newName );
        try
        {
            return connection.processNextBatch();
        }
        finally
        {
            currentThread.setName( originalName );
        }
    }
"
759,Why is it needed here if it's already called from line 176? Not to mention that in the CDA it's run twice,"    protected boolean validateCanUpdateReadOnly(DiskValidator diskValidator) {
        if (updateReadOnlyRequested()) {
            if(getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
            }
            if (!validateVmPoolProperties()) {
                return false;
            }
            return validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface());
        }
        return true;
    }
","    protected boolean validateCanUpdateReadOnly(DiskValidator diskValidator) {
        if (updateReadOnlyRequested()) {
            if(getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
            }
START             if (!validateVmPoolProperties()) { END 
                return false;
            }
            return validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface());
        }
        return true;
    }
","    protected boolean validateCanUpdateReadOnly(DiskValidator diskValidator) {
        if (updateReadOnlyRequested()) {
            if(getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
            }
            return validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface());
        }
        return true;
    }
"
760,"while you're at it, you can remove the thises.","    public TmfEdge(TmfVertex from, TmfVertex to) {
        this.fVertexFrom = from;
        this.fVertexTo = to;
        this.fType = EdgeType.DEFAULT;
    }
","    public TmfEdge(TmfVertex from, TmfVertex to) {
        this.fVertexFrom = from;
START         this.fVertexTo = to; END 
        this.fType = EdgeType.DEFAULT;
    }
","    public TmfEdge(TmfVertex from, TmfVertex to) {
        fVertexFrom = from;
        fVertexTo = to;
        fType = EdgeType.DEFAULT;
    }
"
761,remove `resultPages.process()` -- `resultPages.iterator()` calls `process` and `getResult` as appropriate,"    public void finish()
    {
        if (state == State.NEEDS_INPUT) {
            state = State.HAS_OUTPUT;

            WorkProcessor<Page> resultPages = getSortedPages(
                    new SimplePageWithPositionComparator(sourceTypes, sortChannels, sortOrder));

            resultPages.process();
            sortedPages = resultPages.iterator();
        }
    }
","    public void finish()
    {
        if (state == State.NEEDS_INPUT) {
            state = State.HAS_OUTPUT;

            WorkProcessor<Page> resultPages = getSortedPages(
                    new SimplePageWithPositionComparator(sourceTypes, sortChannels, sortOrder));

START             resultPages.process(); END 
            sortedPages = resultPages.iterator();
        }
    }
","    public void finish()
    {
        if (state == State.NEEDS_INPUT) {
            state = State.HAS_OUTPUT;

            WorkProcessor<Page> resultPages = getSortedPages(
                    new SimplePageWithPositionComparator(sourceTypes, sortChannels, sortOrder));

            sortedPages = resultPages.iterator();
        }
    }
"
762,Should this be called at the end of child class' exit() method?,"        public void exit() {
            super.exit();
            removeMessages(BREDR_STOP_TIMEOUT);
        }
","        public void exit() {
            START  super.exit(); END 
            removeMessages(BREDR_STOP_TIMEOUT);
        }
","        public void exit() {
            removeMessages(BREDR_STOP_TIMEOUT);
            super.exit();
        }
"
763,"I find this easier to read:

```java
List<LocalProperty<Symbol>> localProperties = this.localProperties;

if (unordered) {
    localProperties = filteredCopy(localProperties, property -> !property.isOrderSensitive());
}

return new ActualProperties(global, localProperties, constants);
```","        public ActualProperties build()
        {
            List<LocalProperty<Symbol>> localProperties = unordered ? filteredCopy(this.localProperties, property -> !property.isOrderSensitive()) : this.localProperties;
            return new ActualProperties(global, localProperties, constants);
        }
","        public ActualProperties build()
        {
START             List<LocalProperty<Symbol>> localProperties = unordered ? filteredCopy(this.localProperties, property -> !property.isOrderSensitive()) : this.localProperties; END 
            return new ActualProperties(global, localProperties, constants);
        }
","        public ActualProperties build()
        {
            List<LocalProperty<Symbol>> localProperties = this.localProperties;
            if (unordered) {
                localProperties = filteredCopy(this.localProperties, property -> !property.isOrderSensitive());
            }
            return new ActualProperties(global, localProperties, constants);
        }
"
764,why toString() ?,"  public String getHeader(CharSequence headerName) {
    return headers().get(headerName.toString());
  }
","  public String getHeader(CharSequence headerName) {
START     return headers().get(headerName.toString()); END 
  }
","  public String getHeader(CharSequence headerName) {
    return headers().get(headerName);
  }
"
765,"Why are you synchronizing on ""this"" here if you are synchronizing on the lock below?","    public synchronized Uri insert(Uri uri, ContentValues initialValues) {
        SqlArguments args = new SqlArguments(uri);

        synchronized (mLock) {
            SQLiteDatabase db = mOpenHelper.getWritableDatabase();
            final long rowId = db.insert(args.table, null, initialValues);
            if (rowId <= 0) return null;

            uri = ContentUris.withAppendedId(uri, rowId);
            sendNotify(uri);

            return uri;
        }
    }
","START     public synchronized Uri insert(Uri uri, ContentValues initialValues) { END 
        SqlArguments args = new SqlArguments(uri);

        synchronized (mLock) {
            SQLiteDatabase db = mOpenHelper.getWritableDatabase();
            final long rowId = db.insert(args.table, null, initialValues);
            if (rowId <= 0) return null;

            uri = ContentUris.withAppendedId(uri, rowId);
            sendNotify(uri);

            return uri;
        }
    }
","    public Uri insert(Uri uri, ContentValues initialValues) {
        SqlArguments args = new SqlArguments(uri);

        synchronized (mLock) {
            SQLiteDatabase db = mOpenHelper.getWritableDatabase();
            final long rowId = db.insert(args.table, null, initialValues);
            if (rowId <= 0) return null;

            uri = ContentUris.withAppendedId(uri, rowId);
            sendNotify(uri);

            return uri;
        }
    }
"
766,you only need the controller inside the if block :-),"	protected void completeRemoval(IModule m) {
		// AS7 requires the .deployed markers to be removed. Other servers require no action
		try {
			IPath archiveDestination = getModuleDeployRoot(new IModule[]{m});
			IFilesystemController controller = getFilesystemController();
			boolean useAS7Behavior = DeploymentMarkerUtils.supportsJBoss7MarkerDeployment(getServer());
			if( useAS7Behavior) {
				DeploymentMarkerUtils.removedDeployedMarker(archiveDestination, controller);
				DeploymentMarkerUtils.removedDeployFailedMarker(archiveDestination, controller);
			}
		} catch(CoreException ce) {
			JBossServerCorePlugin.log(ce);
		}
	}
","	protected void completeRemoval(IModule m) {
		// AS7 requires the .deployed markers to be removed. Other servers require no action
		try {
			IPath archiveDestination = getModuleDeployRoot(new IModule[]{m});
START 			IFilesystemController controller = getFilesystemController(); END 
			boolean useAS7Behavior = DeploymentMarkerUtils.supportsJBoss7MarkerDeployment(getServer());
			if( useAS7Behavior) {
				DeploymentMarkerUtils.removedDeployedMarker(archiveDestination, controller);
				DeploymentMarkerUtils.removedDeployFailedMarker(archiveDestination, controller);
			}
		} catch(CoreException ce) {
			JBossServerCorePlugin.log(ce);
		}
	}
","	protected void completeRemoval(IModule m) {
		try {
			IPath archiveDestination = getModuleDeployRoot(new IModule[]{m});
			boolean useAS7Behavior = DeploymentMarkerUtils.supportsJBoss7MarkerDeployment(getServer());
			// AS7-derived requires the .deployed markers to be removed. Other servers require no action
			if( useAS7Behavior) {
				IFilesystemController controller = getFilesystemController();
				DeploymentMarkerUtils.removedDeployedMarker(archiveDestination, controller);
				DeploymentMarkerUtils.removedDeployFailedMarker(archiveDestination, controller);
			}
		} catch(CoreException ce) {
			JBossServerCorePlugin.log(ce);
		}
	}
"
767,Why can't `getPath` be used instead?,"    public void testViolationsByGoogleAndXpathSuppressions(@SysErr Capturable systemErr,
            @SysOut Capturable systemOut) throws Exception {
        System.setProperty(""org.checkstyle.google.suppressionxpathfilter.config"",
                ""src/test/resources/com/puppycrawl/tools/checkstyle/main/""
                        + ""InputMainViolationsForGoogleXpathSuppressions.xml"");
        Main.main(""-c"", ""/google_checks.xml"",
                getPath(""InputMainViolationsForGoogle.java""));
        assertThat(""Unexpected output log"", systemOut.getCapturedData(), is(noViolationsOutput));
        assertThat(""Unexpected system error log"", systemErr.getCapturedData(), is(""""));
    }
","    public void testViolationsByGoogleAndXpathSuppressions(@SysErr Capturable systemErr,
            @SysOut Capturable systemOut) throws Exception {
        System.setProperty(""org.checkstyle.google.suppressionxpathfilter.config"",
                ""src/test/resources/com/puppycrawl/tools/checkstyle/main/""
START                         + ""InputMainViolationsForGoogleXpathSuppressions.xml""); END 
        Main.main(""-c"", ""/google_checks.xml"",
                getPath(""InputMainViolationsForGoogle.java""));
        assertThat(""Unexpected output log"", systemOut.getCapturedData(), is(noViolationsOutput));
        assertThat(""Unexpected system error log"", systemErr.getCapturedData(), is(""""));
    }
","    public void testViolationsByGoogleAndXpathSuppressions(@SysErr Capturable systemErr,
            @SysOut Capturable systemOut) throws Exception {
        System.setProperty(""org.checkstyle.google.suppressionxpathfilter.config"",
                getPath(""InputMainViolationsForGoogleXpathSuppressions.xml""));
        Main.main(""-c"", ""/google_checks.xml"",
                getPath(""InputMainViolationsForGoogle.java""));
        assertThat(""Unexpected output log"", systemOut.getCapturedData(), is(noViolationsOutput));
        assertThat(""Unexpected system error log"", systemErr.getCapturedData(), is(""""));
    }
"
768,Did you mean to remove this println?,"    private static Map<String, String> asMap(final KeyValueStore<String, String> store) {
        final HashMap<String, String> result = new HashMap<>();
        store.all().forEachRemaining(kv -> {
            System.out.println(kv);
            result.put(kv.key, kv.value);
        });
        return result;
    }
","    private static Map<String, String> asMap(final KeyValueStore<String, String> store) {
        final HashMap<String, String> result = new HashMap<>();
        store.all().forEachRemaining(kv -> {
START             System.out.println(kv); END 
            result.put(kv.key, kv.value);
        });
        return result;
    }
","    private static Map<String, String> asMap(final KeyValueStore<String, String> store) {
        final HashMap<String, String> result = new HashMap<>();
        store.all().forEachRemaining(kv -> result.put(kv.key, kv.value));
        return result;
    }
"
769,nit: make this final,"    public Attribute createAttribute(HttpRequest request, String name, long definedSize) {
        Attribute attribute;
        if (useDisk) {
            attribute = new DiskAttribute(name, definedSize, charset);
        } else if (checkSize) {
            attribute = new MixedAttribute(name, definedSize, minSize, charset);
        } else {
            attribute = new MemoryAttribute(name, definedSize);
        }
        attribute.setMaxSize(maxSize);
        List<HttpData> list = getList(request);
        list.add(attribute);
        return attribute;
    }
","    public Attribute createAttribute(HttpRequest request, String name, long definedSize) {
START         Attribute attribute; END 
        if (useDisk) {
            attribute = new DiskAttribute(name, definedSize, charset);
        } else if (checkSize) {
            attribute = new MixedAttribute(name, definedSize, minSize, charset);
        } else {
            attribute = new MemoryAttribute(name, definedSize);
        }
        attribute.setMaxSize(maxSize);
        List<HttpData> list = getList(request);
        list.add(attribute);
        return attribute;
    }
","    public Attribute createAttribute(HttpRequest request, String name, long definedSize) {
        final Attribute attribute;
        if (useDisk) {
            attribute = new DiskAttribute(name, definedSize, charset);
        } else if (checkSize) {
            attribute = new MixedAttribute(name, definedSize, minSize, charset);
        } else {
            attribute = new MemoryAttribute(name, definedSize);
        }
        attribute.setMaxSize(maxSize);
        List<HttpData> list = getList(request);
        list.add(attribute);
        return attribute;
    }
"
770,"isActivated() already checks if dateActivated  == null, so you don't need to check if it is null again here","	public boolean isDiscontinued(Date checkDate) {
		if (dateStopped != null && autoExpireDate != null && dateStopped.after(autoExpireDate)) {
			throw new APIException(""Order.error.invalidDateStoppedAndAutoExpireDate"", (Object[]) null);
		}
		if (isVoided()) {
			return false;
		}
		if (checkDate == null) {
			checkDate = new Date();
		}
		if (dateActivated == null || !isActivated(checkDate) || dateStopped == null) {
			return false;
		}
		return checkDate.after(dateStopped);
	}
","	public boolean isDiscontinued(Date checkDate) {
		if (dateStopped != null && autoExpireDate != null && dateStopped.after(autoExpireDate)) {
			throw new APIException(""Order.error.invalidDateStoppedAndAutoExpireDate"", (Object[]) null);
		}
		if (isVoided()) {
			return false;
		}
		if (checkDate == null) {
			checkDate = new Date();
		}
START 		if (dateActivated == null || !isActivated(checkDate) || dateStopped == null) { END 
			return false;
		}
		return checkDate.after(dateStopped);
	}
","	public boolean isDiscontinued(Date checkDate) {
		if (dateStopped != null && autoExpireDate != null && dateStopped.after(autoExpireDate)) {
			throw new APIException(""Order.error.invalidDateStoppedAndAutoExpireDate"", (Object[]) null);
		}
		if (isVoided()) {
			return false;
		}
		if (checkDate == null) {
			checkDate = new Date();
		}
		if (!isActivated(checkDate) || dateStopped == null) {
			return false;
		}
		return checkDate.after(dateStopped);
	}
"
771,"For readability reasons, please add braces.","    private void operationExecuted(MatchingFrame frame) {
        if (!adapters.isEmpty()) for (ILocalSearchAdapter adapter : adapters) {
            adapter.operationExecuted(this, frame);
        }
    }
","    private void operationExecuted(MatchingFrame frame) {
        START  if (!adapters.isEmpty()) for END  (ILocalSearchAdapter adapter : adapters) {
            adapter.operationExecuted(this, frame);
        }
    }
","    private void operationExecuted(MatchingFrame frame) {
        if (!adapters.isEmpty()){
            for (ILocalSearchAdapter adapter : adapters) {
                adapter.operationExecuted(this, frame);
            }
        }
    }
"
772,"Nit-pick: please consider putting these two at the top instead of having them at the bottom.

(I think we should first prevent/stop the event and then handle it.)","    public void onClick(ClickEvent event) {
        ExpandableListViewItem eventItem = null;
        if (event.getSource() instanceof ExpandableListViewItem) {
            eventItem = (ExpandableListViewItem)event.getSource();
        }
        if (eventItem != null) {
            boolean active = eventItem.isActive();
            // Hide all, then unhide the one clicked.
            hideAllDetails();
            eventItem.toggleExpanded(!active);
            toggleExpanded();
        } else {
            // Clicked a close icon
            hideAllDetails();
        }
        event.preventDefault();
        event.stopPropagation();
    }
","    public void onClick(ClickEvent event) {
        ExpandableListViewItem eventItem = null;
        if (event.getSource() instanceof ExpandableListViewItem) {
            eventItem = (ExpandableListViewItem)event.getSource();
        }
        if (eventItem != null) {
            boolean active = eventItem.isActive();
            // Hide all, then unhide the one clicked.
            hideAllDetails();
            eventItem.toggleExpanded(!active);
            toggleExpanded();
        } else {
            // Clicked a close icon
            hideAllDetails();
        }
        event.preventDefault();
START         event.stopPropagation(); END 
    }
","    public void onClick(ClickEvent event) {
        event.preventDefault();
        event.stopPropagation();
        ExpandableListViewItem eventItem = null;
        if (event.getSource() instanceof ExpandableListViewItem) {
            eventItem = (ExpandableListViewItem)event.getSource();
        }
        if (eventItem != null) {
            boolean active = eventItem.isActive();
            // Hide all, then unhide the one clicked.
            hideAllDetails();
            eventItem.toggleExpanded(!active);
            toggleExpanded();
        } else {
            // Clicked a close icon
            hideAllDetails();
        }
    }
"
773,"For consistency, we have never declared to throw IllegalStateException for null checking. I think we should remove it for consistency.","    public void setLevel(LogLevel level) throws IllegalStateException {
        if(_config == null) {
            throw new IllegalStateException(""Cannot set logging level without a configuration"");
        }

        if(level == null) {
            level = LogLevel.NONE;
        }

        if(_level.equals(level)) {
            return;
        }

        _level = level;
        C4Log.setBinaryFileLevel(level.getValue());
    }
","START     public void setLevel(LogLevel level) throws IllegalStateException { END 
        if(_config == null) {
            throw new IllegalStateException(""Cannot set logging level without a configuration"");
        }

        if(level == null) {
            level = LogLevel.NONE;
        }

        if(_level.equals(level)) {
            return;
        }

        _level = level;
        C4Log.setBinaryFileLevel(level.getValue());
    }
","    public void setLevel(LogLevel level) {
        if(_config == null) {
            throw new IllegalStateException(""Cannot set logging level without a configuration"");
        }

        if(level == null) {
            level = LogLevel.NONE;
        }

        if(_level.equals(level)) {
            return;
        }

        _level = level;
        C4Log.setBinaryFileLevel(level.getValue());
    }
"
774,please use `long` don't need to wrap and unwrap the primitive value,"    public synchronized Long getLogTail() {
        return logMetadata.getGlobalTail();
    }
","START     public synchronized Long getLogTail() { END 
        return logMetadata.getGlobalTail();
    }
","    public synchronized long getLogTail() {
        return logMetadata.getGlobalTail();
    }
"
775,Could you please explain why we would need to store it upper case please ?,"    public FilteringXmlStreamWriter(XMLStreamWriter writer, String encoding) {
        this.writer = writer;
        this.encoding = encoding != null ? encoding.toUpperCase() : null;
    }
","    public FilteringXmlStreamWriter(XMLStreamWriter writer, String encoding) {
        this.writer = writer;
START         this.encoding = encoding != null ? encoding.toUpperCase() : null; END 
    }
","    public FilteringXmlStreamWriter(XMLStreamWriter writer, String encoding) {
        this.writer = writer;
        this.encoding = encoding;
    }
"
776,Use String.valueOf() here instead of appending an empty string,"    public String getPropertyString() {
        return ((Creeper) entity.getBukkitEntity()).getMaxFuseTicks() + """";
    }
","    public String getPropertyString() {
START         return ((Creeper) entity.getBukkitEntity()).getMaxFuseTicks() + """"; END 
    }
","    public String getPropertyString() {
        return String.valueOf(((Creeper) entity.getBukkitEntity()).getMaxFuseTicks());
    }
"
777,"I believe we can have the same selector on mobile and desktop. Please use:
`.invisible-high-impact-wrapper.interstitial .provider-container iframe`","  public static Object[][] interstitialOasis() {
    return new Object[][]{
        {
            new Page(""project43"", ""SyntheticTests/Slots/InvisibleHighImpact/Interstitial""),
            ""#INVISIBLE_HIGH_IMPACT_2 .provider-container iframe"",
            new Dimension(728, 90)
        },
    };
  }
","  public static Object[][] interstitialOasis() {
    return new Object[][]{
        {
            new Page(""project43"", ""SyntheticTests/Slots/InvisibleHighImpact/Interstitial""),
START             ""#INVISIBLE_HIGH_IMPACT_2 .provider-container iframe"", END 
            new Dimension(728, 90)
        },
    };
  }
","  public static Object[][] interstitialOasis() {
    return new Object[][]{
        {
            new Page(""project43"", ""SyntheticTests/Slots/InvisibleHighImpact/Interstitial""),
            new Dimension(728, 90)
        },
    };
  }
"
778,"Would it be worth enforcing that the map being wrapped is empty? As the newImmuatableMap() method makes a copy of the map, properly importing the keys, someone may get the wrong impression that this constructor would remove and re-insert the values currently in the map so that they will be accessible. Right now it would be possible to wrap a map that has uppercase in the key names and those members would not be able to be extracted through this interface.","  protected CaseInsensitiveMap(final Map<String, VALUE> underlyingMap) {
    this.underlyingMap = underlyingMap;
  }
","  protected CaseInsensitiveMap(final Map<String, VALUE> underlyingMap) {
START     this.underlyingMap = underlyingMap; END 
  }
","  private CaseInsensitiveMap(final Map<String, VALUE> underlyingMap) {
    this.underlyingMap = underlyingMap;
  }
"
779,"this will skip the criteria enforced by the delegate (e.g. [MaxMessageHandle](https://github.com/netty/netty/blob/4.1/transport/src/main/java/io/netty/channel/DefaultMaxMessagesRecvByteBufAllocator.java#L142-L145)). The delegate may not respect ""maybe more data"" and may have other criteria to determine it doesn't want to continue reading. The delegate also checks ""auto read"" which seems like a more natural fit for the ""read pending"" check (e.g. `is auto read enabled || someone asked to read`).","    public final boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {
        return (readPending && maybeMoreDataToRead()) || delegate.continueReading(maybeMoreDataSupplier);
    }
","    public final boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {
START         return (readPending && maybeMoreDataToRead()) || delegate.continueReading(maybeMoreDataSupplier); END 
    }
","    public final boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {
        return delegate.continueReading(maybeMoreDataSupplier);
    }
"
780,"@pynicolas why `context.getMeasure(resource, CoreMetrics.NCLOC)` again?","  private void saveZeroValueForResource(org.sonar.api.resources.File resource, SensorContext context) {
    // use non comment lines of code for coverage calculation
    Measure<Integer> nclocMeasure = context.getMeasure(resource, CoreMetrics.NCLOC);
    if (nclocMeasure != null) {
      double ncloc = context.getMeasure(resource, CoreMetrics.NCLOC).getValue();
      context.saveMeasure(resource, getZeroCoverageLineHitsDataMetric(resource, context));
      context.saveMeasure(resource, linesToCoverMetric, ncloc);
      context.saveMeasure(resource, uncoveredLinesMetric, ncloc);
    }
  }
","  private void saveZeroValueForResource(org.sonar.api.resources.File resource, SensorContext context) {
    // use non comment lines of code for coverage calculation
    Measure<Integer> nclocMeasure = context.getMeasure(resource, CoreMetrics.NCLOC);
    if (nclocMeasure != null) {
START       double ncloc = context.getMeasure(resource, CoreMetrics.NCLOC).getValue(); END 
      context.saveMeasure(resource, getZeroCoverageLineHitsDataMetric(resource, context));
      context.saveMeasure(resource, linesToCoverMetric, ncloc);
      context.saveMeasure(resource, uncoveredLinesMetric, ncloc);
    }
  }
","  private void saveZeroValueForResource(org.sonar.api.resources.File resource, SensorContext context) {
    // use non comment lines of code for coverage calculation
    Measure<Integer> nclocMeasure = context.getMeasure(resource, CoreMetrics.NCLOC);
    if (nclocMeasure != null) {
      double ncloc = nclocMeasure.getValue();
      context.saveMeasure(resource, getZeroCoverageLineHitsDataMetric(resource, context));
      context.saveMeasure(resource, linesToCoverMetric, ncloc);
      context.saveMeasure(resource, uncoveredLinesMetric, ncloc);
    }
  }
"
781,Ternary if?,"		CorsConfiguration findCorsConfiguration(String lookupPath) {

			ResourceMetadata resource = getResourceMetadata(getRepositoryBasePath(lookupPath));
			if (resource != null) {

				return createConfiguration(
						repositories.getRepositoryInformationFor(resource.getDomainType()).getRepositoryInterface());
			}

			return null;
		}
","		CorsConfiguration findCorsConfiguration(String lookupPath) {

			ResourceMetadata resource = getResourceMetadata(getRepositoryBasePath(lookupPath));
START 			if (resource != null) { END 

				return createConfiguration(
						repositories.getRepositoryInformationFor(resource.getDomainType()).getRepositoryInterface());
			}

			return null;
		}
","		CorsConfiguration findCorsConfiguration(String lookupPath) {

			ResourceMetadata resource = getResourceMetadata(getRepositoryBasePath(lookupPath));

			return resource != null ? createConfiguration(
					repositories.getRepositoryInformationFor(resource.getDomainType()).getRepositoryInterface()) : null;
		}
"
782,"Super nit: being nit-picky here, but this empty line is not necessary I think.","    public void setUp() {
        fixture = new AggregateTestFixture<>(AnnotatedAggregate.class);
        mockCommandTargetResolver = mock(CommandTargetResolver.class);

    }
","    public void setUp() {
        fixture = new AggregateTestFixture<>(AnnotatedAggregate.class);
        mockCommandTargetResolver = mock(CommandTargetResolver.class);
START  END 
    }
","    public void setUp() {
        fixture = new AggregateTestFixture<>(AnnotatedAggregate.class);
    }
"
783,Is that really possible here given that the button is not disposed?,"	public boolean handleExtraButtonPressed(int buttonId) {
		if (buttonId == QueryWizardDialog.REFRESH_BUTTON_ID) {
			if (getTaskRepository() != null) {
				refreshConfiguration(true);
			} else {
				MessageDialog.openInformation(
						Display.getCurrent().getActiveShell(),
						Messages.AbstractRepositoryQueryPage2_Update_Attributes_Failed,
						Messages.AbstractRepositoryQueryPage2_No_repository_available_please_add_one_using_the_Task_Repositories_view);
			}
			return true;
		} else if (buttonId == QueryWizardDialog.CLEAR_BUTTON_ID) {
			if (!innerComposite.isDisposed()) {
				doClearControls();
				return false;
			}
			return true;
		}
		return false;
	}
","	public boolean handleExtraButtonPressed(int buttonId) {
		if (buttonId == QueryWizardDialog.REFRESH_BUTTON_ID) {
			if (getTaskRepository() != null) {
				refreshConfiguration(true);
			} else {
				MessageDialog.openInformation(
						Display.getCurrent().getActiveShell(),
						Messages.AbstractRepositoryQueryPage2_Update_Attributes_Failed,
						Messages.AbstractRepositoryQueryPage2_No_repository_available_please_add_one_using_the_Task_Repositories_view);
			}
			return true;
		} else if (buttonId == QueryWizardDialog.CLEAR_BUTTON_ID) {
START 			if (!innerComposite.isDisposed()) { END 
				doClearControls();
				return false;
			}
			return true;
		}
		return false;
	}
","	public boolean handleExtraButtonPressed(int buttonId) {
		if (buttonId == QueryWizardDialog.REFRESH_BUTTON_ID) {
			if (getTaskRepository() != null) {
				refreshConfiguration(true);
			} else {
				MessageDialog.openInformation(
						Display.getCurrent().getActiveShell(),
						Messages.AbstractRepositoryQueryPage2_Update_Attributes_Failed,
						Messages.AbstractRepositoryQueryPage2_No_repository_available_please_add_one_using_the_Task_Repositories_view);
			}
			return true;
		} else if (buttonId == QueryWizardDialog.CLEAR_BUTTON_ID) {
			doClearControls();
			return true;
		}
		return false;
	}
"
784,why was this done?,"        public Void apply(KVariable k) {
            hasConfigVar = true;
            return null;
        }
","        public Void apply(KVariable k) {
START             hasConfigVar = true; END 
            return null;
        }
","        public void apply(KVariable k) {
            hasConfigVar = true;
        }
"
785,What's the meaning of 0 ?,"	public boolean willEnter(Object request, Object target) {
		int modifierKeys = 0;
		if (request instanceof SelectionRequest) {
			modifierKeys = ((SelectionRequest) request).getModifiers();
		}
		else if (request instanceof MouseEvent) {
			modifierKeys = ((MouseEvent) request).stateMask;
		}
		return (modifierKeys == SWT.CONTROL + SWT.SHIFT);
	}
","	public boolean willEnter(Object request, Object target) {
		int modifierKeys = START  0; END 
		if (request instanceof SelectionRequest) {
			modifierKeys = ((SelectionRequest) request).getModifiers();
		}
		else if (request instanceof MouseEvent) {
			modifierKeys = ((MouseEvent) request).stateMask;
		}
		return (modifierKeys == SWT.CONTROL + SWT.SHIFT);
	}
","	public boolean willEnter(Object request, Object target) {
		int modifierKeys = SWT.NONE;
		if (request instanceof SelectionRequest) {
			modifierKeys = ((SelectionRequest) request).getModifiers();
		}
		else if (request instanceof MouseEvent) {
			modifierKeys = ((MouseEvent) request).stateMask;
		}
		return (modifierKeys == SWT.CONTROL + SWT.SHIFT);
	}
"
786,I would check first if the value is null,"   public Object fromStorage(Object stored) {
      checkConverters();
      if (stored == null) return null;
      return encoder.fromStorage(wrapper.unwrap(stored));
   }
","   public Object fromStorage(Object stored) {
START       checkConverters(); END 
      if (stored == null) return null;
      return encoder.fromStorage(wrapper.unwrap(stored));
   }
","   public Object fromStorage(Object stored) {
      if (stored == null) return null;
      checkConverters();
      return encoder.fromStorage(wrapper.unwrap(stored));
   }
"
787,You can use ImmutableList.builder().,"    public ScalarFunctionImplementation specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionRegistry functionRegistry)
    {
        List<ScalarImplementationChoice> implementationChoices = new ArrayList<>();
        for (PolymorphicScalarFunctionChoice choice : choices) {
            implementationChoices.add(getScalarFunctionImplementationChoice(boundVariables, typeManager, functionRegistry, choice));
        }

        return new ScalarFunctionImplementation(implementationChoices, deterministic);
    }
","    public ScalarFunctionImplementation specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionRegistry functionRegistry)
    {
START         List<ScalarImplementationChoice> implementationChoices = new ArrayList<>(); END 
        for (PolymorphicScalarFunctionChoice choice : choices) {
            implementationChoices.add(getScalarFunctionImplementationChoice(boundVariables, typeManager, functionRegistry, choice));
        }

        return new ScalarFunctionImplementation(implementationChoices, deterministic);
    }
","    public ScalarFunctionImplementation specialize(BoundVariables boundVariables, int arity, TypeManager typeManager, FunctionRegistry functionRegistry)
    {
        ImmutableList.Builder<ScalarImplementationChoice> implementationChoices = ImmutableList.builder();

        for (PolymorphicScalarFunctionChoice choice : choices) {
            implementationChoices.add(getScalarFunctionImplementationChoice(boundVariables, typeManager, functionRegistry, choice));
        }

        return new ScalarFunctionImplementation(implementationChoices.build(), deterministic);
    }
"
788,"I think even in the `null` case we can return the type, see:

```
select pg_typeof(null::bigint);
 pg_typeof 
-----------
 bigint
```","    public final String evaluate(TransactionContext txnCtx, Input<Object>... args) {
        assert args.length == 1 : ""typeof expects exactly 1 argument, got: "" + args.length;
        Object arg0 = args[0].value();
        return null != arg0 ? type : DataTypes.UNDEFINED.getName();
    }
","    public final String evaluate(TransactionContext txnCtx, Input<Object>... args) {
        assert args.length == 1 : ""typeof expects exactly 1 argument, got: "" + args.length;
        Object arg0 = args[0].value();
START         return null != arg0 ? type : DataTypes.UNDEFINED.getName(); END 
    }
","    public final String evaluate(TransactionContext txnCtx, Input<Object>... args) {
        assert args.length == 1 : ""typeof expects exactly 1 argument, got: "" + args.length;
        return type;
    }
"
789,"Gotcha! :-)
Could you please add braces around the `return null`?

I probably automatically put them in there mentally around both returns that have the same indentation.","    public Document getInnerDocument() {
        IRubyObject innerDocument = getRubyProperty(""inner_document"");
        if (innerDocument.isNil())
        	return null;
		return (Document) NodeConverter.createASTNode(innerDocument);
    }
","    public Document getInnerDocument() {
        IRubyObject innerDocument = getRubyProperty(""inner_document"");
        if (innerDocument.isNil())
        	return null;
START 		return (Document) NodeConverter.createASTNode(innerDocument); END 
    }
","    public Document getInnerDocument() {
        IRubyObject innerDocument = getRubyProperty(""inner_document"");
        if (innerDocument.isNil()) {
        	return null;
        }
		return (Document) NodeConverter.createASTNode(innerDocument);
    }
"
790,"FrontendUtils is already imported at the beginning, looks like we can directly use `readJsonFromChannel` here.","    private Callback<Long> fetchStitchRequestBodyCallback(CopyingAsyncWritableChannel channel, BlobInfo blobInfo) {
      return buildCallback(frontendMetrics.postReadStitchRequestMetrics,
          bytesRead -> router.stitchBlob(blobInfo.getBlobProperties(), blobInfo.getUserMetadata(),
              getChunksToStitch(blobInfo.getBlobProperties(), FrontendUtils.readJsonFromChannel(channel)),
              routerStitchBlobCallback(blobInfo)), uri, LOGGER, finalCallback);
    }
","    private Callback<Long> fetchStitchRequestBodyCallback(CopyingAsyncWritableChannel channel, BlobInfo blobInfo) {
      return buildCallback(frontendMetrics.postReadStitchRequestMetrics,
          bytesRead -> router.stitchBlob(blobInfo.getBlobProperties(), blobInfo.getUserMetadata(),
START               getChunksToStitch(blobInfo.getBlobProperties(), FrontendUtils.readJsonFromChannel(channel)), END 
              routerStitchBlobCallback(blobInfo)), uri, LOGGER, finalCallback);
    }
","    private Callback<Long> fetchStitchRequestBodyCallback(CopyingAsyncWritableChannel channel, BlobInfo blobInfo) {
      return buildCallback(frontendMetrics.postReadStitchRequestMetrics,
          bytesRead -> router.stitchBlob(blobInfo.getBlobProperties(), blobInfo.getUserMetadata(),
              getChunksToStitch(blobInfo.getBlobProperties(), readJsonFromChannel(channel)),
              routerStitchBlobCallback(blobInfo)), uri, LOGGER, finalCallback);
    }
"
791,why not use stripe-mock?,"  public void testDeserialize() throws Exception {
    String json = getResourceAsString(""/api_fixtures/ephemeral_key.json"");
    EphemeralKey resource = APIResource.GSON.fromJson(json, EphemeralKey.class);
    assertNotNull(resource);
    assertEquals(""ephkey_123"", resource.getId());
    assertEquals(""ephemeral_key"", resource.getObject());
  }
","  public void testDeserialize() throws Exception {
    String json = getResourceAsString(""/api_fixtures/ephemeral_key.json"");
    EphemeralKey resource = APIResource.GSON.fromJson(json, EphemeralKey.class);
    assertNotNull(resource);
    assertEquals(""ephkey_123"", resource.getId());
START     assertEquals(""ephemeral_key"", resource.getObject()); END 
  }
","  public void testDeserialize() throws Exception {
    final String json = getResourceAsString(""/api_fixtures/ephemeral_key.json"");
    final EphemeralKey resource = APIResource.GSON.fromJson(json, EphemeralKey.class);
    assertNotNull(resource);
    assertEquals(""ephkey_123"", resource.getId());
    assertEquals(""ephemeral_key"", resource.getObject());
  }
"
792,Log the conflicting classes found for easier tracking.,"    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;

        throw new RuntimeException(""Only one PropertiesModule may be installed"");
    }
","    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;

START         throw new RuntimeException(""Only one PropertiesModule may be installed""); END 
    }
","    public boolean equals(Object obj) {
        // equals() is used by Guice to dedup multiple installs.  This is module has state so we only
        // allow one instance of it to ever be installed.  This equals() implementation
        // forces guice to dedup as long as it is the same exact object.  Installing multiple 
        // PropertiesPropertySource instances will result in duplicate binding errors for PropertySource
        // where the errors will provide details about where the multiple installs came from.
        return this == obj;
    }
"
793,"Note that the load method throws `AggregateNotFoundException` instead of returning `null` when an aggregate isn't found.
Please create a test case to verify this behavior.","        public void send(Message<?> message, ScopeDescriptor scopeDescription) throws Exception {
            if (canResolve(scopeDescription)) {
                String aggregateIdentifier = ((AggregateScopeDescriptor) scopeDescription).getIdentifier().toString();
                Aggregate<T> aggregate = load(aggregateIdentifier);
                if (aggregate != null) {
                    aggregate.handle(message);
                } else {
                    logger.debug(""Aggregate (with id: [{}]) cannot be loaded. Hence, message '[{}]' cannot be handled."",
                                 aggregateIdentifier, message);
                }
            }
        }
","        public void send(Message<?> message, ScopeDescriptor scopeDescription) throws Exception {
            if (canResolve(scopeDescription)) {
                String aggregateIdentifier = ((AggregateScopeDescriptor) scopeDescription).getIdentifier().toString();
                Aggregate<T> aggregate = load(aggregateIdentifier);
START                 if (aggregate != null) { END 
                    aggregate.handle(message);
                } else {
                    logger.debug(""Aggregate (with id: [{}]) cannot be loaded. Hence, message '[{}]' cannot be handled."",
                                 aggregateIdentifier, message);
                }
            }
        }
","        public void send(Message<?> message, ScopeDescriptor scopeDescription) throws Exception {
            if (canResolve(scopeDescription)) {
                String aggregateIdentifier = ((AggregateScopeDescriptor) scopeDescription).getIdentifier().toString();
                load(aggregateIdentifier).handle(message);
            }
        }
"
794,"Minor - Version's compareTo does a null check, so you may not need the vdsGroup.getcompatibility_version() != null","    protected void UpdateDetailsAvailability() {
        super.UpdateDetailsAvailability();
        VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
        getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService()
                && vdsGroup.getcompatibility_version() != null
                && Version.v3_2.compareTo(vdsGroup.getcompatibility_version()) <= 0);
    }
","    protected void UpdateDetailsAvailability() {
        super.UpdateDetailsAvailability();
        VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
        getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService()
START                 && vdsGroup.getcompatibility_version() != null END 
                && Version.v3_2.compareTo(vdsGroup.getcompatibility_version()) <= 0);
    }
","    protected void UpdateDetailsAvailability() {
        super.UpdateDetailsAvailability();
        VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
        getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService()
                && Version.v3_2.compareTo(vdsGroup.getcompatibility_version()) <= 0);
    }
"
795,"This should be a simple setter (that is now deprecated). It shouldn't mess with the system property, in favor of which it is deprecated, because  System.setProperty() is dangerous: presume that a single JVM process runs 2 solver configs, constructed by java (not by xml) and the first one calls setGenerateDroolsTestOnError(true), but the second one doesn't. The second one would feel it too.

=> remove that if-else block","    public void setGenerateDroolsTestOnError(Boolean generateDroolsTestOnError) {
        if (BooleanUtils.isTrue(generateDroolsTestOnError)) {
            System.setProperty(GENERATE_DROOLS_TEST_ON_ERROR_PROPERTY_NAME, ""true"");
        } else {
            System.clearProperty(GENERATE_DROOLS_TEST_ON_ERROR_PROPERTY_NAME);
        }
        this.generateDroolsTestOnError = generateDroolsTestOnError;
    }
","    public void setGenerateDroolsTestOnError(Boolean generateDroolsTestOnError) {
        if (BooleanUtils.isTrue(generateDroolsTestOnError)) {
            System.setProperty(GENERATE_DROOLS_TEST_ON_ERROR_PROPERTY_NAME, ""true"");
        } else {
            System.clearProperty(GENERATE_DROOLS_TEST_ON_ERROR_PROPERTY_NAME);
        }
START         this.generateDroolsTestOnError = generateDroolsTestOnError; END 
    }
","    public void setGenerateDroolsTestOnError(Boolean generateDroolsTestOnError) {
        this.generateDroolsTestOnError = generateDroolsTestOnError;
    }
"
796,You could save a few lines by moving the return null into the default case instead of break.,"    public static String getMessageFromValue(final int value) {
        switch (value) {
            case INVALID_DATE:
                return ""Can only access during valid times:"";
            case INVALID_PERMISSION:
                return ""Can only perform task with valid permission"";
            case NO_AUTH_SENT:
                return ""No Authentication Information was received"";
            default:
                break;
        }
        return null;
    }
","    public static String getMessageFromValue(final int value) {
        switch (value) {
            case INVALID_DATE:
                return ""Can only access during valid times:"";
            case INVALID_PERMISSION:
                return ""Can only perform task with valid permission"";
            case NO_AUTH_SENT:
                return ""No Authentication Information was received"";
            default:
                break;
        }
START         return null; END 
    }
","    public static String getMessageFromValue(final int value) {
        switch (value) {
            case INVALID_DATE:
                return ""Can only access during valid times:"";
            case INVALID_PERMISSION:
                return ""Can only perform task with valid permission"";
            case NO_AUTH_SENT:
                return ""No Authentication Information was received"";
            default:
                return null;
        }
    }
"
797,"need to check that getVm() is not null and also use it in canDoAction and also new audit log for the user to know it was skipped.
please see usage example in StopVmCommandBase and ShutdownVmCommand","    protected boolean shouldSkipCommandExecution() {
        return StringUtils.equals(getVm().getCurrentCd(), getParameters().getCdImagePath());
    }
","    protected boolean shouldSkipCommandExecution() {
START         return StringUtils.equals(getVm().getCurrentCd(), getParameters().getCdImagePath()); END 
    }
","    protected boolean shouldSkipCommandExecution() {
        if (getVm() == null) {
            return false;
        }

        return StringUtils.equals(getVm().getCurrentCd(), getParameters().getCdImagePath());
    }
"
798,"``` java
for (int seconds = 0; seconds < 20; seconds++) {
```

this also have to be changed. Maybe to this code:

``` java
for (int seconds = 0; seconds < 100; seconds+=5) {
```","  public static boolean verifyOozieJobStatus(OozieClient client, String processName,
                                             ENTITY_TYPE entityType, Job.Status expectedStatus)
    throws OozieClientException, InterruptedException {
    for (int seconds = 0; seconds < 20; seconds++) {
      Job.Status status = getOozieJobStatus(client, processName, entityType);
      logger.info(""Current status: "" + status);
      if (status == expectedStatus) {
        return true;
      }
      TimeUnit.SECONDS.sleep(5);
    }
    return false;
  }
","  public static boolean verifyOozieJobStatus(OozieClient client, String processName,
                                             ENTITY_TYPE entityType, Job.Status expectedStatus)
    throws OozieClientException, InterruptedException {
    for (int seconds = 0; seconds < 20; seconds++) {
      Job.Status status = getOozieJobStatus(client, processName, entityType);
      logger.info(""Current status: "" + status);
      if (status == expectedStatus) {
        return true;
      }
START       TimeUnit.SECONDS.sleep(5); END 
    }
    return false;
  }
","  public static boolean verifyOozieJobStatus(OozieClient client, String processName,
                                             ENTITY_TYPE entityType, Job.Status expectedStatus)
    throws OozieClientException, InterruptedException {
    for (int seconds = 0; seconds < 100; seconds+=5) {
      Job.Status status = getOozieJobStatus(client, processName, entityType);
      logger.info(""Current status: "" + status);
      if (status == expectedStatus) {
        return true;
      }
      TimeUnit.SECONDS.sleep(5);
    }
    return false;
  }
"
799,You forgot to call super.init(),"	public void init() throws KalturaManagerException {
		KalturaEventsManager.registerEventConsumer(this, KalturaEventType.STREAM_PUBLISHED, KalturaEventType.STREAM_UNPUBLISHED, KalturaMediaEventType.APPLICATION_INSTANCE_STARTED);
		liveManager = KalturaServer.getManager(ILiveManager.class);
		setInitialized();
	}
","	public void init() throws KalturaManagerException {
START 		KalturaEventsManager.registerEventConsumer(this, KalturaEventType.STREAM_PUBLISHED, KalturaEventType.STREAM_UNPUBLISHED, KalturaMediaEventType.APPLICATION_INSTANCE_STARTED); END 
		liveManager = KalturaServer.getManager(ILiveManager.class);
		setInitialized();
	}
","	public void init() throws KalturaManagerException {
		super.init();
		KalturaEventsManager.registerEventConsumer(this, KalturaEventType.STREAM_PUBLISHED, KalturaEventType.STREAM_UNPUBLISHED, KalturaMediaEventType.APPLICATION_INSTANCE_STARTED);
		liveManager = KalturaServer.getManager(ILiveManager.class);
		setInitialized();
	}
"
800,"Recursive call to `transform(g, m)` could also be possible here.","	public static final void transform(Group group, Matrix4d m) {
		for (Atom atom : group.getAtoms()) {
			transform(atom, m);
		}
		for (Group altG : group.getAltLocs()) {
			for (Atom atom : altG.getAtoms()) {
				transform(atom, m);
			}				
		}
	}
","	public static final void transform(Group group, Matrix4d m) {
		for (Atom atom : group.getAtoms()) {
			transform(atom, m);
		}
		for (Group altG : group.getAltLocs()) {
START 			for (Atom atom : altG.getAtoms()) { END 
				transform(atom, m);
			}				
		}
	}
","	public static final void transform(Group group, Matrix4d m) {
		for (Atom atom : group.getAtoms()) {
			transform(atom, m);
		}
		for (Group altG : group.getAltLocs()) {
			transform(altG, m);
		}
	}
"
801,Here we use it as the same key as we use to create the fReviewList,"	public void updateReviewItem(ChangeInfo task) {
		fReviewList.put(task.getChange_id(), task); //Here we keep the change_id because it is shown to the user
	}
","	public void updateReviewItem(ChangeInfo task) {
START 		fReviewList.put(task.getChange_id(), task); //Here we keep the change_id because it is shown to the user END 
	}
","	public void updateReviewItem(ChangeInfo task) {
		fReviewList.put(task.getId(), task);
	}
"
802,"Could use the same pattern as https://github.com/jclouds/jclouds-labs/blob/master/azurecompute-arm/src/main/java/org/jclouds/azurecompute/arm/domain/ComputeNode.java#L28, i.e.

    return (Protocol) GetEnumValue.fromValueOrDefault(value, Protocol.UNRECOGNIZED);","              public static Protocol fromValue(String value) {
                 Protocol[] items = Protocol.values();
                 for (Protocol item : items) {
                    if (item.toString().equalsIgnoreCase(value)) {
                       return item;
                    }
                 }
                 return (Protocol) GetEnumValue.fromValueOrDefault(value, UNRECOGNIZED);
              }
","              public static Protocol fromValue(String value) {
START                  Protocol[] items = Protocol.values(); END 
                 for (Protocol item : items) {
                    if (item.toString().equalsIgnoreCase(value)) {
                       return item;
                    }
                 }
                 return (Protocol) GetEnumValue.fromValueOrDefault(value, UNRECOGNIZED);
              }
","              public static Protocol fromValue(String value) {
                  return (Protocol) GetEnumValue.fromValueOrDefault(value, Protocol.UNRECOGNIZED);
              }
"
803,"These look like they can simplify to:

```java
binnedRanges.computeIfAbsent(location, k -> new HashMap<>())
  .computeIfAbsent(ke, k -> new ArrayList<>())
  .add(range);
```","  protected static void addRange(Map<String,Map<KeyExtent,List<Range>>> binnedRanges,
      String location, KeyExtent ke, Range range) {
    Map<KeyExtent,List<Range>> tablets =
        binnedRanges.computeIfAbsent(location, k -> new HashMap<>());

    List<Range> tabletsRanges = tablets.computeIfAbsent(ke, k -> new ArrayList<>());

    tabletsRanges.add(range);
  }
","  protected static void addRange(Map<String,Map<KeyExtent,List<Range>>> binnedRanges,
      String location, KeyExtent ke, Range range) {
START     Map<KeyExtent,List<Range>> tablets =
        binnedRanges.computeIfAbsent(location, k -> new HashMap<>());

    List<Range> tabletsRanges = tablets.computeIfAbsent(ke, k -> new ArrayList<>()); END 

    tabletsRanges.add(range);
  }
","  protected static void addRange(Map<String,Map<KeyExtent,List<Range>>> binnedRanges,
      String location, KeyExtent ke, Range range) {
    binnedRanges.computeIfAbsent(location, k -> new HashMap<>())
        .computeIfAbsent(ke, k -> new ArrayList<>()).add(range);
  }
"
804,Constructor should be private. Make a static factory method,"    public ChannelWriteController(
            ApplicationConfigurationFetcher appConfigFetcher,
            ChannelStore store,
            ModelReader reader,
            ChannelModelTransformer channelTransformer
    ) {
        this.appConfigFetcher = checkNotNull(appConfigFetcher);
        this.store = checkNotNull(store);
        this.reader = checkNotNull(reader);
        this.channelTransformer = checkNotNull(channelTransformer);
    }
","START     public ChannelWriteController( END 
            ApplicationConfigurationFetcher appConfigFetcher,
            ChannelStore store,
            ModelReader reader,
            ChannelModelTransformer channelTransformer
    ) {
        this.appConfigFetcher = checkNotNull(appConfigFetcher);
        this.store = checkNotNull(store);
        this.reader = checkNotNull(reader);
        this.channelTransformer = checkNotNull(channelTransformer);
    }
","    private ChannelWriteController(
            ApplicationConfigurationFetcher appConfigFetcher,
            ChannelStore store,
            ModelReader reader,
            ChannelModelTransformer channelTransformer
    ) {
        this.appConfigFetcher = checkNotNull(appConfigFetcher);
        this.store = checkNotNull(store);
        this.reader = checkNotNull(reader);
        this.channelTransformer = checkNotNull(channelTransformer);
    }
"
805,"replace this file with ""previous version"" and commit again - it should remove it from this review","		public TestGerritClient(TaskRepository repository, AbstractWebLocation location) {
			super(repository, GerritFixture.current().getGerritVersion());
			System.out.println(""Testing against Gerrit "" + GerritFixture.current().getGerritVersion());
			initialize(location, null, null, null, null);
		}
","		public TestGerritClient(TaskRepository repository, AbstractWebLocation location) {
			super(repository, GerritFixture.current().getGerritVersion());
START 			System.out.println(""Testing against Gerrit "" + GerritFixture.current().getGerritVersion()); END 
			initialize(location, null, null, null, null);
		}
","		public TestGerritClient(TaskRepository repository, AbstractWebLocation location) {
			super(repository, GerritFixture.current().getGerritVersion());
			initialize(location, null, null, null, null);
		}
"
806,The empty string here is redundent,"    private String GetLocalStoragesFormattedString()
    {
        StringBuilder localStorages = new StringBuilder(""""); //$NON-NLS-1$
        for (StorageDomain a : Linq.<StorageDomain> cast(getSelectedItems()))
        {
            if (a.getStorageType() == StorageType.LOCALFS)
            {
                localStorages.append(a.getStorageName()).append("", ""); //$NON-NLS-1$
            }
        }
        return localStorages.substring(0, localStorages.length() - 2);
    }
","    private String GetLocalStoragesFormattedString()
    {
        StringBuilder localStorages = new StringBuilder(""""); //$NON-NLS-1$
START         for (StorageDomain a : Linq.<StorageDomain> cast(getSelectedItems())) END 
        {
            if (a.getStorageType() == StorageType.LOCALFS)
            {
                localStorages.append(a.getStorageName()).append("", ""); //$NON-NLS-1$
            }
        }
        return localStorages.substring(0, localStorages.length() - 2);
    }
","    private String GetLocalStoragesFormattedString()
    {
        StringBuilder localStorages = new StringBuilder();
        for (StorageDomain a : Linq.<StorageDomain> cast(getSelectedItems()))
        {
            if (a.getStorageType() == StorageType.LOCALFS)
            {
                localStorages.append(a.getStorageName()).append("", ""); //$NON-NLS-1$
            }
        }
        return localStorages.substring(0, localStorages.length() - 2);
    }
"
807,Why are you setting these from here? Why are they class level variables?,"	public void setup() {
		generator = new SequentialIdentifierGenerator();
		handler = new SequentialIdentifierGeneratorResourceHandler();
	}
","	public void setup() {
START 		generator = new SequentialIdentifierGenerator(); END 
		handler = new SequentialIdentifierGeneratorResourceHandler();
	}
","	public void setup() {
		handler = new SequentialIdentifierGeneratorResourceHandler();
	}
"
808,"I don't understand how ignoring the UI event when the Diff base popup selects another field in edit mode fixes the linked issue.

A more descriptive commit message would help.

Is the diffBase widget just supposed to be disabled or invisible in edit mode?","  void onChangeRevision(@SuppressWarnings(""unused"") ChangeEvent e) {
    int idx = diffBase.getSelectedIndex();
    if (0 <= idx && fileTableMode == FileTable.Mode.REVIEW) {
      String n = diffBase.getValue(idx);
      loadConfigInfo(changeInfo, !n.isEmpty() ? n : null);
    }
  }
","  void onChangeRevision(@SuppressWarnings(""unused"") ChangeEvent e) {
    int idx = diffBase.getSelectedIndex();
START     if (0 <= idx && fileTableMode == FileTable.Mode.REVIEW) { END 
      String n = diffBase.getValue(idx);
      loadConfigInfo(changeInfo, !n.isEmpty() ? n : null);
    }
  }
","  void onChangeRevision(@SuppressWarnings(""unused"") ChangeEvent e) {
    int idx = diffBase.getSelectedIndex();
    if (0 <= idx) {
      String n = diffBase.getValue(idx);
      loadConfigInfo(changeInfo, !n.isEmpty() ? n : null);
    }
  }
"
809,this should be removed,"    public String getFingerprint(Schema schema) {
        if (theClient == null)
        {
            theClient = initializeClient();
        }
        String subject = schema.getName();
        final int guid;
        try {
            guid = theClient.register(subject, schema);
            System.out.println(""GUID: ["" + guid + ""]"");
        } catch (IOException | RestClientException e) {
            throw new RuntimeException(e);
        }
        return Integer.toString(guid);
    }
","    public String getFingerprint(Schema schema) {
        if (theClient == null)
        {
            theClient = initializeClient();
        }
        String subject = schema.getName();
        final int guid;
        try {
            guid = theClient.register(subject, schema);
START             System.out.println(""GUID: ["" + guid + ""]""); END 
        } catch (IOException | RestClientException e) {
            throw new RuntimeException(e);
        }
        return Integer.toString(guid);
    }
","    public String getFingerprint(Schema schema) {
        final String subject = schema.getName();
        final int guid;
        try {
            guid = theClient.register(subject, schema);
        } catch (IOException | RestClientException e) {
            throw new RuntimeException(e);
        }
        return Integer.toString(guid);
    }
"
810,Actually I was testing that and trying to import the declaring type just below. So I assume you had a problem somewhere importing a declaring type: the condition below is useless then...,"	private boolean declaringTypeIsLocalOrImported(CtTypeReference declaringType) {
		if (declaringType != null) {
			if (!isTypeInCollision(declaringType, false) && (isImportedInClassImports(declaringType) || classNamePresentInJavaLang(declaringType))) {
				return true;
			}

			if (!isTypeInCollision(declaringType, false) && addClassImport(declaringType)) {
				return true;
			}

			while (declaringType != null) {
				if (declaringType.equals(targetType)) {
					return true;
				}
				declaringType = declaringType.getDeclaringType();
			}

		}
		return false;
	}
","	private boolean declaringTypeIsLocalOrImported(CtTypeReference declaringType) {
		if (declaringType != null) {
START 			if (!isTypeInCollision(declaringType, false) && (isImportedInClassImports(declaringType) || classNamePresentInJavaLang(declaringType))) { END 
				return true;
			}

			if (!isTypeInCollision(declaringType, false) && addClassImport(declaringType)) {
				return true;
			}

			while (declaringType != null) {
				if (declaringType.equals(targetType)) {
					return true;
				}
				declaringType = declaringType.getDeclaringType();
			}

		}
		return false;
	}
","	private boolean declaringTypeIsLocalOrImported(CtTypeReference declaringType) {
		if (declaringType != null) {
			if (!isTypeInCollision(declaringType, false) && addClassImport(declaringType)) {
				return true;
			}

			if (isImportedInClassImports(declaringType) || classNamePresentInJavaLang(declaringType)) {
				return true;
			}

			while (declaringType != null) {
				if (declaringType.equals(targetType)) {
					return true;
				}
				declaringType = declaringType.getDeclaringType();
			}

		}
		return false;
	}
"
811,@prondzyn `++ index`,"    MkNotifications(final int quantity) {
        this.notifications = new ArrayList<Notification>(quantity);
        for (int index = 0; index < quantity; index += 1) {
            this.notifications.add(index, new MkNotification(index));
        }
    }
","    MkNotifications(final int quantity) {
        this.notifications = new ArrayList<Notification>(quantity);
START         for (int index = 0; index < quantity; index += 1) { END 
            this.notifications.add(index, new MkNotification(index));
        }
    }
","    MkNotifications(final int quantity) {
        this.notifications = new ArrayList<Notification>(quantity);
        for (int index = 0; index < quantity; ++index) {
            this.notifications.add(index, new MkNotification(index));
        }
    }
"
812,The left side should be the preferred style (annotations in an extra line).,"    @Override public String setCity(String city) {
        return city;
    }
","START     @Override public String setCity(String city) { END 
        return city;
    }
","    public String setCity(String city) {
        return city;
    }
"
813,`throws Exception`,"  private static SSLFactory getSSLFactoryIfRequired(VerifiableProperties verifiableProperties)
      throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException,
             IllegalAccessException {
    boolean sslRequired = new NettyConfig(verifiableProperties).nettyServerEnableSSL
        || new ClusterMapConfig(verifiableProperties).clusterMapSslEnabledDatacenters.length() > 0;
    return sslRequired? SSLFactory.getNewInstance(new SSLConfig(verifiableProperties)) : null;
  }
","  private static SSLFactory getSSLFactoryIfRequired(VerifiableProperties verifiableProperties)
START       throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, END 
             IllegalAccessException {
    boolean sslRequired = new NettyConfig(verifiableProperties).nettyServerEnableSSL
        || new ClusterMapConfig(verifiableProperties).clusterMapSslEnabledDatacenters.length() > 0;
    return sslRequired? SSLFactory.getNewInstance(new SSLConfig(verifiableProperties)) : null;
  }
","  private static SSLFactory getSSLFactoryIfRequired(VerifiableProperties verifiableProperties) throws Exception {
    boolean sslRequired = new NettyConfig(verifiableProperties).nettyServerEnableSSL
        || new ClusterMapConfig(verifiableProperties).clusterMapSslEnabledDatacenters.length() > 0;
    return sslRequired ? SSLFactory.getNewInstance(new SSLConfig(verifiableProperties)) : null;
  }
"
814,"The newly added line makes me think about DRY for some reason. :D
How about...

```java
return LIMIT(String.valueOf(value));
```","  public T LIMIT(int value) {
    sql().limit = String.valueOf(value);
    sql().limitingRowsStrategy = SQLStatement.LimitingRowsStrategy.OFFSET_LIMIT;
    return getSelf();
  }
","  public T LIMIT(int value) {
    sql().limit = String.valueOf(value);
    sql().limitingRowsStrategy = SQLStatement.LimitingRowsStrategy.OFFSET_LIMIT;
START     return getSelf(); END 
  }
","  public T LIMIT(int value) {
    return LIMIT(String.valueOf(value));
  }
"
815,Please follow existed coding style and put new line after Override,"    @Override public void testSiteBuildWithForkedMojo() throws Exception {
        // TODO currently failing, apparently from NPE in DefaultDependencyGraphBuilder.canFindCoreClass after failing to resolve an artifact from the test project
    }
","START     @Override public void testSiteBuildWithForkedMojo() throws Exception { END 
        // TODO currently failing, apparently from NPE in DefaultDependencyGraphBuilder.canFindCoreClass after failing to resolve an artifact from the test project
    }
","    public void testSiteBuildWithForkedMojo() throws Exception {
        // TODO currently failing, apparently from NPE in DefaultDependencyGraphBuilder.canFindCoreClass after failing to resolve an artifact from the test project
    }
"
816,"This can just be ""if (txInput.....) return true"" right? No need to continue looping after finding that the condition is correct.","    boolean spends(Transaction txA, Transaction txB) {
        boolean spends = false;
        for (TransactionInput txInput : txA.getInputs()) {
            spends |= txInput.getOutpoint().getHash().equals(txB.getHash());
        }
        return spends;
    }
","    boolean spends(Transaction txA, Transaction txB) {
        boolean spends = false;
        for (TransactionInput txInput : txA.getInputs()) {
START             spends |= txInput.getOutpoint().getHash().equals(txB.getHash()); END 
        }
        return spends;
    }
","    boolean spends(Transaction txA, Transaction txB) {
        for (TransactionInput txInput : txA.getInputs()) {
            if (txInput.getOutpoint().getHash().equals(txB.getHash())) {
                return true;
            }
        }
        return false;
    }
"
817,"new echo server for every test or will a single one for all tests suffice? If a single one will suffice, then you could declare all variables used here as static and turn these two functions into @BeforeClass and @AfterClass","  public void setup()
      throws Exception {
    sslFactory = TestUtils.createSSLFactory();
    SSLContext sslContext = sslFactory.createSSLContext();
    sslSocketFactory = sslContext.getSocketFactory();
    sslEchoServer = new SSLBlockingEchoServer(sslFactory, sslPort);
    sslEchoServer.start();
  }
","  public void setup()
START       throws Exception { END 
    sslFactory = TestUtils.createSSLFactory();
    SSLContext sslContext = sslFactory.createSSLContext();
    sslSocketFactory = sslContext.getSocketFactory();
    sslEchoServer = new SSLBlockingEchoServer(sslFactory, sslPort);
    sslEchoServer.start();
  }
","  public void setup()
      throws Exception {
  }
"
818,not needed in this method?,"    public boolean isFinished()
    {
        checkState(initialized.get(), ""Driver is not initialized"");
        checkLockNotHeld(""Can not check finished status while holding the driver lock"");

        // if we can get the lock, attempt a clean shutdown; otherwise someone else will shutdown
        Optional<Boolean> result = tryWithLock(this::isFinishedInternal);
        return result.orElseGet(() -> state.get() != State.ALIVE || driverContext.isDone());
    }
","    public boolean isFinished()
    {
START         checkState(initialized.get(), ""Driver is not initialized""); END 
        checkLockNotHeld(""Can not check finished status while holding the driver lock"");

        // if we can get the lock, attempt a clean shutdown; otherwise someone else will shutdown
        Optional<Boolean> result = tryWithLock(this::isFinishedInternal);
        return result.orElseGet(() -> state.get() != State.ALIVE || driverContext.isDone());
    }
","    public boolean isFinished()
    {
        checkLockNotHeld(""Can not check finished status while holding the driver lock"");

        // if we can get the lock, attempt a clean shutdown; otherwise someone else will shutdown
        Optional<Boolean> result = tryWithLock(this::isFinishedInternal);
        return result.orElseGet(() -> state.get() != State.ALIVE || driverContext.isDone());
    }
"
819,"There is a 3 param constructor, we can call this to reduce code rep..","    public Node(String address, String logPath) {
        this.address = address;
        this.logPath = logPath;
        this.shutdown = new ShutdownAction(this);
        this.start = new StartAction(this);
    }
","START     public Node(String address, String logPath) { END 
        this.address = address;
        this.logPath = logPath;
        this.shutdown = new ShutdownAction(this);
        this.start = new StartAction(this);
    }
","    public Node(String address, String logPath) {
        this(address, null, logPath);
    }
"
820,"What kind of Exception can be thrown here? Could this be made more specific?

Also, is it possible to use some other mechanism of detecting whatever problem this exception is detecting? Exceptions are quite slow compared to other forms of flow control and so I'm concerned about using them in a post-aggregator `compute` function.","  private double cumulativeProbability(double x) {
    try {
      NormalDistribution normDist = new NormalDistribution();
      return normDist.cumulativeProbability(x);
    } catch (Exception ex) {
      return Double.NaN;
    }
  }
","  private double cumulativeProbability(double x) {
    try {
      NormalDistribution normDist = new NormalDistribution();
      return normDist.cumulativeProbability(x);
START     } catch (Exception ex) { END 
      return Double.NaN;
    }
  }
","  private double cumulativeProbability(double x)
  {
    try {
      NormalDistribution normDist = new NormalDistribution();
      return normDist.cumulativeProbability(x);
    }
    catch (IllegalArgumentException ex) {
      return Double.NaN;
    }
  }
"
821,Actually I see the code may well apply if the scan is in progress,"    public Response afterLRA(@HeaderParam(LRA.LRA_HTTP_ENDED_CONTEXT_HEADER) URI endedLRAId) {
        if (afterLRACounter.getAndIncrement() < 2) {
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }

        return Response.ok().build();
    }
","    public Response afterLRA(@HeaderParam(LRA.LRA_HTTP_ENDED_CONTEXT_HEADER) URI endedLRAId) {
START         if (afterLRACounter.getAndIncrement() < 2) { END 
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }

        return Response.ok().build();
    }
","    public Response afterLRA(@HeaderParam(LRA.LRA_HTTP_ENDED_CONTEXT_HEADER) URI endedLRAId) {
        if (afterLRACounter.getAndIncrement() < 1) {
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }

        return Response.ok().build();
    }
"
822,"Does this really work? That validate method i think expects non hashed passwords, probably you shouldn't validate this, the ticket says changePassword methods. I also think these should delegate to the changePassword method that validates the password to centralize the code","	public void changeHashedPassword(User user, String hashedPassword, String salt) throws APIException {
		OpenmrsUtil.validatePassword(user.getUsername(), hashedPassword, user.getSystemId());

		dao.changeHashedPassword(user, hashedPassword, salt);
	}
","	public void changeHashedPassword(User user, String hashedPassword, String salt) throws APIException {
START 		OpenmrsUtil.validatePassword(user.getUsername(), hashedPassword, user.getSystemId()); END 

		dao.changeHashedPassword(user, hashedPassword, salt);
	}
","	public void changeHashedPassword(User user, String hashedPassword, String salt) throws APIException {
		dao.changeHashedPassword(user, hashedPassword, salt);
	}
"
823,Consider adding `queryContext.getRequiredTaskContext(taskId)` to do this in one shot without the `Optional`,"        public void updateSystemMemoryUsage(long deltaMemoryInBytes)
        {
            if (taskContext == null) {
                Optional<TaskContext> taskContext = queryContext.getTaskContextByTaskId(taskId);
                verify(taskContext.isPresent(), ""task does not exist"");
                this.taskContext = taskContext.get();
            }
            if (deltaMemoryInBytes > 0) {
                taskContext.reserveSystemMemory(deltaMemoryInBytes);
            }
            else {
                taskContext.freeSystemMemory(-deltaMemoryInBytes);
            }
        }
","        public void updateSystemMemoryUsage(long deltaMemoryInBytes)
        {
            if (taskContext == null) {
START                 Optional<TaskContext> taskContext = queryContext.getTaskContextByTaskId(taskId); END 
                verify(taskContext.isPresent(), ""task does not exist"");
                this.taskContext = taskContext.get();
            }
            if (deltaMemoryInBytes > 0) {
                taskContext.reserveSystemMemory(deltaMemoryInBytes);
            }
            else {
                taskContext.freeSystemMemory(-deltaMemoryInBytes);
            }
        }
","        public void updateSystemMemoryUsage(long deltaMemoryInBytes)
        {
            if (taskContext == null) {
                taskContext = queryContext.getTaskContextByTaskId(taskId);
            }
            if (deltaMemoryInBytes > 0) {
                taskContext.reserveSystemMemory(deltaMemoryInBytes);
            }
            else {
                taskContext.freeSystemMemory(-deltaMemoryInBytes);
            }
        }
"
824,static import,"    public void testAllOutputsReferenced()
            throws Exception
    {
        tester().assertThat(new PruneAggregationColumns())
                .on(p -> buildProjectedAggregation(p, Predicates.alwaysTrue()))
                .doesNotFire();
    }
","    public void testAllOutputsReferenced()
            throws Exception
    {
        tester().assertThat(new PruneAggregationColumns())
START                 .on(p -> buildProjectedAggregation(p, Predicates.alwaysTrue())) END 
                .doesNotFire();
    }
","    public void testAllOutputsReferenced()
            throws Exception
    {
        tester().assertThat(new PruneAggregationColumns())
                .on(p -> buildProjectedAggregation(p, alwaysTrue()))
                .doesNotFire();
    }
"
825,synchronized,"	public void setSessionRollbackCount(int count) {
		sessionRollbackCount = count;
	}
","START 	public void setSessionRollbackCount(int count) { END 
		sessionRollbackCount = count;
	}
","	public synchronized void setSessionRollbackCount(int count) {
		sessionRollbackCount = count;
	}
"
826,This doesn't seem aligned with the original implementation,"    public PermissionTypeColumn() {
        makeSortable(Comparator.comparing(p -> !resources.userImage().equals(p)));
    }
","    public PermissionTypeColumn() {
START         makeSortable(Comparator.comparing(p -> !resources.userImage().equals(p))); END 
    }
","    public PermissionTypeColumn() {
        makeSortable(Comparator.comparing(p -> !resources.userImage().equals(getValue(p))));
    }
"
827,we can also get rid of the parenthesis by the way.,"	private boolean hasSameSeparateDerivedEncodings() {
		return (separateDerivedEncodingsButton == null)
				|| (separateDerivedEncodingsButton.getSelection() == getStoredSeparateDerivedEncodingsValue());
	}
","	private boolean hasSameSeparateDerivedEncodings() {
START 		return (separateDerivedEncodingsButton == null) END 
				|| (separateDerivedEncodingsButton.getSelection() == getStoredSeparateDerivedEncodingsValue());
	}
","	private boolean hasSameSeparateDerivedEncodings() {
		return separateDerivedEncodingsButton == null
			|| separateDerivedEncodingsButton.getSelection() == getStoredSeparateDerivedEncodingsValue();
	}
"
828,not synchronized?,"  void setMetric(Object metric) {
    this.metric = metric;
  }
","START   void setMetric(Object metric) { END 
    this.metric = metric;
  }
","  synchronized void setMetric(Object metric) {
    this.metric = metric;
  }
"
829,Why public ?,"  public ProgramState stackValue(SymbolicValue sv) {
    Deque<SymbolicValue> newStack = new LinkedList<>(stack);
    newStack.push(sv);
    return new ProgramState(this, newStack);
  }
","START   public ProgramState stackValue(SymbolicValue sv) { END 
    Deque<SymbolicValue> newStack = new LinkedList<>(stack);
    newStack.push(sv);
    return new ProgramState(this, newStack);
  }
","  ProgramState stackValue(SymbolicValue sv) {
    Deque<SymbolicValue> newStack = new LinkedList<>(stack);
    newStack.push(sv);
    return new ProgramState(this, newStack);
  }
"
830,Can we use .equals() instead of .compareTo?,"    private CertificateDTO addCertByChild(List<CertificateDTO> toList, List<CertificateDTO> fromList, CertificateDTO child){
        if (null != child && CollectionUtils.isNotEmpty(fromList)) {
            for(CertificateDTO cert : fromList){
                if(child.getAuthorityKeyID().compareTo(cert.getSubjectKeyID())==0){
                    toList.add(cert);
                    fromList.remove(cert);
                    return cert;
                }
            }
        }

        return null;
    }
","    private CertificateDTO addCertByChild(List<CertificateDTO> toList, List<CertificateDTO> fromList, CertificateDTO child){
        if (null != child && CollectionUtils.isNotEmpty(fromList)) {
            for(CertificateDTO cert : fromList){
START                 if(child.getAuthorityKeyID().compareTo(cert.getSubjectKeyID())==0){ END 
                    toList.add(cert);
                    fromList.remove(cert);
                    return cert;
                }
            }
        }

        return null;
    }
","    private CertificateDTO addCertByChild(List<CertificateDTO> toList, List<CertificateDTO> fromList, CertificateDTO child){
        if (null != child && CollectionUtils.isNotEmpty(fromList)) {
            for(CertificateDTO cert : fromList){
                if (child.getAuthorityKeyID().equals(cert.getSubjectKeyID())) {
                    toList.add(0, cert);
                    fromList.remove(cert);
                    return cert;
                }
            }
        }

        return null;
    }
"
831,Move this private method below the public analyze* methods?,"	private void analyzeClass(final byte[] source) {
		final long classId = CRC64.classId(source);
		final int version = BytecodeVersion.read(source);
		final byte[] b = BytecodeVersion.downgradeIfNeeded(version, source);
		final ClassReader reader = new ClassReader(b);
		final ClassVisitor visitor = createAnalyzingVisitor(classId,
				reader.getClassName());
		reader.accept(visitor, 0);
	}
","START 	private void analyzeClass(final byte[] source) { END 
		final long classId = CRC64.classId(source);
		final int version = BytecodeVersion.read(source);
		final byte[] b = BytecodeVersion.downgradeIfNeeded(version, source);
		final ClassReader reader = new ClassReader(b);
		final ClassVisitor visitor = createAnalyzingVisitor(classId,
				reader.getClassName());
		reader.accept(visitor, 0);
	}
","	private void analyzeClass(final byte[] source) {
		final long classId = CRC64.classId(source);
		final int version = BytecodeVersion.get(source);
		final byte[] b = BytecodeVersion.downgradeIfNeeded(version, source);
		final ClassReader reader = new ClassReader(b);
		final ClassVisitor visitor = createAnalyzingVisitor(classId,
				reader.getClassName());
		reader.accept(visitor, 0);
	}
"
832,Removing the configuration option above simplifies all three of these methods.,"	public void close() throws ItemStreamException {
		if (!ignoreItemStream && delegate instanceof ItemStream) {
			((ItemStream) delegate).close();
		}
	}
","	public void close() throws ItemStreamException {
		if (!ignoreItemStream && delegate instanceof ItemStream) {
			((ItemStream) delegate).close();
		}
START 	} END 
","	public void close() throws ItemStreamException {
		if (delegate instanceof ItemStream) {
			((ItemStream) delegate).close();
		}
	}
"
833,style nit: missing braces,"		public FileMode getMode(File f, FS.Attributes attributes) {
			if (attributes.isSymbolicLink())
				return FileMode.SYMLINK;
			else if (attributes.isDirectory()) {
				return FileMode.TREE;
			} else if (attributes.isExecutable())
				return FileMode.EXECUTABLE_FILE;
			else
				return FileMode.REGULAR_FILE;
		}
","		public FileMode getMode(File f, FS.Attributes attributes) {
START 			if (attributes.isSymbolicLink()) END 
				return FileMode.SYMLINK;
			else if (attributes.isDirectory()) {
				return FileMode.TREE;
			} else if (attributes.isExecutable())
				return FileMode.EXECUTABLE_FILE;
			else
				return FileMode.REGULAR_FILE;
		}
","		public FileMode getMode(File f, FS.Attributes attributes) {
			if (attributes.isSymbolicLink()) {
				return FileMode.SYMLINK;
			} else if (attributes.isDirectory()) {
				return FileMode.TREE;
			} else if (attributes.isExecutable()) {
				return FileMode.EXECUTABLE_FILE;
			} else {
				return FileMode.REGULAR_FILE;
			}
		}
"
834,Please use StringBuilder.,"  protected UserException typeConversionError(ColumnMetadata schema, ValueDef valueDef) {
    String type = valueDef.type().name().toLowerCase();
    if (valueDef.isArray()) {
      for (int i = 0; i < valueDef.dimensions(); i++) {
        type += ""[]"";
      }
    }
    return typeConversionError(schema, type);
  }
","  protected UserException typeConversionError(ColumnMetadata schema, ValueDef valueDef) {
    String type = valueDef.type().name().toLowerCase();
    if (valueDef.isArray()) {
      for (int i = 0; i < valueDef.dimensions(); i++) {
START         type += ""[]""; END 
      }
    }
    return typeConversionError(schema, type);
  }
","  protected UserException typeConversionError(ColumnMetadata schema, ValueDef valueDef) {
    StringBuilder buf = new StringBuilder()
        .append(valueDef.type().name().toLowerCase());
    if (valueDef.isArray()) {
      for (int i = 0; i < valueDef.dimensions(); i++) {
        buf.append(""[]"");
      }
    }
    return typeConversionError(schema, buf.toString());
  }
"
835,static import TestMapFlatSelectiveStreamReader.ExpectedValuesBuilder.Frequency.SOME,"    public void testStructWithNull()
            throws Exception
    {
        runTest(
                ""test_flat_map/flat_map_struct_with_null.dwrf"",
                INTEGER,
                STRUCT_TYPE,
                ExpectedValuesBuilder.get(Function.identity(), TestMapFlatSelectiveStreamReader::intToList).setNullValuesFrequency(TestMapFlatSelectiveStreamReader.ExpectedValuesBuilder.Frequency.SOME));
    }
","    public void testStructWithNull()
            throws Exception
    {
        runTest(
                ""test_flat_map/flat_map_struct_with_null.dwrf"",
                INTEGER,
                STRUCT_TYPE,
START                 ExpectedValuesBuilder.get(Function.identity(), TestMapFlatSelectiveStreamReader::intToList).setNullValuesFrequency(TestMapFlatSelectiveStreamReader.ExpectedValuesBuilder.Frequency.SOME)); END 
    }
","    public void testStructWithNull()
            throws Exception
    {
        runTest(
                ""test_flat_map/flat_map_struct_with_null.dwrf"",
                INTEGER,
                STRUCT_TYPE,
                ExpectedValuesBuilder.get(Function.identity(), TestMapFlatSelectiveStreamReader::intToList).setNullValuesFrequency(SOME));
    }
"
836,"As a convention, it is typically the responsibility of the refreshSomething() method to extract the style and change the figure.

#refreshVisuals() typically calls all #refreshSomething() methods, then each method reads its own style from the notation, and calls #setSomething() on the Figure

Also, #refreshSomething() methods are usually protected, so subclasses may adapt the behavior, without having to install their own listeners (Although in that case, I doubt we'll ever have to override the DurationLink EditParts)","	protected void refreshVisuals() {
		Connector connector = (Connector) getNotationView();
		NamedStyle namedStyle = connector.getNamedStyle(NotationPackage.Literals.INT_VALUE_STYLE, ""delta"");
		if (namedStyle instanceof IntValueStyle) {
			refreshArrowDelta((IntValueStyle) namedStyle);
		} else {
			// no style - reset value
			((DurationLinkFigure) getFigure()).setArrowPositionDelta(0);
		}
		super.refreshVisuals();
	}
","	protected void refreshVisuals() {
		Connector connector = (Connector) getNotationView();
START 		NamedStyle namedStyle = connector.getNamedStyle(NotationPackage.Literals.INT_VALUE_STYLE, ""delta""); END 
		if (namedStyle instanceof IntValueStyle) {
			refreshArrowDelta((IntValueStyle) namedStyle);
		} else {
			// no style - reset value
			((DurationLinkFigure) getFigure()).setArrowPositionDelta(0);
		}
		super.refreshVisuals();
	}
","	protected void refreshVisuals() {
		refreshArrowDelta();
		super.refreshVisuals();
	}
"
837,Weird that you're calling setContentView over and over again.,"  @Override public void changeKey(@Nullable State outgoingState, State incomingState,
      Flow.Direction direction, Context incomingStateContext,
      Flow.TraversalCallback callback) {
    if (textView == null) {
      textView = new TextView(activity);
      textView.setGravity(Gravity.CENTER);
    }
    textView.setText(incomingState.getKey().toString());
    activity.setContentView(textView);
    callback.onTraversalCompleted();
  }
","  @Override public void changeKey(@Nullable State outgoingState, State incomingState,
      Flow.Direction direction, Context incomingStateContext,
      Flow.TraversalCallback callback) {
    if (textView == null) {
      textView = new TextView(activity);
      textView.setGravity(Gravity.CENTER);
    }
    textView.setText(incomingState.getKey().toString());
START     activity.setContentView(textView); END 
    callback.onTraversalCompleted();
  }
","  @Override public void changeKey(@Nullable State outgoingState, State incomingState,
      Flow.Direction direction, Context incomingStateContext,
      Flow.TraversalCallback callback) {
    if (textView == null) {
      textView = new TextView(activity);
      textView.setGravity(Gravity.CENTER);
      activity.setContentView(textView);
    }
    textView.setText(incomingState.getKey().toString());
    callback.onTraversalCompleted();
  }
"
838,Should return the same value it would have returned had it not called toHex,"   public String toHex(DiscreteElement<?> element) {
      return """";
   }
","   public String toHex(DiscreteElement<?> element) {
      START  return """"; END 
   }
","   public String toHex(DiscreteElement<?> element) {
      return element.getValue().toString();
   }
"
839,For TestNG modules we can throw an exception in `TestNGSuiteChecksTest.beforeSuite()` instead of calling `System.exit()`,"   public TestNGTestListener() {
      EnvironmentCheck.checkJVMVersion();
      progressLogger = new TestSuiteProgress();
   }
","   public TestNGTestListener() {
START       EnvironmentCheck.checkJVMVersion(); END 
      progressLogger = new TestSuiteProgress();
   }
","   public TestNGTestListener() {
      progressLogger = new TestSuiteProgress();
   }
"
840,"@cravobranco, `removing` the public access modifier makes these methods invisible outside of the package and will break code using these methods from other packages. Please update the PR with the `public` access modifier.

See: https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html","  void setTo( String to ) {
    if ( to != null && !"""".equals( to ) ) {
      to = to.replaceAll( "";"", "","" );
      props.put( ""to"", to );
    }
  }
","START   void setTo( String to ) { END 
    if ( to != null && !"""".equals( to ) ) {
      to = to.replaceAll( "";"", "","" );
      props.put( ""to"", to );
    }
  }
","  public void setTo( String to ) {
    if ( to != null && !"""".equals( to ) ) {
      to = to.replaceAll( "";"", "","" );
      props.put( ""to"", to );
    }
  }
"
841,I wonder why this method is not final while the others similar to it are. What is the reason for having final methods here?,"    private void prepareMockFileUrls() throws URISyntaxException {
        when(fileServiceClient.getFileUri(SOURCE + CLOUD_ID, SOURCE + REPRESENTATION_NAME, SOURCE + VERSION, SOURCE + FILE)).thenReturn(new URI(SOURCE_VERSION_URL));
        when(fileServiceClient.getFileUri(SOURCE + CLOUD_ID, SOURCE + REPRESENTATION_NAME, SOURCE + VERSION, SOURCE + FILE2)).thenReturn(new URI(SOURCE_VERSION_URL_FILE2));
    }
","START     private void prepareMockFileUrls() throws URISyntaxException { END 
        when(fileServiceClient.getFileUri(SOURCE + CLOUD_ID, SOURCE + REPRESENTATION_NAME, SOURCE + VERSION, SOURCE + FILE)).thenReturn(new URI(SOURCE_VERSION_URL));
        when(fileServiceClient.getFileUri(SOURCE + CLOUD_ID, SOURCE + REPRESENTATION_NAME, SOURCE + VERSION, SOURCE + FILE2)).thenReturn(new URI(SOURCE_VERSION_URL_FILE2));
    }
","    private final void prepareMockFileUrls() throws URISyntaxException {
        when(fileServiceClient.getFileUri(SOURCE + CLOUD_ID, SOURCE + REPRESENTATION_NAME, SOURCE + VERSION, SOURCE + FILE)).thenReturn(new URI(SOURCE_VERSION_URL));
        when(fileServiceClient.getFileUri(SOURCE + CLOUD_ID, SOURCE + REPRESENTATION_NAME, SOURCE + VERSION, SOURCE + FILE2)).thenReturn(new URI(SOURCE_VERSION_URL_FILE2));
    }
"
842,Just notice: It's preferable to manage the comparison '<=' instead of '==',"	public IStatus validate(Object[] selection) {
		String errorMessage = """"; //$NON-NLS-1$
		if (selection.length == 0) {
			errorMessage = NO_SELECTION;
		} else {
			final Object firstSelection = selection[0];
			if (selection.length != 1 || false == firstSelection instanceof Property || (firstSelection instanceof Property && false == ((Property) firstSelection).getType() instanceof PrimitiveType)) {
				errorMessage = Messages.SinglePropertyAttributeValidator_errorMessage;
			}
		}
		return buildIStatus(errorMessage);
	}
","	public IStatus validate(Object[] selection) {
		String errorMessage = """"; //$NON-NLS-1$
START 		if (selection.length == 0) { END 
			errorMessage = NO_SELECTION;
		} else {
			final Object firstSelection = selection[0];
			if (selection.length != 1 || false == firstSelection instanceof Property || (firstSelection instanceof Property && false == ((Property) firstSelection).getType() instanceof PrimitiveType)) {
				errorMessage = Messages.SinglePropertyAttributeValidator_errorMessage;
			}
		}
		return buildIStatus(errorMessage);
	}
","	public IStatus validate(Object[] selection) {
		String errorMessage = """"; //$NON-NLS-1$
		if (selection.length <= 0) {
			errorMessage = NO_SELECTION;
		} else {
			final Object firstSelection = selection[0];
			if (selection.length != 1 || false == firstSelection instanceof Property || (firstSelection instanceof Property && false == ((Property) firstSelection).getType() instanceof PrimitiveType)) {
				errorMessage = Messages.SinglePropertyAttributeValidator_errorMessage;
			}
		}
		return buildIStatus(errorMessage);
	}
"
843,This is less efficient because it looses the short circuit property of Boolean logic.,"    public boolean isItemValidForSlot(int slot, ItemStack stack) {
        if (slot == SLOT_INPUT) {
            boolean b1 = FluidItemHelper.isContainer(stack);
            boolean b2 = FluidItemHelper.isEmptyContainer(stack);
            FluidStack filter = getFilterFluid();
            boolean b3 = filter == null;
            boolean b4 = FluidItemHelper.containsFluid(stack, filter);
            return b1 && (b2 || b3 || b4);
        }
        return false;
    }
","    public boolean isItemValidForSlot(int slot, ItemStack stack) {
        if (slot == SLOT_INPUT) {
            boolean b1 = FluidItemHelper.isContainer(stack);
            boolean b2 = FluidItemHelper.isEmptyContainer(stack);
            FluidStack filter = getFilterFluid();
            boolean b3 = filter == null;
            boolean b4 = FluidItemHelper.containsFluid(stack, filter);
START             return b1 && (b2 || b3 || b4); END 
        }
        return false;
    }
","    public boolean isItemValidForSlot(int slot, ItemStack stack) {
        if (slot == SLOT_INPUT) {
            if (!FluidItemHelper.isContainer(stack))
                return false;
            if (FluidItemHelper.isEmptyContainer(stack))
                return true;
            FluidStack filter = getFilterFluid();
            return filter == null || FluidItemHelper.containsFluid(stack, filter);
        }
        return false;
    }
"
844,let  ColumnModelUtils.createDTOFromDBO(backup); handle the set to default (not setting it here),"	public MigratableTableTranslation<DBOColumnModel, DBOColumnModel> getTranslator() {
		return new BasicMigratableTableTranslation<DBOColumnModel>(){
			@TemporaryCode(author=""ziming"", comment = ""one-time migration change. remove after stack 309"")
			@Override
			public DBOColumnModel createDatabaseObjectFromBackup(DBOColumnModel backup) {
				//doing this round trip will assign default value to maxListLength
				ColumnModel columnModel = ColumnModelUtils.createDTOFromDBO(backup);
				if(ColumnTypeListMappings.isList(columnModel.getColumnType())){
					columnModel.setMaximumListLength(ColumnConstants.MAX_ALLOWED_LIST_LENGTH);
				}
				DBOColumnModel modifiedDBO = ColumnModelUtils.createDBOFromDTO(columnModel,
						StackConfigurationSingleton.singleton().getTableMaxEnumValues());
				return modifiedDBO;
			}
		};
	}
","	public MigratableTableTranslation<DBOColumnModel, DBOColumnModel> getTranslator() {
		return new BasicMigratableTableTranslation<DBOColumnModel>(){
			@TemporaryCode(author=""ziming"", comment = ""one-time migration change. remove after stack 309"")
			@Override
			public DBOColumnModel createDatabaseObjectFromBackup(DBOColumnModel backup) {
				//doing this round trip will assign default value to maxListLength
START 				ColumnModel columnModel = ColumnModelUtils.createDTOFromDBO(backup); END 
				if(ColumnTypeListMappings.isList(columnModel.getColumnType())){
					columnModel.setMaximumListLength(ColumnConstants.MAX_ALLOWED_LIST_LENGTH);
				}
				DBOColumnModel modifiedDBO = ColumnModelUtils.createDBOFromDTO(columnModel,
						StackConfigurationSingleton.singleton().getTableMaxEnumValues());
				return modifiedDBO;
			}
		};
	}
","	public MigratableTableTranslation<DBOColumnModel, DBOColumnModel> getTranslator() {
		return new BasicMigratableTableTranslation<DBOColumnModel>(){
			@TemporaryCode(author=""ziming"", comment = ""one-time migration change. remove after stack 309"")
			@Override
			public DBOColumnModel createDatabaseObjectFromBackup(DBOColumnModel backup) {
				//doing this round trip will assign default value to maxListLength
				ColumnModel columnModel = ColumnModelUtils.createDTOFromDBO(backup);
				DBOColumnModel modifiedDBO = ColumnModelUtils.createDBOFromDTO(columnModel,
						StackConfigurationSingleton.singleton().getTableMaxEnumValues());
				return modifiedDBO;
			}
		};
	}
"
845,"use lambda instead

 	private void openProposalPopupAsync() {
		getControl().getDisplay().asyncExec(() -> {
			Control control = getControl();
			if (control != null && !control.isDisposed()) {
				contentProposer.openProposalPopup();
			}
		});
	}","	private void openProposalPopupAsync() {
		getControl().getDisplay().asyncExec(new Runnable() {
			@Override
			public void run() {
				Control control = getControl();
				if (control != null && !control.isDisposed()) {
					contentProposer.openProposalPopup();
				}
			}
		});
	}
","	private void openProposalPopupAsync() {
START 		getControl().getDisplay().asyncExec(new Runnable() {
			@Override
			public void run() END  {
				Control control = getControl();
				if (control != null && !control.isDisposed()) {
					contentProposer.openProposalPopup();
				}
			}
		});
	}
","	private void openProposalPopupAsync() {
		getControl().getDisplay().asyncExec(() -> {
			Control control = getControl();
			if (control != null && !control.isDisposed()) {
				contentProposer.openProposalPopup();
			}
		});
	}
"
846,nit - use Map instead of HashMap on left hand side,"  private static boolean performImportWithoutUI(VirtualFile importSource, Project destinationProject) throws IOException {
    for (ModuleImporter importer : ModuleImporter.getAllImporters(destinationProject)) {
      if (importer.canImport(importSource)) {
        HashMap<String, VirtualFile> modules = Maps.newHashMap();
        for (ModuleToImport module : importer.findModules(importSource)) {
          modules.put(module.name, module.location);
        }
        importer.importProjects(modules);
        return true;
      }
    }
    return false;
  }
","  private static boolean performImportWithoutUI(VirtualFile importSource, Project destinationProject) throws IOException {
    for (ModuleImporter importer : ModuleImporter.getAllImporters(destinationProject)) {
      if (importer.canImport(importSource)) {
START         HashMap<String, VirtualFile> modules = Maps.newHashMap(); END 
        for (ModuleToImport module : importer.findModules(importSource)) {
          modules.put(module.name, module.location);
        }
        importer.importProjects(modules);
        return true;
      }
    }
    return false;
  }
","  private static boolean performImportWithoutUI(VirtualFile importSource, Project destinationProject) throws IOException {
    for (ModuleImporter importer : ModuleImporter.getAllImporters(destinationProject)) {
      if (importer.canImport(importSource)) {
        Map<String, VirtualFile> modules = Maps.newHashMap();
        for (ModuleToImport module : importer.findModules(importSource)) {
          modules.put(module.name, module.location);
        }
        importer.importProjects(modules);
        return true;
      }
    }
    return false;
  }
"
847,"I would rather this be something like:

``` java
if (uri.toString().startsWith(Contacts.CONTENT_LOOKUP_URI.toString()) {
  uri = Contacts.lookupContact(contentResolver, uri);
}
```

to avoid the unnecessary assignment when the `Uri` does not match.","  public static InputStream getContactPhotoStream(ContentResolver contentResolver, Uri uri) {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      final Uri contactUri = uri.toString().startsWith(
          ContactsContract.Contacts.CONTENT_LOOKUP_URI.toString())
        ? ContactsContract.Contacts.lookupContact(contentResolver, uri)
        : uri;
      return openContactPhotoInputStream(contentResolver, contactUri);
    } else {
      return ContactPhotoStreamIcs.get(contentResolver, uri);
    }
  }
","  public static InputStream getContactPhotoStream(ContentResolver contentResolver, Uri uri) {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      final Uri contactUri = uri.toString().startsWith(
          ContactsContract.Contacts.CONTENT_LOOKUP_URI.toString())
        ? ContactsContract.Contacts.lookupContact(contentResolver, uri)
START         : uri; END 
      return openContactPhotoInputStream(contentResolver, contactUri);
    } else {
      return ContactPhotoStreamIcs.get(contentResolver, uri);
    }
  }
","  public static InputStream getContactPhotoStream(ContentResolver contentResolver, Uri uri) {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
      if (uri.toString().startsWith(ContactsContract.Contacts.CONTENT_LOOKUP_URI.toString()))
        uri = ContactsContract.Contacts.lookupContact(contentResolver, uri);

      return openContactPhotoInputStream(contentResolver, uri);
    } else {
      return ContactPhotoStreamIcs.get(contentResolver, uri);
    }
  }
"
848,"Multimap never returns null, so we could get rid of this method.","	public Collection<String> getReviewUrls(String taskUrl) {
		List<String> reviewUrls = taskReviewsMap.get(taskUrl);

		if (reviewUrls == null) {
			return Collections.emptyList();
		}

		return reviewUrls;

	}
","	public Collection<String> getReviewUrls(String taskUrl) {
START 		List<String> reviewUrls = taskReviewsMap.get(taskUrl); END 

		if (reviewUrls == null) {
			return Collections.emptyList();
		}

		return reviewUrls;

	}
","	public Collection<String> getReviewUrls(String taskUrl) {
		return taskReviewsMap.get(taskUrl);
	}
"
849,style nit: we don't use braces around single line blocks,"	private void showResource(final IResource resource) {
		IProject project = resource.getProject();
		RepositoryMapping mapping = RepositoryMapping.getMapping(project);
		if (mapping == null)
			return;
		Repository newRep = mapping.getRepositoryOrNestedSubmoduleRepository(resource);
		if (newRep != currentRepository) {
			reload(newRep);
		}
	}
","	private void showResource(final IResource resource) {
		IProject project = resource.getProject();
		RepositoryMapping mapping = RepositoryMapping.getMapping(project);
		if (mapping == null)
			return;
		Repository newRep = mapping.getRepositoryOrNestedSubmoduleRepository(resource);
		if (newRep != currentRepository) START  { END 
			reload(newRep);
		}
	}
","	private void showResource(final IResource resource) {
		Repository newRep = getRepositoryOrNestedSubmoduleRepository(resource);
		if (newRep != null && newRep != currentRepository) {
			reload(newRep);
		}
	}
"
850,"a length of 1? That's wrong in most cases, or?","		public void apply(DirCacheEntry ent) {
			ent.setFileMode(FileMode.REGULAR_FILE);
			ent.setLength(1);
			ent.setObjectId(data);
		}
","		public void apply(DirCacheEntry ent) {
			ent.setFileMode(FileMode.REGULAR_FILE);
START 			ent.setLength(1); END 
			ent.setObjectId(data);
		}
","		public void apply(DirCacheEntry ent) {
			ent.setFileMode(FileMode.REGULAR_FILE);
			ent.setLength(length);
			ent.setObjectId(data);
		}
"
851,"Would be simpler as:

  return Arrays.asList(Action.RELOAD);","    private List<Action> handleChangesCanceled(Session session, Resource resource, ResourceStatus newStatus) {
        final List<Action> actions = Lists.newArrayList();
        actions.add(Action.RELOAD);
        return actions;
    }
","    private List<Action> handleChangesCanceled(Session session, Resource resource, ResourceStatus newStatus) {
        final List<Action> actions = Lists.newArrayList();
        actions.add(Action.RELOAD);
        START  return actions; END 
    }
","    private List<Action> handleChangesCanceled(Session session, Resource resource, ResourceStatus newStatus) {
        return Arrays.asList(Action.RELOAD);
    }
"
852,Is this change required?,"  public LocalDateTime toLocalDateTimeBin(TimeZone tz, byte[] bytes) throws PSQLException {

    ParsedBinaryTimestamp parsedTimestamp = this.toParsedTimestampBin(null, bytes, true);
    if (parsedTimestamp.infinity == Infinity.POSITIVE) {
      return LocalDateTime.MAX;
    } else if (parsedTimestamp.infinity == Infinity.NEGATIVE) {
      return LocalDateTime.MAX;
    }

    return LocalDateTime.ofEpochSecond(parsedTimestamp.millis / 1000L, parsedTimestamp.nanos, ZoneOffset.UTC);
  }
","START   public LocalDateTime toLocalDateTimeBin(TimeZone tz, byte[] bytes) throws PSQLException { END 

    ParsedBinaryTimestamp parsedTimestamp = this.toParsedTimestampBin(null, bytes, true);
    if (parsedTimestamp.infinity == Infinity.POSITIVE) {
      return LocalDateTime.MAX;
    } else if (parsedTimestamp.infinity == Infinity.NEGATIVE) {
      return LocalDateTime.MAX;
    }

    return LocalDateTime.ofEpochSecond(parsedTimestamp.millis / 1000L, parsedTimestamp.nanos, ZoneOffset.UTC);
  }
","  public LocalDateTime toLocalDateTimeBin(TimeZone tz, byte[] bytes) throws PSQLException {

    ParsedBinaryTimestamp parsedTimestamp = this.toParsedTimestampBin(tz, bytes, true);
    if (parsedTimestamp.infinity == Infinity.POSITIVE) {
      return LocalDateTime.MAX;
    } else if (parsedTimestamp.infinity == Infinity.NEGATIVE) {
      return LocalDateTime.MAX;
    }

    return LocalDateTime.ofEpochSecond(parsedTimestamp.millis / 1000L, parsedTimestamp.nanos, ZoneOffset.UTC);
  }
"
853,For non-public methods checkWidget() is not required.,"void hideCurrentToolTip () {
	checkWidget ();
	if (this.selectedMenuItem != null) {
		selectedMenuItem.hideToolTip ();
	}
}
","void hideCurrentToolTip () {
START 	checkWidget (); END 
	if (this.selectedMenuItem != null) {
		selectedMenuItem.hideToolTip ();
	}
}
","void hideCurrentToolTip () {
	if (this.selectedMenuItem != null) {
		selectedMenuItem.hideToolTip ();
	}
}
"
854,no need to create this Set when updateCenter is not present,"  public void installEdition(Set<String> pluginKeys) {
    Optional<UpdateCenter> updateCenter = updateCenterMatrixFactory.getUpdateCenter(true);
    Set<Release> pluginsToInstall = new HashSet<>();
    if (updateCenter.isPresent()) {
      for (String pluginKey : pluginKeys) {
        pluginsToInstall.addAll(updateCenter.get().findInstallablePlugins(pluginKey, Version.create("""")));
      }
    }

    pluginsToInstall.forEach(super::download);
  }
","  public void installEdition(Set<String> pluginKeys) {
    Optional<UpdateCenter> updateCenter = updateCenterMatrixFactory.getUpdateCenter(true);
START     Set<Release> pluginsToInstall = new HashSet<>(); END 
    if (updateCenter.isPresent()) {
      for (String pluginKey : pluginKeys) {
        pluginsToInstall.addAll(updateCenter.get().findInstallablePlugins(pluginKey, Version.create("""")));
      }
    }

    pluginsToInstall.forEach(super::download);
  }
","  public void installEdition(Set<String> pluginKeys) {
    Optional<UpdateCenter> updateCenter = updateCenterMatrixFactory.getUpdateCenter(true);
    if (updateCenter.isPresent()) {
      Set<Release> pluginsToInstall = new HashSet<>();
      for (String pluginKey : pluginKeys) {
        pluginsToInstall.addAll(updateCenter.get().findInstallablePlugins(pluginKey, Version.create("""")));
      }

      for (Release r : pluginsToInstall) {
        super.download(r);
      }
    }
  }
"
855,Looks that the list isn't needed.,"  public boolean isApplicable(String requestPath)
  {
    List<String> applicablePaths = ImmutableList.of(""druid/coordinator/v1/security/"");
    for (String path : applicablePaths) {
      if (requestPath.startsWith(path) && !requestPath.equals(path)) {
        return true;
      }
    }
    return false;
  }
","  public boolean isApplicable(String requestPath)
  {
START     List<String> applicablePaths = ImmutableList.of(""druid/coordinator/v1/security/""); END 
    for (String path : applicablePaths) {
      if (requestPath.startsWith(path) && !requestPath.equals(path)) {
        return true;
      }
    }
    return false;
  }
","  public boolean isApplicable(String requestPath)
  {
    for (String path : applicablePaths) {
      if (requestPath.startsWith(path) && !requestPath.equals(path)) {
        return true;
      }
    }
    return false;
  }
"
856,should be catching Exception here too,"    public void execute(Runnable command) {
        final Runnable runnable = doWrap(command, controlPoint);
        try {
            super.execute(doIdentityWrap(runnable));
        } catch (RejectedExecutionException e) {
            controlPoint.requestComplete();
            throw e;
        }
    }
","    public void execute(Runnable command) {
        final Runnable runnable = doWrap(command, controlPoint);
        try {
            super.execute(doIdentityWrap(runnable));
START         } catch (RejectedExecutionException e) { END 
            controlPoint.requestComplete();
            throw e;
        }
    }
","    public void execute(Runnable command) {
        final Runnable runnable = doWrap(command, controlPoint);
        try {
            super.execute(doIdentityWrap(runnable));
        } catch (Exception e) {
            controlPoint.requestComplete();
            throw e;
        }
    }
"
857,not needed,"    public void shouldFormatUniquenessConstraints()
    {
        final int[] propertyKeyIds = new int[]{42};
        assertEquals( ""new UniquenessConstraint( SchemaDescriptorFactory.forLabel( 23, 42 ) )"",
                formatArgument( new UniquenessConstraint( SchemaDescriptorFactory.forLabel( 23, propertyKeyIds ) ) ) );
    }
","    public void shouldFormatUniquenessConstraints()
    {
START         final int[] propertyKeyIds = new int[]{42}; END 
        assertEquals( ""new UniquenessConstraint( SchemaDescriptorFactory.forLabel( 23, 42 ) )"",
                formatArgument( new UniquenessConstraint( SchemaDescriptorFactory.forLabel( 23, propertyKeyIds ) ) ) );
    }
","    public void shouldFormatUniquenessConstraints()
    {
        assertEquals( ""new UniquenessConstraint( SchemaDescriptorFactory.forLabel( 23, 42 ) )"",
                formatArgument( new UniquenessConstraint( SchemaDescriptorFactory.forLabel( 23, 42 ) ) ) );
    }
"
858,can we be sure that context is a ScriptActivity?,"	private void launchUserBrickScriptActivity(Context context, UserBrick userBrick) {
		((ScriptActivity) context).removeFormulaEditorFragment();

		Intent intent = new Intent(context, UserBrickScriptActivity.class);
		ProjectManager.getInstance().setCurrentUserBrick(userBrick);
		context.startActivity(intent);
	}
","	private void launchUserBrickScriptActivity(Context context, UserBrick userBrick) {
START 		((ScriptActivity) context).removeFormulaEditorFragment(); END 

		Intent intent = new Intent(context, UserBrickScriptActivity.class);
		ProjectManager.getInstance().setCurrentUserBrick(userBrick);
		context.startActivity(intent);
	}
","	private void launchUserBrickScriptActivity(Context context, UserBrick userBrick) {
		if (context instanceof ScriptActivity) {
			((ScriptActivity) context).removeFormulaEditorFragment();
		}

		Intent intent = new Intent(context, UserBrickScriptActivity.class);
		ProjectManager.getInstance().setCurrentUserBrick(userBrick);
		context.startActivity(intent);
	}
"
859,please perform the update explicitly on the image that you modified in the line before (add .getId),"    protected void revertTask() {
        getEnclosingCommand().getParameters().getDiskImage().setImageStatus(ImageStatus.ILLEGAL);
        ImagesHandler.updateImageStatus(
                getEnclosingCommand().getParameters().getDestinationImageId(), ImageStatus.ILLEGAL);
    }
","    protected void revertTask() {
        getEnclosingCommand().getParameters().getDiskImage().setImageStatus(ImageStatus.ILLEGAL);
        ImagesHandler.updateImageStatus(
START                 getEnclosingCommand().getParameters().getDestinationImageId(), ImageStatus.ILLEGAL); END 
    }
","    protected void revertTask() {
        // nothing to do
    }
"
860,why not use assertEquals as well ?,"    public void checkIPAdress() {
        Set<ConstraintViolation<VmNic>> validate =
                validator.validate(createVmNic(), groups);
        assertEquals(validMacAddress, validate.isEmpty());

        if (validMacAddress) {
            assertTrue(validate.isEmpty());
        } else {
            assertEquals(1, validate.size());
            assertTrue(validate.iterator().next().getMessage().equals(message));
        }
    }
","    public void checkIPAdress() {
        Set<ConstraintViolation<VmNic>> validate =
                validator.validate(createVmNic(), groups);
        assertEquals(validMacAddress, validate.isEmpty());

        if (validMacAddress) {
            assertTrue(validate.isEmpty());
        } else {
            assertEquals(1, validate.size());
START             assertTrue(validate.iterator().next().getMessage().equals(message)); END 
        }
    }
","    public void checkIPAdress() {
        Set<ConstraintViolation<VmNic>> validate =
                validator.validate(createVmNic(), groups);
        assertEquals(validMacAddress, validate.isEmpty());

        if (validMacAddress) {
            assertTrue(validate.isEmpty());
        } else {
            assertEquals(1, validate.size());
            assertEquals(message, validate.iterator().next().getMessage());
        }
    }
"
861,"if `mNextEntry` is `null`, will this if statement always evaluate to `true`? If not, then it would just loop again, and what would happen?","  public State advance() throws IOException {
    mCheckpointStream = null;
    mNextEntry = null;
    while (true) {
      updateInputStream();
      if (mCheckpointStream != null) {
        return State.CHECKPOINT;
      }
      advanceEntry();
      if (mNextEntry != null) {
        return State.LOG;
      }
      if (mInputStream == null || mInputStream.isDone() || mInputStream.mFile.isIncompleteLog()) {
        return State.DONE;
      }
    }
  }
","  public State advance() throws IOException {
    mCheckpointStream = null;
    mNextEntry = null;
    while (true) {
      updateInputStream();
      if (mCheckpointStream != null) {
        return State.CHECKPOINT;
      }
      advanceEntry();
      if (mNextEntry != null) {
        return State.LOG;
      }
START       if (mInputStream == null || mInputStream.isDone() || mInputStream.mFile.isIncompleteLog()) { END 
        return State.DONE;
      }
    }
  }
","  public State advance() throws IOException {
    mCheckpointStream = null;
    mNextEntry = null;
    updateInputStream();
    if (mCheckpointStream != null) {
      return State.CHECKPOINT;
    }
    advanceEntry();
    if (mNextEntry != null) {
      return State.LOG;
    }
    return State.DONE;
  }
"
862,This is not a good convention. How about changing `internalNext()` to be able to return null to indicate there's no more elements?,"    public boolean hasNext()
    {

      if (saveNext != null) {
        return true;
      }

      try {
        saveNext = internalNext();
        return true;
      }
      catch (NoSuchElementException e) {
        return false;
      }


    }
","    public boolean hasNext()
    {

      if (saveNext != null) {
        return true;
      }

      try {
        saveNext = internalNext();
        return true;
      }
      catch (NoSuchElementException e) {
START         return false; END 
      }


    }
","    public boolean hasNext()
    {
      if (saveNext != null) {
        return true;
      }

      saveNext = internalNext();
      return (saveNext != null);
    }
"
863,This can be removed. The SubMonitor itself can handle null,"	public void process(IProgressMonitor monitor) throws CoreException {
		if (monitor == null)
			monitor = new NullProgressMonitor();
		SubMonitor subMonitor = SubMonitor.convert(monitor, ""Searching unused members"", this.units.length); //$NON-NLS-1$
		for (ICompilationUnit unit : this.units) {
			doSearchCU(unit, subMonitor.newChild(1));
		}
	}
","	public void process(IProgressMonitor monitor) throws CoreException {
		if (monitor == null)
START 			monitor = new NullProgressMonitor(); END 
		SubMonitor subMonitor = SubMonitor.convert(monitor, ""Searching unused members"", this.units.length); //$NON-NLS-1$
		for (ICompilationUnit unit : this.units) {
			doSearchCU(unit, subMonitor.newChild(1));
		}
	}
","	public void process(IProgressMonitor monitor) throws CoreException {
		SubMonitor subMonitor = SubMonitor.convert(monitor, ""Searching unused members"", this.units.length); //$NON-NLS-1$
		for (ICompilationUnit unit : this.units) {
			doSearchCU(unit, subMonitor.split(1));
		}
	}
"
864,Does it make sense to try to delete the server even if the shared storage delete operation failed? We should try to avoid leaking resources.,"   public void teardownTest() throws InterruptedException {
      sharedStorageApi().delete(currentSharedStorage.id());
      assertNodeAvailable(currentServer);
      deleteServer(currentServer.id());
   }
","   public void teardownTest() throws InterruptedException {
      sharedStorageApi().delete(currentSharedStorage.id());
START       assertNodeAvailable(currentServer); END 
      deleteServer(currentServer.id());
   }
","   public void teardownTest() {
      sharedStorageApi().delete(currentSharedStorage.id());
      assertNodeAvailable(currentServer);
      deleteServer(currentServer.id());
   }
"
865,This is unnecessary,"    public BenchmarkSuiteConfig setSuite(String suite)
    {
        if (suite != null) {
            this.suite = suite;
        }
        return this;
    }
","    public BenchmarkSuiteConfig setSuite(String suite)
    {
START         if (suite != null) {
            this.suite = suite;
        } END 
        return this;
    }
","    public BenchmarkSuiteConfig setSuite(String suite)
    {
        this.suite = suite;
        return this;
    }
"
866,I'm not sure you need to remove all of these `static` modifiers. Some of them are probably still valid (this one notably),"  private boolean isCloseable(Type type) {
    return type.isSubtypeOf(JAVA_IO_AUTO_CLOSEABLE) || type.isSubtypeOf(JAVA_IO_CLOSEABLE);
  }
","START   private boolean isCloseable(Type type) { END 
    return type.isSubtypeOf(JAVA_IO_AUTO_CLOSEABLE) || type.isSubtypeOf(JAVA_IO_CLOSEABLE);
  }
","  private static boolean isCloseable(Type type) {
    return type.isSubtypeOf(JAVA_IO_AUTO_CLOSEABLE) || type.isSubtypeOf(JAVA_IO_CLOSEABLE);
  }
"
867,not sure if this needs to be synchronized,"  public synchronized CryptoService getCryptoService() {
    if (cryptoService == null) {
      throw new CryptoService.CryptoException(""Crypto service not initialized."");
    }
    return cryptoService;
  }
","START   public synchronized CryptoService getCryptoService() { END 
    if (cryptoService == null) {
      throw new CryptoService.CryptoException(""Crypto service not initialized."");
    }
    return cryptoService;
  }
","  public CryptoService getCryptoService() {
    if (cryptoService == null) {
      throw new CryptoService.CryptoException(""Crypto service not initialized."");
    }
    return cryptoService;
  }
"
868,@archupsg03 I think we can remove this change?,"   public Segment(String path, String etag, long sizeBytes) {
      this.path = checkNotNull(path, ""path"");
      this.etag = checkNotNull(etag, ""etag of %s"", path);
      this.sizeBytes = sizeBytes;
   }
","START    public Segment(String path, String etag, long sizeBytes) { END 
      this.path = checkNotNull(path, ""path"");
      this.etag = checkNotNull(etag, ""etag of %s"", path);
      this.sizeBytes = sizeBytes;
   }
","   private Segment(String path, String etag, long sizeBytes) {
      this.path = checkNotNull(path, ""path"");
      this.etag = checkNotNull(etag, ""etag of %s"", path);
      this.sizeBytes = sizeBytes;
   }
"
869,@NonNull double[] ?,"    public double @NonNull [] getXAxis() {
        return fXValues;
    }
","    public START  double @NonNull [] getXAxis() END  {
        return fXValues;
    }
","    public double[] getXAxis() {
        return fXValues;
    }
"
870,"What about having a simple `for` loop here. Like:

``` java
for (int i = columnPointers[k]; i < columnPointers[j + 1]; i++) {
    procedure.apply(rowIndices[i], j, values[i]);
}
```

There is something wrong with your code. First, `i = rowIndicies[k]`. And then you're getting row by `rowIndicies[i]`. This is strange. I guarantee it will fail tests.","    public void eachNonZeroInColumn(int j, MatrixProcedure procedure) {
        int k = columnPointers[j], i = rowIndices[k];
        while (i < columnPointers[j+1]) {
            procedure.apply(rowIndices[i],j,values[i]);
            i++;
        }
    }
","START     public void eachNonZeroInColumn(int j, MatrixProcedure procedure) { END 
        int k = columnPointers[j], i = rowIndices[k];
        while (i < columnPointers[j+1]) {
            procedure.apply(rowIndices[i],j,values[i]);
            i++;
        }
    }
","    public void eachNonZeroInColumn(int j, MatrixProcedure procedure) {
        for (int i = columnPointers[j]; i < columnPointers[j + 1]; i++) {
            procedure.apply(rowIndices[i], j, values[i]);
        }
    }
"
871,wrong casting,"    public ApiAuthenticationResult authenticate(HttpRequest httpRequest) {

        Assert.notNull(httpRequest, ""httpRequest argument cannot be null."");

        if (ServletHttpRequest.class.isAssignableFrom(httpRequest.getClass())){
            this.httpRequest = (ServletHttpRequest) httpRequest;
        } else {
            Assert.isInstanceOf(HttpRequest.class, httpRequest,
                    ""The specified httpRequest argument must be an instance of "" +
                            HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName());
            this.httpRequest = httpRequest;
        }

        return this.execute();
    }
","    public ApiAuthenticationResult authenticate(HttpRequest httpRequest) {

        Assert.notNull(httpRequest, ""httpRequest argument cannot be null."");

        if (ServletHttpRequest.class.isAssignableFrom(httpRequest.getClass())){
START             this.httpRequest = (ServletHttpRequest) httpRequest; END 
        } else {
            Assert.isInstanceOf(HttpRequest.class, httpRequest,
                    ""The specified httpRequest argument must be an instance of "" +
                            HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName());
            this.httpRequest = httpRequest;
        }

        return this.execute();
    }
","    public ApiAuthenticationResult authenticate(HttpRequest httpRequest) {

        Assert.notNull(httpRequest, ""httpRequest argument cannot be null."");

        if (ServletHttpRequest.class.isAssignableFrom(httpRequest.getClass())){
            this.httpRequest = httpRequest;
        } else {
            Assert.isInstanceOf(HttpRequest.class, httpRequest,
                    ""The specified httpRequest argument must be an instance of "" +
                            HttpRequest.class.getName() + "" or "" + ServletHttpRequest.class.getName());
            this.httpRequest = httpRequest;
        }

        return this.execute();
    }
"
872,could be also just `.equalsIgnoreCase()`,"        public static Mode fromString(String inStr) {
            if (inStr == null || inStr.isEmpty()) {
                throw new IllegalArgumentException(""String representation of MultiAuthenticator.Mode can not be null nor empty."");
            }
            inStr = inStr.toLowerCase();
            if (inStr.equals(""any"")){
                return ANY;
            }
            if (inStr.equals(""all"") || inStr.equals(""every"")){
                return ALL;
            }
            throw new IllegalArgumentException(""Unknown string representation ["" + inStr + ""] for MultiAuthenticator.Mode"");
        }
","        public static Mode fromString(String inStr) {
            if (inStr == null || inStr.isEmpty()) {
                throw new IllegalArgumentException(""String representation of MultiAuthenticator.Mode can not be null nor empty."");
            }
            inStr = inStr.toLowerCase();
START             if (inStr.equals(""any"")){ END 
                return ANY;
            }
            if (inStr.equals(""all"") || inStr.equals(""every"")){
                return ALL;
            }
            throw new IllegalArgumentException(""Unknown string representation ["" + inStr + ""] for MultiAuthenticator.Mode"");
        }
","        public static Mode fromString(String inStr) {
            if (inStr == null || inStr.isEmpty()) {
                throw new IllegalArgumentException(""String representation of MultiAuthenticator.Mode can not be null nor empty."");
            }
            if (inStr.equalsIgnoreCase(""any"")){
                return ANY;
            }
            if (inStr.equalsIgnoreCase(""all"")){
                return ALL;
            }
            throw new IllegalArgumentException(""Unknown string representation ["" + inStr + ""] for MultiAuthenticator.Mode"");
        }
"
873,Typo?,"    protected CoverageAgendaListener createCoverageAgendaListenerWithData(Map<String, Integer> rulesToNumberOfTimes) {
        CoverageAgendaListener coverageAgendaListener = new CoverageAgendaListener();
        for (Map.Entry<String, Integer> ruleToNumberOfTimes : rulesToNumberOfTimes.entrySet()) {
            BeforeMatchFiredEvent beforeMatchFiredEventMock = createBeforeMatchFiredEventMock(ruleToNumberOfTimes.getKey());
            IntStream.range(0, ruleToNumberOfTimes.getValue()).forEach(i -> coverageAgendaListener.beforeMatchFired(beforeMatchFiredEventMock));
        }
        ;
        return coverageAgendaListener;
    }
","    protected CoverageAgendaListener createCoverageAgendaListenerWithData(Map<String, Integer> rulesToNumberOfTimes) {
        CoverageAgendaListener coverageAgendaListener = new CoverageAgendaListener();
        for (Map.Entry<String, Integer> ruleToNumberOfTimes : rulesToNumberOfTimes.entrySet()) {
            BeforeMatchFiredEvent beforeMatchFiredEventMock = createBeforeMatchFiredEventMock(ruleToNumberOfTimes.getKey());
            IntStream.range(0, ruleToNumberOfTimes.getValue()).forEach(i -> coverageAgendaListener.beforeMatchFired(beforeMatchFiredEventMock));
        }
START         ; END 
        return coverageAgendaListener;
    }
","    protected CoverageAgendaListener createCoverageAgendaListenerWithData(Map<String, Integer> rulesToNumberOfTimes) {
        CoverageAgendaListener coverageAgendaListener = new CoverageAgendaListener();
        for (Map.Entry<String, Integer> ruleToNumberOfTimes : rulesToNumberOfTimes.entrySet()) {
            BeforeMatchFiredEvent beforeMatchFiredEventMock = createBeforeMatchFiredEventMock(ruleToNumberOfTimes.getKey());
            IntStream.range(0, ruleToNumberOfTimes.getValue()).forEach(i -> coverageAgendaListener.beforeMatchFired(beforeMatchFiredEventMock));
        }
        return coverageAgendaListener;
    }
"
874,"I'm really not a fan of `commitAllowingStateLoss`, and the general android advice is to use it as a last resort only. see above on handling `onNewIntent`.","    private void startListFragment(byte[] bytes, Uri dataUri, String serverQuery,
                                   Preferences.CloudSearchPrefs cloudSearchPrefs) {
        Fragment listFragment =
                ImportKeysListFragment.newInstance(bytes, dataUri, serverQuery, false,
                        cloudSearchPrefs);
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_list_container, listFragment, TAG_FRAG_LIST)
                .commitAllowingStateLoss();
        // we commitAllowingStateLoss for when the Activity is already started but an Intent is
        // received and to be rendered
    }
","    private void startListFragment(byte[] bytes, Uri dataUri, String serverQuery,
                                   Preferences.CloudSearchPrefs cloudSearchPrefs) {
        Fragment listFragment =
                ImportKeysListFragment.newInstance(bytes, dataUri, serverQuery, false,
                        cloudSearchPrefs);
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_list_container, listFragment, TAG_FRAG_LIST)
START                 .commitAllowingStateLoss(); END 
        // we commitAllowingStateLoss for when the Activity is already started but an Intent is
        // received and to be rendered
    }
","    private void startListFragment(byte[] bytes, Uri dataUri, String serverQuery,
                                   Preferences.CloudSearchPrefs cloudSearchPrefs) {
        Fragment listFragment =
                ImportKeysListFragment.newInstance(bytes, dataUri, serverQuery, false,
                        cloudSearchPrefs);
        getSupportFragmentManager().beginTransaction()
                .replace(R.id.import_keys_list_container, listFragment, TAG_FRAG_LIST)
                .commit();
    }
"
875,":warning: `requireNonNull` on a nullable argument

highlights that a UT is missing (could be testing that `Optional.empty()` is returned when argument is `null`)","  public Webhook(String componentUuid, @Nullable String ceTaskUuid, @Nullable String analysisUuid, String name, String url) {
    this.componentUuid = requireNonNull(componentUuid);
    this.ceTaskUuid = ceTaskUuid;
    this.analysisUuid = requireNonNull(analysisUuid);
    this.name = requireNonNull(name);
    this.url = requireNonNull(url);
  }
","  public Webhook(String componentUuid, @Nullable String ceTaskUuid, @Nullable String analysisUuid, String name, String url) {
    this.componentUuid = requireNonNull(componentUuid);
    this.ceTaskUuid = ceTaskUuid;
START     this.analysisUuid = requireNonNull(analysisUuid); END 
    this.name = requireNonNull(name);
    this.url = requireNonNull(url);
  }
","  public Webhook(String componentUuid, @Nullable String ceTaskUuid, @Nullable String analysisUuid, String name, String url) {
    this.componentUuid = requireNonNull(componentUuid);
    this.ceTaskUuid = ceTaskUuid;
    this.analysisUuid = analysisUuid;
    this.name = requireNonNull(name);
    this.url = requireNonNull(url);
  }
"
876,I just want to make sure the result of this call is not expected to be modified anywhere. I see one assignment to a instance variable `this.excludeTags`,"    private static List<String> toStringList(final Object toCast) {
        // Return object as an ArrayList wherever it's defined as
        // list or not
        //
        // ### Example
        // object:
        //                  - firstValue
        //                  - secondValue
        // ### OR
        // object: singleValue
        // ###
        if (toCast instanceof List) {
            return (List<String>) toCast;
        }
        return Collections.singletonList((String) toCast);
    }
","    private static List<String> toStringList(final Object toCast) {
        // Return object as an ArrayList wherever it's defined as
        // list or not
        //
        // ### Example
        // object:
        //                  - firstValue
        //                  - secondValue
        // ### OR
        // object: singleValue
        // ###
        if (toCast instanceof List) {
            return (List<String>) toCast;
        }
START         return Collections.singletonList((String) toCast); END 
    }
","    private static List<String> toStringList(final Object toCast) {
        // Return object as an ArrayList wherever it's defined as
        // list or not
        //
        // ### Example
        // object:
        //                  - firstValue
        //                  - secondValue
        // ### OR
        // object: singleValue
        // ###
        if (toCast instanceof List) {
            return (List<String>) toCast;
        }
        return new ArrayList<String>(Arrays.asList((String) toCast));
    }
"
877,`topic.substring(prefix.length())`,"    protected String getNameFromTopic(String topic) {
        if (!topic.startsWith(prefix)) {
            throw new IllegalArgumentException(String.format(""topic %s with invalid prefix %s"", topic, prefix));
        }
        return topic.replaceFirst(prefix, """");
    }
","    protected String getNameFromTopic(String topic) {
        if (!topic.startsWith(prefix)) {
            throw new IllegalArgumentException(String.format(""topic %s with invalid prefix %s"", topic, prefix));
        }
START         return topic.replaceFirst(prefix, """"); END 
    }
","    protected String getNameFromTopic(String topic) {
        if (!topic.startsWith(prefix)) {
            throw new IllegalArgumentException(String.format(""topic %s with invalid prefix %s"", topic, prefix));
        }
        return topic.substring(prefix.length());
    }
"
878,"// nitpick-mode-on
Can you change `this.ctx` to `ctx`?
// nitpick-mode-off","    protected Buffer getBuffer(Dsn dsn) {
        File bufferDir;
        String bufferDirOpt = Lookup.lookup(BUFFER_DIR_OPTION, dsn);
        if (bufferDirOpt != null) {
            bufferDir = new File(bufferDirOpt);
        } else {
            bufferDir = new File(this.ctx.getCacheDir().getAbsolutePath(), DEFAULT_BUFFER_DIR);
        }

        Log.d(TAG, ""Using buffer dir: "" + bufferDir.getAbsolutePath());
        return new DiskBuffer(bufferDir, getBufferSize(dsn));
    }
","    protected Buffer getBuffer(Dsn dsn) {
        File bufferDir;
        String bufferDirOpt = Lookup.lookup(BUFFER_DIR_OPTION, dsn);
        if (bufferDirOpt != null) {
            bufferDir = new File(bufferDirOpt);
        } else {
START             bufferDir = new File(this.ctx.getCacheDir().getAbsolutePath(), DEFAULT_BUFFER_DIR); END 
        }

        Log.d(TAG, ""Using buffer dir: "" + bufferDir.getAbsolutePath());
        return new DiskBuffer(bufferDir, getBufferSize(dsn));
    }
","    protected Buffer getBuffer(Dsn dsn) {
        File bufferDir;
        String bufferDirOpt = Lookup.lookup(BUFFER_DIR_OPTION, dsn);
        if (bufferDirOpt != null) {
            bufferDir = new File(bufferDirOpt);
        } else {
            bufferDir = new File(ctx.getCacheDir().getAbsolutePath(), DEFAULT_BUFFER_DIR);
        }

        Log.d(TAG, ""Using buffer dir: "" + bufferDir.getAbsolutePath());
        return new DiskBuffer(bufferDir, getBufferSize(dsn));
    }
"
879,clean up message,"    public void run(final SpringConfiguration configuration, final Environment environment) throws Exception {
        log.info(""_____spring scanning________*******************"");
        initializeSpring(configuration, environment);
        // Do the dropwizard registrations
        addResources(environment);
        addHealthChecks(environment);
        addTasks(environment);
        addManaged(environment);
    }
","    public void run(final SpringConfiguration configuration, final Environment environment) throws Exception {
START         log.info(""_____spring scanning________*******************""); END 
        initializeSpring(configuration, environment);
        // Do the dropwizard registrations
        addResources(environment);
        addHealthChecks(environment);
        addTasks(environment);
        addManaged(environment);
    }
","    public void run(final SpringConfiguration configuration, final Environment environment) throws Exception {
        initializeSpring(configuration, environment);
        // Do the dropwizard registrations
        addResources(environment);
        addHealthChecks(environment);
        addTasks(environment);
        addManaged(environment);
    }
"
880,This can potentially throw an `IOException`.,"    private static JSONObject createJsonFileObject(InputStream stream)
            throws IOException, JSONException {
        String line;
        StringBuilder result = new StringBuilder();
        // Reads from stream
        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
        try {
            // Read each line of the GeoJSON file into a string
            while ((line = reader.readLine()) != null) {
                result.append(line);
            }
        } finally {
            reader.close();
        }
        // Converts the result string into a JSONObject
        return new JSONObject(result.toString());
    }
","    private static JSONObject createJsonFileObject(InputStream stream)
            throws IOException, JSONException {
        String line;
        StringBuilder result = new StringBuilder();
        // Reads from stream
        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
        try {
            // Read each line of the GeoJSON file into a string
            while ((line = reader.readLine()) != null) {
                result.append(line);
            }
        } finally {
START             reader.close(); END 
        }
        // Converts the result string into a JSONObject
        return new JSONObject(result.toString());
    }
","    private static JSONObject createJsonFileObject(InputStream stream)
            throws IOException, JSONException {
        String line;
        StringBuilder result = new StringBuilder();
        // Reads from stream
        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
        // Read each line of the GeoJSON file into a string
        while ((line = reader.readLine()) != null) {
            result.append(line);
        }
        reader.close();

        // Converts the result string into a JSONObject
        return new JSONObject(result.toString());
    }
"
881,"Since it's a testing facility I'd make the methods around it at least package private. 
Another possible approach would be to manually register a RequestPostProcessor that does the same work using GeoServerExtensionsHelper.singleton","    public void setExecutionAudit(BiConsumer<RequestData, Authentication> executionAudit) {
        this.executionAudit = executionAudit;
    }
","START     public void setExecutionAudit(BiConsumer<RequestData, Authentication> executionAudit) { END 
        this.executionAudit = executionAudit;
    }
","    void setExecutionAudit(BiConsumer<RequestData, Authentication> executionAudit) {
        this.executionAudit = executionAudit;
    }
"
882,"A number of these tests don't actually throw an `HttpMediaTypeNotAcceptableException`. Will you please remove the `throws` from the signature where it is unnecessary? This way, the expectations of the test are clearer.","	public void useEqualsWhenTrueThenCustomMediaTypeIsMatched() throws HttpMediaTypeNotAcceptableException {
		request.addHeader(""Accept"", ""text/unique"");

		matcher = new MediaTypeRequestMatcher(new MediaType(""text"", ""unique""));
		matcher.setUseEquals(true);
		assertThat(matcher.matches(request)).isTrue();
	}
","START 	public void useEqualsWhenTrueThenCustomMediaTypeIsMatched() throws HttpMediaTypeNotAcceptableException { END 
		request.addHeader(""Accept"", ""text/unique"");

		matcher = new MediaTypeRequestMatcher(new MediaType(""text"", ""unique""));
		matcher.setUseEquals(true);
		assertThat(matcher.matches(request)).isTrue();
	}
","	public void useEqualsWhenTrueThenCustomMediaTypeIsMatched() {
		request.addHeader(""Accept"", ""text/unique"");

		matcher = new MediaTypeRequestMatcher(new MediaType(""text"", ""unique""));
		matcher.setUseEquals(true);
		assertThat(matcher.matches(request)).isTrue();
	}
"
883,"Could use `forEach` here too, otherwise we're not really gaining anything from using a lambda","   default void executeTask(final KeyFilter<? super K> filter, BiConsumer<? super K, InternalCacheEntry<K, V>> action) throws InterruptedException {
      iterator().forEachRemaining(ice -> {
         if (filter == null || filter.accept(ice.getKey())) {
            action.accept(ice.getKey(), ice);
         }
      });
   }
","   default void executeTask(final KeyFilter<? super K> filter, BiConsumer<? super K, InternalCacheEntry<K, V>> action) throws InterruptedException {
START       iterator().forEachRemaining(ice -> { END 
         if (filter == null || filter.accept(ice.getKey())) {
            action.accept(ice.getKey(), ice);
         }
      });
   }
","   default void executeTask(final KeyFilter<? super K> filter, BiConsumer<? super K, InternalCacheEntry<K, V>> action) throws InterruptedException {
      forEach(ice -> {
         if (filter == null || filter.accept(ice.getKey())) {
            action.accept(ice.getKey(), ice);
         }
      });
   }
"
884,set as final,"    private void sendRelationshipErrorMessage(
            final String relationName,
            final User user
    ) {

        SystemMessageEventUtil systemMessageEventUtil = SystemMessageEventUtil.getInstance();

        try {
            systemMessageEventUtil.pushMessage(
                new SystemMessageBuilder()
                    .setMessage(LanguageUtil.format(
                            user.getLocale(),
                            ""contenttypes.field.properties.relationship.required.error"",
                            relationName)
                    )
                    .setSeverity(MessageSeverity.INFO)
                    .setType(MessageType.SIMPLE_MESSAGE)
                    .create(),
                list(user.getUserId())
            );
        } catch (LanguageException e) {
            throw new DotRuntimeException(e);
        }
    }
","    private void sendRelationshipErrorMessage(
            final String relationName,
            final User user
    ) {

START         SystemMessageEventUtil systemMessageEventUtil = SystemMessageEventUtil.getInstance(); END 

        try {
            systemMessageEventUtil.pushMessage(
                new SystemMessageBuilder()
                    .setMessage(LanguageUtil.format(
                            user.getLocale(),
                            ""contenttypes.field.properties.relationship.required.error"",
                            relationName)
                    )
                    .setSeverity(MessageSeverity.INFO)
                    .setType(MessageType.SIMPLE_MESSAGE)
                    .create(),
                list(user.getUserId())
            );
        } catch (LanguageException e) {
            throw new DotRuntimeException(e);
        }
    }
","    private void sendRelationshipErrorMessage(
            final String relationName,
            final User user
    ) {

        final SystemMessageEventUtil systemMessageEventUtil = SystemMessageEventUtil.getInstance();

        try {
            systemMessageEventUtil.pushMessage(
                new SystemMessageBuilder()
                    .setMessage(LanguageUtil.format(
                            user.getLocale(),
                            ""contenttypes.field.properties.relationship.required.error"",
                            relationName)
                    )
                    .setSeverity(MessageSeverity.INFO)
                    .setType(MessageType.SIMPLE_MESSAGE)
                    .create(),
                list(user.getUserId())
            );
        } catch (LanguageException e) {
            throw new DotRuntimeException(e);
        }
    }
"
885,Is synchronized necessary here?,"    public synchronized void updateCommittedTail(long newCommittedTail) {
        committedTail.updateAndGet(curr -> {
            if (newCommittedTail <= curr) {
                return curr;
            }
            return newCommittedTail;
        });
    }
","START     public synchronized void updateCommittedTail(long newCommittedTail) { END 
        committedTail.updateAndGet(curr -> {
            if (newCommittedTail <= curr) {
                return curr;
            }
            return newCommittedTail;
        });
    }
","    public void updateCommittedTail(long newCommittedTail) {
        committedTail.updateAndGet(curr -> {
            if (newCommittedTail <= curr) {
                return curr;
            }
            return newCommittedTail;
        });
    }
"
886,nit: missing braces around if bodies (https://wiki.eclipse.org/EGit/Contributor_Guide#Braces_for_one-line_statements),"	private boolean isNestedCopyfile(CopyFile copyfile) {
		if (copyfile.dest.indexOf('/') == -1)
			// If the copyfile is at root level then it won't be nested.
			return false;
		for (RepoProject proj : filteredProjects) {
			if (proj.getPath().compareTo(copyfile.dest) > 0)
				// Early return as remaining projects can't be ancestor of this
				// copyfile config (filteredProjects is sorted).
				return false;
			if (proj.isAncestorOf(copyfile.dest)) {
				return true;
			}
		}
		return false;
	}
","	private boolean isNestedCopyfile(CopyFile copyfile) {
START 		if (copyfile.dest.indexOf('/') == -1)
			// If the copyfile is at root level then it won't be nested.
			return false;
		for (RepoProject proj : filteredProjects) {
			if (proj.getPath().compareTo(copyfile.dest) > 0)
				// Early return as remaining projects can't be ancestor of this
				// copyfile config (filteredProjects is sorted).
				return false; END 
			if (proj.isAncestorOf(copyfile.dest)) {
				return true;
			}
		}
		return false;
	}
","	private boolean isNestedCopyfile(CopyFile copyfile) {
		if (copyfile.dest.indexOf('/') == -1) {
			// If the copyfile is at root level then it won't be nested.
			return false;
		}
		for (RepoProject proj : filteredProjects) {
			if (proj.getPath().compareTo(copyfile.dest) > 0) {
				// Early return as remaining projects can't be ancestor of this
				// copyfile config (filteredProjects is sorted).
				return false;
			}
			if (proj.isAncestorOf(copyfile.dest)) {
				return true;
			}
		}
		return false;
	}
"
887,The exception should be logged completely.,"		public void write(OutputStream out) {
			try {
				IOUtils.copy(results.getInputStream(), out);
			} catch (IOException e) {
				log.warn(e.getMessage());
				throw new WebApplicationException(Response.status(Status.SERVICE_UNAVAILABLE)
						.entity(""Service Unavailable, IO Exception with Search Engine"").build());
			} finally {
				results.disconnect();
				
			}
		}
","		public void write(OutputStream out) {
			try {
				IOUtils.copy(results.getInputStream(), out);
			} catch (IOException e) {
START 				log.warn(e.getMessage()); END 
				throw new WebApplicationException(Response.status(Status.SERVICE_UNAVAILABLE)
						.entity(""Service Unavailable, IO Exception with Search Engine"").build());
			} finally {
				results.disconnect();
				
			}
		}
","		public void write(OutputStream out) {
			try {
				IOUtils.copy(results.getInputStream(), out);
			} catch (IOException e) {
				log.warn(e.getMessage(), e);
				throw new WebApplicationException(Response.status(Status.SERVICE_UNAVAILABLE)
						.entity(""Service Unavailable, IO Exception with Search Engine"").build());
			} finally {
				results.disconnect();
				
			}
		}
"
888,this can fit on one line,"    private static Collection<@NonNull TmfAbstractAnalysisRequirement> getSubRequirements() {
        Set<@NonNull String> requiredEventsFields = Collections.singleton(
                ITraceEventConstants.DURATION);

        TmfAnalysisEventFieldRequirement entryReq = new TmfAnalysisEventFieldRequirement(
                StringUtils.EMPTY,
                requiredEventsFields);
        return Collections.singleton(entryReq);
    }
","    private static Collection<@NonNull TmfAbstractAnalysisRequirement> getSubRequirements() {
        Set<@NonNull String> requiredEventsFields = START  Collections.singleton(
                ITraceEventConstants.DURATION); END 

        TmfAnalysisEventFieldRequirement entryReq = new TmfAnalysisEventFieldRequirement(
                StringUtils.EMPTY,
                requiredEventsFields);
        return Collections.singleton(entryReq);
    }
","    private static Collection<@NonNull TmfAbstractAnalysisRequirement> getSubRequirements() {
        TmfAnalysisEventFieldRequirement entryReq = new TmfAnalysisEventFieldRequirement(
                StringUtils.EMPTY,
                Collections.singleton(ITraceEventConstants.DURATION));
        return Collections.singleton(entryReq);
    }
"
889,Why not static as others? Same to function `makeQuickResponse `.,"    protected boolean allowPausedModeWork(boolean internalCall, boolean adminConnection) {
        return (VoltDB.instance().getMode() != OperationMode.PAUSED ||
                internalCall ||
                adminConnection);
    }
","START     protected boolean allowPausedModeWork(boolean internalCall, boolean adminConnection) { END 
        return (VoltDB.instance().getMode() != OperationMode.PAUSED ||
                internalCall ||
                adminConnection);
    }
","    static protected boolean allowPausedModeWork(boolean internalCall, boolean adminConnection) {
        return (VoltDB.instance().getMode() != OperationMode.PAUSED ||
                internalCall ||
                adminConnection);
    }
"
890,"Have you considered skipping the line above by having something like 

`Queue<ControllerAction> result  = new ArrayDeque(queuedActions);`","    public Queue<ControllerAction> getInputQueue() {
        Queue<ControllerAction> result = new ArrayDeque<>();
        result.addAll(queuedActions);
        queuedActions.clear();
        return result;
    }
","    public Queue<ControllerAction> getInputQueue() {
        Queue<ControllerAction> result = new ArrayDeque<>();
START         result.addAll(queuedActions); END 
        queuedActions.clear();
        return result;
    }
","    public Queue<ControllerAction> getInputQueue() {
        Queue<ControllerAction> result = new ArrayDeque<>(queuedActions);
        queuedActions.clear();
        return result;
    }
"
891,"If `createParams` should always have `commonParams` and `commonServerParams`, why not just define it that way to start with? And I think you could make the collection a static final variable at the class level.","    private void runLibertyMojoCreate() throws MojoExecutionException {
        createParams.addAll(commonParams);
        createParams.addAll(commonServerParams);
        Xpp3Dom config = stripConfigElements(getLibertyPluginConfig(), createParams);
        log.info(""Running liberty:create goal"");
        runLibertyMojo(""create"", config);
    }
","    private void runLibertyMojoCreate() throws MojoExecutionException {
        createParams.addAll(commonParams);
START         createParams.addAll(commonServerParams); END 
        Xpp3Dom config = stripConfigElements(getLibertyPluginConfig(), createParams);
        log.info(""Running liberty:create goal"");
        runLibertyMojo(""create"", config);
    }
","    private void runLibertyMojoCreate() throws MojoExecutionException {
        Xpp3Dom config = stripConfigElements(getLibertyPluginConfig(), createParams);
        log.info(""Running liberty:create goal"");
        runLibertyMojo(""create"", config);
    }
"
892,Please fix this issue.,"    private ProgramState closeResource(ProgramState programState, final SymbolicValue target) {
      if (target != null && isOpened(programState, target)) {
        return programState.addConstraint(target.wrappedValue(), NullConstraint.CLOSED);
      }
      return programState;
    }
","START     private ProgramState closeResource(ProgramState programState, final SymbolicValue target) { END 
      if (target != null && isOpened(programState, target)) {
        return programState.addConstraint(target.wrappedValue(), NullConstraint.CLOSED);
      }
      return programState;
    }
","    private static ProgramState closeResource(ProgramState programState, final SymbolicValue target) {
      if (target != null && isOpened(programState, target)) {
        return programState.addConstraint(target.wrappedValue(), NullConstraint.CLOSED);
      }
      return programState;
    }
"
893,"This selector is going to throw NPE on get() if extractionFn is null, so it's better to throw it in construction:

```
this.extractionFn = Preconditions.checkNotNull(extractionFn, ""extractionFn"");
```","  public LongWrappingDimensionSelector(LongColumnSelector selector, ExtractionFn extractionFn)
  {
    this.delegate = selector;
    this.exFn = extractionFn;
  }
","  public LongWrappingDimensionSelector(LongColumnSelector selector, ExtractionFn extractionFn)
  {
    this.delegate = selector;
START     this.exFn = extractionFn; END 
  }
","  public LongWrappingDimensionSelector(LongColumnSelector selector, ExtractionFn extractionFn)
  {
    this.selector = selector;
    this.extractionFn = extractionFn;
  }
"
894,can account list be null or empty here?,"    private String getCurrentUser() {
        // authenticator is not used if there is not any user
        Account[] accountList = mAcctManager
                .getAccountsByType(AuthenticationConstants.Broker.BROKER_ACCOUNT_TYPE);
        return accountList[0].name;
    }
","    private String getCurrentUser() {
        // authenticator is not used if there is not any user
        Account[] accountList = mAcctManager
                .getAccountsByType(AuthenticationConstants.Broker.BROKER_ACCOUNT_TYPE);
START         return accountList[0].name; END 
    }
","    private String getCurrentUser() {
        // authenticator is not used if there is not any user
        Account[] accountList = mAcctManager
                .getAccountsByType(AuthenticationConstants.Broker.BROKER_ACCOUNT_TYPE);
        if (accountList != null && accountList.length > 0) {
            return accountList[0].name;
        }

        return null;
    }
"
895,Suggest using parenthesis to clarify order of operator evaluation,"   private boolean isExpired(Long issuedAt, Long lifetime) {
      return lifetime != -1 && issuedAt + lifetime < System.currentTimeMillis() / 1000;
   }
","   private boolean isExpired(Long issuedAt, Long lifetime) {
START       return lifetime != -1 && issuedAt + lifetime < System.currentTimeMillis() / 1000; END 
   }
","   private boolean isExpired(Long issuedAt, Long lifetime) {
      return lifetime != -1 && ((issuedAt + lifetime) < (System.currentTimeMillis() / 1000));
   }
"
896,"Looks to me like the last parameter never does anything, but not sure if there is some location that uses it and it is just not in the diff.","    private void onSafeDelete() {

        if (context.getEditorModelContent().getOriginalClassName() != null) {
            //if we are about to delete a .java file that could be parsed without errors, and we can calculate the
            //className then we can check for class usages prior to deletion.

            final String className = context.getEditorModelContent().getOriginalClassName();

            showAssetUsagesDisplayer.showAssetUsages(Constants.INSTANCE.modelEditor_confirm_deletion_of_used_class(className),
                                                     versionRecordManager.getCurrentPath(),
                                                     className,
                                                     ResourceType.JAVA,
                                                     () -> onDelete(versionRecordManager.getPathToLatest()),
                                                     () -> {
                                                     });
        } else {
            //we couldn't parse the class, so no check can be done. Just proceed with the standard
            //file deletion procedure.
            onDelete(versionRecordManager.getPathToLatest());
        }
    }
","    private void onSafeDelete() {

        if (context.getEditorModelContent().getOriginalClassName() != null) {
            //if we are about to delete a .java file that could be parsed without errors, and we can calculate the
            //className then we can check for class usages prior to deletion.

            final String className = context.getEditorModelContent().getOriginalClassName();

            showAssetUsagesDisplayer.showAssetUsages(Constants.INSTANCE.modelEditor_confirm_deletion_of_used_class(className),
                                                     versionRecordManager.getCurrentPath(),
                                                     className,
                                                     ResourceType.JAVA,
                                                     () -> onDelete(versionRecordManager.getPathToLatest()),
                                                     () -> {
START                                                      }); END 
        } else {
            //we couldn't parse the class, so no check can be done. Just proceed with the standard
            //file deletion procedure.
            onDelete(versionRecordManager.getPathToLatest());
        }
    }
","    public void onSafeDelete() {

        if (context.getEditorModelContent().getOriginalClassName() != null) {
            //if we are about to delete a .java file that could be parsed without errors, and we can calculate the
            //className then we can check for class usages prior to deletion.

            final String className = context.getEditorModelContent().getOriginalClassName();

            showAssetUsagesDisplayer.showAssetUsages(Constants.INSTANCE.modelEditor_confirm_deletion_of_used_class(className),
                                                     versionRecordManager.getCurrentPath(),
                                                     className,
                                                     ResourceType.JAVA,
                                                     () -> onDelete(versionRecordManager.getPathToLatest()),
                                                     () -> {
                                                     });
        } else {
            //we couldn't parse the class, so no check can be done. Just proceed with the standard
            //file deletion procedure.
            onDelete(versionRecordManager.getPathToLatest());
        }
    }
"
897,Missing @Override annotations?,"  public V get(final String key) {
    return super.get(key.toLowerCase());
  }
","START   public V get(final String key) { END 
    return super.get(key.toLowerCase());
  }
","  public V get(final String key) {
    return this.map.get(key.toLowerCase());
  }
"
898,nit: maybe use `finally` to restore this value.,"    public static byte[] byteBufferToArray(ByteBuffer buf) {
        byte[] arr = new byte[buf.remaining()];
        int prevPosition = buf.position();
        buf.get(arr);
        buf.position(prevPosition);
        return arr;
    }
","    public static byte[] byteBufferToArray(ByteBuffer buf) {
        byte[] arr = new byte[buf.remaining()];
        int prevPosition = buf.position();
        buf.get(arr);
START         buf.position(prevPosition); END 
        return arr;
    }
","    public static byte[] byteBufferToArray(ByteBuffer buf) {
        byte[] arr = new byte[buf.remaining()];
        int prevPosition = buf.position();
        try {
            buf.get(arr);
        } finally {
            buf.position(prevPosition);
        }
        return arr;
    }
"
899,Style-nit: Braces aren't necessary here.,"	private boolean deleteRef() {
		if (!fs.retryFailedLockFileCommit())
			return ref.delete();
		// file deletion fails on windows if another
		// thread is reading the file concurrently
		// So let's try 10 times...
		for (int i = 0; i < 10; i++) {
			if (ref.delete()) {
				return true;
			}
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// ignore
			}
		}
		return false;
	}
","	private boolean deleteRef() {
		if (!fs.retryFailedLockFileCommit())
			return ref.delete();
		// file deletion fails on windows if another
		// thread is reading the file concurrently
		// So let's try 10 times...
		for (int i = 0; i < 10; i++) {
START 			if (ref.delete()) { END 
				return true;
			}
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// ignore
			}
		}
		return false;
	}
","	private boolean deleteRef() {
		if (!fs.retryFailedLockFileCommit())
			return ref.delete();
		// file deletion fails on windows if another
		// thread is reading the file concurrently
		// So let's try 10 times...
		for (int i = 0; i < 10; i++) {
			if (ref.delete())
				return true;
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				return false;
			}
		}
		return false;
	}
"
900,Some of the partitionObjs entries can be NULL if the table is not partitioned. Need to handle it.,"  public Partition getPartitionObj(int idx) throws Exception {
    return partitionObjs == null ? null :
            (Partition)JSONMessageFactory.getTObj(partitionObjs.get(idx), Partition.class);
  }
","  public Partition getPartitionObj(int idx) throws Exception {
    return partitionObjs == null ? null :
START             (Partition)JSONMessageFactory.getTObj(partitionObjs.get(idx), Partition.class); END 
  }
","  public Partition getPartitionObj(int idx) throws Exception {
    return (partitionObjs == null ? null : (partitionObjs.get(idx) == null ? null :
            (Partition)JSONMessageFactory.getTObj(partitionObjs.get(idx), Partition.class)));
  }
"
901,"This isn't a Messaging component and from other side using this one within a Messaging component, raising a `MessagingException` from here, we prevent re-throwing a correct `MessagingException` with `failedMessage` context.
So, for me simple `RuntimeException` is enough in this context.
WDYT?","		public void lock() {
			try {
				this.mutex.acquire();
			}
			catch (Exception e) {
				throw new MessagingException(""Failed to aquire mutex at "" + this.path, e);
			}
		}
","		public void lock() {
			try {
				this.mutex.acquire();
			}
			catch (Exception e) {
START 				throw new MessagingException(""Failed to aquire mutex at "" + this.path, e); END 
			}
		}
","		public void lock() {
			try {
				this.mutex.acquire();
			}
			catch (Exception e) {
				throw new RuntimeException(""Failed to aquire mutex at "" + this.path, e);
			}
		}
"
902,please move it to inside the method to be consistent...,"    protected void executeCommand() {
        initConnectionList(true);

        for (Map.Entry<StorageType, List<StorageServerConnections>> connectionToType : getConnectionsTypeMap().entrySet()) {
            disconnectStorageByType(connectionToType.getKey(), connectionToType.getValue());
        }

        if (FeatureSupported.cinderProviderSupported(getStoragePool().getCompatibilityVersion())) {
            // Unregister all libvirt secrets if needed
            unregisterLibvirtSecrets();
        }
    }
","    protected void executeCommand() {
        initConnectionList(true);

        for (Map.Entry<StorageType, List<StorageServerConnections>> connectionToType : getConnectionsTypeMap().entrySet()) {
            disconnectStorageByType(connectionToType.getKey(), connectionToType.getValue());
        }

START         if (FeatureSupported.cinderProviderSupported(getStoragePool().getCompatibilityVersion())) { END 
            // Unregister all libvirt secrets if needed
            unregisterLibvirtSecrets();
        }
    }
","    protected void executeCommand() {
        initConnectionList(true);

        for (Map.Entry<StorageType, List<StorageServerConnections>> connectionToType : getConnectionsTypeMap().entrySet()) {
            disconnectStorageByType(connectionToType.getKey(), connectionToType.getValue());
        }
        unregisterLibvirtSecrets();
    }
"
903,Why you create new List here? getGeoRepPubKeys returns a list already.,"    protected void executeVdsBrokerCommand() {
        UpdateGlusterGeoRepKeysVDSParameters parameters = getParameters();
        status =
                getBroker().glusterGeoRepKeysUpdate(parameters.getRemoteUserName(),
                        new ArrayList<>(parameters.getGeoRepPubKeys()));
        proceedProxyReturnValue();
    }
","    protected void executeVdsBrokerCommand() {
        UpdateGlusterGeoRepKeysVDSParameters parameters = getParameters();
        status =
                getBroker().glusterGeoRepKeysUpdate(parameters.getRemoteUserName(),
START                         new ArrayList<>(parameters.getGeoRepPubKeys())); END 
        proceedProxyReturnValue();
    }
","    protected void executeVdsBrokerCommand() {
        UpdateGlusterGeoRepKeysVDSParameters parameters = getParameters();
        status =
                getBroker().glusterGeoRepKeysUpdate(parameters.getGeoRepPubKeys(), parameters.getRemoteUserName());
        proceedProxyReturnValue();
    }
"
904,You are not setting the endpoints for this client,"	public static void beforeClass() throws Exception {
		// Create a user
		adminSynapse = new SynapseAdminClientImpl();
		SynapseClientHelper.setEndpoints(adminSynapse);
		adminSynapse.setUsername(StackConfigurationSingleton.singleton().getMigrationAdminUsername());
		adminSynapse.setApiKey(StackConfigurationSingleton.singleton().getMigrationAdminAPIKey());
		synapse = new SynapseClientImpl();
		userId = SynapseClientHelper.createUser(adminSynapse, synapse);
		

	}
","	public static void beforeClass() throws Exception {
		// Create a user
		adminSynapse = new SynapseAdminClientImpl();
		SynapseClientHelper.setEndpoints(adminSynapse);
		adminSynapse.setUsername(StackConfigurationSingleton.singleton().getMigrationAdminUsername());
		adminSynapse.setApiKey(StackConfigurationSingleton.singleton().getMigrationAdminAPIKey());
START 		synapse = new SynapseClientImpl(); END 
		userId = SynapseClientHelper.createUser(adminSynapse, synapse);
		

	}
","	public static void beforeClass() throws Exception {
		// Create a user
		adminSynapse = new SynapseAdminClientImpl();
		SynapseClientHelper.setEndpoints(adminSynapse);
		adminSynapse.setUsername(StackConfigurationSingleton.singleton().getMigrationAdminUsername());
		adminSynapse.setApiKey(StackConfigurationSingleton.singleton().getMigrationAdminAPIKey());
		synapse = new SynapseClientImpl();
		userId = SynapseClientHelper.createUser(adminSynapse, synapse);
		SynapseClientHelper.setEndpoints(synapse);
	}
"
905,I see that all the bloomFilters of RFW are allocated using [fragment context allocator](https://github.com/apache/drill/blob/master/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/join/HashJoinBatch.java#L836) not operator context so why does the order in which `closeNotConsumedRFWs()` is called matters here ?,"  public void close() {
    waitForSendComplete();

    // Close the buffers before closing the operators; this is needed as buffer ownership
    // is attached to the receive operators.
    suppressingClose(buffers);
    // close operator context
    for (OperatorContextImpl opContext : contexts) {
      suppressingClose(opContext);
    }
    closeNotConsumedRFWs();
    suppressingClose(bufferManager);
    suppressingClose(allocator);
  }
","  public void close() {
    waitForSendComplete();

    // Close the buffers before closing the operators; this is needed as buffer ownership
    // is attached to the receive operators.
    suppressingClose(buffers);
    // close operator context
    for (OperatorContextImpl opContext : contexts) {
      suppressingClose(opContext);
    }
START     closeNotConsumedRFWs(); END 
    suppressingClose(bufferManager);
    suppressingClose(allocator);
  }
","  public void close() {
    waitForSendComplete();

    // Close the buffers before closing the operators; this is needed as buffer ownership
    // is attached to the receive operators.
    suppressingClose(buffers);
    closeNotConsumedRFWs();
    // close operator context
    for (OperatorContextImpl opContext : contexts) {
      suppressingClose(opContext);
    }
    suppressingClose(bufferManager);
    suppressingClose(allocator);
  }
"
906,"Let the auto-boxing and auto-unboxing do this for you.
When you do this manually the pool of String/numbers of java will not be used.
You just need to return `nicVo.getInstanceId()`","    public Long getPeerRouterId(String publicMacAddress, final long routerId) {
        final SearchCriteria<NicVO> sc = PeerRouterSearch.create();
        sc.setParameters(""instanceId"", routerId);
        sc.setParameters(""macAddress"", publicMacAddress);
        sc.setParameters(""vmType"", VirtualMachine.Type.DomainRouter);
        NicVO nicVo = findOneBy(sc);
        if (nicVo != null) {
            return (new Long(nicVo.getInstanceId()));
        }
        return null;
    }
","    public Long getPeerRouterId(String publicMacAddress, final long routerId) {
        final SearchCriteria<NicVO> sc = PeerRouterSearch.create();
        sc.setParameters(""instanceId"", routerId);
        sc.setParameters(""macAddress"", publicMacAddress);
        sc.setParameters(""vmType"", VirtualMachine.Type.DomainRouter);
        NicVO nicVo = findOneBy(sc);
        if (nicVo != null) {
START             return (new Long(nicVo.getInstanceId())); END 
        }
        return null;
    }
","    public Long getPeerRouterId(String publicMacAddress, final long routerId) {
        final SearchCriteria<NicVO> sc = PeerRouterSearch.create();
        sc.setParameters(""instanceId"", routerId);
        sc.setParameters(""macAddress"", publicMacAddress);
        sc.setParameters(""vmType"", VirtualMachine.Type.DomainRouter);
        NicVO nicVo = findOneBy(sc);
        if (nicVo != null) {
            return nicVo.getInstanceId();
        }
        return null;
    }
"
907,"Use `List<Tree.Kind>` for the variable declaration (always use interface for declaration, and implementation for instantiation.)","  public List<Tree.Kind> nodesToVisit() {
    ArrayList<Tree.Kind> nodesToVisit = new ArrayList<>(super.nodesToVisit());
    nodesToVisit.add(Tree.Kind.CLASS);
    nodesToVisit.add(Tree.Kind.ASSIGNMENT);
    nodesToVisit.add(Tree.Kind.STATIC_INITIALIZER);
    return nodesToVisit;
  }
","  public List<Tree.Kind> nodesToVisit() {
START     ArrayList<Tree.Kind> nodesToVisit = new ArrayList<>(super.nodesToVisit()); END 
    nodesToVisit.add(Tree.Kind.CLASS);
    nodesToVisit.add(Tree.Kind.ASSIGNMENT);
    nodesToVisit.add(Tree.Kind.STATIC_INITIALIZER);
    return nodesToVisit;
  }
","  public List<Tree.Kind> nodesToVisit() {
    List<Tree.Kind> nodesToVisit = new ArrayList<>(super.nodesToVisit());
    nodesToVisit.add(Tree.Kind.CLASS);
    nodesToVisit.add(Tree.Kind.ASSIGNMENT);
    nodesToVisit.add(Tree.Kind.STATIC_INITIALIZER);
    return nodesToVisit;
  }
"
908,"Super Minor: Format XMLs in this test to look like (unless you have some autoformatting, etc., then you can leave it as it is):

```
String groupConfig = ""    <group>\n""
                   + ""        <name>foobar</name>\n""
                   + ""        <password>dev-pass</password>\n""
                   + ""    </group>\n"";
```","    public void testXmlDeniesDuplicateGroupConfig() {
        expectDuplicateElementError(""group"");
        String groupConfig = ""    <group>\n""
                + ""        <name>foobar</name>\n""
                + ""        <password>dev-pass</password>\n""
                + ""    </group>\n"";
        buildConfig(HAZELCAST_START_TAG + groupConfig + groupConfig + HAZELCAST_END_TAG, null);
    }
","    public void testXmlDeniesDuplicateGroupConfig() {
        expectDuplicateElementError(""group"");
START         String groupConfig = ""    <group>\n"" END 
                + ""        <name>foobar</name>\n""
                + ""        <password>dev-pass</password>\n""
                + ""    </group>\n"";
        buildConfig(HAZELCAST_START_TAG + groupConfig + groupConfig + HAZELCAST_END_TAG, null);
    }
","    public void testXmlDeniesDuplicateGroupConfig() {
        expectDuplicateElementError(""group"");
        String groupConfig = """"
                + ""    <group>\n""
                + ""        <name>foobar</name>\n""
                + ""        <password>dev-pass</password>\n""
                + ""    </group>\n"";
        buildConfig(HAZELCAST_START_TAG + groupConfig + groupConfig + HAZELCAST_END_TAG);
    }
"
909,"You could also put the isNexusStarted method call after the ""evt instanceof ..."" checks - this should perform better because you'd avoid calling the synchronous method for other Nexus events. Also maybe add brackets to make it clear whether the status check applies to both events or just the registry one.","    public boolean accepts( Event<?> evt )
    {
        return applicationStatusSource.getSystemStatus().isNexusStarted()
            && ( evt instanceof RepositoryRegistryRepositoryEvent )
            || ( evt instanceof RepositoryConfigurationUpdatedEvent );
    }
","    public boolean accepts( Event<?> evt )
    {
        return applicationStatusSource.getSystemStatus().isNexusStarted()
            && ( evt instanceof RepositoryRegistryRepositoryEvent )
START             || ( evt instanceof RepositoryConfigurationUpdatedEvent ); END 
    }
","    public boolean accepts( Event<?> evt )
    {
        return ( ( evt instanceof RepositoryRegistryRepositoryEvent ) || ( evt instanceof RepositoryConfigurationUpdatedEvent ) )
            && applicationStatusSource.getSystemStatus().isNexusStarted();
    }
"
910,Braces required by coding convention.,"	public static ISynchronizeService getSyncService(String syncServiceId) {
		ISynchronizeServiceDescriptor desc = SynchronizeServiceRegistry.getSynchronizeServiceDescriptor(syncServiceId);
		if(desc == null)
			return null;
		return desc.getService();
	}
","	public static ISynchronizeService getSyncService(String syncServiceId) {
		ISynchronizeServiceDescriptor desc = SynchronizeServiceRegistry.getSynchronizeServiceDescriptor(syncServiceId);
		if(desc == null)
START 			return null; END 
		return desc.getService();
	}
","	public static ISynchronizeService getSyncService(String syncServiceId) {
		ISynchronizeServiceDescriptor desc = SynchronizeServiceRegistry.getSynchronizeServiceDescriptor(syncServiceId);
		if(desc == null) {
			return null;
		}
		return desc.getService();
	}
"
911,"I would prefer:

  if (isExtended())
   return NB.decodeUInt16(info, infoOffset + P_FLAGS2) << 16;
  else
    return 0;","	private int getExtendedFlags() {
		if (!isExtended()) {
			return 0;
		}

		return NB.decodeUInt16(info, infoOffset + P_FLAGS2) << 16;
	}
","	private int getExtendedFlags() {
START 		if (!isExtended()) { END 
			return 0;
		}

		return NB.decodeUInt16(info, infoOffset + P_FLAGS2) << 16;
	}
","	private int getExtendedFlags() {
		if (isExtended())
			return NB.decodeUInt16(info, infoOffset + P_FLAGS2) << 16;
		else
			return 0;
	}
"
912,"Cannot we just do: `profiles.put(id, attributes);`?","    protected void update(final Map<String, Object> attributes) {
        final String id = (String) attributes.get(getIdAttribute());
        logger.debug(""Updating id: {} with attributes: {}"", id, attributes);
        final Map<String,Object> profile = profiles.get(id);
        if (profile != null) {
            profile.putAll(attributes);
        } else {
            insert(attributes);
        }
    }
","    protected void update(final Map<String, Object> attributes) {
        final String id = (String) attributes.get(getIdAttribute());
        logger.debug(""Updating id: {} with attributes: {}"", id, attributes);
        final Map<String,Object> profile = profiles.get(id);
        if (profile != null) {
            profile.putAll(attributes);
        } else {
START             insert(attributes); END 
        }
    }
","    protected void update(final Map<String, Object> attributes) {
        final String id = (String) attributes.get(getIdAttribute());
        logger.debug(""Updating id: {} with attributes: {}"", id, attributes);
        final Map<String,Object> profile = profiles.get(id);
        if (profile != null) {
            profile.putAll(attributes);
        } else {
            profiles.put(id, attributes);
        }
    }
"
913,I still be able to see this line :/,"    private <T extends DAO> T getDao(Class<T> daoType) {
        for (DAO dao : daos) {
            if (daoType.isAssignableFrom(dao.getClass())) {
                if (dao instanceof BaseDAODbFacade) {
                    initBaseDAO((BaseDAODbFacade) dao);
                }
                return (T) dao;
            }
        }
        log.error(""Can't find dao for "" + daoType);
        return null;
    }
","    private <T extends DAO> T getDao(Class<T> daoType) {
        for (DAO dao : daos) {
            if (daoType.isAssignableFrom(dao.getClass())) {
                if (dao instanceof BaseDAODbFacade) {
START                     initBaseDAO((BaseDAODbFacade) dao); END 
                }
                return (T) dao;
            }
        }
        log.error(""Can't find dao for "" + daoType);
        return null;
    }
","    private <T extends DAO> T getDao(Class<T> daoType) {
        for (DAO dao : daos) {
            if (daoType.isAssignableFrom(dao.getClass())) {
                return (T) dao;
            }
        }
        log.error(""Can't find dao for "" + daoType);
        return null;
    }
"
914,chnge to error,"    private DatabaseClient(final String url) {
        MongoClient mongoClient = null;
        try {
            mongoClient = new MongoClient(url);
        } catch (UnknownHostException e) {
            LOG.info(LoggingConstants.EXCEPTION_MESSAGE, e);
        }
        if (mongoClient == null) {
            return;
        }
        database = mongoClient.getDB(""submissions"");
        if (database == null) {
            LOG.info(""Db is null!"");
        } else {
            setUpIndexes();
        }
    }
","    private DatabaseClient(final String url) {
        MongoClient mongoClient = null;
        try {
            mongoClient = new MongoClient(url);
        } catch (UnknownHostException e) {
            LOG.info(LoggingConstants.EXCEPTION_MESSAGE, e);
        }
        if (mongoClient == null) {
            return;
        }
        database = mongoClient.getDB(""submissions"");
        if (database == null) {
START             LOG.info(""Db is null!""); END 
        } else {
            setUpIndexes();
        }
    }
","    private DatabaseClient(final String url) {
        MongoClient mongoClient = null;
        try {
            mongoClient = new MongoClient(url);
        } catch (UnknownHostException e) {
            LOG.error(LoggingConstants.EXCEPTION_MESSAGE, e);
        }
        if (mongoClient == null) {
            return;
        }
        database = mongoClient.getDB(""submissions"");
        if (database == null) {
            LOG.error(""Db is null!"");
        } else {
            setUpIndexes();
        }
    }
"
915,this shows that the algorithm list should be moved to the base fb. otherwise change alg type will not work for siimple fbs.,"	public void undo() {
		if (fbType instanceof BasicFBType) {
			((BasicFBType) fbType).getAlgorithm().add(((BasicFBType) fbType).getAlgorithm().indexOf(newAlgorithm),
					oldAlgorithm);
			updateECActions(false);
			((BasicFBType) fbType).getAlgorithm().remove(newAlgorithm);
		}
	}
","	public void undo() {
START 		if (fbType instanceof BasicFBType) {
			((BasicFBType) fbType).getAlgorithm().add(((BasicFBType) fbType).getAlgorithm().indexOf(newAlgorithm),
					oldAlgorithm);
			updateECActions(false);
			((BasicFBType) fbType).getAlgorithm().remove(newAlgorithm);
		} END 
	}
","	public void undo() {
		((BasicFBType) fbType).getAlgorithm().add(((BasicFBType) fbType).getAlgorithm().indexOf(newAlgorithm),
				oldAlgorithm);
		updateECActions(false);
		((BasicFBType) fbType).getAlgorithm().remove(newAlgorithm);
	}
"
916,nit: static import currentTimeMillis,"    public long getLastSchedulingCycleRuntimeDelayMs()
    {
        return System.currentTimeMillis() - lastSchedulingCycleRunTimeMs.get();
    }
","    public long getLastSchedulingCycleRuntimeDelayMs()
    {
START         return System.currentTimeMillis() - lastSchedulingCycleRunTimeMs.get(); END 
    }
","    public long getLastSchedulingCycleRuntimeDelayMs()
    {
        return currentTimeMillis() - lastSchedulingCycleRunTimeMs.get();
    }
"
917,`anySet()` is pretty weak. Can't we verify we pass in the right IDs?,"    public void synchronizeMailboxSynchronous_withAccountPolicySetToExpungeOnPoll_shouldExpungeRemoteFolder()
            throws Exception {
        messageCountInRemoteFolder(1);
        when(account.getExpungePolicy()).thenReturn(Account.Expunge.EXPUNGE_ON_POLL);
        configureRemoteStoreWithFolder();

        controller.synchronizeMailboxSynchronous(account, FOLDER_NAME, listener, null);

        verify(remoteFolder).expunge(anySet());
    }
","    public void synchronizeMailboxSynchronous_withAccountPolicySetToExpungeOnPoll_shouldExpungeRemoteFolder()
            throws Exception {
        messageCountInRemoteFolder(1);
        when(account.getExpungePolicy()).thenReturn(Account.Expunge.EXPUNGE_ON_POLL);
        configureRemoteStoreWithFolder();

        controller.synchronizeMailboxSynchronous(account, FOLDER_NAME, listener, null);

START         verify(remoteFolder).expunge(anySet()); END 
    }
","    public void synchronizeMailboxSynchronous_withAccountPolicySetToExpungeOnPoll_shouldExpungeRemoteFolder()
            throws Exception {
        messageCountInRemoteFolder(1);
        when(account.getExpungePolicy()).thenReturn(Account.Expunge.EXPUNGE_ON_POLL);
        configureRemoteStoreWithFolder();

        controller.synchronizeMailboxSynchronous(account, FOLDER_NAME, listener, null);

        verify(remoteFolder).expunge();
    }
"
918,I prefer an `else` instead of this `return`.,"    public void onBackPressed() {
        Fragment currentFragment = fragmentManager
                .findFragmentById(R.id.fragment_holder);
        if (currentFragment instanceof About) {
            fragmentManager.popBackStack(FragmentTags.CARD_LIST, 0);
            return;
        }
        super.onBackPressed();
    }
","    public void onBackPressed() {
        Fragment currentFragment = fragmentManager
                .findFragmentById(R.id.fragment_holder);
        if (currentFragment instanceof About) {
            fragmentManager.popBackStack(FragmentTags.CARD_LIST, 0);
START             return; END 
        }
        super.onBackPressed();
    }
","    public void onBackPressed() {
        Fragment currentFragment = fragmentManager
                .findFragmentById(R.id.fragment_holder);
        if (currentFragment instanceof About) {
            fragmentManager.popBackStack(FragmentTags.CARD_LIST, 0);
        }
        else {
            super.onBackPressed();
        }
    }
"
919,An instanceof check would be good in case other items are added to the view in the future.,"	public boolean select(Viewer viewer, Object parent, Object element) {
		IBreakpoint breakpoint = (IBreakpoint) element;
		IInteractionElement interactionElement = ContextCore.getContextManager().getElement(
				structureBridge.getHandleIdentifier(breakpoint));
		if (interactionElement == null) {
			return true;
		}
		return !interactionElement.getInterest().isInteresting();
	}
","	public boolean select(Viewer viewer, Object parent, Object element) {
START 		IBreakpoint breakpoint = (IBreakpoint) element; END 
		IInteractionElement interactionElement = ContextCore.getContextManager().getElement(
				structureBridge.getHandleIdentifier(breakpoint));
		if (interactionElement == null) {
			return true;
		}
		return !interactionElement.getInterest().isInteresting();
	}
","	public boolean select(Viewer viewer, Object parent, Object element) {
		if (element instanceof IBreakpoint) {
			IBreakpoint breakpoint = (IBreakpoint) element;
			IInteractionElement interactionElement = ContextCore.getContextManager().getElement(
					structureBridge.getHandleIdentifier(breakpoint));
			if (interactionElement == null) {
				return true;
			}
			return !interactionElement.getInterest().isInteresting();
		}

		return true;
	}
"
920,seems quite wide to catch all RuntimeException : http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#compile(java.lang.String),"  public void scanFile(JavaFileScannerContext context) {
    super.context = context;
    if (isRegularExpression) {
      try {
        searchPattern = Pattern.compile(headerFormat, Pattern.DOTALL);
      } catch (RuntimeException e) {
        throw new IllegalArgumentException(""["" + getClass().getSimpleName() + ""] Unable to compile the regular expression: "" + headerFormat, e);
      }
    } else {
      expectedLines = headerFormat.split(""(?:\r)?\n|\r"");
    }
    visitFile(context.getFile());
  }
","  public void scanFile(JavaFileScannerContext context) {
    super.context = context;
    if (isRegularExpression) {
      try {
        searchPattern = Pattern.compile(headerFormat, Pattern.DOTALL);
START       } catch (RuntimeException e) { END 
        throw new IllegalArgumentException(""["" + getClass().getSimpleName() + ""] Unable to compile the regular expression: "" + headerFormat, e);
      }
    } else {
      expectedLines = headerFormat.split(""(?:\r)?\n|\r"");
    }
    visitFile(context.getFile());
  }
","  public void scanFile(JavaFileScannerContext context) {
    super.context = context;
    if (isRegularExpression) {
      if (searchPattern == null) {
        try {
          searchPattern = Pattern.compile(headerFormat, Pattern.DOTALL);
        } catch (IllegalArgumentException e) {
          throw new IllegalArgumentException(""["" + getClass().getSimpleName() + ""] Unable to compile the regular expression: "" + headerFormat, e);
        }
      }
    } else {
      expectedLines = headerFormat.split(""(?:\r)?\n|\r"");
    }
    visitFile(context.getFile());
  }
"
921,"This method needs to enhance. I mean If the first `if` is true, then the code bellow is always false. Also I think `System.out.print(""null"");` should be replaced with some log.","    private boolean isAllowedToClone(Object value) {
        if(value == null){
            System.out.print(""null"");
        }
        return Objects.nonNull(value) &&
                ((value instanceof String) || (classUtils.isPrimitiveClass(value.getClass())));
    }
","    private boolean isAllowedToClone(Object value) {
        if(value == null){
            System.out.print(""null"");
START         } END 
        return Objects.nonNull(value) &&
                ((value instanceof String) || (classUtils.isPrimitiveClass(value.getClass())));
    }
","    private boolean isAllowedToClone(Object value) {
        return Objects.nonNull(value) &&
                ((value instanceof String) || (classUtils.isPrimitiveClass(value.getClass())));
    }
"
922,Nitpick: space,"   public void validate(GlobalConfiguration globalConfig) {
      if(mediaType != null) {
         CONFIG.ignoringSpecificMediaTypes();
         key().mediaType(mediaType);
         value().mediaType(mediaType);
      }
      keyContentTypeBuilder.validate();
      valueContentTypeBuilder.validate();
   }
","   public void validate(GlobalConfiguration globalConfig) {
START       if(mediaType != null) { END 
         CONFIG.ignoringSpecificMediaTypes();
         key().mediaType(mediaType);
         value().mediaType(mediaType);
      }
      keyContentTypeBuilder.validate();
      valueContentTypeBuilder.validate();
   }
","   public void validate(GlobalConfiguration globalConfig) {
   }
"
923,"1. trick to use `LOG`: add exception as the last argument and it will be logged as the cause automatically. like this:
```java
LOG.info(""Fail to create folder "" + path, e);
```
2. actually i think we should throw this exception rather than swallow it. Why do you catch and convert the exception to log message?","  public static void createDir(String path) throws IOException {
    try {
      Files.createDirectories(Paths.get(path));
    } catch (AccessDeniedException e) {
      LOG.info(""Fail to create folder "" + path + ""caused by AccessDeniedException"");
    }
  }
","  public static void createDir(String path) throws IOException {
    try {
      Files.createDirectories(Paths.get(path));
    } catch (AccessDeniedException e) {
START       LOG.info(""Fail to create folder "" + path + ""caused by AccessDeniedException""); END 
    }
  }
","  public static void createDir(String path) throws IOException {
    Files.createDirectories(Paths.get(path));
  }
"
924,"Why not use null instead of """"?","		public TraceStatusDMData() {
			this(false, false, false, 0, 0, 0, """", """", """"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
			fTracingSupported = false;
		}
","		public TraceStatusDMData() {
START 			this(false, false, false, 0, 0, 0, """", """", """"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ END 
			fTracingSupported = false;
		}
","		public TraceStatusDMData() {
			fTracingSupported = false;
		}
"
925,"I would replace those statements above with `this(handledExceptions,failureWindow,halfOpenAfter,threshold,false)`.","    public ThrottlingExceptionRoutePolicy(int threshold, long failureWindow, long halfOpenAfter, List<Class<?>> handledExceptions) {
        this.throttledExceptions = handledExceptions;
        this.failureWindow = failureWindow;
        this.halfOpenAfter = halfOpenAfter;
        this.failureThreshold = threshold;
        this.keepOpen.set(false);
    }
","    public ThrottlingExceptionRoutePolicy(int threshold, long failureWindow, long halfOpenAfter, List<Class<?>> handledExceptions) {
        this.throttledExceptions = handledExceptions;
        this.failureWindow = failureWindow;
        this.halfOpenAfter = halfOpenAfter;
        this.failureThreshold = threshold;
START         this.keepOpen.set(false); END 
    }
","    public ThrottlingExceptionRoutePolicy(int threshold, long failureWindow, long halfOpenAfter, List<Class<?>> handledExceptions) {
        this(threshold, failureWindow, halfOpenAfter, handledExceptions, false);
    }
"
926,"Using the error message in the metric could get really messy. These are arbitrary strings, and could be very long. For Error, we're using the error code–a _very_ different thing, since these are well known, and short. The exception type name is enough for Exceptions.","        public void markRequestException(Exception e) {
        	String errorMessage = e.getMessage().replaceAll(REGEX, ""."");
        	metricsRegistry.meter(errorNamespace(metricNamespace, e, errorMessage)).mark();
        }
","        public void markRequestException(Exception e) {
START         	String errorMessage = e.getMessage().replaceAll(REGEX, "".""); END 
        	metricsRegistry.meter(errorNamespace(metricNamespace, e, errorMessage)).mark();
        }
","        public void markRequestException(Exception e) {
        	metricsRegistry.meter(errorNamespace(metricNamespace, e, null)).mark();
        }
"
927,Perhaps you can use static imports for everything form Assertion?,"  public void anonUserOnMobileCanSeeAppPromotion() {
    Promoting promoting = findPromoting();
    Assertion.assertTrue(promoting.isMobileBannerDisplayed());
    Assertion.assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT);
  }
","  public void anonUserOnMobileCanSeeAppPromotion() {
    Promoting promoting = findPromoting();
    Assertion.assertTrue(promoting.isMobileBannerDisplayed());
START     Assertion.assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT); END 
  }
","  public void anonUserOnMobileCanSeeAppPromotion() {
    Promoting promoting = findPromoting();
    assertTrue(promoting.isMobileBannerDisplayed());
    assertStringContains(promoting.getPromotionAppMobileText(), MOBILE_PROMOTION_TEXT);
  }
"
928,Maybe move this to doTestWrongSelectionBug534319.,"	public void testWrongSelectionBug534319singleThread() throws Exception {
		waitForNonConsoleJobs();

		// Run a few times since the problem doesn't occur always
		int iterations = 5;
		final String typeName = ""Bug534319singleThread"";
		final String breakpointMethodName = ""breakpointMethod"";
		doTestWrongSelectionBug534319(iterations, typeName, breakpointMethodName);
	}
","	public void testWrongSelectionBug534319singleThread() throws Exception {
START 		waitForNonConsoleJobs(); END 

		// Run a few times since the problem doesn't occur always
		int iterations = 5;
		final String typeName = ""Bug534319singleThread"";
		final String breakpointMethodName = ""breakpointMethod"";
		doTestWrongSelectionBug534319(iterations, typeName, breakpointMethodName);
	}
","	public void testWrongSelectionBug534319singleThread() throws Exception {
		// Run a few times since the problem doesn't occur always
		int iterations = 5;
		final String typeName = ""Bug534319singleThread"";
		final String breakpointMethodName = ""breakpointMethod"";
		doTestWrongSelectionBug534319(iterations, typeName, breakpointMethodName);
	}
"
929,"Normally, a 'validate' method should return true in case of success, and false if validation failed.","    private boolean validateServers(Set<String> serverNames) {
        for (String serverName : serverNames) {
            if (getVdsStaticDao().getAllForHost(serverName).size() > 0
                    || getVdsStaticDao().getAllWithIpAddress(serverName).size() > 0) {
                return true;
            }
        }
        return false;
    }
","START     private boolean validateServers(Set<String> serverNames) { END 
        for (String serverName : serverNames) {
            if (getVdsStaticDao().getAllForHost(serverName).size() > 0
                    || getVdsStaticDao().getAllWithIpAddress(serverName).size() > 0) {
                return true;
            }
        }
        return false;
    }
","    private boolean validateServers(Set<String> serverNames) {
        for (String serverName : serverNames) {
            if (getVdsStaticDao().getAllForHost(serverName).size() > 0
                    || getVdsStaticDao().getAllWithIpAddress(serverName).size() > 0) {
                return false;
            }
        }
        return true;
    }
"
930,"I don't think the fboName is ever going to change, will it?","    public void update() {
        fboId = frameBuffersManager.getFBO(fboName).fboId;
        task.setFboId(fboId);
        task.setFboName(fboName);
    }
","    public void update() {
        fboId = frameBuffersManager.getFBO(fboName).fboId;
        task.setFboId(fboId);
START         task.setFboName(fboName); END 
    }
","    public void update() {
        fboId = frameBuffersManager.getFBO(fboName).fboId;
        task.setFboId(fboId);
    }
"
931,Ah - guessing that we are using static `Bugsnag` everywhere to make this whole interface possible. Any workarounds you can think of that would avoid depending on the static class?,"    public static String getContext() {
        return Bugsnag.getClient().getContext();
    }
","    public static String getContext() {
START         return Bugsnag.getClient().getContext(); END 
    }
","    public static String getContext() {
        return getClient().getContext();
    }
"
932,No curly braces.,"	public NameRevCommand add(Iterable<ObjectId> ids)
			throws MissingObjectException, JGitInternalException {
		for (ObjectId id : ids) {
			add(id);
		}
		return this;
	}
","	public NameRevCommand add(Iterable<ObjectId> ids)
			throws MissingObjectException, JGitInternalException {
START 		for (ObjectId id : ids) { END 
			add(id);
		}
		return this;
	}
","	public NameRevCommand add(Iterable<ObjectId> ids)
			throws MissingObjectException, JGitInternalException {
		for (ObjectId id : ids)
			add(id);
		return this;
	}
"
933,Remove the public modifier from all injection constructors.,"      public ParseFirewallRules(Json json) {
         super(json, TypeLiteral.get(FirewallRules.class));
      }
","START       public ParseFirewallRules(Json json) { END 
         super(json, TypeLiteral.get(FirewallRules.class));
      }
","      ParseFirewallRules(Json json) {
         super(json, TypeLiteral.get(FirewallRules.class));
      }
"
934,shouldn't be private for all the types ?,"  public int value( ) {
    return rand.nextInt();
  }
","START   public int value( ) { END 
    return rand.nextInt();
  }
","  private int value() {
    return rand.nextInt();
  }
"
935,"Static import, for consistency? :)","    private void setUpHttpLogging() throws IOException
    {
        if ( !getConfig().get( http_logging_enabled ) )
        {
            return;
        }

        AsyncRequestLog requestLog = new AsyncRequestLog(
                dependencyResolver.resolveDependency( FileSystemAbstraction.class ),
                config.get( GraphDatabaseSettings.log_timezone ).getZoneId(),
                config.get( http_log_path ).toString(),
                config.get( http_logging_rotation_size ),
                config.get( http_logging_rotation_keep_number ) );
        webServer.setRequestLog( requestLog );
    }
","    private void setUpHttpLogging() throws IOException
    {
        if ( !getConfig().get( http_logging_enabled ) )
        {
            return;
        }

        AsyncRequestLog requestLog = new AsyncRequestLog(
                dependencyResolver.resolveDependency( FileSystemAbstraction.class ),
START                 config.get( GraphDatabaseSettings.log_timezone ).getZoneId(), END 
                config.get( http_log_path ).toString(),
                config.get( http_logging_rotation_size ),
                config.get( http_logging_rotation_keep_number ) );
        webServer.setRequestLog( requestLog );
    }
","    private void setUpHttpLogging() throws IOException
    {
        if ( !getConfig().get( http_logging_enabled ) )
        {
            return;
        }

        AsyncRequestLog requestLog = new AsyncRequestLog(
                dependencyResolver.resolveDependency( FileSystemAbstraction.class ),
                config.get( log_timezone ).getZoneId(),
                config.get( http_log_path ).toString(),
                config.get( http_logging_rotation_size ),
                config.get( http_logging_rotation_keep_number ) );
        webServer.setRequestLog( requestLog );
    }
"
936,Does that mean `getClearEachIteration` impacts the result no matter of `getControlledByThread`?,"    public void testIterationStart(LoopIterationEvent event) {
        JMeterVariables jMeterVariables = JMeterContextService.getContext().getVariables();
        if ((getControlledByThread() && !jMeterVariables.isSameUserOnNextIteration()) 
                || getClearEachIteration()) {
            log.debug(""Initialise cookies from pre-defined list"");
            // No need to call clear
            setProperty(initialCookies.clone());
        }
    }
","    public void testIterationStart(LoopIterationEvent event) {
        JMeterVariables jMeterVariables = JMeterContextService.getContext().getVariables();
        if ((getControlledByThread() && !jMeterVariables.isSameUserOnNextIteration()) 
START                 || getClearEachIteration()) { END 
            log.debug(""Initialise cookies from pre-defined list"");
            // No need to call clear
            setProperty(initialCookies.clone());
        }
    }
","    public void testIterationStart(LoopIterationEvent event) {
        JMeterVariables jMeterVariables = JMeterContextService.getContext().getVariables();
        if ((getControlledByThread() && !jMeterVariables.isSameUserOnNextIteration()) 
                || (!getControlledByThread() && getClearEachIteration())) {
            log.debug(""Initialise cookies from pre-defined list"");
            // No need to call clear
            setProperty(initialCookies.clone());
        }
    }
"
937,I believe using `forEach` ensures nothing is done if collection is empty. We should remove the outer `if`.,"    private void appendRows(Map<Integer, Map<Integer, String>> rowsMap) {
        if (!rowsMap.isEmpty()) {
            rowsMap.forEach((rowIndex, cellValueMap) -> {
                model.insertRow(rowIndex, new ScenarioGridRow());
                cellValueMap.forEach((columnIndex, cellValue) -> model.setCell(rowIndex, columnIndex, () -> new ScenarioGridCell(new ScenarioGridCellValue(cellValue))));
            });
        }
    }
","    private void appendRows(Map<Integer, Map<Integer, String>> rowsMap) {
        if (!rowsMap.isEmpty()) {
START             rowsMap.forEach((rowIndex, cellValueMap) -> { END 
                model.insertRow(rowIndex, new ScenarioGridRow());
                cellValueMap.forEach((columnIndex, cellValue) -> model.setCell(rowIndex, columnIndex, () -> new ScenarioGridCell(new ScenarioGridCellValue(cellValue))));
            });
        }
    }
","    private void appendRows(Map<Integer, Map<Integer, String>> rowsMap) {
        rowsMap.forEach((rowIndex, cellValueMap) -> {
            model.insertRow(rowIndex, new ScenarioGridRow());
            cellValueMap.forEach((columnIndex, cellValue) -> model.setCell(rowIndex, columnIndex, () -> new ScenarioGridCell(new ScenarioGridCellValue(cellValue))));
        });
    }
"
938,"findByLoginId은 구조적으로 null을 return 하지 않음

(...)

방어코드를 줄이기 위해 NullUser Pattern이 쓰였는데 나중에 도입된거라 조금 아쉽게 만들어져 있긴 함","    public static boolean isAllowedToSettings(String loginId, Project project) {
        if(loginId == null) {
            return false;
        }

        User user = User.findByLoginId(loginId);
        if(user == null || user.isAnonymous()) {
            return false;
        }
        if(user.isSiteManager() || ProjectUser.isManager(user.id, project.id)) {
            return true;
        }
        return false;
    }
","    public static boolean isAllowedToSettings(String loginId, Project project) {
        if(loginId == null) {
            return false;
        }

START         User user = User.findByLoginId(loginId); END 
        if(user == null || user.isAnonymous()) {
            return false;
        }
        if(user.isSiteManager() || ProjectUser.isManager(user.id, project.id)) {
            return true;
        }
        return false;
    }
","    public static boolean isAllowedToSettings(String loginId, Project project) {
        if(loginId == null) {
            return false;
        }

        User user = User.findByLoginId(loginId);
        if(user.isAnonymous()) {
            return false;
        }
        if(user.isSiteManager() || ProjectUser.isManager(user.id, project.id)) {
            return true;
        }
        return false;
    }
"
939,Either no brackets or put invalidate on its own line.,"        public void invalidate() {
            mActionMode.invalidate();
            if (mMenu != null) { mMenu.invalidate(); }
        }
","        public void invalidate() {
            mActionMode.invalidate();
START             if (mMenu != null) { mMenu.invalidate(); } END 
        }
","        public void invalidate() {
            mActionMode.invalidate();
            if (mMenu != null) mMenu.invalidate();
        }
"
940,double semicolon,"  private void writeObject(ObjectOutputStream out) throws IOException {
    out.writeObject(myProjectSystemId);
    out.writeObject(myModuleName);
    out.writeObject(myRootDirPath);

    synchronized (myProxyDelegateLock) {
      if (myProxyDelegate == null) {
        // Compute the proxy object in case the proxy operation scheduled in the pooled thread is not yet completed.
        myProxyDelegate = reproxy(AndroidProject.class, myDelegate);;
      }
    }

    out.writeObject(myProxyDelegate);
    out.writeObject(mySelectedVariantName);
    out.writeObject(mySelectedTestArtifactName);
  }
","  private void writeObject(ObjectOutputStream out) throws IOException {
    out.writeObject(myProjectSystemId);
    out.writeObject(myModuleName);
    out.writeObject(myRootDirPath);

    synchronized (myProxyDelegateLock) {
      if (myProxyDelegate == null) {
        // Compute the proxy object in case the proxy operation scheduled in the pooled thread is not yet completed.
        myProxyDelegate = reproxy(AndroidProject.class, START myDelegate);; END 
      }
    }

    out.writeObject(myProxyDelegate);
    out.writeObject(mySelectedVariantName);
    out.writeObject(mySelectedTestArtifactName);
  }
","  private void writeObject(ObjectOutputStream out) throws IOException {
    out.writeObject(myProjectSystemId);
    out.writeObject(myModuleName);
    out.writeObject(myRootDirPath);

    synchronized (myProxyDelegateLock) {
      if (myProxyDelegate == null) {
        // Compute the proxy object in case the proxy operation scheduled in the pooled thread is not yet completed.
        myProxyDelegate = reproxy(AndroidProject.class, myDelegate);
      }
    }

    out.writeObject(myProxyDelegate);
    out.writeObject(mySelectedVariantName);
    out.writeObject(mySelectedTestArtifactName);
  }
"
941,I would prefer to use standard Java API instead and minimize dependencies usage when possible.,"    public MainEventHandler() {
        String connectionlessProtocolList = Context.getConfig().getString(""status.ignoreOffline"");
        if (connectionlessProtocolList != null) {
            connectionlessProtocols.addAll(Arrays.asList(connectionlessProtocolList.split("","")));
        }
        logEvents = Sets.newHashSet(Context.getConfig().getString(""logger.events"", DEFAULT_LOGGER_EVENTS).split("",""));
    }
","    public MainEventHandler() {
        String connectionlessProtocolList = Context.getConfig().getString(""status.ignoreOffline"");
        if (connectionlessProtocolList != null) {
            connectionlessProtocols.addAll(Arrays.asList(connectionlessProtocolList.split("","")));
        }
START         logEvents = Sets.newHashSet(Context.getConfig().getString(""logger.events"", DEFAULT_LOGGER_EVENTS).split("","")); END 
    }
","    public MainEventHandler() {
        String connectionlessProtocolList = Context.getConfig().getString(""status.ignoreOffline"");
        if (connectionlessProtocolList != null) {
            connectionlessProtocols.addAll(Arrays.asList(connectionlessProtocolList.split("","")));
        }
        logEvents = new HashSet<>(Arrays.asList(
                Context.getConfig().getString(""logger.events"", DEFAULT_LOGGER_EVENTS).split("","")));
    }
"
942,"this should be checked at construction time. If the guy is excluding all values from the enum, throw him a beautiful IllegalArgumentException. Hence, `getRandomValue` should not declare throwing NoSuchElementException","	public E getRandomValue() throws NoSuchElementException {
		List<E> enumConstants = getFilteredList();
		if (enumConstants.isEmpty()) {
			throw new NoSuchElementException(""No enum element available for random picking."");
		}
		int randomIndex = random.nextInt(enumConstants.size());
		return enumConstants.get(randomIndex);
	}
","	public E getRandomValue() throws NoSuchElementException {
		List<E> enumConstants = getFilteredList();
START 		if (enumConstants.isEmpty()) { END 
			throw new NoSuchElementException(""No enum element available for random picking."");
		}
		int randomIndex = random.nextInt(enumConstants.size());
		return enumConstants.get(randomIndex);
	}
","	public E getRandomValue() {
		List<E> enumConstants = getFilteredList();
		int randomIndex = random.nextInt(enumConstants.size());
		return enumConstants.get(randomIndex);
	}
"
943,remove this.,"    public void setColor(int color) {
        this.setColor(color, color);
    }
","    public void setColor(int color) {
        START  this.setColor(color, END  color);
    }
","    public void setColor(int color) {
        setColor(color, color);
    }
"
944,"A HTTP header named """" should probably be treated as invalid, I think we should refuse it at construction, not try to coerce it here.","    private boolean shouldBypassThrottling(HttpServletRequest request) {
        if (enableThrottlingIfHeader == null || enableThrottlingIfHeader.length() == 0) {
            return false;
        }
        return request.getHeader(enableThrottlingIfHeader) == null;
    }
","    private boolean shouldBypassThrottling(HttpServletRequest request) {
        if (enableThrottlingIfHeader == null START  || enableThrottlingIfHeader.length() == 0) { END 
            return false;
        }
        return request.getHeader(enableThrottlingIfHeader) == null;
    }
","    private boolean shouldBypassThrottling(HttpServletRequest request) {
        if (enableThrottlingIfHeader == null) return false;

        return request.getHeader(enableThrottlingIfHeader) == null;
    }
"
945,should this just print with info level since this is a debugState why make another hop to enable debug for this topology.,"    private void print(List<List<Object>> keys, List<ValueUpdater> updaters) {
        for (int i = 0; i < keys.size(); i++) {
            ValueUpdater valueUpdater = updaters.get(i);
            Object arg = ((CombinerValueUpdater) valueUpdater).getArg();
            LOG.debug(""updateCount = {}, keys = {} => updaterArgs = {}"", updateCount, keys.get(i), arg);
        }
    }
","    private void print(List<List<Object>> keys, List<ValueUpdater> updaters) {
        for (int i = 0; i < keys.size(); i++) {
            ValueUpdater valueUpdater = updaters.get(i);
            Object arg = ((CombinerValueUpdater) valueUpdater).getArg();
START             LOG.debug(""updateCount = {}, keys = {} => updaterArgs = {}"", updateCount, keys.get(i), arg); END 
        }
    }
","    private void print(List<List<Object>> keys, List<ValueUpdater> updaters) {
        for (int i = 0; i < keys.size(); i++) {
            ValueUpdater valueUpdater = updaters.get(i);
            Object arg = ((CombinerValueUpdater) valueUpdater).getArg();
            LOG.info(""updateCount = {}, keys = {} => updaterArgs = {}"", updateCount, keys.get(i), arg);
        }
    }
"
946,can be omitted,"    public MockSCMSource(String controllerId, String repository, List<SCMSourceTrait> traits) {
        super();
        this.controllerId = controllerId;
        this.repository = repository;
        this.traits = new ArrayList<SCMSourceTrait>(traits);
    }
","    public MockSCMSource(String controllerId, String repository, List<SCMSourceTrait> traits) {
START         super(); END 
        this.controllerId = controllerId;
        this.repository = repository;
        this.traits = new ArrayList<SCMSourceTrait>(traits);
    }
","    public MockSCMSource(String controllerId, String repository, List<SCMSourceTrait> traits) {
        this.controllerId = controllerId;
        this.repository = repository;
        this.traits = new ArrayList<SCMSourceTrait>(traits);
    }
"
947,"change to `this(proxifier, ...., new NullEnvironment())`","	public MockSerializationResult(Proxifier proxifier, XStreamBuilder xstreambuilder, GsonSerializerBuilder gsonBuilder) {
		super(proxifier);
		this.response = new MockHttpServletResponse();
		this.extractor = new DefaultTypeNameExtractor();
		this.xstreambuilder = xstreambuilder;
		this.gsonBuilder = gsonBuilder;
		this.environment = new NullEnvironment();
	}
","	public MockSerializationResult(Proxifier proxifier, XStreamBuilder xstreambuilder, GsonSerializerBuilder gsonBuilder) {
START 		super(proxifier); END 
		this.response = new MockHttpServletResponse();
		this.extractor = new DefaultTypeNameExtractor();
		this.xstreambuilder = xstreambuilder;
		this.gsonBuilder = gsonBuilder;
		this.environment = new NullEnvironment();
	}
","	public MockSerializationResult(Proxifier proxifier, XStreamBuilder xstreambuilder, GsonSerializerBuilder gsonBuilder) {
		this(proxifier, xstreambuilder, gsonBuilder, new NullEnvironment());
	}
"
948,"I don't feel very good about this constructor. It seems counter-intuitive to have the fsContext as an argument here.

There is already an fsContext embededed within the `fs` object. Is there a better way to access it?","  public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) {
    super(fs);
    mFsContext = fsContext;
    // needs to be moved outside FileSystem constructor
    mLocalCacheManager = new LocalCacheManager(mFsContext);
  }
","START   public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) { END 
    super(fs);
    mFsContext = fsContext;
    // needs to be moved outside FileSystem constructor
    mLocalCacheManager = new LocalCacheManager(mFsContext);
  }
","  public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) {
    super(fs);
    mFsContext = fsContext;
  }
"
949,"I'd remove the whole guard, and simply return null (mSessionID MUST be set to null when the session has left a realm already - and of course it must be null when the transport is detached then too)","    public long getID() {
        if (!isConnected()) {
            throw new IllegalStateException(""Session must be connected first."");
        }
        return mSessionID;
    }
","    public long getID() {
START         if (!isConnected()) { END 
            throw new IllegalStateException(""Session must be connected first."");
        }
        return mSessionID;
    }
","    public long getID() {
        return mSessionID;
    }
"
950,Shouldn't this return `Flux.error(e)` ?,"    static public <T> Flux<T> fluxInlineIfPossibleAsObs(Callable<Flux<T>> function, IRetryPolicy retryPolicy) {

        if (retryPolicy == null) {
            // shortcut
            return Flux.defer(() -> {
                try {
                    return function.call();
                } catch (Exception e) {
                    return Mono.error(e);
                }
            });

        } else {
            return BackoffRetryUtility.fluxExecuteRetry(() -> function.call(), retryPolicy);
        }
    }
","    static public <T> Flux<T> fluxInlineIfPossibleAsObs(Callable<Flux<T>> function, IRetryPolicy retryPolicy) {

        if (retryPolicy == null) {
            // shortcut
            return Flux.defer(() -> {
                try {
                    return function.call();
                } catch (Exception e) {
START                     return Mono.error(e); END 
                }
            });

        } else {
            return BackoffRetryUtility.fluxExecuteRetry(() -> function.call(), retryPolicy);
        }
    }
","    static public <T> Flux<T> fluxInlineIfPossibleAsObs(Callable<Flux<T>> function, IRetryPolicy retryPolicy) {

        if (retryPolicy == null) {
            // shortcut
            return Flux.defer(() -> {
                try {
                    return function.call();
                } catch (Exception e) {
                    return Flux.error(e);
                }
            });

        } else {
            return BackoffRetryUtility.fluxExecuteRetry(() -> function.call(), retryPolicy);
        }
    }
"
951,style nit: missing braces,"	public int getTreeDepth() {
		if (currVisit == null)
			return 0;
		return currVisit.depth;
	}
","	public int getTreeDepth() {
START 		if (currVisit == null) END 
			return 0;
		return currVisit.depth;
	}
","	public int getTreeDepth() {
		if (currVisit == null) {
			return 0;
		}
		return currVisit.depth;
	}
"
952,"Any reason not to do `getBlobInfo(blobId, null)` directly? `completeOperation()` handles null callbacks anyway. Similar question for similar functions.","  public Future<BlobInfo> getBlobInfo(String blobId) {
    FutureResult<BlobInfo> futureResult = new FutureResult<BlobInfo>();
    OperationController oc = getOperationController();
    if (oc == null) {
      completeOperation(futureResult, null, null, ROUTER_CLOSED_EXCEPTION);
    } else {
      oc.getBlobInfo(blobId, futureResult, null);
    }
    return futureResult;
  }
","  public Future<BlobInfo> getBlobInfo(String blobId) {
    FutureResult<BlobInfo> futureResult = new FutureResult<BlobInfo>();
    OperationController oc = getOperationController();
    if (oc == null) {
      completeOperation(futureResult, null, null, ROUTER_CLOSED_EXCEPTION);
    } else {
      oc.getBlobInfo(blobId, futureResult, null);
    }
START     return futureResult; END 
  }
","  public Future<BlobInfo> getBlobInfo(String blobId) {
    return getBlobInfo(blobId, null);
  }
"
953,"Talked in real, we can use `loggerClass` to do what we want.","    public void shouldNotLogMessageAsInfo() {
        logFeature.setLevel(DEPRECATED_LOGGER, ""FATAL"");
        System.setProperty(Framework.NUXEO_DEV_SYSTEM_PROP, ""false"");
        logDeprecatedMessageAndVerify(false);
    }
","    public void shouldNotLogMessageAsInfo() {
START         logFeature.setLevel(DEPRECATED_LOGGER, ""FATAL""); END 
        System.setProperty(Framework.NUXEO_DEV_SYSTEM_PROP, ""false"");
        logDeprecatedMessageAndVerify(false);
    }
","    public void shouldNotLogMessageAsInfo() {
        logDeprecatedMessageAndVerify(false);
    }
"
954,lambda?,"    public TimeGraphScale(Composite parent, TimeGraphColorScheme colors) {
        super(parent, colors, SWT.NO_BACKGROUND | SWT.NO_FOCUS | SWT.DOUBLE_BUFFERED);
        TmfSignalManager.register(this);
        addMouseListener(this);
        addMouseMoveListener(this);
        TimeDraw.updateTimeZone();
        addDisposeListener(new DisposeListener() {
            @Override
            public void widgetDisposed(DisposeEvent e) {
                TmfSignalManager.deregister(TimeGraphScale.this);
            }
        });
    }
","    public TimeGraphScale(Composite parent, TimeGraphColorScheme colors) {
        super(parent, colors, SWT.NO_BACKGROUND | SWT.NO_FOCUS | SWT.DOUBLE_BUFFERED);
        TmfSignalManager.register(this);
        addMouseListener(this);
        addMouseMoveListener(this);
        TimeDraw.updateTimeZone();
        addDisposeListener(new DisposeListener() {
            @Override
START             public void widgetDisposed(DisposeEvent e) { END 
                TmfSignalManager.deregister(TimeGraphScale.this);
            }
        });
    }
","    public TimeGraphScale(Composite parent, TimeGraphColorScheme colors) {
        super(parent, colors, SWT.NO_BACKGROUND | SWT.NO_FOCUS | SWT.DOUBLE_BUFFERED);
        TmfSignalManager.register(this);
        addMouseListener(this);
        addMouseMoveListener(this);
        TimeDraw.updateTimeZone();
        addDisposeListener((e) -> {
            TmfSignalManager.deregister(TimeGraphScale.this);
        });
    }
"
955,I would say just store the actual Map directly and instead return the map wrapped by an unmodifiable map. Otherwise we will have extra allocations on every operation for the unmodifiable wrappers internally when they aren't needed.,"   private Map<String, TopologyIracVersion> generateNewVectorFunction(Integer s,
         Map<String, TopologyIracVersion> versions) {
      if (versions == null) {
         return Collections.singletonMap(localSite, TopologyIracVersion.newVersion(topologyId));
      } else {
         Map<String, TopologyIracVersion> copy = new HashMap<>(versions);
         copy.compute(localSite, this::incrementVersionFunction);
         return Collections.unmodifiableMap(copy);
      }
   }
","   private Map<String, TopologyIracVersion> generateNewVectorFunction(Integer s,
         Map<String, TopologyIracVersion> versions) {
      if (versions == null) {
         return Collections.singletonMap(localSite, TopologyIracVersion.newVersion(topologyId));
      } else {
         Map<String, TopologyIracVersion> copy = new HashMap<>(versions);
         copy.compute(localSite, this::incrementVersionFunction);
START          return Collections.unmodifiableMap(copy); END 
      }
   }
","   private Map<String, TopologyIracVersion> generateNewVectorFunction(Integer s,
         Map<String, TopologyIracVersion> versions) {
      if (versions == null) {
         return Collections.singletonMap(localSite, TopologyIracVersion.newVersion(topologyId));
      } else {
         Map<String, TopologyIracVersion> copy = new HashMap<>(versions);
         copy.compute(localSite, this::incrementVersionFunction);
         return copy;
      }
   }
"
956,`Map`,"  private HashMap<String, String> getParamsForQuery() {
    HashMap<String, String> params = new HashMap<>();
    params.put(METRIC_PARAM, getValidTableName(name));
    params.put(AGGREGATOR_PARAM, SUM_AGGREGATOR);
    params.put(TIME_PARAM, DEFAULT_TIME);
    return params;
  }
","START   private HashMap<String, String> getParamsForQuery() { END 
    HashMap<String, String> params = new HashMap<>();
    params.put(METRIC_PARAM, getValidTableName(name));
    params.put(AGGREGATOR_PARAM, SUM_AGGREGATOR);
    params.put(TIME_PARAM, DEFAULT_TIME);
    return params;
  }
","  private Map<String, String> getParamsForQuery() {
    HashMap<String, String> params = new HashMap<>();
    params.put(METRIC_PARAM, getValidTableName(name));
    params.put(AGGREGATOR_PARAM, SUM_AGGREGATOR);
    params.put(TIME_PARAM, DEFAULT_TIME);
    return params;
  }
"
957,Why use getSearchKey rather than getDisplayValue?,"	public String getDisplayValue() {
		CutoffFacetNode lastNode = this.getHighestTierNode();
		if (lastNode == null)
			return null;
		return lastNode.getSearchKey();
	}
","	public String getDisplayValue() {
		CutoffFacetNode lastNode = this.getHighestTierNode();
		if (lastNode == null)
			return null;
START 		return lastNode.getSearchKey(); END 
	}
","	public String getDisplayValue() {
		return getSearchKey();
	}
"
958,nit: `ImmutableList.copyOf(`,"    public PagesSpatialIndexFactory(List<Type> types, List<Type> outputTypes)
    {
        this.types = ImmutableList.copyOf(types);
        this.outputTypes = outputTypes;
    }
","    public PagesSpatialIndexFactory(List<Type> types, List<Type> outputTypes)
    {
        this.types = ImmutableList.copyOf(types);
START         this.outputTypes = outputTypes; END 
    }
","    public PagesSpatialIndexFactory(List<Type> types, List<Type> outputTypes)
    {
        this.types = ImmutableList.copyOf(types);
        this.outputTypes = ImmutableList.copyOf(outputTypes);
    }
"
959,these lines should be moved in the SessionInfo class instead. Otherwise each user of SessionInfo has to do the same check (see SessionConfigGenerator),"    public boolean isStreamedTrace() {
        if (fSessionInfo.isSnapshotSession()) {
            return fSessionInfo.getSnapshotInfo().isStreamedSnapshot();
        }
        return fSessionInfo.isStreamedTrace();
    }
","    public boolean isStreamedTrace() {
        if (fSessionInfo.isSnapshotSession()) {
START             return fSessionInfo.getSnapshotInfo().isStreamedSnapshot(); END 
        }
        return fSessionInfo.isStreamedTrace();
    }
","    public boolean isStreamedTrace() {
        return fSessionInfo.isStreamedTrace();
    }
"
960,why not to rely on AbstractCollection..toString?,"        public void releaseMacsOnCommit(List<String> macs) {
            log.debug(""Non-tx, non-compensation state, immediately releasing macs {}."",
                    Arrays.toString(macs.toArray()));
            macs.forEach(macPool::freeMac);
        }
","        public void releaseMacsOnCommit(List<String> macs) {
            log.debug(""Non-tx, non-compensation state, immediately releasing macs {}."",
                    START  Arrays.toString(macs.toArray())); END 
            macs.forEach(macPool::freeMac);
        }
","        public void releaseMacsOnCommit(List<String> macs) {
            log.debug(""Non-tx, non-compensation state, immediately releasing macs {}."", macs);
            macs.forEach(macPool::freeMac);
        }
"
961,"```suggestion
    return details.getHtmlDescription() + ""<br/><br/>"" + extendedDescription;
```","  public String getDescription(String ruleKey) {
    ConnectedRuleDetails details = ruleDetails(ruleKey);
    if (details == null) {
      return null;
    }
    String extendedDescription = details.getExtendedDescription();
    if (extendedDescription.isEmpty()) {
      return details.getHtmlDescription();
    }
    return details.getHtmlDescription() + ""<br/><br/>"" + details.getExtendedDescription();
  }
","  public String getDescription(String ruleKey) {
    ConnectedRuleDetails details = ruleDetails(ruleKey);
    if (details == null) {
      return null;
    }
    String extendedDescription = details.getExtendedDescription();
    if (extendedDescription.isEmpty()) {
      return details.getHtmlDescription();
    }
START     return details.getHtmlDescription() + ""<br/><br/>"" + details.getExtendedDescription(); END 
  }
","  public String getDescription(String ruleKey) {
    ConnectedRuleDetails details = ruleDetails(ruleKey);
    if (details == null) {
      return null;
    }
    String extendedDescription = details.getExtendedDescription();
    if (extendedDescription.isEmpty()) {
      return details.getHtmlDescription();
    }
    return details.getHtmlDescription() + ""<br/><br/>"" + extendedDescription;
  }
"
962,Make this public static so you can call it from the live test too and avoid the code duplication?,"   private void verifyRunListForEnvironment(Map<String, List<String>> envRunList, String envName,
         String... expectedEntries) {
      assertTrue(envRunList.containsKey(envName), ""envRunList contains "" + envName);
      assertEquals(envRunList.get(envName).size(), expectedEntries.length, ""envRunList size for '"" + envName);
      assertTrue(envRunList.get(envName).containsAll(Arrays.asList(expectedEntries)), ""envRunList for e1 contains ""
            + Arrays.asList(expectedEntries));
   }
","START    private void verifyRunListForEnvironment(Map<String, List<String>> envRunList, String envName, END 
         String... expectedEntries) {
      assertTrue(envRunList.containsKey(envName), ""envRunList contains "" + envName);
      assertEquals(envRunList.get(envName).size(), expectedEntries.length, ""envRunList size for '"" + envName);
      assertTrue(envRunList.get(envName).containsAll(Arrays.asList(expectedEntries)), ""envRunList for e1 contains ""
            + Arrays.asList(expectedEntries));
   }
","   public static void verifyRunListForEnvironment(Map<String, List<String>> envRunList, String envName,
         String... expectedEntries) {
      assertTrue(envRunList.containsKey(envName), ""envRunList contains "" + envName);
      assertEquals(envRunList.get(envName).size(), expectedEntries.length, ""envRunList size for '"" + envName);
      assertTrue(envRunList.get(envName).containsAll(Arrays.asList(expectedEntries)), ""envRunList for e1 contains ""
            + Arrays.asList(expectedEntries));
   }
"
963,Couldn't this just check `unavailableException` if it is null or not? Seems we wouldn't need the `managerAvailable` variable as well then.,"   private void checkStoreAvailability() {
      if (!enabled) return;

      if (!isAvailable()) {
         throw unavailableException;
      }
   }
","   private void checkStoreAvailability() {
      if (!enabled) return;

START       if (!isAvailable()) { END 
         throw unavailableException;
      }
   }
","   private void checkStoreAvailability() {
      if (!enabled) return;

      if (unavailableException != null) {
         throw unavailableException;
      }
   }
"
964,use logger,"	public void addTest(Class<?> testClass) {
		System.out.println(""Adding class without a run: "" + testClass.getName());
		allTestClasses.add(testClass);
	}
","	public void addTest(Class<?> testClass) {
START 		System.out.println(""Adding class without a run: "" + testClass.getName()); END 
		allTestClasses.add(testClass);
	}
","	public void addTest(Class<?> testClass) {
		allTestClasses.add(testClass);
	}
"
965,"If this constructor is to be called only by the builder, remove the public modifier","   public CompatibilityModeConfiguration(boolean enabled, Marshaller marshaller) {
      this.enabled = enabled;
      this.marshaller = marshaller;
   }
","START    public CompatibilityModeConfiguration(boolean enabled, Marshaller marshaller) { END 
      this.enabled = enabled;
      this.marshaller = marshaller;
   }
","   CompatibilityModeConfiguration(boolean enabled, Marshaller marshaller) {
      this.enabled = enabled;
      this.marshaller = marshaller;
   }
"
966,"We historically use ""String"" value type for LoA, since it's like that in all production DBs. Please fix type to String in both modules (user|member:virt:loa). Thank you.","	public AttributeDefinition getAttributeDefinition() {
		AttributeDefinition attr = new AttributeDefinition();
		attr.setNamespace(AttributesManager.NS_USER_ATTR_VIRT);
		attr.setFriendlyName(""loa"");
		attr.setDisplayName(""Level of assurance"");
		attr.setType(Integer.class.getName());
		attr.setDescription(""The highest value of LoA from all user's userExtSources."");
		return attr;
	}
","	public AttributeDefinition getAttributeDefinition() {
		AttributeDefinition attr = new AttributeDefinition();
		attr.setNamespace(AttributesManager.NS_USER_ATTR_VIRT);
		attr.setFriendlyName(""loa"");
		attr.setDisplayName(""Level of assurance"");
START 		attr.setType(Integer.class.getName()); END 
		attr.setDescription(""The highest value of LoA from all user's userExtSources."");
		return attr;
	}
","	public AttributeDefinition getAttributeDefinition() {
		AttributeDefinition attr = new AttributeDefinition();
		attr.setNamespace(AttributesManager.NS_USER_ATTR_VIRT);
		attr.setFriendlyName(""loa"");
		attr.setDisplayName(""Level of assurance"");
		attr.setType(String.class.getName());
		attr.setDescription(""The highest value of LoA from all user's userExtSources."");
		return attr;
	}
"
967,"One suggestion, this might be useful to put in the AttributeGetter code since it is a special case for this attribute.  I don't know whether that would cause issues elsewhere though.","    public Intersection(SimpleFeature intersectionFeature, AttributeGetter getter) {
        this.point = (Point) intersectionFeature.getDefaultGeometry();
        this.attGet = getter;
        this.transectId = (Integer) attGet.getValue(TRANSECT_ID_ATTR, intersectionFeature);
        this.distance = (Double) attGet.getValue(DISTANCE_ATTR, intersectionFeature);
        this.isMeanHighWater = getBooleanFromMhwAttribute(attGet.getValue(MHW_ATTR, intersectionFeature));
        this.feature = intersectionFeature;
    }
","    public Intersection(SimpleFeature intersectionFeature, AttributeGetter getter) {
        this.point = (Point) intersectionFeature.getDefaultGeometry();
        this.attGet = getter;
        this.transectId = (Integer) attGet.getValue(TRANSECT_ID_ATTR, intersectionFeature);
        this.distance = (Double) attGet.getValue(DISTANCE_ATTR, intersectionFeature);
START         this.isMeanHighWater = getBooleanFromMhwAttribute(attGet.getValue(MHW_ATTR, intersectionFeature)); END 
        this.feature = intersectionFeature;
    }
","    public Intersection(SimpleFeature intersectionFeature, AttributeGetter getter) {
        this.point = (Point) intersectionFeature.getDefaultGeometry();
        this.attGet = getter;
        this.transectId = (Integer) attGet.getValue(TRANSECT_ID_ATTR, intersectionFeature);
        this.distance = (Double) attGet.getValue(DISTANCE_ATTR, intersectionFeature);
        this.isMeanHighWater = attGet.getBooleanFromMhwAttribute(attGet.getValue(MHW_ATTR, intersectionFeature));
        this.feature = intersectionFeature;
    }
"
968,Let's make it public.,"	Parent( String parentAttribute ) {
		this.parentAttribute = parentAttribute;
	}
","START 	Parent( String parentAttribute ) { END 
		this.parentAttribute = parentAttribute;
	}
","	public Parent( String parentAttribute ) {
		this.parentAttribute = parentAttribute;
	}
"
969,"As far as I understand start column is replaced with `**` in Calcite, do we need to check for `*` as well?","  public static List<SchemaPath> projectList(String... names) {
    List<SchemaPath> selected = new ArrayList<>();
    for (String name : names) {
      if (name.equals(SchemaPath.DYNAMIC_STAR) ||
          name.equals(""*"")) {
        selected.add(SchemaPath.STAR_COLUMN);
      } else {
        selected.add(SchemaPath.parseFromString(name));
      }
    }
    return selected;
  }
","  public static List<SchemaPath> projectList(String... names) {
    List<SchemaPath> selected = new ArrayList<>();
    for (String name : names) {
      if (name.equals(SchemaPath.DYNAMIC_STAR) ||
START           name.equals(""*"")) { END 
        selected.add(SchemaPath.STAR_COLUMN);
      } else {
        selected.add(SchemaPath.parseFromString(name));
      }
    }
    return selected;
  }
","  public static List<SchemaPath> projectList(String... names) {
    List<SchemaPath> selected = new ArrayList<>();
    for (String name : names) {
      if (name.equals(SchemaPath.DYNAMIC_STAR)) {
        selected.add(SchemaPath.STAR_COLUMN);
      } else {
        selected.add(SchemaPath.parseFromString(name));
      }
    }
    return selected;
  }
"
970,static import,"    private static String asText(JsonNode node)
    {
        Preconditions.checkState(node.isValueNode());
        return node.isNull() ? null : node.asText();
    }
","    private static String asText(JsonNode node)
    {
START         Preconditions.checkState(node.isValueNode()); END 
        return node.isNull() ? null : node.asText();
    }
","    private static String asText(JsonNode node)
    {
        checkState(node.isValueNode());
        return node.isNull() ? null : node.asText();
    }
"
971,"Are these ""contains"" assertions necessary? You're checking ```operators.size() == 0```","    public void testFilterOptionsForConstraintTypeLiteralWhenConstraintValueIsFormula() {
        when(plugin.constraintValue()).thenReturn(BaseSingleFieldConstraint.TYPE_RET_VALUE);

        final String[] result = page.filterOptionsForConstraintTypeLiteral(OperatorsOracle.EXPLICIT_LIST_OPERATORS);
        final List<String> operators = Arrays.asList(result);

        assertFalse(operators.contains(""in""));
        assertFalse(operators.contains(""not in""));
        assertEquals(0,
                     operators.size());
    }
","    public void testFilterOptionsForConstraintTypeLiteralWhenConstraintValueIsFormula() {
        when(plugin.constraintValue()).thenReturn(BaseSingleFieldConstraint.TYPE_RET_VALUE);

        final String[] result = page.filterOptionsForConstraintTypeLiteral(OperatorsOracle.EXPLICIT_LIST_OPERATORS);
        final List<String> operators = Arrays.asList(result);

START         assertFalse(operators.contains(""in"")); END 
        assertFalse(operators.contains(""not in""));
        assertEquals(0,
                     operators.size());
    }
","    public void testFilterOptionsForConstraintTypeLiteralWhenConstraintValueIsFormula() {
        when(plugin.constraintValue()).thenReturn(BaseSingleFieldConstraint.TYPE_RET_VALUE);

        final String[] result = page.filterOptionsForConstraintTypeLiteral(OperatorsOracle.EXPLICIT_LIST_OPERATORS);
        final List<String> operators = Arrays.asList(result);
        assertEquals(0, operators.size());
    }
"
972,"The main logic is run at the end: it is somewhat counter-intuitive. 
 
More of a style issue: as both the `dodeleteFeedMediaOfItem()` and `removeQueueItem()` are really run asynchronously anyway.","    public static Future<?> deleteFeedMediaOfItem(final Context context,
                                                  final long mediaId) {
        if (UserPreferences.shouldDeleteRemoveFromQueue()) {
            DBWriter.removeQueueItem(context, DBReader.getFeedMedia(mediaId).getItem(), false);
        }
        return doDeleteFeedMediaOfItem(context, mediaId);
    }
","    public static Future<?> deleteFeedMediaOfItem(final Context context,
                                                  final long mediaId) {
        if (UserPreferences.shouldDeleteRemoveFromQueue()) {
            DBWriter.removeQueueItem(context, DBReader.getFeedMedia(mediaId).getItem(), false);
        }
START         return doDeleteFeedMediaOfItem(context, mediaId); END 
    }
","    public static Future<?> deleteFeedMediaOfItem(final Context context,
                                                  final long mediaId) {
        Future res = doDeleteFeedMediaOfItem(context, mediaId);
        if (UserPreferences.shouldDeleteRemoveFromQueue()) {
            DBWriter.removeQueueItem(context, DBReader.getFeedMedia(mediaId).getItem(), false);
        }
        return res;
    }
"
973,Could combine this line with the next one.,"        public void clientCallback(ClientResponse response) throws Exception {
            m_responses[m_index] = new ClientResponseWithPartitionKey(m_partitionKey, response);
            m_partitionCounter.decrementAndGet();
            if (m_partitionCounter.get() == 0) {
                m_cb.clientCallback(m_responses);
            }
        }
","        public void clientCallback(ClientResponse response) throws Exception {
            m_responses[m_index] = new ClientResponseWithPartitionKey(m_partitionKey, response);
START             m_partitionCounter.decrementAndGet(); END 
            if (m_partitionCounter.get() == 0) {
                m_cb.clientCallback(m_responses);
            }
        }
","        public void clientCallback(ClientResponse response) throws Exception {
            m_responses[m_index] = new ClientResponseWithPartitionKey(m_partitionKey, response);
            if (m_partitionCounter.decrementAndGet() == 0) {
                m_cb.clientCallback(m_responses);
            }
        }
"
974,I would prefer IllegalArgumentException,"  public synchronized IResource getResource(
      IReferencePoint referencePoint, IPath referencePointRelativePath) {
    if (referencePoint == null) throw new NullPointerException(""Reference point is null"");

    if (referencePointRelativePath == null) throw new NullPointerException(""Path is null"");

    org.eclipse.core.resources.IProject project = get(referencePoint);

    if (project == null)
      throw new NullPointerException(
          ""For reference point "" + referencePoint + "" does'nt exist a project."");

    return project.findMember(referencePointRelativePath);
  }
","  public synchronized IResource getResource(
      IReferencePoint referencePoint, IPath referencePointRelativePath) {
    if (referencePoint == null) throw new NullPointerException(""Reference point is null"");

START     if (referencePointRelativePath == null) throw new NullPointerException(""Path is null""); END 

    org.eclipse.core.resources.IProject project = get(referencePoint);

    if (project == null)
      throw new NullPointerException(
          ""For reference point "" + referencePoint + "" does'nt exist a project."");

    return project.findMember(referencePointRelativePath);
  }
","  public IResource getResource(IReferencePoint referencePoint, IPath referencePointRelativePath) {
    if (referencePoint == null) throw new IllegalStateException(""Reference point is null"");

    if (referencePointRelativePath == null) throw new IllegalStateException(""Path is null"");

    org.eclipse.core.resources.IProject project = get(referencePoint);

    if (project == null)
      throw new NullPointerException(
          ""For reference point "" + referencePoint + "" does'nt exist a project."");

    return project.findMember(referencePointRelativePath);
  }
"
975,convert to conditional expression (? :).,"	protected boolean doSelect(Viewer viewer, Object parent, Object element) {
		if (element instanceof PackageFragmentRootContainer) {
			if (isApplicable() && viewer instanceof StructuredViewer) {
				PackageFragmentRootContainer rootContainer = (PackageFragmentRootContainer) element;
				if (rootContainer.getChildren().length > 0) {
					return hasFilteredChildren((StructuredViewer) viewer, rootContainer);
				}
				return false;
			}
		}
		return true;
	}
","	protected boolean doSelect(Viewer viewer, Object parent, Object element) {
		if (element instanceof PackageFragmentRootContainer) {
			if (isApplicable() && viewer instanceof StructuredViewer) {
				PackageFragmentRootContainer rootContainer = (PackageFragmentRootContainer) element;
START 				if (rootContainer.getChildren().length > 0) {
					return hasFilteredChildren((StructuredViewer) viewer, rootContainer);
				}
				return false; END 
			}
		}
		return true;
	}
","	protected boolean doSelect(Viewer viewer, Object parent, Object element) {
		if (element instanceof PackageFragmentRootContainer) {
			if (isApplicable() && viewer instanceof StructuredViewer) {
				PackageFragmentRootContainer rootContainer= (PackageFragmentRootContainer) element;
				return rootContainer.getChildren().length > 0 ? hasFilteredChildren((StructuredViewer) viewer, rootContainer) : false;
			}
		}
		return true;
	}
"
976,"Definitely remove the sorting.
If possible, don't convert to a List either, if JSON serialization prints a Set as a JSON array.","  public Response handle() throws Exception {
    ServerSideSession session = getDriver().getSession(getRequest().getSession());
    List<String> types = new ArrayList<String>(session.getLogManager().getTypes());
    Collections.sort(types);
    return createResponse(types);
  }
","  public Response handle() throws Exception {
    ServerSideSession session = getDriver().getSession(getRequest().getSession());
START     List<String> types = new ArrayList<String>(session.getLogManager().getTypes()); END 
    Collections.sort(types);
    return createResponse(types);
  }
","  public Response handle() throws Exception {
    ServerSideSession session = getDriver().getSession(getRequest().getSession());
    Set<String> types = session.getLogManager().getTypes();
    return createResponse(types);
  }
"
977,Duplicate non-null check (also done in Transition).,"    public boolean addStateTransition(final ActivationState from, final EventType event, final ActivationState to) {
        Objects.requireNonNull(from, ""From state cannot be null!"");
        Objects.requireNonNull(event, ""Event cannot be null!"");
        Objects.requireNonNull(to, ""To state cannot be null!"");
        Transition transition = new Transition(from, event, to);
        
        return addStateTransition(transition);
    }
","    public boolean addStateTransition(final ActivationState from, final EventType event, final ActivationState to) {
START         Objects.requireNonNull(from, ""From state cannot be null!""); END 
        Objects.requireNonNull(event, ""Event cannot be null!"");
        Objects.requireNonNull(to, ""To state cannot be null!"");
        Transition transition = new Transition(from, event, to);
        
        return addStateTransition(transition);
    }
","    public boolean addStateTransition(final ActivationState from, final EventType event, final ActivationState to) {
        return addStateTransition(new Transition(from, event, to));
    }
"
978,Why convulotions between list and array ?,"  Type leastUpperBound(List<Type> typeAlternatives) {
    return types.leastUpperBound(typeAlternatives.toArray(new Type[typeAlternatives.size()]));
  }
","  Type leastUpperBound(List<Type> typeAlternatives) {
START     return types.leastUpperBound(typeAlternatives.toArray(new Type[typeAlternatives.size()])); END 
  }
","  Type leastUpperBound(List<Type> typeAlternatives) {
    return types.leastUpperBound(typeAlternatives);
  }
"
979,Still not thread safe. Needs to be done at startup / postconstruct.,"    public Response getOpenApiSpec(@Context HttpHeaders headers,
            @Context UriInfo uriInfo,
            @PathParam(""type"") String type,
            @Context ServletConfig config,
            @Context Application app)
            throws Exception
    {
        setOpenApiConfiguration(oasConfig);
        Response response = super.getOpenApi(headers, config, app, uriInfo, type);
        response.getHeaders().add(""Access-Control-Allow-Origin"", ""*"");
        return response;
    }
","    public Response getOpenApiSpec(@Context HttpHeaders headers,
            @Context UriInfo uriInfo,
            @PathParam(""type"") String type,
            @Context ServletConfig config,
            @Context Application app)
            throws Exception
    {
START         setOpenApiConfiguration(oasConfig); END 
        Response response = super.getOpenApi(headers, config, app, uriInfo, type);
        response.getHeaders().add(""Access-Control-Allow-Origin"", ""*"");
        return response;
    }
","    public Response getOpenApiSpec(
            @Context HttpHeaders headers,
            @Context UriInfo uriInfo,
            @PathParam(""type"") String type,
            @Context ServletConfig config,
            @Context Application app)
            throws Exception
    {
        Response response = getOpenApi(headers, config, app, uriInfo, type);
        response.getHeaders().add(""Access-Control-Allow-Origin"", ""*"");
        return response;
    }
"
980,"I'm really used to the builders creating all their children all the time, is it really worth doing it differently here?","    public Optional<RestRouterConfiguration> build() {
        if (this.enabled) {
            try {
                validate();
            } catch (Exception e) {
                throw logger.configurationValidationError(e);
            }
            return Optional.of(new RestRouterConfiguration(ip, port));
        }
        return Optional.empty();
    }
","    public Optional<RestRouterConfiguration> build() {
        if (this.enabled) {
            try {
                validate();
            } catch (Exception e) {
                throw logger.configurationValidationError(e);
            }
            return Optional.of(new RestRouterConfiguration(ip, port));
        }
START         return Optional.empty(); END 
    }
","    public RestRouterConfiguration build() {
        if (this.enabled) {
            try {
                validate();
            } catch (Exception e) {
                throw logger.configurationValidationError(e);
            }
            return new RestRouterConfiguration(ip, port);
        }
        return null;
    }
"
981,Why not getNicType().getItems() != null?,"    protected void initSelectedType() {
        final VmInterfaceType defaultNicType = getDeafultNicTypeByProfile();

        final Collection<VmInterfaceType> vnicTypes =
                supportedVnicTypes == null ? new ArrayList<VmInterfaceType>() : supportedVnicTypes;

        if (getNicType().getItems() != vnicTypes) {
            getNicType().setItems(vnicTypes, defaultNicType);
        } else {
            getNicType().setSelectedItem(defaultNicType);
        }
    }
","    protected void initSelectedType() {
        final VmInterfaceType defaultNicType = getDeafultNicTypeByProfile();

        final Collection<VmInterfaceType> vnicTypes =
                supportedVnicTypes == null ? new ArrayList<VmInterfaceType>() : supportedVnicTypes;

START         if (getNicType().getItems() != vnicTypes) { END 
            getNicType().setItems(vnicTypes, defaultNicType);
        } else {
            getNicType().setSelectedItem(defaultNicType);
        }
    }
","    protected void initSelectedType() {
        final VmInterfaceType defaultNicType = getDeafultNicTypeByProfile();

        final Collection<VmInterfaceType> vnicTypes =
                supportedVnicTypes == null ? new ArrayList<VmInterfaceType>() : supportedVnicTypes;

        if (getNicType().getItems() == null) {
            getNicType().setItems(vnicTypes, defaultNicType);
        } else {
            getNicType().setSelectedItem(defaultNicType);
        }
    }
"
982,Why does this need a super()?,"  public TestToolUtils() throws IOException {
    super();
  }
","  public TestToolUtils() throws IOException {
START     super(); END 
  }
","  public TestToolUtils() throws IOException {}
"
983,Isn't there a way to first of all get the first item and only if present return the idea? Can save the mapping of the complete list just to return the first one (IIUC),"    private Guid getStorageDomainId(Guid poolId, StorageDomainType type, StorageDomainStatus status) {
        return getStorageDomains(poolId, type, status).stream().map(StorageDomain::getId).findFirst().orElse(Guid.Empty);
    }
","    private Guid getStorageDomainId(Guid poolId, StorageDomainType type, StorageDomainStatus status) {
        return getStorageDomains(poolId, type, START status).stream().map(StorageDomain::getId).findFirst().orElse(Guid.Empty); END 
    }
","    private Guid getStorageDomainId(Guid poolId, StorageDomainType type, StorageDomainStatus status) {
        return getStorageDomains(poolId, type, status).stream().findFirst().map(StorageDomain::getId).orElse(Guid.Empty);
    }
"
984,"This doesn't need to be public, it's only called from within this file.","  public static List<PostAggregator> prunePostAggregators(TopNQuery query)
  {
    return AggregatorUtil.pruneDependentPostAgg(
        query.getPostAggregatorSpecs(),
        query.getTopNMetricSpec().getMetricName(query.getDimensionSpec())
    );
  }
","START   public static List<PostAggregator> prunePostAggregators(TopNQuery query) END 
  {
    return AggregatorUtil.pruneDependentPostAgg(
        query.getPostAggregatorSpecs(),
        query.getTopNMetricSpec().getMetricName(query.getDimensionSpec())
    );
  }
","  private static List<PostAggregator> prunePostAggregators(TopNQuery query)
  {
    return AggregatorUtil.pruneDependentPostAgg(
        query.getPostAggregatorSpecs(),
        query.getTopNMetricSpec().getMetricName(query.getDimensionSpec())
    );
  }
"
985,"I would put this method just after `isGlobalGetOptMethod()`, to group methods in logical call order.","  private boolean isSuspiciousClassInstantiation(ExpressionTree callee) {
    if (callee.is(Tree.Kind.NAMESPACE_NAME)) {
      NamespaceNameTree classNameTree = (NamespaceNameTree) callee;
      QualifiedName className = getFullyQualifiedName(classNameTree);
      return SUSPICIOUS_CLASS_INSTANTIATIONS.stream().anyMatch(className::equals);
    }
    return false;
  }
","START   private boolean isSuspiciousClassInstantiation(ExpressionTree callee) { END 
    if (callee.is(Tree.Kind.NAMESPACE_NAME)) {
      NamespaceNameTree classNameTree = (NamespaceNameTree) callee;
      QualifiedName className = getFullyQualifiedName(classNameTree);
      return SUSPICIOUS_CLASS_INSTANTIATIONS.stream().anyMatch(className::equals);
    }
    return false;
  }
","  private boolean isSuspiciousClassInstantiation(ExpressionTree callee) {
    if (callee.is(Tree.Kind.NAMESPACE_NAME)) {
      QualifiedName className = getFullyQualifiedName((NamespaceNameTree) callee);
      return SUSPICIOUS_CLASS_INSTANTIATIONS.stream().anyMatch(className::equals);
    }
    return false;
  }
"
986,"why are you removing the response, some of the thing we have figured out is that the request must be always coming together with the response, even if it is not used at this time, could be in the future","    private PageMode getMode() {
        final PageMode currentMode = PageMode.get(request);
        return currentMode.showLive ? currentMode :
                APILocator.getHTMLPageAssetRenderedAPI().getDefaultEditPageMode(user, request, uri, response);
    }
","    private PageMode getMode() {
        final PageMode currentMode = PageMode.get(request);
        return currentMode.showLive ? currentMode :
START                 APILocator.getHTMLPageAssetRenderedAPI().getDefaultEditPageMode(user, request, uri, response); END 
    }
","    private PageMode getMode() {
        final PageMode currentMode = PageMode.get(request);
        return currentMode.showLive ? currentMode :
                APILocator.getHTMLPageAssetRenderedAPI().getDefaultEditPageMode(user, request, uri);
    }
"
987,"I'd put this if outside the other.

but :+1: anyway... no need for locks, since the temp dir won't change (or shouldn't, anyway)","	public File getDirectory() {
		if (tmpdir == null) {
			tmpdir = getTemporaryDirectory();
			if (tmpdir == null) {
				tmpdir = createDirInsideApplication();
			}
		}

		return tmpdir.toFile();
	}
","	public File getDirectory() {
		if (tmpdir == null) {
			tmpdir = getTemporaryDirectory();
			if (tmpdir == null) {
				tmpdir = createDirInsideApplication();
START 			} END 
		}

		return tmpdir.toFile();
	}
","	public File getDirectory() {
		if (tmpdir == null) {
			tmpdir = getTemporaryDirectory();
		}

		if (tmpdir == null) {
			tmpdir = createDirInsideApplication();
		}

		return tmpdir.toFile();
	}
"
988,nit: remove `else` as you return in the `if` block anyway.,"        public boolean matches(ILoggingEvent actual) {
            // Match only the first line to skip the validation of hex-dump format.
            actualMsg = actual.getMessage().split(""(?s)[\\r\\n]+"")[0];
            if (actualMsg.matches(expected)) {
                // The presence of a newline implies a hex-dump was logged
                return actual.getMessage().contains(NEWLINE) == shouldContainNewline; 
            } else {
                return false;
            }
        }
","        public boolean matches(ILoggingEvent actual) {
            // Match only the first line to skip the validation of hex-dump format.
            actualMsg = actual.getMessage().split(""(?s)[\\r\\n]+"")[0];
            if (actualMsg.matches(expected)) {
                // The presence of a newline implies a hex-dump was logged
                return actual.getMessage().contains(NEWLINE) == shouldContainNewline; 
START             } else { END 
                return false;
            }
        }
","        public boolean matches(ILoggingEvent actual) {
            // Match only the first line to skip the validation of hex-dump format.
            actualMsg = actual.getMessage().split(""(?s)[\\r\\n]+"")[0];
            if (actualMsg.matches(expected)) {
                // The presence of a newline implies a hex-dump was logged
                return actual.getMessage().contains(NEWLINE) == shouldContainNewline;
            }
            return false;
        }
"
989,I think this method has no need to be `static`,"    private static void addPropertyVariableToResult(Collection<Pair<Object, String>> result, String element) {
        if (element.length() > 0) {
            List<String> list = Arrays.asList(element.split("",""));
            list.forEach(s1 -> {
                String value = s1.split("":"")[0];
                result.add(new Pair<>(value, value));
            });
        }
    }
","START     private static void addPropertyVariableToResult(Collection<Pair<Object, String>> result, String element) { END 
        if (element.length() > 0) {
            List<String> list = Arrays.asList(element.split("",""));
            list.forEach(s1 -> {
                String value = s1.split("":"")[0];
                result.add(new Pair<>(value, value));
            });
        }
    }
","    private void addPropertyVariableToResult(Collection<Pair<Object, String>> result, String element) {
        if (element.length() > 0) {
            List<String> list = Arrays.asList(element.split("",""));
            list.forEach(s1 -> {
                String value = s1.split("":"")[0];
                result.add(new Pair<>(value, value));
            });
        }
    }
"
990,Unnecessary else. You can just return extensionJobNames outside the if statement.,"    public List<String> getJobsForAnExtension(final String extensionName) throws FalconException {
        List<ExtensionJobsBean> extensionJobs = metaStore.getJobsForAnExtension(extensionName);
        List<String> extensionJobNames = new ArrayList<>();
        if (null != extensionJobs && !extensionJobs.isEmpty()){
            for (ExtensionJobsBean extensionJobsBean: extensionJobs) {
                extensionJobNames.add(extensionJobsBean.getJobName());
            }
            return extensionJobNames;
        } else {
            return extensionJobNames;
        }
    }
","    public List<String> getJobsForAnExtension(final String extensionName) throws FalconException {
        List<ExtensionJobsBean> extensionJobs = metaStore.getJobsForAnExtension(extensionName);
        List<String> extensionJobNames = new ArrayList<>();
        if (null != extensionJobs && !extensionJobs.isEmpty()){
            for (ExtensionJobsBean extensionJobsBean: extensionJobs) {
                extensionJobNames.add(extensionJobsBean.getJobName());
            }
            return extensionJobNames;
START         } else { END 
            return extensionJobNames;
        }
    }
","    public List<String> getJobsForAnExtension(final String extensionName) throws FalconException {
        List<ExtensionJobsBean> extensionJobs = metaStore.getJobsForAnExtension(extensionName);
        List<String> extensionJobNames = new ArrayList<>();
        if (null != extensionJobs && !extensionJobs.isEmpty()) {
            for (ExtensionJobsBean extensionJobsBean : extensionJobs) {
                extensionJobNames.add(extensionJobsBean.getJobName());
            }
        }
        return extensionJobNames;
    }
"
991,I thought the default was false.,"  public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    copySelfOnEmail = false;
    displayPatchSetsInReverseOrder = false;
    displayPersonNameInReviewCategory = true;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
  }
","  public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    copySelfOnEmail = false;
    displayPatchSetsInReverseOrder = false;
START     displayPersonNameInReviewCategory = true; END 
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
  }
","  public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    copySelfOnEmail = false;
    displayPatchSetsInReverseOrder = false;
    displayPersonNameInReviewCategory = false;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
  }
"
992,why did you reverse this return value @kansal ? I missed it in the first itteration,"    public static boolean isIpWithtInCidrRange(final String ipAddress, final String cidr) {
        if (!isValidIp(ipAddress)) {
            return false;
        }
        if (!isValidCIDR(cidr)) {
            return false;
        }

        // check if the gatewayip is the part of the ip range being added.
        // RFC 3021 - 31-Bit Prefixes on IPv4 Point-to-Point Links
        //     GW              Netmask         Stat IP        End IP
        // 192.168.24.0 - 255.255.255.254 - 192.168.24.0 - 192.168.24.1
        // https://tools.ietf.org/html/rfc3021
        // Added by Wilder Rodrigues
        final SubnetUtils subnetUtils = new SubnetUtils(cidr);
        subnetUtils.setInclusiveHostCount(true);

        final boolean isInRange = subnetUtils.getInfo().isInRange(ipAddress);

        return !isInRange;
    }
","    public static boolean isIpWithtInCidrRange(final String ipAddress, final String cidr) {
        if (!isValidIp(ipAddress)) {
            return false;
        }
        if (!isValidCIDR(cidr)) {
            return false;
        }

        // check if the gatewayip is the part of the ip range being added.
        // RFC 3021 - 31-Bit Prefixes on IPv4 Point-to-Point Links
        //     GW              Netmask         Stat IP        End IP
        // 192.168.24.0 - 255.255.255.254 - 192.168.24.0 - 192.168.24.1
        // https://tools.ietf.org/html/rfc3021
        // Added by Wilder Rodrigues
        final SubnetUtils subnetUtils = new SubnetUtils(cidr);
        subnetUtils.setInclusiveHostCount(true);

        final boolean isInRange = subnetUtils.getInfo().isInRange(ipAddress);

START         return !isInRange; END 
    }
","    public static boolean isIpWithtInCidrRange(final String ipAddress, final String cidr) {
        if (!isValidIp(ipAddress)) {
            return false;
        }
        if (!isValidCIDR(cidr)) {
            return false;
        }

        // check if the gatewayip is the part of the ip range being added.
        // RFC 3021 - 31-Bit Prefixes on IPv4 Point-to-Point Links
        //     GW              Netmask         Stat IP        End IP
        // 192.168.24.0 - 255.255.255.254 - 192.168.24.0 - 192.168.24.1
        // https://tools.ietf.org/html/rfc3021
        // Added by Wilder Rodrigues
        final SubnetUtils subnetUtils = new SubnetUtils(cidr);
        subnetUtils.setInclusiveHostCount(true);

        final boolean isInRange = subnetUtils.getInfo().isInRange(ipAddress);

        return isInRange;
    }
"
993,isn't it true by default?,"    public void edit(final UnitVmModel object) {
        super.edit(object);

        if (object.getIsNew()) {
            object.getNumOfDesktops().setEntity(1);
        }
        prestartedVmsEditor.setEnabled(true);
    }
","    public void edit(final UnitVmModel object) {
        super.edit(object);

        if (object.getIsNew()) {
            object.getNumOfDesktops().setEntity(1);
        }
START         prestartedVmsEditor.setEnabled(true); END 
    }
","    public void edit(final UnitVmModel object) {
        super.edit(object);

        if (object.getIsNew()) {
            object.getNumOfDesktops().setEntity(1);
        }
    }
"
994,"We should handle the case where ""ctx"" is null here.  Consider either returning null or throwing a IllegalStateException similar to how other methods in WolfSSLContext.java do.","    public String[] getProtocolsMask(long noOpt) {
            ctx.setOptions(noOpt);
            return WolfSSL.getProtocolsMask(noOpt);
    }
","    public String[] getProtocolsMask(long noOpt) {
START             ctx.setOptions(noOpt); END 
            return WolfSSL.getProtocolsMask(noOpt);
    }
","    public String[] getProtocolsMask(long noOpt) {
            if(ctx != null)
                ctx.setOptions(noOpt);
            return WolfSSL.getProtocolsMask(noOpt);
    }
"
995,remove,"    public synchronized boolean installSingleNodeLayoutIfAbsent() {
        if ((Boolean) getServerConfig().get(""--single"") && getCurrentLayout() == null) {
            setCurrentLayout(getNewSingleNodeLayout());
            log.error(""HERE ====="");
            return true;
        }
        return false;
    }
","    public synchronized boolean installSingleNodeLayoutIfAbsent() {
        if ((Boolean) getServerConfig().get(""--single"") && getCurrentLayout() == null) {
            setCurrentLayout(getNewSingleNodeLayout());
START             log.error(""HERE =====""); END 
            return true;
        }
        return false;
    }
","    public synchronized boolean installSingleNodeLayoutIfAbsent() {
        if ((Boolean) getServerConfig().get(""--single"") && getCurrentLayout() == null) {
            setCurrentLayout(getNewSingleNodeLayout());
            return true;
        }
        return false;
    }
"
996,"We can convert `this.fsConf` to be a local variable and in `getConf()` do 
`return new Configuration(underlyingFs.getConf());`","  public DrillFileSystem(Configuration fsConf, OperatorStats operatorStats) throws IOException {
    // Configuration objects are mutable, and the underlying FileSystem object may directly use a passed in Configuration.
    // In order to avoid scenarios where a Configuration can change after a DrillFileSystem is created, we make a copy
    // of the Configuration.
    this.fsConf = new Configuration(fsConf);
    this.underlyingFs = FileSystem.get(this.fsConf);
    this.codecFactory = new CompressionCodecFactory(this.fsConf);
    this.operatorStats = operatorStats;
    this.initialized = true;
  }
","  public DrillFileSystem(Configuration fsConf, OperatorStats operatorStats) throws IOException {
    // Configuration objects are mutable, and the underlying FileSystem object may directly use a passed in Configuration.
    // In order to avoid scenarios where a Configuration can change after a DrillFileSystem is created, we make a copy
    // of the Configuration.
START     this.fsConf = new Configuration(fsConf); END 
    this.underlyingFs = FileSystem.get(this.fsConf);
    this.codecFactory = new CompressionCodecFactory(this.fsConf);
    this.operatorStats = operatorStats;
    this.initialized = true;
  }
","  public DrillFileSystem(Configuration fsConf, OperatorStats operatorStats) throws IOException {
    // Configuration objects are mutable, and the underlying FileSystem object may directly use a passed in Configuration.
    // In order to avoid scenarios where a Configuration can change after a DrillFileSystem is created, we make a copy
    // of the Configuration.
    fsConf = new Configuration(fsConf);
    this.underlyingFs = FileSystem.get(fsConf);
    this.codecFactory = new CompressionCodecFactory(fsConf);
    this.operatorStats = operatorStats;
  }
"
997,this is just white space changes right?,"    @Test public void testParse() throws NoSuchAuthorityCodeException {
        final URN_Parser parser = URN_Parser.buildParser(""urn:ogc:def:CRS:EPSG:6.11.2:4326"");
        assertEquals(""crs"", parser.type.name);
        assertEquals(""EPSG"", parser.authority);
        assertEquals(""6.11.2"", parser.version.toString());
        assertEquals(""4326"", parser.code);
        assertEquals(""EPSG:4326"", parser.getAuthorityCode());
    }
","    @Test public void testParse() throws NoSuchAuthorityCodeException {
        final URN_Parser parser = URN_Parser.buildParser(""urn:ogc:def:CRS:EPSG:6.11.2:4326"");
        assertEquals(""crs"", parser.type.name);
        assertEquals(""EPSG"", parser.authority);
        assertEquals(""6.11.2"", parser.version.toString());
START         assertEquals(""4326"", parser.code); END 
        assertEquals(""EPSG:4326"", parser.getAuthorityCode());
    }
","    public void testParse() throws NoSuchAuthorityCodeException {
        final URN_Parser parser = URN_Parser.buildParser(""urn:ogc:def:CRS:EPSG:6.11.2:4326"");
        assertEquals(""crs"",       parser.type.name);
        assertEquals(""EPSG"",      parser.authority);
        assertEquals(""6.11.2"",    parser.version.toString());
        assertEquals(""4326"",      parser.code);
        assertEquals(""EPSG:4326"", parser.getAuthorityCode());
    }
"
998,"Not related to this fix, but can't we get rid of this extra `InitializingBean` operation and just `getSSLContext()` directly in the ctor ?","	public void afterPropertiesSet() throws Exception {
		this.sslContext = this.sslContextSupport.getSSLContext();
		Assert.notNull(this.sslContext, ""SSLContext must not be null"");
	}
","	public void afterPropertiesSet() throws Exception {
START 		this.sslContext = this.sslContextSupport.getSSLContext(); END 
		Assert.notNull(this.sslContext, ""SSLContext must not be null"");
	}
","	public void afterPropertiesSet() throws Exception {
	}
"
999,status repeated twice. I guess it was there in the original code too.,"    public int hashCode() {
        return Objects.hash(
                snapshotId,
                clusterId,
                volumeId,
                snapshotName,
                status,
                description,
                status
        );
    }
","    public int hashCode() {
        return Objects.hash(
                snapshotId,
                clusterId,
                volumeId,
                snapshotName,
                status,
                description,
START                 status END 
        );
    }
","    public int hashCode() {
        return Objects.hash(
                snapshotId,
                clusterId,
                volumeId,
                snapshotName,
                description,
                status
        );
    }
"
1000,What does the above line mean?,"	public Model getUPDATEModel(Representation representation) {
		return new ModelImpl()
		        .property(""condition"", new StringProperty())
		        .property(""patient"", new StringProperty())
		        .property(""clinicalStatus"", new StringProperty())
		        .property(""verificationStatus"", new StringProperty())
		        .property(""previousVersion"", new StringProperty())
		        .property(""onsetDate"", new StringProperty())
		        .property(""voided"", new StringProperty())
		        .required(""condition"").required(""onsetDate"");
	}
","	public Model getUPDATEModel(Representation representation) {
		return new ModelImpl()
		        .property(""condition"", new StringProperty())
		        .property(""patient"", new StringProperty())
		        .property(""clinicalStatus"", new StringProperty())
		        .property(""verificationStatus"", new StringProperty())
		        .property(""previousVersion"", new StringProperty())
		        .property(""onsetDate"", new StringProperty())
		        .property(""voided"", new StringProperty())
START 		        .required(""condition"").required(""onsetDate""); END 
	}
","	public Model getUPDATEModel(Representation representation) {
		return new ModelImpl()
		        .property(""condition"", new StringProperty())
		        .property(""clinicalStatus"", new StringProperty())
		        .property(""verificationStatus"", new StringProperty())
		        .property(""previousVersion"", new StringProperty())
		        .property(""onsetDate"", new StringProperty())
		        .property(""voided"", new StringProperty());
	}
"
1001,please import this.,"    public String getHostFingerprint() throws IOException {
        if (_client == null) {
            throw new java.net.ConnectException(""SSH is not connected"");
        }
        return ((EngineSSHClient)_client).getHostFingerprint();
    }
","    public String getHostFingerprint() throws IOException {
        if (_client == null) {
START             throw new java.net.ConnectException(""SSH is not connected""); END 
        }
        return ((EngineSSHClient)_client).getHostFingerprint();
    }
","    public String getHostFingerprint() throws IOException {
        if (_client == null) {
            throw new ConnectException(""SSH is not connected"");
        }
        return ((EngineSSHClient)_client).getHostFingerprint();
    }
"
1002,@ekondrashev what `1` means here?,"    public void invite(final String friend) throws IOException {
        try {
            new JdbcSession(this.sql.source())
                // @checkstyle LineLength (1 line)
                .sql(""INSERT INTO friend (bout, alias, subscription) VALUES (?, ?, ?)"")
                .set(this.bout)
                .set(friend)
                .set(1)
                .insert(Outcome.VOID);
        } catch (final SQLException ex) {
            throw new IOException(ex);
        }
    }
","    public void invite(final String friend) throws IOException {
        try {
            new JdbcSession(this.sql.source())
                // @checkstyle LineLength (1 line)
                .sql(""INSERT INTO friend (bout, alias, subscription) VALUES (?, ?, ?)"")
                .set(this.bout)
                .set(friend)
START                 .set(1) END 
                .insert(Outcome.VOID);
        } catch (final SQLException ex) {
            throw new IOException(ex);
        }
    }
","    public void invite(final String friend) throws IOException {
        try {
            new JdbcSession(this.sql.source())
                // @checkstyle LineLength (1 line)
                .sql(""INSERT INTO friend (bout, alias, subscription) VALUES (?, ?, ?)"")
                .set(this.bout)
                .set(friend)
                .set(true)
                .insert(Outcome.VOID);
        } catch (final SQLException ex) {
            throw new IOException(ex);
        }
    }
"
1003,false=>true (after changing to isNewHost),"    public AddVdsVDSCommand(P parameters) {
        super(parameters, false);
    }
","    public AddVdsVDSCommand(P parameters) {
START         super(parameters, false); END 
    }
","    public AddVdsVDSCommand(P parameters) {
        super(parameters, true);
    }
"
1004,unnecessary cast to long,"        void run() {
            if (fused) {
                return;
            }
            Observer<? super Long> actual = this.actual;
            long e = end;
            for (long i = index; i != e && get() == 0; i++) {
                actual.onNext((long)i);
            }
            if (get() == 0) {
                lazySet(1);
                actual.onComplete();
            }
        }
","        void run() {
            if (fused) {
                return;
            }
            Observer<? super Long> actual = this.actual;
            long e = end;
            for (long i = index; i != e && get() == 0; i++) {
START                 actual.onNext((long)i); END 
            }
            if (get() == 0) {
                lazySet(1);
                actual.onComplete();
            }
        }
","        void run() {
            if (fused) {
                return;
            }
            Observer<? super Long> actual = this.actual;
            long e = end;
            for (long i = index; i != e && get() == 0; i++) {
                actual.onNext(i);
            }
            if (get() == 0) {
                lazySet(1);
                actual.onComplete();
            }
        }
"
1005,Unfortunately here we can have a situation when some events can be lost. I meant that ```eventsToFire``` map can have at the moment of call of method more elements than were processed in the loop because ```eventsToFire``` is backed by ```events``` map.,"  private void fireEventsFor(OLogSequenceNumber lsn) {
    // may be executed by only one thread at every instant of time

    final ConcurrentNavigableMap<OLogSequenceNumber, Runnable> eventsToFire = events.headMap(lsn, true);

    for (Runnable runnable : eventsToFire.values())
      runnable.run();

    eventsToFire.clear();
  }
","  private void fireEventsFor(OLogSequenceNumber lsn) {
    // may be executed by only one thread at every instant of time

    final ConcurrentNavigableMap<OLogSequenceNumber, Runnable> eventsToFire = events.headMap(lsn, true);

    for (Runnable runnable : eventsToFire.values())
      runnable.run();

START     eventsToFire.clear(); END 
  }
","  private void fireEventsFor(OLogSequenceNumber lsn) {
    // may be executed by only one thread at every instant of time

    final Iterator<Runnable> eventsToFire = events.headMap(lsn, true).values().iterator();
    while (eventsToFire.hasNext()) {
      eventsToFire.next().run();
      eventsToFire.remove();
    }
  }
"
1006,Unused args?,"   public void testPurgeDeletedVault() {
      api().purgeVault(LOCATION, vaultName);
      Object[] args = { resourceGroupName, vaultName, false };
      checkState(deletedVaultStatus.create(resourceGroupName, true).apply(vaultName),
              ""vault was not purged before timeout"");

   }
","   public void testPurgeDeletedVault() {
      api().purgeVault(LOCATION, vaultName);
START       Object[] args = { resourceGroupName, vaultName, false }; END 
      checkState(deletedVaultStatus.create(resourceGroupName, true).apply(vaultName),
              ""vault was not purged before timeout"");

   }
","   public void testPurgeDeletedVault() {
      api().purgeVault(LOCATION, vaultName);
      checkState(deletedVaultStatus.create(resourceGroupName, true).apply(vaultName),
              ""vault was not purged before timeout"");

   }
"
1007,"In a good implementation, the spatial reference instance should be shared between all instances of geometry coming the same dataset, so usually the esriSR size would not contribute to OGC types, but we don't enforce that on geometry side right now.","	public long estimateMemorySize()
	{
		return SIZE_OF_OGC_POINT + (point != null ? point.estimateMemorySize() : 0) +
				(esriSR != null ? esriSR.estimateMemorySize() : 0);
	}
","	public long estimateMemorySize()
	{
		return SIZE_OF_OGC_POINT + (point != null ? point.estimateMemorySize() : 0) +
START 				(esriSR != null ? esriSR.estimateMemorySize() : 0); END 
	}
","	public long estimateMemorySize()
	{
		return SIZE_OF_OGC_POINT + (point != null ? point.estimateMemorySize() : 0);
	}
"
1008,"Should these cases be reverse? (i.e., don't instantiate the logger unless audit logging is on)","    public void auditResponseMessage(T request, K response, AssertionType assertion, NhinTargetSystemType target,
        String direction, String _interface, Boolean isRequesting, Properties webContextProperties,
        String serviceName) {

        LOG.trace(""--- Before auditing of response message ---"");
        if (getAuditLogger() != null && isAuditLoggingOn(serviceName)) {
            getAuditLogger().auditResponseMessage(request, response, assertion, target, direction, _interface,
                isRequesting, webContextProperties, serviceName, getAuditTransforms());
        }
        LOG.trace(""--- After auditing of response message ---"");
    }
","    public void auditResponseMessage(T request, K response, AssertionType assertion, NhinTargetSystemType target,
        String direction, String _interface, Boolean isRequesting, Properties webContextProperties,
        String serviceName) {

        LOG.trace(""--- Before auditing of response message ---"");
START         if (getAuditLogger() != null && isAuditLoggingOn(serviceName)) { END 
            getAuditLogger().auditResponseMessage(request, response, assertion, target, direction, _interface,
                isRequesting, webContextProperties, serviceName, getAuditTransforms());
        }
        LOG.trace(""--- After auditing of response message ---"");
    }
","    public void auditResponseMessage(T request, K response, AssertionType assertion, NhinTargetSystemType target,
        String direction, String _interface, Boolean isRequesting, Properties webContextProperties,
        String serviceName) {

        LOG.trace(""--- Before auditing of response message ---"");
        if (isAuditLoggingOn(serviceName) && getAuditLogger() != null) {
            getAuditLogger().auditResponseMessage(request, response, assertion, target, direction, _interface,
                isRequesting, webContextProperties, serviceName, getAuditTransforms());
        }
        LOG.trace(""--- After auditing of response message ---"");
    }
"
1009,"I believe `mRenderer` should be converted to a local variable (instead of member variable) here?  `GeoJsonLayer` extends `Layer`, and there is a reference to the `GeoJsonRenderer` superclass `Renderer` within `Layers.storeRenderer()`.","    public GeoJsonLayer(GoogleMap map, JSONObject geoJsonFile) {
        if (geoJsonFile == null) {
            throw new IllegalArgumentException(""GeoJSON file cannot be null"");
        }
        mBoundingBox = null;
        GeoJsonParser parser = new GeoJsonParser(geoJsonFile);
        // Assign GeoJSON bounding box for FeatureCollection
        mBoundingBox = parser.getBoundingBox();
        HashMap<GeoJsonFeature, Object> geoJsonFeatures = new HashMap<>();
        for (GeoJsonFeature feature : parser.getFeatures()) {
            geoJsonFeatures.put(feature, null);
        }
        mRenderer = new GeoJsonRenderer(map, geoJsonFeatures);
        storeRenderer(mRenderer);
    }
","    public GeoJsonLayer(GoogleMap map, JSONObject geoJsonFile) {
        if (geoJsonFile == null) {
            throw new IllegalArgumentException(""GeoJSON file cannot be null"");
        }
        mBoundingBox = null;
        GeoJsonParser parser = new GeoJsonParser(geoJsonFile);
        // Assign GeoJSON bounding box for FeatureCollection
        mBoundingBox = parser.getBoundingBox();
        HashMap<GeoJsonFeature, Object> geoJsonFeatures = new HashMap<>();
        for (GeoJsonFeature feature : parser.getFeatures()) {
            geoJsonFeatures.put(feature, null);
        }
START         mRenderer = new GeoJsonRenderer(map, geoJsonFeatures); END 
        storeRenderer(mRenderer);
    }
","    public GeoJsonLayer(GoogleMap map, JSONObject geoJsonFile) {
        if (geoJsonFile == null) {
            throw new IllegalArgumentException(""GeoJSON file cannot be null"");
        }
        mBoundingBox = null;
        GeoJsonParser parser = new GeoJsonParser(geoJsonFile);
        // Assign GeoJSON bounding box for FeatureCollection
        mBoundingBox = parser.getBoundingBox();
        HashMap<GeoJsonFeature, Object> geoJsonFeatures = new HashMap<>();
        for (GeoJsonFeature feature : parser.getFeatures()) {
            geoJsonFeatures.put(feature, null);
        }
        GeoJsonRenderer mRenderer = new GeoJsonRenderer(map, geoJsonFeatures);
        storeRenderer(mRenderer);
    }
"
1010,this condition can be incorporated into the for loop,"  protected int computeNewLength(int[] dimValSelector, int numProcessed, int numToProcess)
  {
    int valid = 0;
    int length = 0;
    for (int i = numProcessed; i < dimValSelector.length; i++) {
      length++;
      if (SKIP_POSITION_VALUE != dimValSelector[i]) {
        valid++;
      }
      if (valid == numToProcess) {
        break;
      }
    }
    return length;
  }
","  protected int computeNewLength(int[] dimValSelector, int numProcessed, int numToProcess)
  {
    int valid = 0;
    int length = 0;
    for (int i = numProcessed; i < dimValSelector.length; i++) {
      length++;
      if (SKIP_POSITION_VALUE != dimValSelector[i]) {
        valid++;
      }
START       if (valid == numToProcess) { END 
        break;
      }
    }
    return length;
  }
","  protected int computeNewLength(int[] dimValSelector, int numProcessed, int numToProcess)
  {
    int valid = 0;
    int length = 0;
    for (int i = numProcessed; i < dimValSelector.length && valid < numToProcess; i++) {
      length++;
      if (SKIP_POSITION_VALUE != dimValSelector[i]) {
        valid++;
      }
    }
    return length;
  }
"
1011,I think this should throw the DebugException and let the caller deal with it.  Someone else may want to do something else than log the error.,"	protected IMemoryBlockRetrieval createMemoryBlockRetrieval(String model, ILaunchConfiguration config, DsfSession session) {
		DsfMemoryBlockRetrieval memRetrieval = null;
		try {
			memRetrieval = new DsfMemoryBlockRetrieval(model, config, session);
		} catch (DebugException e) {
			DsfPlugin.getDefault().getLog().log(e.getStatus());	
		}
		
		return memRetrieval;
	}
","START 	protected IMemoryBlockRetrieval createMemoryBlockRetrieval(String model, ILaunchConfiguration config, DsfSession session) { END 
		DsfMemoryBlockRetrieval memRetrieval = null;
		try {
			memRetrieval = new DsfMemoryBlockRetrieval(model, config, session);
		} catch (DebugException e) {
			DsfPlugin.getDefault().getLog().log(e.getStatus());	
		}
		
		return memRetrieval;
	}
","	protected IMemoryBlockRetrieval createMemoryBlockRetrieval(String model, ILaunchConfiguration config,
			DsfSession session) throws DebugException {
		return new DsfMemoryBlockRetrieval(model, config, session);
	}
"
1012,protected,"	public PathAnnotationRoutesParser() {
	}
","START 	public PathAnnotationRoutesParser() { END 
	}
","	protected PathAnnotationRoutesParser() {
		this(null);
	}
"
1013,Here I would expect 'getPoints.size-1' for both cases,"    private int getLength(Object o, int index) {
        if (o instanceof InstructionList) {
            // we do not store the last point of an instruction
            Instruction instruction = ((InstructionList) o).get(index);
            int size;
            if(instruction instanceof ViaInstruction)
                size = 0;
            else
                size = instruction.getPoints().size();
            // the last point of instruction (i.e. first point of next instruction) is not included
            return size;
        }
        if (o instanceof List) {
            return ((List<PathDetail>) o).get(index).getLength();
        }
        throw new IllegalStateException(""We can only handle PathDetails or InstructionList in PathSimplification"");
    }
","    private int getLength(Object o, int index) {
        if (o instanceof InstructionList) {
            // we do not store the last point of an instruction
            Instruction instruction = ((InstructionList) o).get(index);
            int size;
            if(instruction instanceof ViaInstruction)
                size = 0;
            else
START                 size = instruction.getPoints().size(); END 
            // the last point of instruction (i.e. first point of next instruction) is not included
            return size;
        }
        if (o instanceof List) {
            return ((List<PathDetail>) o).get(index).getLength();
        }
        throw new IllegalStateException(""We can only handle PathDetails or InstructionList in PathSimplification"");
    }
","    private int getLength(Object o, int index) {
        if (o instanceof InstructionList) {
            // we do not store the last point of an instruction
            Instruction instruction = ((InstructionList) o).get(index);
            return instruction.getLength();
        }
        if (o instanceof List) {
            return ((List<PathDetail>) o).get(index).getLength();
        }
        throw new IllegalStateException(""We can only handle PathDetails or InstructionList in PathSimplification"");
    }
"
1014,The `BeanUtils.copyProperties()` cant handle this?,"    private DataPointAssignment marshallToDomain(DataPointAssignmentDto dto) {
        final DataPointAssignment dpa = new DataPointAssignment();

        BeanUtils.copyProperties(dto, dpa);
        if (dto.getKeyId() != null) {
            dpa.setKey(KeyFactory.createKey(""DataPointAssignment"", dto.getKeyId()));
        }
        //Lists must be copied separately
        dpa.setDataPointIds(dto.getDataPointIds());

        return dpa;
    }
","    private DataPointAssignment marshallToDomain(DataPointAssignmentDto dto) {
        final DataPointAssignment dpa = new DataPointAssignment();

        BeanUtils.copyProperties(dto, dpa);
        if (dto.getKeyId() != null) {
            dpa.setKey(KeyFactory.createKey(""DataPointAssignment"", dto.getKeyId()));
        }
        //Lists must be copied separately
START         dpa.setDataPointIds(dto.getDataPointIds()); END 

        return dpa;
    }
","    private DataPointAssignment marshallToDomain(DataPointAssignmentDto dto) {
        final DataPointAssignment dpa = new DataPointAssignment();

        BeanUtils.copyProperties(dto, dpa);
        if (dto.getKeyId() != null) {
            dpa.setKey(KeyFactory.createKey(""DataPointAssignment"", dto.getKeyId()));
        }

        return dpa;
    }
"
1015,only one return is possible here.,"	protected boolean equivalent(Constraint constraint) {
		if (constraint == this || constraint instanceof IsTreeTableConstraint) {
			return true;
		}

		return false;
	}
","	protected boolean equivalent(Constraint constraint) {
		if (constraint == this || constraint instanceof IsTreeTableConstraint) {
			return true;
		}

START 		return false; END 
	}
","	protected boolean equivalent(Constraint constraint) {
		return constraint == this || constraint instanceof IsTreeTableConstraint;
	}
"
1016,A minor optimization here is to create the new ArrayList with the nodeBasedCHGraphs already or at least init the size with node+edge,"    private Collection<CHGraphImpl> getAllCHGraphs() {
        // todo: this method is only used to have a 'view' on the two collections. we could also create this only once
        // as long as the graph collections are only modified in the constructor (otherwise we would have to make sure
        // the lists are in sync). another option would be something like guava concat.
        List<CHGraphImpl> result = new ArrayList<>();
        result.addAll(nodeBasedCHGraphs);
        result.addAll(edgeBasedCHGraphs);
        return result;
    }
","    private Collection<CHGraphImpl> getAllCHGraphs() {
        // todo: this method is only used to have a 'view' on the two collections. we could also create this only once
        // as long as the graph collections are only modified in the constructor (otherwise we would have to make sure
        // the lists are in sync). another option would be something like guava concat.
        List<CHGraphImpl> result = new ArrayList<>();
        result.addAll(nodeBasedCHGraphs);
START         result.addAll(edgeBasedCHGraphs); END 
        return result;
    }
","    private Collection<CHGraphImpl> getAllCHGraphs() {
        // todo: this method is only used to have a 'view' on the two collections. we could also create this only once
        // as long as the graph collections are only modified in the constructor (otherwise we would have to make sure
        // the lists are in sync). another option would be something like guava concat.
        List<CHGraphImpl> result = new ArrayList<>(nodeBasedCHGraphs.size() + edgeBasedCHGraphs.size());
        result.addAll(nodeBasedCHGraphs);
        result.addAll(edgeBasedCHGraphs);
        return result;
    }
"
1017,"`other != null` is redundant with `other instanceof Module`, which already returns `false` when `other` is `null`.","        @Override public boolean equals(Object other) {
            return other != null && (other instanceof Module) && Objects.equals(name, ((Module)other).name);
        }
","        @Override public boolean equals(Object other) {
START             return other != null && (other instanceof Module) && Objects.equals(name, ((Module)other).name); END 
        }
","        @Override public boolean equals(Object other) {
            return (other instanceof Module) && Objects.equals(name, ((Module)other).name);
        }
"
1018,"Yes, I agree that there is no ""a lot of sense"" and this topic is... debatable. From my point of view, ""private static"" is still make sense because
1) it emphasizes the fact that this method doesn't depend on other class members (doesn't use internal state)
2) JVM doesn't pass `this` as the first parameter to such the methods

Here are my points. The last call, of course, in on @Hi-Fi and you :)","	public static boolean textContains(String actual, String text, boolean ignoreCase) {
		return ignoreCase
				? StringUtils.containsIgnoreCase(actual, text)
				: StringUtils.contains(actual, text);
	}
","START 	public static boolean textContains(String actual, String text, boolean ignoreCase) { END 
		return ignoreCase
				? StringUtils.containsIgnoreCase(actual, text)
				: StringUtils.contains(actual, text);
	}
","    private boolean textContains(String actual, String text, boolean ignoreCase) {
        return ignoreCase
                ? StringUtils.containsIgnoreCase(actual, text)
                : StringUtils.contains(actual, text);
    }
"
1019,File,"	public List<String> getRepositoryDirectories() {
		return new ArrayList<>(repositoryDirectories);
	}
","	public START List<String> getRepositoryDirectories() END  {
		return new ArrayList<>(repositoryDirectories);
	}
","	public List<File> getRepositoryDirectories() {
		return new ArrayList<>(repositoryDirectories);
	}
"
1020,"You do not need bindAnnotated, since there's only one implementation of RpcDispatchHooks. bindAnnotated was used to bind an interface for the RPC and REST dispatchers to different implementations","    protected void configureDispatch() {
        bindAnnotated(RpcDispatchHooks.class).to(builder.getDispatchHooks()).in(Singleton.class);

        bind(RpcDispatchCallFactory.class).to(DefaultRpcDispatchCallFactory.class).in(Singleton.class);

        bind(DispatchAsync.class).to(RpcDispatchAsync.class).in(Singleton.class);
    }
","    protected void configureDispatch() {
START         bindAnnotated(RpcDispatchHooks.class).to(builder.getDispatchHooks()).in(Singleton.class); END 

        bind(RpcDispatchCallFactory.class).to(DefaultRpcDispatchCallFactory.class).in(Singleton.class);

        bind(DispatchAsync.class).to(RpcDispatchAsync.class).in(Singleton.class);
    }
","    protected void configureDispatch() {
        bind(RpcDispatchHooks.class).to(builder.getDispatchHooks()).in(Singleton.class);

        bind(RpcDispatchCallFactory.class).to(DefaultRpcDispatchCallFactory.class).in(Singleton.class);

        bind(DispatchAsync.class).to(RpcDispatchAsync.class).in(Singleton.class);
    }
"
1021,Is this log necessary?,"    protected void onExportToCsv() {
        GWT.log(this.toString() + ""onExportToCsv"");
        scenarioSimulationEditorWrapper.onExportToCsv(getExportCallBack(), new ScenarioSimulationHasBusyIndicatorDefaultErrorCallback(view), context.getStatus().getSimulation());
    }
","    protected void onExportToCsv() {
START         GWT.log(this.toString() + ""onExportToCsv""); END 
        scenarioSimulationEditorWrapper.onExportToCsv(getExportCallBack(), new ScenarioSimulationHasBusyIndicatorDefaultErrorCallback(view), context.getStatus().getSimulation());
    }
","    protected void onExportToCsv() {
        scenarioSimulationEditorWrapper.onExportToCsv(getExportCallBack(), new ScenarioSimulationHasBusyIndicatorDefaultErrorCallback(view), context.getStatus().getSimulation());
    }
"
1022,super is implied,"    public QuotaProgressBar() {
        super();
        tooltip = new WidgetTooltip(this);
    }
","    public QuotaProgressBar() {
START         super(); END 
        tooltip = new WidgetTooltip(this);
    }
","    public QuotaProgressBar() {
        tooltip = new WidgetTooltip(this);
    }
"
1023,"As I said: `TestUtils.createTestApplicationContext()` so, no changes here, please.","		public TestApplicationContext() {
			super();
		}
","START 		public TestApplicationContext() { END 
			super();
		}
","		TestApplicationContext() {
			super();
		}
"
1024,"Here it is been generated sometimes a NullPointer exception, because `mCurrentStorageManager` is found in the StorageManager Map with a different id of the current storage managers.","    public Cursor queryDocument(String documentId, String[] projection) throws FileNotFoundException {
        final long docId = Long.parseLong(documentId);
        updateCurrentStorageManagerIfNeeded(docId);

        final FileCursor result = new FileCursor(projection);
        result.addFile(mCurrentStorageManager.getFileById(docId));

        return result;
    }
","    public Cursor queryDocument(String documentId, String[] projection) throws FileNotFoundException {
        final long docId = Long.parseLong(documentId);
        updateCurrentStorageManagerIfNeeded(docId);

        final FileCursor result = new FileCursor(projection);
START         result.addFile(mCurrentStorageManager.getFileById(docId)); END 

        return result;
    }
","    public Cursor queryDocument(String documentId, String[] projection) throws FileNotFoundException {
        final long docId = Long.parseLong(documentId);
        updateCurrentStorageManagerIfNeeded(docId);

        final FileCursor result = new FileCursor(projection);
        if (result != null)
          result.addFile(mCurrentStorageManager.getFileById(docId));

        return result;
    }
"
1025,"[bit] prefer inline conditionals for this kind of stuff:
```java
request = this.isSAS ? filterSAS(request, this.credential) : filterKey(request);
```","   public HttpRequest filter(HttpRequest request) throws HttpException {
      if (this.isSAS){
         request = filterSAS(request, this.credential);
      } else {
         request = filterKey(request);
      }
      utils.logRequest(signatureLog, request, ""<<"");
      return request;
   }
","   public HttpRequest filter(HttpRequest request) throws HttpException {
      if (this.isSAS){
         request = filterSAS(request, this.credential);
      } else {
         request = filterKey(request);
START       } END 
      utils.logRequest(signatureLog, request, ""<<"");
      return request;
   }
","   public HttpRequest filter(HttpRequest request) throws HttpException {
      request = this.isSAS ? filterSAS(request, this.credential) : filterKey(request);
      utils.logRequest(signatureLog, request, ""<<"");
      return request;
   }
"
1026,"If we add this version check inside `default-record-store`, client initiated operations can also be caught.","    public void setTTL(K key, long ttl, TimeUnit timeunit) {
        if (getNodeEngine().getClusterService().getClusterVersion().isLessThan(Versions.V3_11)) {
            throw new UnsupportedOperationException(""setTTL method is available when cluster version is 3.11 or higher"");
        }
        checkNotNull(key);
        setTTLInternal(key, ttl, timeunit);
    }
","    public void setTTL(K key, long ttl, TimeUnit timeunit) {
START         if (getNodeEngine().getClusterService().getClusterVersion().isLessThan(Versions.V3_11)) { END 
            throw new UnsupportedOperationException(""setTTL method is available when cluster version is 3.11 or higher"");
        }
        checkNotNull(key);
        setTTLInternal(key, ttl, timeunit);
    }
","    public void setTTL(K key, long ttl, TimeUnit timeunit) {
        checkNotNull(key);
        checkNotNull(timeunit);
        setTTLInternal(key, ttl, timeunit);
    }
"
1027,"Why is `bindDynamicProducer` `synchronized`, but this one not?
I need to know more about this `MessageBus` stuff and where it is used from, to determine which behaviour is correct for this methods, but I hope you can provide correct answer anyway","	public MessageChannel bindDynamicPubSubProducer(String name) {
		MessageChannel channel = this.directChannelProvider.lookupSharedChannel(name);
		if (channel == null) {
			channel = this.directChannelProvider.createAndRegisterChannel(name);
			bindPubSubProducer(name, channel);
		}
		return channel;
	}
","START 	public MessageChannel bindDynamicPubSubProducer(String name) { END 
		MessageChannel channel = this.directChannelProvider.lookupSharedChannel(name);
		if (channel == null) {
			channel = this.directChannelProvider.createAndRegisterChannel(name);
			bindPubSubProducer(name, channel);
		}
		return channel;
	}
","	public synchronized MessageChannel bindDynamicPubSubProducer(String name) {
		MessageChannel channel = this.directChannelProvider.lookupSharedChannel(name);
		if (channel == null) {
			channel = this.directChannelProvider.createAndRegisterChannel(name);
			bindPubSubProducer(name, channel);
		}
		return channel;
	}
"
1028,`check` does checkCanceled,"  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
    return new GoVisitor() {
      @Override
      public void visitFunctionOrMethodDeclaration(@NotNull GoFunctionOrMethodDeclaration o) { // todo: extract common interface
        super.visitFunctionOrMethodDeclaration(o);
        check(o.getSignature(), o.getBlock(), holder);
      }

      @Override
      public void visitFunctionLit(@NotNull GoFunctionLit o) {
        super.visitFunctionLit(o);
        check(o.getSignature(), o.getBlock(), holder);
      }
    };
  }
","  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
    return new GoVisitor() {
      @Override
      public void visitFunctionOrMethodDeclaration(@NotNull GoFunctionOrMethodDeclaration o) { // todo: extract common interface
START         super.visitFunctionOrMethodDeclaration(o); END 
        check(o.getSignature(), o.getBlock(), holder);
      }

      @Override
      public void visitFunctionLit(@NotNull GoFunctionLit o) {
        super.visitFunctionLit(o);
        check(o.getSignature(), o.getBlock(), holder);
      }
    };
  }
","  protected GoVisitor buildGoVisitor(@NotNull final ProblemsHolder holder, @NotNull LocalInspectionToolSession session) {
    return new GoVisitor() {
      @Override
      public void visitFunctionOrMethodDeclaration(@NotNull GoFunctionOrMethodDeclaration o) { // todo: extract common interface
        check(o.getSignature(), o.getBlock(), holder);
      }

      @Override
      public void visitFunctionLit(@NotNull GoFunctionLit o) {
        check(o.getSignature(), o.getBlock(), holder);
      }
    };
  }
"
1029,"This make sense, since `getToken()` is `final`, but what would you think of just doing:

```suggestion
		this.name = jwt.getSubject();
```

So that readers of this code have fewer methods to jump through to understand the code.","	public JwtAuthenticationToken(Jwt jwt) {
		super(jwt);
		this.name = this.getToken().getSubject();
	}
","	public JwtAuthenticationToken(Jwt jwt) {
		super(jwt);
START 		this.name = this.getToken().getSubject(); END 
	}
","	public JwtAuthenticationToken(Jwt jwt) {
		super(jwt);
		this.name = jwt.getSubject();
	}
"
1030,no longer used as well.,"   public void start() {
      cacheName = ByteString.fromString(cache.getName());
      this.transactional = configuration.transaction().transactionMode().isTransactional();
      this.totalOrderProtocol = configuration.transaction().transactionProtocol().isTotalOrder();
      this.distributedOrReplicated = configuration.clustering().cacheMode().isDistributed() || configuration.clustering().cacheMode().isReplicated();
   }
","   public void start() {
      cacheName = ByteString.fromString(cache.getName());
      this.transactional = configuration.transaction().transactionMode().isTransactional();
      this.totalOrderProtocol = configuration.transaction().transactionProtocol().isTotalOrder();
START       this.distributedOrReplicated = configuration.clustering().cacheMode().isDistributed() || configuration.clustering().cacheMode().isReplicated(); END 
   }
","   public void start() {
      cacheName = ByteString.fromString(cache.getName());
      this.transactional = configuration.transaction().transactionMode().isTransactional();
      this.totalOrderProtocol = configuration.transaction().transactionProtocol().isTotalOrder();
   }
"
1031,"I am OK with just using ex.getErrorMessage() than getLocalizedMessage(), but I do agree that we should try to stick with one method in our code for loggers.","    private URL getUrl() {
        String urlString = null;
        URL url = null;
        try {
            urlString = oProxyHelper
                    .getAdapterEndPointFromConnectionManager(DIRECT_CONFIG_SERVICE_NAME);
        } catch (ConnectionManagerException ex) {
            LOG.error(""Error reading directConfig Url cannot be found: {}"", ex.getLocalizedMessage(), ex);
        }
        try {
            url = new URL(urlString);
        } catch (MalformedURLException ex) {
            LOG.error(""Error while converting urlString into Url format {}"", ex.getMessage(), ex);
        }
        return url;
    }
","    private URL getUrl() {
        String urlString = null;
        URL url = null;
        try {
            urlString = oProxyHelper
                    .getAdapterEndPointFromConnectionManager(DIRECT_CONFIG_SERVICE_NAME);
        } catch (ConnectionManagerException ex) {
START             LOG.error(""Error reading directConfig Url cannot be found: {}"", ex.getLocalizedMessage(), ex); END 
        }
        try {
            url = new URL(urlString);
        } catch (MalformedURLException ex) {
            LOG.error(""Error while converting urlString into Url format {}"", ex.getMessage(), ex);
        }
        return url;
    }
","    private URL getUrl() {
        String urlString = null;
        URL url = null;
        try {
            urlString = oProxyHelper
                    .getAdapterEndPointFromConnectionManager(DIRECT_CONFIG_SERVICE_NAME);
        } catch (ConnectionManagerException ex) {
            LOG.error(""Error reading directConfig Url cannot be found: {}"", ex.getLocalizedMessage(), ex);
        }
        try {
            url = new URL(urlString);
        } catch (MalformedURLException ex) {
            LOG.error(""Error while converting urlString into Url format {}"", ex.getLocalizedMessage(), ex);
        }
        return url;
    }
"
1032,are your sure hashCode/equals of SpoonFolder are correct? I'm not sure they are well tested.,"	public List<SpoonFolder> getSubFolders() {
		List<SpoonFolder> result = new ArrayList<>();
		Set<SpoonFolder> distinctSet = new HashSet<>();
		for (SpoonFile f : getAllFiles()) {
			SpoonFolder folder = f.getParent();
			if (distinctSet.add(folder)) {
				result.add(folder);
			}
		}
		return Collections.unmodifiableList(result);
	}
","	public List<SpoonFolder> getSubFolders() {
		List<SpoonFolder> result = new ArrayList<>();
		Set<SpoonFolder> distinctSet = new HashSet<>();
		for (SpoonFile f : getAllFiles()) {
START 			SpoonFolder folder = f.getParent(); END 
			if (distinctSet.add(folder)) {
				result.add(folder);
			}
		}
		return Collections.unmodifiableList(result);
	}
","	public List<SpoonFolder> getSubFolders() {
		List<SpoonFolder> result = new ArrayList<>();
		for (SpoonFile f : getAllFiles()) {
			SpoonFolder folder = f.getParent();
			if (!result.contains(folder)) {
				result.add(folder);
			}
		}
		return Collections.unmodifiableList(result);
	}
"
1033,"Instead of the line above, why don't you just call newPutRequest(requestURI, json)?","	public MockHttpServletRequest newPutRequest(String requestURI, Object content) {
		MockHttpServletRequest request = request(RequestMethod.PUT, requestURI);
		try {
			String json = new ObjectMapper().writeValueAsString(content);
			request.setContent(json.getBytes(""UTF-8""));
		}
		catch (Exception e) {
			throw new RuntimeException(e);
		}
		return request;
	}
","	public MockHttpServletRequest newPutRequest(String requestURI, Object content) {
		MockHttpServletRequest request = request(RequestMethod.PUT, requestURI);
		try {
			String json = new ObjectMapper().writeValueAsString(content);
START 			request.setContent(json.getBytes(""UTF-8"")); END 
		}
		catch (Exception e) {
			throw new RuntimeException(e);
		}
		return request;
	}
","	public MockHttpServletRequest newPutRequest(String requestURI, Object content) {
		try {
			String json = new ObjectMapper().writeValueAsString(content);
			return newPutRequest(requestURI, json);
		}
		catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
"
1034,`int[] props` would make everyone including the style checker much happier,"    private int[] propertyIds()
    {
        int props[] = new int[numberOfProps];
        for ( int i = 0; i < numberOfProps; i++ )
        {
            props[i] = i;
        }
        return props;
    }
","    private int[] propertyIds()
    {
START         int props[] = new int[numberOfProps]; END 
        for ( int i = 0; i < numberOfProps; i++ )
        {
            props[i] = i;
        }
        return props;
    }
","    private int[] propertyIds()
    {
        int[] props = new int[numberOfProps];
        for ( int i = 0; i < numberOfProps; i++ )
        {
            props[i] = i;
        }
        return props;
    }
"
1035,How sure are you that it was not null before the purging?,"	public void shouldPurgeAnAutoGenerationOption() throws Exception {
		MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + ""/"" + getUuid());
		req.addParameter(""purge"", """");
		handle(req);
		assertNull(identifierSourceService
		        .getAutoGenerationOption(Context.getPatientService().getPatientIdentifierTypeByUuid(getUuid())));
	}
","	public void shouldPurgeAnAutoGenerationOption() throws Exception {
		MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + ""/"" + getUuid());
		req.addParameter(""purge"", """");
		handle(req);
START 		assertNull(identifierSourceService END 
		        .getAutoGenerationOption(Context.getPatientService().getPatientIdentifierTypeByUuid(getUuid())));
	}
","	public void shouldPurgeAnAutoGenerationOption() throws Exception {
		assertNotNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())));
		MockHttpServletRequest req = request(RequestMethod.DELETE, getURI() + ""/"" + getUuid());
		req.addParameter(""purge"", """");
		handle(req);
		assertNull(identifierSourceService.getAutoGenerationOption(Integer.parseInt(getUuid())));
	}
"
1036,Why both Arrays.copyOf and System.arrayCopy?,"    public Page appendColumn(Block block)
    {
        requireNonNull(block, ""block is null"");
        if (positionCount != block.getPositionCount()) {
            throw new IllegalArgumentException(""Block does not have same position count"");
        }

        Block[] newBlocks = Arrays.copyOf(blocks, blocks.length + 1);
        System.arraycopy(blocks, 0, newBlocks, 0, blocks.length);
        newBlocks[blocks.length] = block;
        return new Page(newBlocks);
    }
","    public Page appendColumn(Block block)
    {
        requireNonNull(block, ""block is null"");
        if (positionCount != block.getPositionCount()) {
            throw new IllegalArgumentException(""Block does not have same position count"");
        }

        Block[] newBlocks = Arrays.copyOf(blocks, blocks.length + 1);
START         System.arraycopy(blocks, 0, newBlocks, 0, blocks.length); END 
        newBlocks[blocks.length] = block;
        return new Page(newBlocks);
    }
","    public Page appendColumn(Block block)
    {
        requireNonNull(block, ""block is null"");
        if (positionCount != block.getPositionCount()) {
            throw new IllegalArgumentException(""Block does not have same position count"");
        }

        Block[] newBlocks = Arrays.copyOf(blocks, blocks.length + 1);
        newBlocks[blocks.length] = block;
        return new Page(newBlocks);
    }
"
1037,empty finally block,"    public void close()
    {
        Closeables.closeQuietly(nettyConnectionPool);

        try {
            timer.stop();
        }
        finally {
            // ignored
        }
    }
","    public void close()
    {
        Closeables.closeQuietly(nettyConnectionPool);

        try {
            timer.stop();
        }
START         finally { END 
            // ignored
        }
    }
","    public void close()
    {
        Closeables.closeQuietly(nettyConnectionPool);
        try {
            timer.stop();
        }
        catch(Exception e) {
            // ignored
        }
    }
"
1038,why not use `new ArrayList<>(futures.values());`,"   private void completeAllExceptionally(Throwable t) {
      List<Data> completed;
      synchronized (futures) {
         completed = new ArrayList<>(futures.size());
         completed.addAll(futures.values());
      }
      for (Data data : completed) {
         data.cancelFuture.cancel(false);
         data.completeExceptionally(t);
      }
   }
","   private void completeAllExceptionally(Throwable t) {
      List<Data> completed;
      synchronized (futures) {
START          completed = new ArrayList<>(futures.size()); END 
         completed.addAll(futures.values());
      }
      for (Data data : completed) {
         data.cancelFuture.cancel(false);
         data.completeExceptionally(t);
      }
   }
","   private void completeAllExceptionally(Throwable t) {
      List<Data> completed;
      synchronized (futures) {
         completed = new ArrayList<>(futures.values());
      }
      for (Data data : completed) {
         data.cancelFuture.cancel(false);
         data.completeExceptionally(t);
      }
   }
"
1039,Why use only w2? Why the right shift? Likely it doesn't really matter.,"	public final int hashCode() {
		return (int) (w2 >>> 32);
	}
","START 	public final int hashCode() {
		return (int) (w2 >>> 32);
	} END 
","	public final int hashCode() {
		return (int) (w2);
	}
"
1040,should loader also be checked if it's non-null so that if follows similar paradigm as client. This way can call close() from main()'s exception block -> case where initialize fails in initializing loader for some reason and the logic can thereby make sure the initialized client connection gets closed and is not leaked.,"    private void close() {
        try {
            closeExecutors();
            m_loader.close();
            if (m_client != null) {
                m_client.close();
                m_client = null;
            }
        }
        catch (Exception ex) {
            // Ignore
        }
    }
","    private void close() {
        try {
            closeExecutors();
START             m_loader.close(); END 
            if (m_client != null) {
                m_client.close();
                m_client = null;
            }
        }
        catch (Exception ex) {
            // Ignore
        }
    }
","    private void close() {
        try {
            closeExecutors();
            if (m_loader != null) {
                m_loader.close();
                m_loader = null;
            }
            if (m_client != null) {
                m_client.close();
                m_client = null;
            }
        }
        catch (Exception ex) {
            // Ignore
        }
    }
"
1041,"The try-with-resources takes care of the closing, right?","    private static void writeContents( FileSystemAbstraction fileSystemAbstraction, File file, String contents )
    {
        byte[] bytes = contents.getBytes();
        try ( StoreChannel storeChannel = fileSystemAbstraction.create( file ) )
        {
            storeChannel.write( ByteBuffer.wrap( bytes ) );
            storeChannel.close();
        }
        catch ( IOException e )
        {
            throw new RuntimeException( e );
        }
    }
","    private static void writeContents( FileSystemAbstraction fileSystemAbstraction, File file, String contents )
    {
        byte[] bytes = contents.getBytes();
        try ( StoreChannel storeChannel = fileSystemAbstraction.create( file ) )
        {
            storeChannel.write( ByteBuffer.wrap( bytes ) );
START             storeChannel.close(); END 
        }
        catch ( IOException e )
        {
            throw new RuntimeException( e );
        }
    }
","    private static void writeContents( FileSystemAbstraction fileSystemAbstraction, File file, String contents )
    {
        byte[] bytes = contents.getBytes();
        try ( StoreChannel storeChannel = fileSystemAbstraction.create( file ) )
        {
            storeChannel.write( ByteBuffer.wrap( bytes ) );
        }
        catch ( IOException e )
        {
            throw new RuntimeException( e );
        }
    }
"
1042,"This change seems unnecessary.
Best keep this PR limited to _just_ what's necessary to achieve this PR's aims.","    public boolean getAllowUntrustedCertificate() {
        return vsConnectionConfig != null && vsConnectionConfig.getAllowUntrustedCertificate();
    }
","    public boolean getAllowUntrustedCertificate() {
START         return vsConnectionConfig != null && vsConnectionConfig.getAllowUntrustedCertificate(); END 
    }
","    public boolean getAllowUntrustedCertificate() {
        return vsConnectionConfig != null ? vsConnectionConfig.getAllowUntrustedCertificate() : false;
    }
"
1043,A DB call inside the constuctor - not a good practice.,"    public StopVmCommandBase(T parameters) {
        super(parameters);
        setStoragePoolId(getVm().getstorage_pool_id());
    }
","    public StopVmCommandBase(T parameters) {
        super(parameters);
START         setStoragePoolId(getVm().getstorage_pool_id()); END 
    }
","    public StopVmCommandBase(T parameters) {
        super(parameters);
    }
"
1044,No space between STARTS and WITH??,"    public String getSQL() {

        String       left  = getContextSQL(nodes[LEFT]);
        String       right = getContextSQL(nodes[RIGHT]);
        StringBuffer sb    = new StringBuffer();

        sb.append(left).append(' ').append(Tokens.T_STARTS).append(Tokens.T_WITH).append(' ');
        sb.append(right);

        return sb.toString();
    }
","    public String getSQL() {

        String       left  = getContextSQL(nodes[LEFT]);
        String       right = getContextSQL(nodes[RIGHT]);
        StringBuffer sb    = new StringBuffer();

START         sb.append(left).append(' ').append(Tokens.T_STARTS).append(Tokens.T_WITH).append(' '); END 
        sb.append(right);

        return sb.toString();
    }
","    public String getSQL() {

        String       left  = getContextSQL(nodes[LEFT]);
        String       right = getContextSQL(nodes[RIGHT]);
        StringBuffer sb    = new StringBuffer();

        sb.append(left).append(' ').append(Tokens.T_STARTS).append(' ').append(Tokens.T_WITH).append(' ');
        sb.append(right);

        return sb.toString();
    }
"
1045,simplify: `return ...`,"  public boolean isApplicable(UpgradeCheckRequest request) throws AmbariException {
    UpgradeType upgradeType = request.getUpgradeType();

    UpgradeCheckInfo annotation = m_checkClass.getAnnotation(UpgradeCheckInfo.class);
    if (null == annotation) {
      return true;
    }

    // empty upgrade type or matching should return true
    UpgradeType[] upgradeTypes = annotation.required();
    if (ArrayUtils.isEmpty(upgradeTypes) || ArrayUtils.contains(upgradeTypes, upgradeType)) {
      return true;
    }

    return false;
  }
","  public boolean isApplicable(UpgradeCheckRequest request) throws AmbariException {
    UpgradeType upgradeType = request.getUpgradeType();

    UpgradeCheckInfo annotation = m_checkClass.getAnnotation(UpgradeCheckInfo.class);
    if (null == annotation) {
      return true;
    }

    // empty upgrade type or matching should return true
    UpgradeType[] upgradeTypes = annotation.required();
START     if (ArrayUtils.isEmpty(upgradeTypes) || ArrayUtils.contains(upgradeTypes, upgradeType)) { END 
      return true;
    }

    return false;
  }
","  public boolean isApplicable(UpgradeCheckRequest request) throws AmbariException {
    UpgradeType upgradeType = request.getUpgradeType();

    UpgradeCheckInfo annotation = m_checkClass.getAnnotation(UpgradeCheckInfo.class);
    if (null == annotation) {
      return true;
    }

    // empty upgrade type or matching should return true
    UpgradeType[] upgradeTypes = annotation.required();
    return (ArrayUtils.isEmpty(upgradeTypes) || ArrayUtils.contains(upgradeTypes, upgradeType));
  }
"
1046,maybe `return false` here at once would be better?,"	private boolean validateHostPort(String string) {
		// https://stackoverflow.com/questions/2345063/java-common-way-to-validate-and-convert-hostport-to-inetsocketaddress
		try {
			// WORKAROUND: add any scheme to make the resulting URI valid.
			URI uri = new URI(""my://"" + string); // may throw URISyntaxException
			if (uri.getHost() == null || uri.getPort() == -1) {
				throw new URISyntaxException(uri.toString(), ""URI must have host and port parts"");
			}
		} catch (URISyntaxException ex) {
			// validation failed
			return false;
		}

		// validation succeeded
		return true;
	}
","	private boolean validateHostPort(String string) {
		// https://stackoverflow.com/questions/2345063/java-common-way-to-validate-and-convert-hostport-to-inetsocketaddress
		try {
			// WORKAROUND: add any scheme to make the resulting URI valid.
			URI uri = new URI(""my://"" + string); // may throw URISyntaxException
			if (uri.getHost() == null || uri.getPort() == -1) {
START 				throw new URISyntaxException(uri.toString(), ""URI must have host and port parts""); END 
			}
		} catch (URISyntaxException ex) {
			// validation failed
			return false;
		}

		// validation succeeded
		return true;
	}
","	private boolean validateHostPort(String string) {
		// https://stackoverflow.com/questions/2345063/java-common-way-to-validate-and-convert-hostport-to-inetsocketaddress
		try {
			// WORKAROUND: add any scheme to make the resulting URI valid.
			URI uri = new URI(""my://"" + string); // may throw URISyntaxException
			if (uri.getHost() == null || uri.getPort() == -1) {
				return false;
			}
		} catch (URISyntaxException ex) {
			// validation failed
			return false;
		}

		// validation succeeded
		return true;
	}
"
1047,"as before, this could be if-then-else without the increment below for the `if` case.","    private int nextCorrelationId() {
        if (!isReserved(correlationId)) correlationId = MIN_RESERVED_CORRELATION_ID;
        return correlationId++;
    }
","    private int nextCorrelationId() {
START         if (!isReserved(correlationId)) correlationId = MIN_RESERVED_CORRELATION_ID; END 
        return correlationId++;
    }
","    int nextCorrelationId() {
        if (!isReserved(correlationId))
            correlationId = MIN_RESERVED_CORRELATION_ID;
        return correlationId++;
    }
"
1048,Can this be just `this.monitors = Arrays.asList( monitors );`?,"    public BoltConnectionQueueMonitorAggregate( BoltConnectionQueueMonitor... monitors )
    {
        this.monitors = new ArrayList<>( Arrays.asList( monitors ) );
    }
","    public BoltConnectionQueueMonitorAggregate( BoltConnectionQueueMonitor... monitors )
    {
START         this.monitors = new ArrayList<>( Arrays.asList( monitors ) ); END 
    }
","    public BoltConnectionQueueMonitorAggregate( BoltConnectionQueueMonitor... monitors )
    {
        this.monitors = Arrays.asList( monitors );
    }
"
1049,Do you think we should use `assertEquals()` (with as useful message) instead of `assertTrue()` so you'll get a useful stack trace if this fails? Future users might look at this file as an example of how to write a good JUnit test.,"    public void testElementAt() {
        int i = fullList.get(0);
        assertTrue(i == 1);

        try {
            fullList.get(fullList.size());
        } catch (IndexOutOfBoundsException e) {
            return;
        }
        fail(""Should raise an ArrayIndexOutOfBoundsException"");
    }
","    public void testElementAt() {
        int i = fullList.get(0);
START         assertTrue(i == 1); END 

        try {
            fullList.get(fullList.size());
        } catch (IndexOutOfBoundsException e) {
            return;
        }
        fail(""Should raise an ArrayIndexOutOfBoundsException"");
    }
","    public void testElementAt() {
        int i = fullList.get(0);
        assertEquals(1,i);

        try {
            fullList.get(fullList.size());
        } catch (IndexOutOfBoundsException e) {
            return;
        }
        fail(""Should raise an ArrayIndexOutOfBoundsException"");
    }
"
1050,needs a space after the if and needs {} both here and with the else.,"    public String shell(PyObject[] args, String[] kws) {
        ArgParser ap = JythonUtils.createArgParser(args, kws);
        Preconditions.checkNotNull(ap);
        String cmd = ap.getString(0);

        if(args.length == 2)
            return impl.shell(cmd, ap.getInt(1));
        else
            return impl.shell(cmd);
    }
","    public String shell(PyObject[] args, String[] kws) {
        ArgParser ap = JythonUtils.createArgParser(args, kws);
        Preconditions.checkNotNull(ap);
        String cmd = ap.getString(0);

START         if(args.length == 2) END 
            return impl.shell(cmd, ap.getInt(1));
        else
            return impl.shell(cmd);
    }
","    public String shell(PyObject[] args, String[] kws) {
        ArgParser ap = JythonUtils.createArgParser(args, kws);
        Preconditions.checkNotNull(ap);
        String cmd = ap.getString(0);

        if (args.length == 2) {
            return impl.shell(cmd, ap.getInt(1));
        } else {
            return impl.shell(cmd);
        }
    }
"
1051,Remove synchronized.,"  public synchronized static Set<Class<? extends PhysicalOperator>> getSubTypes(ScanResult classpathScan) {
    final Set<Class<? extends PhysicalOperator>> ops = classpathScan.getImplementations(PhysicalOperator.class);
    logger.debug(""Found {} physical operator classes: {}."", ops.size(),
                 ops);
    return ops;
  }
","START   public synchronized static Set<Class<? extends PhysicalOperator>> getSubTypes(ScanResult classpathScan) { END 
    final Set<Class<? extends PhysicalOperator>> ops = classpathScan.getImplementations(PhysicalOperator.class);
    logger.debug(""Found {} physical operator classes: {}."", ops.size(),
                 ops);
    return ops;
  }
","  public static Set<Class<? extends PhysicalOperator>> getSubTypes(ScanResult classpathScan) {
    final Set<Class<? extends PhysicalOperator>> ops = classpathScan.getImplementations(PhysicalOperator.class);
    logger.debug(""Found {} physical operator classes: {}."", ops.size(),
                 ops);
    return ops;
  }
"
1052,Good catch on the null check.  I forgot Maps can have `null` as a key.,"    protected Map<String, Object> subsetMap(String prefix) {
        Map<String, Object> subset = new TreeMap<String, Object>();

        for (Map.Entry<String, Object> e : configMap.entrySet()) {
            if (e.getKey() != null && e.getKey().startsWith(prefix)) {
                subset.put(e.getKey(), e.getValue());
            }
        }

        return subset;
    }
","    protected Map<String, Object> subsetMap(String prefix) {
        Map<String, Object> subset = new TreeMap<String, Object>();

        for (Map.Entry<String, Object> e : configMap.entrySet()) {
START             if (e.getKey() != null && e.getKey().startsWith(prefix)) { END 
                subset.put(e.getKey(), e.getValue());
            }
        }

        return subset;
    }
","    protected Map<String, String> subsetMap(String prefix) {
        Map<String, String> subset = new TreeMap<String, String>();

        for (Map.Entry<String, String> e : configMap.entrySet()) {
            if (e.getKey() != null && e.getKey().startsWith(prefix)) {
                subset.put(e.getKey(), e.getValue());
            }
        }

        return subset;
    }
"
1053,Let's use debug level instead of info.,"    public DesiredCapabilities getCapability(String testName) {
        DesiredCapabilities capabilities = new DesiredCapabilities();

        // add capabilities based on dynamic _config.properties variables
        capabilities = initCapabilities(capabilities);

        if (R.CONFIG.getBoolean(SpecialKeywords.FULL_RESET_BEFORE_SUITE) && !R.CONFIG.get(SpecialKeywords.FULL_RESET_BEFORE_SUITE).isEmpty()) {
            LOGGER.info(""Will be execute 'fullResetBeforeSuite'!"");
            executeFullResetBeforeSuite(capabilities);
        }

        return capabilities;
    }
","    public DesiredCapabilities getCapability(String testName) {
        DesiredCapabilities capabilities = new DesiredCapabilities();

        // add capabilities based on dynamic _config.properties variables
        capabilities = initCapabilities(capabilities);

        if (R.CONFIG.getBoolean(SpecialKeywords.FULL_RESET_BEFORE_SUITE) && !R.CONFIG.get(SpecialKeywords.FULL_RESET_BEFORE_SUITE).isEmpty()) {
START             LOGGER.info(""Will be execute 'fullResetBeforeSuite'!""); END 
            executeFullResetBeforeSuite(capabilities);
        }

        return capabilities;
    }
","    public DesiredCapabilities getCapability(String testName) {
        DesiredCapabilities capabilities = new DesiredCapabilities();

        // add capabilities based on dynamic _config.properties variables
        capabilities = initCapabilities(capabilities);
        return capabilities;
    }
"
1054,"This no longer needs to be synchronized.  That was used to protect connections, and is no longer needed if all we do is create a new Client.","    public synchronized IConnection connect(String storm_id, String host, int port, AtomicBoolean[] remoteBpStatus) {
        return new Client(topoConf, remoteBpStatus, clientChannelFactory,
                                        clientScheduleService, host, port, this);
    }
","START     public synchronized IConnection connect(String storm_id, String host, int port, AtomicBoolean[] remoteBpStatus) { END 
        return new Client(topoConf, remoteBpStatus, clientChannelFactory,
                                        clientScheduleService, host, port, this);
    }
","    public IConnection connect(String storm_id, String host, int port, AtomicBoolean[] remoteBpStatus) {
        return new Client(topoConf, remoteBpStatus, clientChannelFactory,
                                        clientScheduleService, host, port);
    }
"
1055,It seems cleaner to me to get rid of the DISABLED filter and rewrite the code so that if `isEnabled` is false you never access the filters or create a `FilteredOutputStream` at all. I would also move the ALL filter to `ContentFilter.java` so that this file is just the anonymization config settings.,"    public static ContentFilter get() {
        return ExtensionList.lookupSingleton(ContentFilters.class).isEnabled() ? ALL : DISABLED;
    }
","START     public static ContentFilter get() { END 
        return ExtensionList.lookupSingleton(ContentFilters.class).isEnabled() ? ALL : DISABLED;
    }
","    public static ContentFilters get() {
        return ExtensionList.lookupSingleton(ContentFilters.class);
    }
"
1056,Likewise (re string comparison),"   public AvailabilityType getAvailability() {
      ReadAttribute op = new ReadAttribute(getAddress(), ""cache-status"");
      Result res = getASConnection().execute(op);
      if (res != null && res.isSuccess()) {
         if (res.getResult().equals(""RUNNING"")) {
             return AvailabilityType.UP;
         }
      }
      return AvailabilityType.DOWN;
   }
","   public AvailabilityType getAvailability() {
      ReadAttribute op = new ReadAttribute(getAddress(), ""cache-status"");
      Result res = getASConnection().execute(op);
      if (res != null && res.isSuccess()) {
START          if (res.getResult().equals(""RUNNING"")) { END 
             return AvailabilityType.UP;
         }
      }
      return AvailabilityType.DOWN;
   }
","   public AvailabilityType getAvailability() {
      ReadAttribute op = new ReadAttribute(getAddress(), ""cache-status"");
      Result res = getASConnection().execute(op);
      if (res != null && res.isSuccess()) {
         if (""RUNNING"".equals(res.getResult())) {
             return AvailabilityType.UP;
         }
      }
      return AvailabilityType.DOWN;
   }
"
1057,to remove with the remark below,"    public boolean isEdgeWithRectilinearRoutingStyle() {
        boolean isEdgeRectilinearRoutingStyle = false;
        if (Routing.RECTILINEAR_LITERAL.getLiteral().equals(getRoutingStyle())) {
            isEdgeRectilinearRoutingStyle = true;
        }
        return isEdgeRectilinearRoutingStyle;
    }
","    public boolean isEdgeWithRectilinearRoutingStyle() {
        boolean isEdgeRectilinearRoutingStyle = false;
        if START (Routing.RECTILINEAR_LITERAL.getLiteral().equals(getRoutingStyle())) END  {
            isEdgeRectilinearRoutingStyle = true;
        }
        return isEdgeRectilinearRoutingStyle;
    }
","    public boolean isEdgeWithRectilinearRoutingStyle() {
        boolean isEdgeRectilinearRoutingStyle = false;
        if (Routing.RECTILINEAR_LITERAL.equals(getRoutingStyle())) {
            isEdgeRectilinearRoutingStyle = true;
        }
        return isEdgeRectilinearRoutingStyle;
    }
"
1058,"would it be better to implement it like this?

```java
    @Deprecated
    protected Object decodeHeartbeatData(Channel channel, ObjectInput in) throws IOException {
        return Response.HEARTBEAT_EVENT;
    }
```","    private void encodeEventData(ObjectOutput out, Object data) throws IOException {
        if(data != null) {
            out.writeObject(data);
        }else{
            logger.warn(""encodeEventData  data is null"");
        }
    }
","    private void encodeEventData(ObjectOutput out, Object data) throws IOException {
        if(data != null) {
START             out.writeObject(data); END 
        }else{
            logger.warn(""encodeEventData  data is null"");
        }
    }
","    private void encodeEventData(ObjectOutput out, Object data) throws IOException {
        out.writeObject(data);
    }
"
1059,Is there a need to have log.debug within transaction scope?,"    public void engineIsRunningNotification() {
        try {
            log.debug(""DWH Heart Beat - Start"");
            TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
                heartBeatVar.setDateTime(new Date());
                dwhHistoryTimekeepingDao.save(heartBeatVar);
                log.debug(""DWH Heart Beat - End"");
                return null;
            });
        } catch (Exception ex) {
            log.error(""Error updating DWH Heart Beat: {}"", ex.getMessage());
            log.debug(""Exception"", ex);
        }
    }
","    public void engineIsRunningNotification() {
        try {
            log.debug(""DWH Heart Beat - Start"");
            TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
                heartBeatVar.setDateTime(new Date());
                dwhHistoryTimekeepingDao.save(heartBeatVar);
START                 log.debug(""DWH Heart Beat - End""); END 
                return null;
            });
        } catch (Exception ex) {
            log.error(""Error updating DWH Heart Beat: {}"", ex.getMessage());
            log.debug(""Exception"", ex);
        }
    }
","    public void engineIsRunningNotification() {
        try {
            log.debug(""DWH Heart Beat - Start"");
            TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, () -> {
                heartBeatVar.setDateTime(new Date());
                dwhHistoryTimekeepingDao.save(heartBeatVar);
                return null;
            });
            log.debug(""DWH Heart Beat - End"");
        } catch (Exception ex) {
            log.error(""Error updating DWH Heart Beat: {}"", ex.getMessage());
            log.debug(""Exception"", ex);
        }
    }
"
1060,"Missing args, to -> `Preconditions.checkNotNull(fields, ""fields should not be null."");`","    public BaseCassandraBolt withOutputFields(Fields fields) {
        Preconditions.checkNotNull(""fields should not be null."");
        this.outputsFields.put(Utils.DEFAULT_STREAM_ID, fields);
        return this;
    }
","    public BaseCassandraBolt withOutputFields(Fields fields) {
START         Preconditions.checkNotNull(""fields should not be null.""); END 
        this.outputsFields.put(Utils.DEFAULT_STREAM_ID, fields);
        return this;
    }
","    public BaseCassandraBolt withOutputFields(Fields fields) {
        Preconditions.checkNotNull(fields, ""fields should not be null."");
        this.outputsFields.put(Utils.DEFAULT_STREAM_ID, fields);
        return this;
    }
"
1061,Have you considered what is the most likely case if any? Is it more likely that an entity is always relevant or is it more likely that the block at the given position is relevant? If the latter is more likely you'd gain a smidgen of performance by inverting the two expressions.,"    private boolean isRelevant(EntityRef entity, Vector3f position) {
        return entity.isAlwaysRelevant() || worldProvider.isBlockRelevant(position);
    }
","    private boolean isRelevant(EntityRef entity, Vector3f position) {
START         return entity.isAlwaysRelevant() || worldProvider.isBlockRelevant(position); END 
    }
","    private boolean isRelevant(EntityRef entity, Vector3f position) {
        return worldProvider.isBlockRelevant(position) || entity.isAlwaysRelevant();
    }
"
1062,Declared but unused.,"    public String getClassificationValue(ClassificationScheme classification, ExtrinsicObjectType extrinsicObject) {
        RegistryObjectType registryObjectType = getClassification(classification, extrinsicObject);
        ClassificationType classType = null;
        if ((registryObjectType != null) && (registryObjectType instanceof ClassificationType)) {
            return ((ClassificationType) registryObjectType).getNodeRepresentation();
        }
        return null;
    }
","    public String getClassificationValue(ClassificationScheme classification, ExtrinsicObjectType extrinsicObject) {
        RegistryObjectType registryObjectType = getClassification(classification, extrinsicObject);
START         ClassificationType classType = null; END 
        if ((registryObjectType != null) && (registryObjectType instanceof ClassificationType)) {
            return ((ClassificationType) registryObjectType).getNodeRepresentation();
        }
        return null;
    }
","    public String getClassificationValue(ClassificationScheme classification, ExtrinsicObjectType extrinsicObject) {
        RegistryObjectType registryObjectType = getClassification(classification, extrinsicObject);
        if (registryObjectType != null && (registryObjectType instanceof ClassificationType)) {
            return ((ClassificationType) registryObjectType).getNodeRepresentation();
        }
        return null;
    }
"
1063,Not following XWiki codestyle.,"    @Override public String toString()
    {
        return ""MetaData{metadata="" + metadata + '}';
    }
","START     @Override public String toString() END 
    {
        return ""MetaData{metadata="" + metadata + '}';
    }
","    public String toString()
    {
        return ""MetaData{metadata="" + metadata + '}';
    }
"
1064,The two lines can be merged into one.,"  public static FlowTrigger createTestFlowTrigger(final List<FlowTriggerDependency> deps,
      final Duration
          maxWaitDuration) {
    final FlowTrigger flowTrigger = new FlowTrigger(
        new CronSchedule(""* * * * ? *""), deps, maxWaitDuration);
    return flowTrigger;
  }
","  public static FlowTrigger createTestFlowTrigger(final List<FlowTriggerDependency> deps,
      final Duration
          maxWaitDuration) {
START     final FlowTrigger flowTrigger = new FlowTrigger( END 
        new CronSchedule(""* * * * ? *""), deps, maxWaitDuration);
    return flowTrigger;
  }
","  public static FlowTrigger createTestFlowTrigger(final List<FlowTriggerDependency> deps,
      final Duration maxWaitDuration) {
    return new FlowTrigger(
        new CronSchedule(""* * * * ? *""), deps, maxWaitDuration);
  }
"
1065,"`new PrestoException(GENERIC_RECOVERY_ERROR)` ?

Make sure that you rethrow it as is here: https://github.com/prestodb/presto/pull/12529/commits/1690f79d028246209297d0f9743bc0893773ec97#diff-e97f65103d2e8ce8ea2916e4ab25f522R539

(catch PrestoException specifically as a special case)","    public synchronized void recover(TaskId taskId)
            throws TooManyTasksFailedException
    {
        checkState(groupedLifespanScheduler.isPresent(), ""groupedLifespanScheduler is not present for recoverable grouped execution"");
        if (anySourceSchedulingFinished) {
            throw new IllegalStateException(""Recover after any source scheduling finished is not supported"");
        }

        groupedLifespanScheduler.get().onTaskFailed(taskId.getId(), sourceSchedulers);
    }
","    public synchronized void recover(TaskId taskId)
            throws TooManyTasksFailedException
    {
        checkState(groupedLifespanScheduler.isPresent(), ""groupedLifespanScheduler is not present for recoverable grouped execution"");
        if (anySourceSchedulingFinished) {
START             throw new IllegalStateException(""Recover after any source scheduling finished is not supported""); END 
        }

        groupedLifespanScheduler.get().onTaskFailed(taskId.getId(), sourceSchedulers);
    }
","    public synchronized void recover(TaskId taskId)
    {
        checkState(groupedLifespanScheduler.isPresent(), ""groupedLifespanScheduler is not present for recoverable grouped execution"");
        if (anySourceSchedulingFinished) {
            throw new IllegalStateException(""Recover after any source scheduling finished is not supported"");
        }

        groupedLifespanScheduler.get().onTaskFailed(taskId.getId(), sourceSchedulers);
    }
"
1066,why not `[0..length)`,"    public Block[] getSequenceBlocks(int start, int length)
    {
        BlockBuilder blockBuilder = UNKNOWN.createBlockBuilder(new BlockBuilderStatus(), length);
        for (int i = start; i < start + length; i++) {
            blockBuilder.appendNull();
        }
        return new Block[] {blockBuilder.build()};
    }
","    public Block[] getSequenceBlocks(int start, int length)
    {
        BlockBuilder blockBuilder = UNKNOWN.createBlockBuilder(new BlockBuilderStatus(), length);
START         for (int i = start; i < start + length; i++) { END 
            blockBuilder.appendNull();
        }
        return new Block[] {blockBuilder.build()};
    }
","    public Block[] getSequenceBlocks(int start, int length)
    {
        BlockBuilder blockBuilder = UNKNOWN.createBlockBuilder(new BlockBuilderStatus(), length);
        for (int i = 0; i < length; i++) {
            blockBuilder.appendNull();
        }
        return new Block[] {blockBuilder.build()};
    }
"
1067,I don't think we need to LOG.info any-more; we can used LOG.debug or removed.,"    public List<ExchangeDownloadStatus> refreshExchangeManager() {
        LOG.info(""force the exchangeManager to refresh: {}"");
        ExchangeManagerUtil exUtil = new ExchangeManagerUtil();
        return exUtil.forceRefreshExchanges();
    }
","    public List<ExchangeDownloadStatus> refreshExchangeManager() {
START         LOG.info(""force the exchangeManager to refresh: {}""); END 
        ExchangeManagerUtil exUtil = new ExchangeManagerUtil();
        return exUtil.forceRefreshExchanges();
    }
","    public List<ExchangeDownloadStatus> refreshExchangeManager() {
        ExchangeManagerUtil exUtil = new ExchangeManagerUtil();
        return exUtil.forceRefreshExchanges();
    }
"
1068,shouldn't the exception be logged ?,"    protected void postShutdown() {
        logger().debug(""Shutting down the elasticsearch index provider '{0}' in repository '{1}'"", getName(), getRepositoryName());
        try {
            client.close();
            esNode.stop();
        } catch (Exception e) {
        }
    }
","    protected void postShutdown() {
        logger().debug(""Shutting down the elasticsearch index provider '{0}' in repository '{1}'"", getName(), getRepositoryName());
        try {
            client.close();
            esNode.stop();
        } catch (Exception e) {
START         } END 
    }
","    protected void postShutdown() {
        logger().debug(""Shutting down the elasticsearch index provider '{0}' in repository '{1}'"", getName(), getRepositoryName());
    }
"
1069,Also consider pageDescriptionText.setVisibility(pageDescriptionText.getLineCount() > 2 > View.VISIBLE : View.GONE); to emphasize that conditional effects function input and no other logic.,"    private void layoutWikiDataDescription(String description) {
        // set the text of the description...
        pageDescriptionText.setText(description);
        // and wait for it to lay out, so that we know the height of the description text.
        pageDescriptionText.post(new Runnable() {
            @Override
            public void run() {
                if (!parentFragment.isAdded()) {
                    return;
                }
                // only show the description if it's two lines or less
                if (pageDescriptionText.getLineCount() > 2) {
                    pageDescriptionText.setVisibility(View.GONE);
                } else {
                    pageDescriptionText.setVisibility(View.VISIBLE);
                }
            }
        });
    }
","    private void layoutWikiDataDescription(String description) {
        // set the text of the description...
        pageDescriptionText.setText(description);
        // and wait for it to lay out, so that we know the height of the description text.
        pageDescriptionText.post(new Runnable() {
            @Override
            public void run() {
                if (!parentFragment.isAdded()) {
                    return;
                }
                // only show the description if it's two lines or less
                if (pageDescriptionText.getLineCount() > 2) {
START                     pageDescriptionText.setVisibility(View.GONE); END 
                } else {
                    pageDescriptionText.setVisibility(View.VISIBLE);
                }
            }
        });
    }
","    private void layoutWikiDataDescription(String description) {
        // set the text of the description...
        pageDescriptionText.setText(description);
        // and wait for it to lay out, so that we know the height of the description text.
        pageDescriptionText.post(new Runnable() {
            @Override
            public void run() {
                if (!parentFragment.isAdded()) {
                    return;
                }
                // only show the description if it's two lines or less
                pageDescriptionText.setVisibility(pageDescriptionText.getLineCount() > 2
                        ? View.GONE : View.VISIBLE);
            }
        });
    }
"
1070,Is there a reason to not make it `protected` ?,"        AsyncSession getSession() {
            return AsyncSession.this;
        }
","START         AsyncSession getSession() { END 
            return AsyncSession.this;
        }
","        protected AsyncSession getSession() {
            return AsyncSession.this;
        }
"
1071,`getOrDefault` is not available in Java 7.,"    public static String get() { return props.getOrDefault(VERSION_RELEASE_KEY, ""unset""); }
","START     public static String get() { return props.getOrDefault(VERSION_RELEASE_KEY, ""unset""); } END 
","    public static String get() { return props.get(VERSION_RELEASE_KEY); }
"
1072,"![MAJOR](https://sonarsource.github.io/sonar-github/severity-major.png 'Severity: MAJOR') Add the ""@Override"" annotation above this method signature [![rule](https://sonarsource.github.io/sonar-github/rule.png)](https://sonarcloud.io/coding_rules#rule_key=squid%3AS1161)","	protected Composite createWidgets(Composite parent, CDKServer cdkServer, FormToolkit toolkit) {
		Composite composite = initializeSectionWidget(parent, toolkit);
		createChooseCredentialsWidgets(composite, toolkit);
		createEnvironmentWidgets(composite, toolkit, cdkServer);
		addRegistrationWidgets(parent, cdkServer, toolkit);
		return composite;
	}
","START 	protected Composite createWidgets(Composite parent, CDKServer cdkServer, FormToolkit toolkit) { END 
		Composite composite = initializeSectionWidget(parent, toolkit);
		createChooseCredentialsWidgets(composite, toolkit);
		createEnvironmentWidgets(composite, toolkit, cdkServer);
		addRegistrationWidgets(parent, cdkServer, toolkit);
		return composite;
	}
","	protected Composite createWidgets(Composite parent, CDKServer cdkServer, FormToolkit toolkit) {
		Composite composite = initializeSectionWidget(parent, toolkit);
		createChooseCredentialsWidgets(composite, toolkit);
		createEnvironmentWidgets(composite, toolkit, cdkServer);
		addRegistrationWidgets(composite, cdkServer, toolkit);
		return composite;
	}
"
1073,TODO : remove that log before release.,"  private void drawTiles( Canvas canvas ) {
    if( mPreviouslyDrawnTiles.size() > 0 ) {
      drawTilesConsideringPreviouslyDrawnLevel( canvas );
    } else {
      drawTilesWithoutConsideringPreviouslyDrawnLevel( canvas );
    }
    Log.d( getClass().getSimpleName(), ""prevous tile count: "" + mPreviouslyDrawnTiles.size() );
  }
","  private void drawTiles( Canvas canvas ) {
    if( mPreviouslyDrawnTiles.size() > 0 ) {
      drawTilesConsideringPreviouslyDrawnLevel( canvas );
    } else {
      drawTilesWithoutConsideringPreviouslyDrawnLevel( canvas );
    }
START     Log.d( getClass().getSimpleName(), ""prevous tile count: "" + mPreviouslyDrawnTiles.size() ); END 
  }
","  private void drawTiles( Canvas canvas ) {
    if( mPreviouslyDrawnTiles.size() > 0 ) {
      drawTilesConsideringPreviouslyDrawnLevel( canvas );
    } else {
      drawTilesWithoutConsideringPreviouslyDrawnLevel( canvas );
    }
  }
"
1074,When do we decide to use `stream`?,"  private static void cleanUpOldFiles(File dir) {
    long cutoffTimestamp = System.currentTimeMillis() - (MAX_FILE_AGE_HOURS * Constants.HOUR_MS);
    File[] files = dir.listFiles();
    for (File file : files) {
      if (!FileUtils.isFileNewer(file, cutoffTimestamp)) {
        delete(file);
      }
    }
  }
","  private static void cleanUpOldFiles(File dir) {
    long cutoffTimestamp = System.currentTimeMillis() - (MAX_FILE_AGE_HOURS * Constants.HOUR_MS);
    File[] files = dir.listFiles();
    for (File file : files) {
      if (!FileUtils.isFileNewer(file, cutoffTimestamp)) {
START         delete(file); END 
      }
    }
  }
","  private static void cleanUpOldFiles(File dir) {
    long cutoffTimestamp = System.currentTimeMillis() - (MAX_FILE_AGE_HOURS * Constants.HOUR_MS);
    Arrays.asList(dir.listFiles()).stream()
        .filter(file -> !FileUtils.isFileNewer(file, cutoffTimestamp))
        .forEach(file -> delete(file));
  }
"
1075,nit: long ?,"        boolean getAsBoolean() throws Exception;
    }

    /** Wait until {@code predicate} is satisfied, or fail, with a given timeout. */
    public static void waitUntil(
            String message, int timeoutSeconds, BooleanSupplierWithThrow predicate)
            throws Exception {
        int sleep = 125;
        final long timeout = System.currentTimeMillis() + timeoutSeconds * 1000;
        while (System.currentTimeMillis() < timeout) {
            if (predicate.getAsBoolean()) {
                return;
            }
            RunUtil.getDefault().sleep(sleep);
        }
        fail(message);
    }
","        boolean getAsBoolean() throws Exception;
    }

    /** Wait until {@code predicate} is satisfied, or fail, with a given timeout. */
    public static void waitUntil(
            String message, START  int timeoutSeconds, END  BooleanSupplierWithThrow predicate)
            throws Exception {
        int sleep = 125;
        final long timeout = System.currentTimeMillis() + timeoutSeconds * 1000;
        while (System.currentTimeMillis() < timeout) {
            if (predicate.getAsBoolean()) {
                return;
            }
            RunUtil.getDefault().sleep(sleep);
        }
        fail(message);
    }
","        boolean getAsBoolean() throws Exception;
    }

    /** Wait until {@code predicate} is satisfied, or fail, with a given timeout. */
    public static void waitUntil(
            String message, long timeoutSeconds, BooleanSupplierWithThrow predicate)
            throws Exception {
        int sleep = 125;
        final long timeout = System.currentTimeMillis() + timeoutSeconds * 1000;
        while (System.currentTimeMillis() < timeout) {
            if (predicate.getAsBoolean()) {
                return;
            }
            RunUtil.getDefault().sleep(sleep);
        }
        fail(message);
    }
"
1076,missing return here,"    protected void endVmCommand() {
        setCommandShouldBeLogged(false);
        if (getVm() == null) {
            log.warn(""VM is null, not performing full endAction"");
            setSucceeded(true);
        }

        getVm().setStatus(VMStatus.Down);
        getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
        getVmDynamicDao().update(getVm().getDynamicData());
        setSucceeded(true);
    }
","    protected void endVmCommand() {
        setCommandShouldBeLogged(false);
        if (getVm() == null) {
            log.warn(""VM is null, not performing full endAction"");
START             setSucceeded(true); END 
        }

        getVm().setStatus(VMStatus.Down);
        getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
        getVmDynamicDao().update(getVm().getDynamicData());
        setSucceeded(true);
    }
","    protected void endVmCommand() {
        setCommandShouldBeLogged(false);
        if (getVm() == null) {
            log.warn(""VM is null, not performing full endAction"");
            setSucceeded(true);
            return;
        }

        getVm().setStatus(VMStatus.Down);
        getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
        getVmDynamicDao().update(getVm().getDynamicData());
        setSucceeded(true);
    }
"
1077,"element.fromString only returns a BaseProperty, it doesn't change the LevelsClass. i guess the method should only returns a new LevelsClass?","  protected LevelsClass getListClass() {
    LevelsClass element = new LevelsClass();
    element.fromString(Joiner.on(getSeparator()).join(FluentIterable.from(Arrays.asList(
        enumType.getEnumConstants())).transform(GET_ACCESS_LEVEL_ENUM_IDENTIFIERS)));
    return element;
  }
","  protected LevelsClass getListClass() {
    LevelsClass element = new LevelsClass();
    element.fromString(Joiner.on(getSeparator()).join(FluentIterable.from(Arrays.asList(
START         enumType.getEnumConstants())).transform(GET_ACCESS_LEVEL_ENUM_IDENTIFIERS))); END 
    return element;
  }
","  protected LevelsClass getListClass() {
    return new LevelsClass();
  }
"
1078,"Remove this Log, please.","    public void onRefresh() {
        super.onRefresh();
        
        if (mFile != null) {
            // Refresh mFile
            mFile = mContainerActivity.getStorageManager().getFileById(mFile.getFileId());

            listDirectory(mFile);
            
            ((FileDisplayActivity)mContainerActivity).startSyncFolderOperation(mFile);
            Log_OC.d(TAG, ""Parent etag= |"" + mFile.getEtag() + ""|"");
        }
    }
","    public void onRefresh() {
        super.onRefresh();
        
        if (mFile != null) {
            // Refresh mFile
            mFile = mContainerActivity.getStorageManager().getFileById(mFile.getFileId());

            listDirectory(mFile);
            
            ((FileDisplayActivity)mContainerActivity).startSyncFolderOperation(mFile);
START             Log_OC.d(TAG, ""Parent etag= |"" + mFile.getEtag() + ""|""); END 
        }
    }
","    public void onRefresh() {
        super.onRefresh();
        
        if (mFile != null) {
            // Refresh mFile
            mFile = mContainerActivity.getStorageManager().getFileById(mFile.getFileId());

            listDirectory(mFile);
            
            ((FileDisplayActivity)mContainerActivity).startSyncFolderOperation(mFile);
        }
    }
"
1079,Change from `Object.equals` to `Double.compare` should be part of previous commit.,"    public boolean equals(Object o)
    {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PlanNodeStatsEstimate that = (PlanNodeStatsEstimate) o;
        return Double.compare(that.outputRowCount, outputRowCount) == 0 &&
                Double.compare(that.outputSizeInBytes, outputSizeInBytes) == 0 &&
                Objects.equals(symbolStatistics, that.symbolStatistics);
    }
","    public boolean equals(Object o)
    {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PlanNodeStatsEstimate that = (PlanNodeStatsEstimate) o;
START         return Double.compare(that.outputRowCount, outputRowCount) == 0 && END 
                Double.compare(that.outputSizeInBytes, outputSizeInBytes) == 0 &&
                Objects.equals(symbolStatistics, that.symbolStatistics);
    }
","    public boolean equals(Object o)
    {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PlanNodeStatsEstimate that = (PlanNodeStatsEstimate) o;
        return Double.compare(outputRowCount, that.outputRowCount) == 0 &&
                Objects.equals(symbolStatistics, that.symbolStatistics);
    }
"
1080,nit: Suggest renaming `iterations` and its getter as well here,"  public BasicAuthDBConfig(
      final PasswordProvider initialAdminPassword,
      final PasswordProvider initialInternalClientPassword,
      final String initialAdminUser,
      final String initialAdminRole,
      final String initialAdminGroupMapping,
      final boolean enableCacheNotifications,
      final long cacheNotificationTimeout,
      final int credentialIterations
  )
  {
    this.initialAdminPassword = initialAdminPassword;
    this.initialInternalClientPassword = initialInternalClientPassword;
    this.initialAdminUser = initialAdminUser;
    this.initialAdminRole = initialAdminRole;
    this.initialAdminGroupMapping = initialAdminGroupMapping;
    this.enableCacheNotifications = enableCacheNotifications;
    this.cacheNotificationTimeout = cacheNotificationTimeout;
    this.iterations = credentialIterations;
  }
","  public BasicAuthDBConfig(
      final PasswordProvider initialAdminPassword,
      final PasswordProvider initialInternalClientPassword,
      final String initialAdminUser,
      final String initialAdminRole,
      final String initialAdminGroupMapping,
      final boolean enableCacheNotifications,
      final long cacheNotificationTimeout,
      final int credentialIterations
  )
  {
    this.initialAdminPassword = initialAdminPassword;
    this.initialInternalClientPassword = initialInternalClientPassword;
    this.initialAdminUser = initialAdminUser;
    this.initialAdminRole = initialAdminRole;
    this.initialAdminGroupMapping = initialAdminGroupMapping;
    this.enableCacheNotifications = enableCacheNotifications;
    this.cacheNotificationTimeout = cacheNotificationTimeout;
START     this.iterations = credentialIterations; END 
  }
","  public BasicAuthDBConfig(
      final PasswordProvider initialAdminPassword,
      final PasswordProvider initialInternalClientPassword,
      final String initialAdminUser,
      final String initialAdminRole,
      final String initialAdminGroupMapping,
      final boolean enableCacheNotifications,
      final long cacheNotificationTimeout,
      final int credentialIterations
  )
  {
    this.initialAdminPassword = initialAdminPassword;
    this.initialInternalClientPassword = initialInternalClientPassword;
    this.initialAdminUser = initialAdminUser;
    this.initialAdminRole = initialAdminRole;
    this.initialAdminGroupMapping = initialAdminGroupMapping;
    this.enableCacheNotifications = enableCacheNotifications;
    this.cacheNotificationTimeout = cacheNotificationTimeout;
    this.credentialIterations = credentialIterations;
  }
"
1081,Please pass 'isFixedLayout' to the 'setWidth' methods,"    public void setWidth(String width, boolean isFixedLayout) {
        table.setWidth(""100%"", true); //$NON-NLS-1$
        tableHeader.setWidth(""100%"", true); //$NON-NLS-1$
    }
","    public void setWidth(String width, boolean isFixedLayout) {
        table.setWidth(""100%"", true); //$NON-NLS-1$
START         tableHeader.setWidth(""100%"", true); //$NON-NLS-1$ END 
    }
","    public void setWidth(String width, boolean isFixedLayout) {
        table.setWidth(""100%"", isFixedLayout); //$NON-NLS-1$
        tableHeader.setWidth(""100%"", isFixedLayout); //$NON-NLS-1$
    }
"
1082,"same commit vs apply question here, one answer answers both","    private void setCustomServer(String s) {

        SharedPreferences userPreferences = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance());
        SharedPreferences.Editor e = userPreferences.edit();
        e.putBoolean(""useCustomSyncServer"", true);
        e.putString(""syncBaseUrl"", s);
        e.commit();
    }
","    private void setCustomServer(String s) {

        SharedPreferences userPreferences = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance());
        SharedPreferences.Editor e = userPreferences.edit();
        e.putBoolean(""useCustomSyncServer"", true);
        e.putString(""syncBaseUrl"", s);
START         e.commit(); END 
    }
","    private void setCustomServer(String s) {

        SharedPreferences userPreferences = AnkiDroidApp.getSharedPrefs(AnkiDroidApp.getInstance());
        SharedPreferences.Editor e = userPreferences.edit();
        e.putBoolean(""useCustomSyncServer"", true);
        e.putString(""syncBaseUrl"", s);
        e.apply();
    }
"
1083,"Generally better to qualify than making static import; this makes me go look at where it's coming from (ie. did you implement your own for some reason?) I tend to use static imports for constants or in Unit tests where its very obvious what is not provided by custom code (ie. assertXXX(..), mock(..), etc.)
```suggestion
        return Collections.emptyList();
```","    default List<Pattern> getExcludedResponseHeaderPatterns() {
        return emptyList();
    }
","    default List<Pattern> getExcludedResponseHeaderPatterns() {
START         return emptyList(); END 
    }
","    default List<Pattern> getExcludedResponseHeaderPatterns() {
        return Collections.emptyList();
    }
"
1084,I don't think the `if` case is required here since it is assumed that `accountServiceConfig.zkClientConnectString` is not invalid (it is used in `getAccountService()`). What do you think?,"  public HelixAccountServiceFactory(VerifiableProperties verifiableProperties, MetricRegistry metricRegistry) {
    storeConfig = new HelixPropertyStoreConfig(verifiableProperties);
    accountServiceConfig = new HelixAccountServiceConfig(verifiableProperties);
    accountServiceMetrics = new AccountServiceMetrics(metricRegistry);
    notifier =
        accountServiceConfig.zkClientConnectString.equals(HelixAccountServiceConfig.INVALID_ZK_CLIENT_CONNECT_STRING)
            ? null : new HelixNotifier(accountServiceConfig.zkClientConnectString, storeConfig);
  }
","  public HelixAccountServiceFactory(VerifiableProperties verifiableProperties, MetricRegistry metricRegistry) {
    storeConfig = new HelixPropertyStoreConfig(verifiableProperties);
    accountServiceConfig = new HelixAccountServiceConfig(verifiableProperties);
    accountServiceMetrics = new AccountServiceMetrics(metricRegistry);
    notifier =
START         accountServiceConfig.zkClientConnectString.equals(HelixAccountServiceConfig.INVALID_ZK_CLIENT_CONNECT_STRING) END 
            ? null : new HelixNotifier(accountServiceConfig.zkClientConnectString, storeConfig);
  }
","  public HelixAccountServiceFactory(VerifiableProperties verifiableProperties, MetricRegistry metricRegistry) {
    this(new HelixPropertyStoreConfig(verifiableProperties), new HelixAccountServiceConfig(verifiableProperties),
        new AccountServiceMetrics(metricRegistry),
        new HelixNotifier(new HelixAccountServiceConfig(verifiableProperties).zkClientConnectString,
            new HelixPropertyStoreConfig(verifiableProperties)));
  }
"
1085,Debug has to be detected first otherwise we'll always take the INFO branch.,"	private void logExceptionBeforeFailOver(Exception ex, MessageHandler handler, Message<?> message) {
		if (this.logger.isInfoEnabled()) {
			this.logger.info(""An exception was thrown by '"" + handler + ""' while handling '"" + message + ""': "" +
					ex.getMessage() + "". Failing over to the next subscriber."");
		}
		else if (this.logger.isDebugEnabled()) {
			this.logger.debug(""An exception was thrown by '"" + handler + ""' while handling '"" + message +
					""'. Failing over to the next subscriber."", ex);
		}
	}
","	private void logExceptionBeforeFailOver(Exception ex, MessageHandler handler, Message<?> message) {
		if (this.logger.isInfoEnabled()) {
			this.logger.info(""An exception was thrown by '"" + handler + ""' while handling '"" + message + ""': "" +
					ex.getMessage() + "". Failing over to the next subscriber."");
		}
		else if (this.logger.isDebugEnabled()) {
			this.logger.debug(""An exception was thrown by '"" + handler + ""' while handling '"" + message +
START 					""'. Failing over to the next subscriber."", ex); END 
		}
	}
","	private void logExceptionBeforeFailOver(Exception ex, MessageHandler handler, Message<?> message) {
		if (this.logger.isDebugEnabled()) {
			this.logger.debug(""An exception was thrown by '"" + handler + ""' while handling '"" + message +
					""'. Failing over to the next subscriber."", ex);
		}
		else if (this.logger.isInfoEnabled()) {
			this.logger.info(""An exception was thrown by '"" + handler + ""' while handling '"" + message + ""': "" +
					ex.getMessage() + "". Failing over to the next subscriber."");
		}
	}
"
1086,"You should not be creating Location Attributes on idgen module startup.  This is not a core function of the idgen module and might have other implications.  If an implementer wants to use the LocationBasedPrefixProvider, then can take responsibility over ensuring that the correct LocationAttributeType and LocationAttributes exist.","	public void started() {
		IdgenTask.setEnabled(true);
		createLocationPrefixAttributeType();
		log.info(""Idgen Module Started..."");
	}
","	public void started() {
		IdgenTask.setEnabled(true);
START 		createLocationPrefixAttributeType(); END 
		log.info(""Idgen Module Started..."");
	}
","	public void started() {
		IdgenTask.setEnabled(true);
		log.info(""Idgen Module Started..."");
	}
"
1087,pls use diamond `new ArrayList<>();`,"    private static List<RunOrderWithArguments> withEmptyArguments( RunOrder[] runOrders )
    {
        List<RunOrderWithArguments> orderWithArguments = new ArrayList<RunOrderWithArguments>();
        for ( RunOrder runOrder : runOrders )
        {
            RunOrderArguments args = new RunOrderArguments( new ArrayList<String>() );
            orderWithArguments.add( new RunOrderWithArguments( runOrder, args ) );
        }
        return orderWithArguments;
    }
","    private static List<RunOrderWithArguments> withEmptyArguments( RunOrder[] runOrders )
    {
START         List<RunOrderWithArguments> orderWithArguments = new ArrayList<RunOrderWithArguments>(); END 
        for ( RunOrder runOrder : runOrders )
        {
            RunOrderArguments args = new RunOrderArguments( new ArrayList<String>() );
            orderWithArguments.add( new RunOrderWithArguments( runOrder, args ) );
        }
        return orderWithArguments;
    }
","    private static List<RunOrderWithArguments> withEmptyArguments( RunOrder[] runOrders )
    {
        List<RunOrderWithArguments> orderWithArguments = new ArrayList<>();
        for ( RunOrder runOrder : runOrders )
        {
            RunOrderArguments args = new RunOrderArguments( new ArrayList<String>() );
            orderWithArguments.add( new RunOrderWithArguments( runOrder, args ) );
        }
        return orderWithArguments;
    }
"
1088,This does not follow XWiki codestyle (missing { and }).,"    public String getResourceContent(String name) throws IOException
    {
        String output = """";
        if (getEngineContext() != null) {
            try (InputStream is = getResourceAsStream(name)) {
                if (is == null) {
                    // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding
                    output = FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);
                }
                else output =  IOUtils.toString(is, DEFAULT_ENCODING);
            } 
        }
        return output;
    }
","    public String getResourceContent(String name) throws IOException
    {
        String output = """";
        if (getEngineContext() != null) {
            try (InputStream is = getResourceAsStream(name)) {
                if (is == null) {
                    // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding
                    output = FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);
                }
START                 else output =  IOUtils.toString(is, DEFAULT_ENCODING); END 
            } 
        }
        return output;
    }
","    public String getResourceContent(String name) throws IOException
    {
        if (getEngineContext() != null) {
            try (InputStream is = getResourceAsStream(name)) {
                if (is != null) {
                    return IOUtils.toString(is, DEFAULT_ENCODING);
                }
            }
        }
        // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding
        return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);
    }
"
1089,Why not adding this to `Predicates` ?,"    public void assertStartsWithCount(int eventsCount, String startsWith) {
        List<LogEntry> logs = auditBackend.queryLogs(new AuditQueryBuilder().predicates(
                Predicates.eq(LOG_EVENT_ID, ID_FOR_AUDIT_STORAGE_TESTS),
                new Predicate(new Reference(LOG_DOC_PATH), Operator.STARTSWITH, Literals.toLiteral(startsWith))));
        assertEquals(eventsCount, logs.size());
    }
","    public void assertStartsWithCount(int eventsCount, String startsWith) {
        List<LogEntry> logs = auditBackend.queryLogs(new AuditQueryBuilder().predicates(
                Predicates.eq(LOG_EVENT_ID, ID_FOR_AUDIT_STORAGE_TESTS),
START                 new Predicate(new Reference(LOG_DOC_PATH), Operator.STARTSWITH, Literals.toLiteral(startsWith)))); END 
        assertEquals(eventsCount, logs.size());
    }
","    public void assertStartsWithCount(int eventsCount, String startsWith) {
        List<LogEntry> logs = auditBackend.queryLogs(new AuditQueryBuilder().predicates(
                Predicates.eq(LOG_EVENT_ID, ID_FOR_AUDIT_STORAGE_TESTS),
                Predicates.startsWith(LOG_DOC_PATH, startsWith)));
        assertEquals(eventsCount, logs.size());
    }
"
1090,"Inverse this, and combine with following lines. Can get rid of an entire branch","    public static boolean isInChain(Certificate cert, List<Certificate> chain) {
        String lookSKI = getCertKeyIdSubject(cert);
        if (null == lookSKI) {
            return false;
        }
        String foundSKI = null;
        for (Certificate link : chain) {
            foundSKI = getCertKeyIdSubject(link);
            if (lookSKI.equals(foundSKI)) {
                return true;
            }
        }
        return false;
    }
","    public static boolean isInChain(Certificate cert, List<Certificate> chain) {
        String lookSKI = getCertKeyIdSubject(cert);
START         if (null == lookSKI) { END 
            return false;
        }
        String foundSKI = null;
        for (Certificate link : chain) {
            foundSKI = getCertKeyIdSubject(link);
            if (lookSKI.equals(foundSKI)) {
                return true;
            }
        }
        return false;
    }
","    public static boolean isInChain(Certificate cert, List<Certificate> chain) {
        String lookSKI = getCertKeyIdSubject(cert);
        if (null != lookSKI) {
            for (Certificate link : chain) {
                String foundSKI = getCertKeyIdSubject(link);
                if (lookSKI.equals(foundSKI)) {
                    return true;
                }
            }
        }
        return false;
    }
"
1091,"Why convert this to a double, rather than leave it as the exact long value?","    public static Function<HttpPollValue, Double> latency() {
        return new Function<HttpPollValue, Double>() {
            @Override
            @Nullable
            public Double apply(HttpPollValue input) {
                if (input.getLatencyFullContent()==null) return null;
                return input.getLatencyFullContent().doubleValue();
            }
        };
    }
","    public static Function<HttpPollValue, Double> latency() {
        return new Function<HttpPollValue, Double>() {
            @Override
            @Nullable
            public Double apply(HttpPollValue input) {
                if (input.getLatencyFullContent()==null) return null;
START                 return input.getLatencyFullContent().doubleValue(); END 
            }
        };
    }
","    public static Function<HttpPollValue, Long> latency() {
        return new Function<HttpPollValue, Long>() {
            public Long apply(HttpPollValue input) {
                return input.getLatencyFullContent();
            }
        };
    }
"
1092,"nit: this isn't exactly a result of an interrupt, so I think throwing a RuntimeException like `IllegalStateException` would be a better fit here.","  public void sendRequest(NetworkRequest request) throws InterruptedException {
    DataInputStream stream = new DataInputStream(request.getInputStream());
    try {
      // The first 8 bytes is size of the request. TCP implementation uses this size to allocate buffer. See {@link BoundedReceive}
      // Here we just need to consume it.
      stream.readLong();
    } catch (IOException e) {
      throw new InterruptedException(""stream read error."" + e);
    }
    requestQueue.put(request);
  }
","  public void sendRequest(NetworkRequest request) throws InterruptedException {
    DataInputStream stream = new DataInputStream(request.getInputStream());
    try {
      // The first 8 bytes is size of the request. TCP implementation uses this size to allocate buffer. See {@link BoundedReceive}
      // Here we just need to consume it.
      stream.readLong();
    } catch (IOException e) {
START       throw new InterruptedException(""stream read error."" + e); END 
    }
    requestQueue.put(request);
  }
","  public void sendRequest(NetworkRequest request) throws InterruptedException {
    DataInputStream stream = new DataInputStream(request.getInputStream());
    try {
      // The first 8 bytes is size of the request. TCP implementation uses this size to allocate buffer. See {@link BoundedReceive}
      // Here we just need to consume it.
      stream.readLong();
    } catch (IOException e) {
      throw new IllegalStateException(""stream read error."" + e);
    }
    requestQueue.put(request);
  }
"
1093,no need the final in static methods,"   public static final KeyValueStoreListener create() {
      return new ClientKeyValueStoreListener();
   }
","START    public static final KeyValueStoreListener create() { END 
      return new ClientKeyValueStoreListener();
   }
","   public static KeyValueStoreListener create() {
      return new ClientKeyValueStoreListener();
   }
"
1094,"If you did this in the reverse order, you would prevent races... so blindly delete and then check if it still exists.","    public void rollback()
    {
        for (Path file : tempFiles) {
            try {
                if (fileSystem.exists(file) && !fileSystem.delete(file, false)) {
                    throw new IOException(""Delete failed"");
                }
            }
            catch (IOException e) {
                log.warn(e, ""Failed to delete temporary file: "" + file);
            }
        }

        outputWriter.rollback();
    }
","    public void rollback()
    {
        for (Path file : tempFiles) {
            try {
                if (fileSystem.exists(file) && !fileSystem.delete(file, false)) {
                    throw new IOException(""Delete failed"");
                }
            }
            catch (IOException e) {
                log.warn(e, ""Failed to delete temporary file: "" + file);
            }
START         } END 

        outputWriter.rollback();
    }
","    public void rollback()
    {
        for (Path file : tempFiles) {
            try {
                fileSystem.delete(file, false);
                if (fileSystem.exists(file)) {
                    throw new IOException(""Delete failed"");
                }
            }
            catch (IOException e) {
                log.warn(e, ""Failed to delete temporary file: "" + file);
            }
        }

        outputWriter.rollback();
    }
"
1095,shouldn't you use a simple System.currrentTimeMillis() instead of the SystemReader?,"	private void writePackedRefs(String content) throws IOException {
		File pr = new File(diskRepo.getDirectory(), ""packed-refs"");
		write(pr, content);

		final long now = SystemReader.getInstance().getCurrentTime();
		final int oneHourAgo = 3600 * 1000;
		pr.setLastModified(now - oneHourAgo);
	}
","	private void writePackedRefs(String content) throws IOException {
		File pr = new File(diskRepo.getDirectory(), ""packed-refs"");
		write(pr, content);

START 		final long now = SystemReader.getInstance().getCurrentTime(); END 
		final int oneHourAgo = 3600 * 1000;
		pr.setLastModified(now - oneHourAgo);
	}
","	private void writePackedRefs(String content) throws IOException {
		File pr = new File(diskRepo.getDirectory(), ""packed-refs"");
		write(pr, content);

		final long now = System.currentTimeMillis();
		final int oneHourAgo = 3600 * 1000;
		pr.setLastModified(now - oneHourAgo);
	}
"
1096,can be replaced by an unmodifiable version like `List.of()`,"    protected NuxeoPrincipal createAdministrator() {
        return new UserPrincipal(""Administrator"", new ArrayList<>(), false, true);
    }
","    protected NuxeoPrincipal createAdministrator() {
START         return new UserPrincipal(""Administrator"", new ArrayList<>(), false, true); END 
    }
","    protected NuxeoPrincipal createAdministrator() {
        return new UserPrincipal(""Administrator"", List.of(), false, true);
    }
"
1097,Doesn't mFileSystem do the merging already?,"  private void migrateDirectory(String path, String source, String destination) throws Exception {
    String newDir = computeTargetPath(path, source, destination);
    mFileSystem.createDirectory(new AlluxioURI(newDir),
        FileSystemOptions.createDirectoryDefaults(ServerConfiguration.global()));
  }
","  private void migrateDirectory(String path, String source, String destination) throws Exception {
    String newDir = computeTargetPath(path, source, destination);
    mFileSystem.createDirectory(new AlluxioURI(newDir),
START         FileSystemOptions.createDirectoryDefaults(ServerConfiguration.global())); END 
  }
","  private void migrateDirectory(String path, String source, String destination) throws Exception {
    String newDir = computeTargetPath(path, source, destination);
    mFileSystem.createDirectory(new AlluxioURI(newDir));
  }
"
1098,"you should replace the test by (primeRefining == null) and execute statements from the else block. Then always return primeRefining field after the ""if"", the main local variable is not useful","	public Diff getPrimeRefining() {
		Diff main = null;
		if (primeRefining != null) {
			main = primeRefining;
		} else {
			for (Diff refBy : this.getRefinedBy()) {
				if (refBy instanceof ReferenceChange) {
					ReferenceChange rc = (ReferenceChange)refBy;
					if (rc.getReference().isContainment() && (this.getDiscriminant() == rc.getValue())) {
						main = rc;
						break;
					}
				}
			}
		}
		return main;
	}
","	public Diff getPrimeRefining() {
		Diff main = null;
START 		if (primeRefining != null) { END 
			main = primeRefining;
		} else {
			for (Diff refBy : this.getRefinedBy()) {
				if (refBy instanceof ReferenceChange) {
					ReferenceChange rc = (ReferenceChange)refBy;
					if (rc.getReference().isContainment() && (this.getDiscriminant() == rc.getValue())) {
						main = rc;
						break;
					}
				}
			}
		}
		return main;
	}
","	public Diff getPrimeRefining() {
		if (primeRefining == null) {
			for (Diff refBy : this.getRefinedBy()) {
				if (refBy instanceof ReferenceChange) {
					ReferenceChange rc = (ReferenceChange)refBy;
					if (rc.getReference().isContainment() && (this.getDiscriminant() == rc.getValue())) {
						primeRefining = rc;
						break;
					}
				}
			}
		}
		return primeRefining;
	}
"
1099,This constructor should delegate to other constructor,"    StoreIndexDescriptor( StoreIndexDescriptor indexDescriptor )
    {
        super( indexDescriptor );
        this.id = indexDescriptor.id;
        this.owningConstraintId = indexDescriptor.owningConstraintId;
        this.name = indexDescriptor.name;
    }
","START     StoreIndexDescriptor( StoreIndexDescriptor indexDescriptor ) END 
    {
        super( indexDescriptor );
        this.id = indexDescriptor.id;
        this.owningConstraintId = indexDescriptor.owningConstraintId;
        this.name = indexDescriptor.name;
    }
","    protected StoreIndexDescriptor( StoreIndexDescriptor indexDescriptor )
    {
        super( indexDescriptor );
        this.id = indexDescriptor.id;
        this.owningConstraintId = indexDescriptor.owningConstraintId;
        this.name = indexDescriptor.name;
    }
"
1100,"You should return void instead of Void, so you won't have to return null","    public Void delete(@PathParam(RestParameter.ID) Long id) {
        ratingDao.delete(id);
        return null;
    }
","START     public Void delete(@PathParam(RestParameter.ID) Long id) { END 
        ratingDao.delete(id);
        return null;
    }
","    public void delete(@PathParam(RestParameter.ID) Long id) {
        ratingDao.delete(id);
    }
"
1101,This version check could be removed as we already move to 2.6.x,"    protected AbstractXmlApplicationContext createApplicationContext() {
        String version = Version.getCurrentVersion();
        
        ClassPathXmlApplicationContext applicationContext = null;
        
        if (version.startsWith(""2"") && (version.contains(""2.5"") || version.contains(""2.4""))) {
            applicationContext = new ClassPathXmlApplicationContext(new String(""org/apache/camel/component/cxf/jaxrs/CxfRsSpringEndpointBeans.xml""));
        } else {
            applicationContext = new ClassPathXmlApplicationContext(new String(""org/apache/camel/component/cxf/jaxrs/CxfRsSpringEndpointBeans-2.6.xml""));    
        }
        
        emulateBeanRegistrationProgrammatically(applicationContext);
        
        return applicationContext;
    }
","    protected AbstractXmlApplicationContext createApplicationContext() {
        String version = Version.getCurrentVersion();
        
        ClassPathXmlApplicationContext applicationContext = null;
        
START         if (version.startsWith(""2"") && (version.contains(""2.5"") || version.contains(""2.4""))) { END 
            applicationContext = new ClassPathXmlApplicationContext(new String(""org/apache/camel/component/cxf/jaxrs/CxfRsSpringEndpointBeans.xml""));
        } else {
            applicationContext = new ClassPathXmlApplicationContext(new String(""org/apache/camel/component/cxf/jaxrs/CxfRsSpringEndpointBeans-2.6.xml""));    
        }
        
        emulateBeanRegistrationProgrammatically(applicationContext);
        
        return applicationContext;
    }
","    protected AbstractXmlApplicationContext createApplicationContext() {      
        
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(new String(""org/apache/camel/component/cxf/jaxrs/CxfRsSpringEndpointBeans.xml""));        
        emulateBeanRegistrationProgrammatically(applicationContext);
        
        return applicationContext;
    }
"
1102,You should extract to local variable before the if and use this variable to null-check in the if,"    private void handlePendingScenario(ITmfEvent event, boolean isInputValid) {
        if (fConsuming && isEventConsumed()) {
            return;
        }

        if ((fInitialStateId.equals(TmfXmlState.INITIAL_STATE_ID) || isInputValid) && fPendingScenario != null) {
            @NonNull TmfXmlScenario scenario = fPendingScenario;
            handleScenario(scenario, event);
            if (!scenario.isPending()) {
                addActiveScenario(scenario);
                fPendingScenario = null;
            }
        }
    }
","    private void handlePendingScenario(ITmfEvent event, boolean isInputValid) {
        if (fConsuming && isEventConsumed()) {
            return;
        }

        if ((fInitialStateId.equals(TmfXmlState.INITIAL_STATE_ID) || isInputValid) && fPendingScenario != null) {
START             @NonNull TmfXmlScenario scenario = fPendingScenario; END 
            handleScenario(scenario, event);
            if (!scenario.isPending()) {
                addActiveScenario(scenario);
                fPendingScenario = null;
            }
        }
    }
","    private void handlePendingScenario(ITmfEvent event, boolean isInputValid) {
        if (fConsuming && isEventConsumed()) {
            return;
        }

        TmfXmlScenario scenario = fPendingScenario;
        if ((fInitialStateId.equals(TmfXmlState.INITIAL_STATE_ID) || isInputValid) && scenario != null) {
            handleScenario(scenario, event);
            if (!scenario.isPending()) {
                addActiveScenario(scenario);
                fPendingScenario = null;
            }
        }
    }
"
1103,Oops.,"		public boolean isRestricted() {
			throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
		}
","		public boolean isRestricted() {
START 			throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates. END 
		}
","		public boolean isRestricted() {
			return true;
		}
"
1104,"I think that this check makes more sense in the ""getClusterId"" method. Can we move it there?","    private Guid getTargetClusterId(Action action) {
        if (action.isSetCluster() && (action.getCluster().isSetId() || action.getCluster().isSetName())) {
            return getClusterId(action);
        }

        // means use the cluster of the provided host
        return null;
    }
","    private Guid getTargetClusterId(Action action) {
        if (action.isSetCluster() && START  (action.getCluster().isSetId() || action.getCluster().isSetName())) { END 
            return getClusterId(action);
        }

        // means use the cluster of the provided host
        return null;
    }
","    private Guid getTargetClusterId(Action action) {
        if (action.isSetCluster()) {
            return getClusterId(action);
        }

        // means use the cluster of the provided host
        return null;
    }
"
1105,do you have any trouble with array initializers?,"   public Object[] factory() {
      List testsToRun = new ArrayList<>();
      testsToRun.add(new DistributedMultimapCacheTest().fromOwner(false).cacheMode(CacheMode.DIST_SYNC).transactional(false));
      testsToRun.add(new DistributedMultimapCacheTest().fromOwner(true).cacheMode(CacheMode.DIST_SYNC).transactional(false));
      return testsToRun.toArray();
   }
","   public Object[] factory() {
START       List testsToRun = new ArrayList<>(); END 
      testsToRun.add(new DistributedMultimapCacheTest().fromOwner(false).cacheMode(CacheMode.DIST_SYNC).transactional(false));
      testsToRun.add(new DistributedMultimapCacheTest().fromOwner(true).cacheMode(CacheMode.DIST_SYNC).transactional(false));
      return testsToRun.toArray();
   }
","   public Object[] factory() {
      return new Object[]{
            new DistributedMultimapCacheTest().fromOwner(false).cacheMode(CacheMode.DIST_SYNC).transactional(false),
            new DistributedMultimapCacheTest().fromOwner(true).cacheMode(CacheMode.DIST_SYNC).transactional(false),
      };
   }
"
1106,"unnecessary assignment, actually it can be moved into if","  private boolean isNimbus(Subject who) {
    Set<Principal> principals = null;
    boolean isNimbusInstance = false;
    if (who != null) {
      principals = who.getPrincipals();
      for (Principal principal : principals) {
        if (principal instanceof NimbusPrincipal) {
          isNimbusInstance = true;
        }
      }
    }
    return isNimbusInstance;
  }
","  private boolean isNimbus(Subject who) {
START     Set<Principal> principals = null; END 
    boolean isNimbusInstance = false;
    if (who != null) {
      principals = who.getPrincipals();
      for (Principal principal : principals) {
        if (principal instanceof NimbusPrincipal) {
          isNimbusInstance = true;
        }
      }
    }
    return isNimbusInstance;
  }
","    private boolean isNimbus(Subject who) {
        Set<Principal> principals;
        boolean isNimbusInstance = false;
        if (who != null) {
            principals = who.getPrincipals();
            for (Principal principal : principals) {
                if (principal instanceof NimbusPrincipal) {
                    isNimbusInstance = true;
                }
            }
        }
        return isNimbusInstance;
    }
"
1107,Return just here.,"    ILogData read(long address) {
        if (!runtime.getParameters().isCacheDisabled()) {
            // The VersionLockedObject and the Transaction layer will generate
            // undoRecord(s) during a transaction commit, or object sync. These
            // undo records are stored in transient fields and are not persisted.
            // A missing undo record can cause a NoRollbackException, thus forcing
            // a complete object rebuild that generates a ""scanning"" behavior
            // which affects the LRU window. In essence, affecting other cache users
            // and making the VersionLockedObject very sensitive to caching behavior.
            // A concrete example of this would be unsynchronized readers/writes:
            // 1. Thread A starts replicating write1
            // 2. Thread B discovers the write (via stream tail query) and
            //    tries to read write1
            // 3. Thread B's read results in a cache miss and the reader thread
            //    starts loading the value into the cache
            // 4. Thread A completes its write and caches it with undo records
            // 5. Thread B finishes loading and caches the loaded value replacing
            //    the cached value from step 4 (i.e. loss of undo records computed
            //    by thread A)
            ILogData data = readCache.getIfPresent(address);
            if (data == null) {
                final ILogData loadedVal = fetch(address);
                data = readCache.asMap().computeIfAbsent(address, (k) -> loadedVal);
            }

            return data;
        }

        return fetch(address);
    }
","    ILogData read(long address) {
        if (!runtime.getParameters().isCacheDisabled()) {
            // The VersionLockedObject and the Transaction layer will generate
            // undoRecord(s) during a transaction commit, or object sync. These
            // undo records are stored in transient fields and are not persisted.
            // A missing undo record can cause a NoRollbackException, thus forcing
            // a complete object rebuild that generates a ""scanning"" behavior
            // which affects the LRU window. In essence, affecting other cache users
            // and making the VersionLockedObject very sensitive to caching behavior.
            // A concrete example of this would be unsynchronized readers/writes:
            // 1. Thread A starts replicating write1
            // 2. Thread B discovers the write (via stream tail query) and
            //    tries to read write1
            // 3. Thread B's read results in a cache miss and the reader thread
            //    starts loading the value into the cache
            // 4. Thread A completes its write and caches it with undo records
            // 5. Thread B finishes loading and caches the loaded value replacing
            //    the cached value from step 4 (i.e. loss of undo records computed
            //    by thread A)
            ILogData data = readCache.getIfPresent(address);
            if (data == null) {
                final ILogData loadedVal = fetch(address);
START                 data = readCache.asMap().computeIfAbsent(address, (k) -> loadedVal); END 
            }

            return data;
        }

        return fetch(address);
    }
","    ILogData read(long address) {
        if (!runtime.getParameters().isCacheDisabled()) {
            // The VersionLockedObject and the Transaction layer will generate
            // undoRecord(s) during a transaction commit, or object sync. These
            // undo records are stored in transient fields and are not persisted.
            // A missing undo record can cause a NoRollbackException, thus forcing
            // a complete object rebuild that generates a ""scanning"" behavior
            // which affects the LRU window. In essence, affecting other cache users
            // and making the VersionLockedObject very sensitive to caching behavior.
            // A concrete example of this would be unsynchronized readers/writes:
            // 1. Thread A starts replicating write1
            // 2. Thread B discovers the write (via stream tail query) and
            //    tries to read write1
            // 3. Thread B's read results in a cache miss and the reader thread
            //    starts loading the value into the cache
            // 4. Thread A completes its write and caches it with undo records
            // 5. Thread B finishes loading and caches the loaded value replacing
            //    the cached value from step 4 (i.e. loss of undo records computed
            //    by thread A)
            ILogData data = readCache.getIfPresent(address);
            if (data == null) {
                // Loading a value without the cache loader can result in
                // redundant loading calls (i.e. multiple threads try to
                // load the same value), but currently a redundant RPC
                // is much cheaper than the cost of a NoRollBackException, therefore
                // this trade-off is reasonable
                final ILogData loadedVal = fetch(address);
                return readCache.asMap().computeIfAbsent(address, (k) -> loadedVal);
            }

            return data;
        }

        return fetch(address);
    }
"
1108,Why not just `queryRunner.close();`?,"    public void tearDown()
    {
        closeAllRuntimeException(queryRunner);
        queryRunner = null;
    }
","    public void tearDown()
    {
START         closeAllRuntimeException(queryRunner); END 
        queryRunner = null;
    }
","    public void tearDown()
    {
        queryRunner.close();
    }
"
1109,"since this method is called after the validate method, you can make the check shorter as you did in the executeCommand method","    public AuditLogType getAuditLogTypeValue() {
        UserProfile existingProfile = getUserProfile();
        if (existingProfile != null && isSSHPublicKeyUpdate(existingProfile)) {
            return getSucceeded() ? AuditLogType.USER_UPDATE_PROFILE : AuditLogType.USER_UPDATE_PROFILE_FAILED;
        } else {
            return getSucceeded() ? AuditLogType.USER_ADD_PROFILE : AuditLogType.USER_ADD_PROFILE_FAILED;
        }
    }
","    public AuditLogType getAuditLogTypeValue() {
        UserProfile existingProfile = getUserProfile();
START         if (existingProfile != null && isSSHPublicKeyUpdate(existingProfile)) { END 
            return getSucceeded() ? AuditLogType.USER_UPDATE_PROFILE : AuditLogType.USER_UPDATE_PROFILE_FAILED;
        } else {
            return getSucceeded() ? AuditLogType.USER_ADD_PROFILE : AuditLogType.USER_ADD_PROFILE_FAILED;
        }
    }
","    public AuditLogType getAuditLogTypeValue() {
        UserProfile existingProfile = getUserProfile();
        if (existingProfile != null) { /* same as executeCommand below */
            return getSucceeded() ? AuditLogType.USER_UPDATE_PROFILE : AuditLogType.USER_UPDATE_PROFILE_FAILED;
        } else {
            return getSucceeded() ? AuditLogType.USER_ADD_PROFILE : AuditLogType.USER_ADD_PROFILE_FAILED;
        }
    }
"
1110,Aren't there any test methods that require compatibility?,"   public ConfigurationBuilder getDefaultCacheBuilder() {
      ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();
      configurationBuilder.memory().storageType(StorageType.OFF_HEAP);
      // Off heap and compatibility don't work together
      configurationBuilder.compatibility().disable();
      return configurationBuilder;
   }
","   public ConfigurationBuilder getDefaultCacheBuilder() {
      ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();
      configurationBuilder.memory().storageType(StorageType.OFF_HEAP);
      // Off heap and compatibility don't work together
START       configurationBuilder.compatibility().disable(); END 
      return configurationBuilder;
   }
","   public ConfigurationBuilder getDefaultCacheBuilder() {
      ConfigurationBuilder configurationBuilder = new ConfigurationBuilder();
      configurationBuilder.memory().storageType(StorageType.OFF_HEAP);
      return configurationBuilder;
   }
"
1111,UTF8?,"    public boolean counter(String key, int magnitude) {
        String stat = String.format(Locale.ENGLISH, ""%s:%d|c"", key, magnitude);
        return maybeAppend(stat);
    }
","    public boolean counter(String key, int magnitude) {
START         String stat = String.format(Locale.ENGLISH, ""%s:%d|c"", key, magnitude); END 
        return maybeAppend(stat);
    }
","    public boolean counter(String key, int magnitude) {
        String stat = String.format(""%s:%d|c"", key, magnitude);
        return maybeAppend(stat);
    }
"
1112,"Maybe a static helper function `isStaticFunctionNamespace(functionHandle)`; also, why not `functionHandle instanceof StaticFunctionHandle`?","    public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)
    {
        checkArgument(functionHandle.getCatalogSchemaName().equals(STATIC_FUNCTION_NAMESPACE_CATALOG_SCHEMA_NAME), ""Expect static function namespace"");
        return staticFunctionNamespace.getFunctionMetadata((StaticFunctionHandle) functionHandle);
    }
","    public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)
    {
START         checkArgument(functionHandle.getCatalogSchemaName().equals(STATIC_FUNCTION_NAMESPACE_CATALOG_SCHEMA_NAME), ""Expect static function namespace""); END 
        return staticFunctionNamespace.getFunctionMetadata((StaticFunctionHandle) functionHandle);
    }
","    public FunctionMetadata getFunctionMetadata(FunctionHandle functionHandle)
    {
        return staticFunctionNamespace.getFunctionMetadata(functionHandle);
    }
"
1113,"I don't think we should escape on this level, we should explicitly escape title of a video when passing to a method, not in here. Let's move it to `verifyVideoAdded(String videoTitle)` in `SpecialVideosPageObject`","  public void waitForValueToBePresentInElementsAttributeByCss(String selector, String attribute,
                                                              String value) {
    changeImplicitWait(250, TimeUnit.MILLISECONDS);
    try {
      waitFor.until(CommonExpectedConditions.valueToBePresentInElementsAttribute(
          By.cssSelector(selector), attribute, escapeHtml(value)));
    } finally {
      restoreDeaultImplicitWait();
    }
  }
","  public void waitForValueToBePresentInElementsAttributeByCss(String selector, String attribute,
                                                              String value) {
    changeImplicitWait(250, TimeUnit.MILLISECONDS);
    try {
      waitFor.until(CommonExpectedConditions.valueToBePresentInElementsAttribute(
START           By.cssSelector(selector), attribute, escapeHtml(value))); END 
    } finally {
      restoreDeaultImplicitWait();
    }
  }
","  public void waitForValueToBePresentInElementsAttributeByCss(String selector, String attribute,
                                                              String value) {
    changeImplicitWait(250, TimeUnit.MILLISECONDS);
    try {
      waitFor.until(CommonExpectedConditions.valueToBePresentInElementsAttribute(
          By.cssSelector(selector), attribute, value));
    } finally {
      restoreDeaultImplicitWait();
    }
  }
"
1114,А вообще надо два append() делать,"	public String parse() {
		StringBuilder myCommandBuilder = new StringBuilder("""");
		for (String argument:mArgs) {
			myCommandBuilder.append(argument+"" "");
		}
		return myCommandBuilder.toString();
	}
","	public String parse() {
		StringBuilder myCommandBuilder = new StringBuilder("""");
		for (String argument:mArgs) {
START 			myCommandBuilder.append(argument+"" ""); END 
		}
		return myCommandBuilder.toString();
	}
","	public String parse() {
		StringBuilder myCommandBuilder = new StringBuilder("""");
		for (String argument : mArgs) {
			myCommandBuilder.append(argument);
			myCommandBuilder.append("" "");
		}
		return myCommandBuilder.toString();
	}
"
1115,Can we use a try-with-resource pattern here?,"  public void testUseMetaAfterCreate() throws IOException {
    DataFileWriter<?> w = new DataFileWriter<>(new GenericDatumWriter<>());
    w.create(Schema.create(Type.NULL), new ByteArrayOutputStream());
    w.setMeta(""foo"", ""bar"");
    w.close();
  }
","  public void testUseMetaAfterCreate() throws IOException {
    DataFileWriter<?> w = new DataFileWriter<>(new GenericDatumWriter<>());
    w.create(Schema.create(Type.NULL), new ByteArrayOutputStream());
    w.setMeta(""foo"", ""bar"");
START     w.close(); END 
  }
","  public void testUseMetaAfterCreate() throws IOException {
    try (DataFileWriter<?> w = new DataFileWriter<>(new GenericDatumWriter<>())) {
      w.create(Schema.create(Type.NULL), new ByteArrayOutputStream());
      w.setMeta(""foo"", ""bar"");
    }

  }
"
1116,Is the fluent required here? could we just a have a basic setter instead?,"    public LabelMetadataBuilder setOrigin(String origin)
    {
        this.origin = origin;
        return this;
    }
","    public LabelMetadataBuilder setOrigin(String origin)
    {
        this.origin = origin;
START         return this; END 
    }
","    public void setOrigin(String origin)
    {
        this.origin = origin;
    }
"
1117,"This method is a simple converter that is only dependent on frequency and not dependent on clock offset.

It should return cycles * clock.getScale(), or cycles if clock is null.","    public long cyclesToNanos(long cycles) {
        // CTFTrace adds the clock offset in cycles to the input
        CTFTrace trace = fTrace;
        if (trace != null) {
            CTFClock clock = trace.getClock();
            return trace.timestampCyclesToNanos(cycles - trace.getOffset()) + clock.getClockOffsetNs();
        }
        return 0;
    }
","START     public long cyclesToNanos(long cycles) { END 
        // CTFTrace adds the clock offset in cycles to the input
        CTFTrace trace = fTrace;
        if (trace != null) {
            CTFClock clock = trace.getClock();
            return trace.timestampCyclesToNanos(cycles - trace.getOffset()) + clock.getClockOffsetNs();
        }
        return 0;
    }
","    public long cyclesToNanos(long cycles) {
        // CTFTrace adds the clock offset in cycles to the input
        CTFTrace trace = fTrace;
        if (trace != null) {
            return trace.timestampCyclesToNanos(cycles - trace.getOffset());
        }
        return 0;
    }
"
1118,"dont do this but let the exception be propagated  back up so we can have a better error reporting about not possible to generate jacoco report due to ....

Also these methods can be static methods","    private Document createDocument() {
    	Document document = null;
    	try {	
    	    DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();        
    	    DocumentBuilder documentBuilder = documentFactory.newDocumentBuilder();
    	    document = documentBuilder.newDocument();
        
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
        } 
    	
    	return document;
        
    }
","    private Document createDocument() {
    	Document document = null;
    	try {	
    	    DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();        
    	    DocumentBuilder documentBuilder = documentFactory.newDocumentBuilder();
    	    document = documentBuilder.newDocument();
        
        } catch (ParserConfigurationException pce) {
START             pce.printStackTrace(); END 
        } 
    	
    	return document;
        
    }
","    private static Document createDocument() throws ParserConfigurationException {
    	Document document = null;
    	DocumentBuilderFactory documentFactory = DocumentBuilderFactory.newInstance();        
    	DocumentBuilder documentBuilder = documentFactory.newDocumentBuilder();
    	document = documentBuilder.newDocument();
    	
    	return document; 
    }
"
1119,"You can directly invoke

  Job job = locationMap.remove(buffer.getLocation());
  if (job != null) {
    job.cancel();
  }","	public ConnectDocumentToLanguageServerSetupParticipant() {

		ITextFileBufferManager.DEFAULT.addFileBufferListener(new FileBufferListenerAdapter() {
			@Override
			public void bufferDisposed(IFileBuffer buffer) {
				Job job = locationMap.get(buffer.getLocation());
				if (job != null) {
					job.cancel();
				}
				locationMap.remove(buffer.getLocation());
			}
		});
	}
","	public ConnectDocumentToLanguageServerSetupParticipant() {

		ITextFileBufferManager.DEFAULT.addFileBufferListener(new FileBufferListenerAdapter() {
			@Override
			public void bufferDisposed(IFileBuffer buffer) {
START 				Job job = locationMap.get(buffer.getLocation()); END 
				if (job != null) {
					job.cancel();
				}
				locationMap.remove(buffer.getLocation());
			}
		});
	}
","	public ConnectDocumentToLanguageServerSetupParticipant() {

		ITextFileBufferManager.DEFAULT.addFileBufferListener(new FileBufferListenerAdapter() {
			@Override
			public void bufferDisposed(IFileBuffer buffer) {
				Job job = locationMap.remove(buffer.getLocation());
				if (job != null) {
					job.cancel();
				}
			}
		});
	}
"
1120,Can it be `protected`?,"    public void createAndSetPhoneHome() {
        this.phoneHome = new PhoneHome(node);
    }
","START     public void createAndSetPhoneHome() { END 
        this.phoneHome = new PhoneHome(node);
    }
","    protected void createAndSetPhoneHome() {
        this.phoneHome = new PhoneHome(node);
    }
"
1121,"Can simplify by avoiding the temporary:

  corruptObjects.add(new CorruptObject(...));","	protected void verifySafeObject(final AnyObjectId id, final int type,
			final byte[] data) {
		try {
			super.verifySafeObject(id, type, data);
		} catch (CorruptObjectException e) {
			// catch the exception and continue parse the pack file
			CorruptObject o = new CorruptObject(id.toObjectId(), type,
					e.getErrorType());
			corruptObjects.add(o);
		}
	}
","	protected void verifySafeObject(final AnyObjectId id, final int type,
			final byte[] data) {
		try {
			super.verifySafeObject(id, type, data);
		} catch (CorruptObjectException e) {
			// catch the exception and continue parse the pack file
START 			CorruptObject o = new CorruptObject(id.toObjectId(), type, END 
					e.getErrorType());
			corruptObjects.add(o);
		}
	}
","	protected void verifySafeObject(final AnyObjectId id, final int type,
			final byte[] data) {
		try {
			super.verifySafeObject(id, type, data);
		} catch (CorruptObjectException e) {
			corruptObjects.add(
					new CorruptObject(id.toObjectId(), type, e.getErrorType()));
		}
	}
"
1122,"Nit-pick: to have more consistent constructor behavior, I'd prefer to do

 this(false)","    public KeyValuePairValidation() {
        this.allowAlsoKey = false;
    }
","    public KeyValuePairValidation() {
START         this.allowAlsoKey = false; END 
    }
","    public KeyValuePairValidation() {
        this(false);
    }
"
1123,nl and return directly,"    public String getNameTokenWithClass() {
        if (nameTokenPsiClass == null) {
            return """";
        }
        String s = nameTokenPsiClass.getName().replace("".java"", """") + ""."" + nameToken;
        return s;
    }
","    public String getNameTokenWithClass() {
        if (nameTokenPsiClass == null) {
            return """";
        }
START         String s = nameTokenPsiClass.getName().replace("".java"", """") + ""."" + nameToken; END 
        return s;
    }
","    public String getNameTokenWithClass() {
        if (nameTokenPsiClass == null) {
            return """";
        }

        return nameTokenPsiClass.getName().replace("".java"", """") + ""."" + nameToken;
    }
"
1124,"the sole appropriate grantType must be an `stormpath_token` therefore please assert that the parameter is always `stormpath_token`. Additionally it should not be `public` (`protected` at the minimum), it should be just invoked internally when this class is created.","    public void setGrantType(String grantType) {
        setProperty(GRANT_TYPE, grantType);
    }
","    public void setGrantType(String grantType) {
START         setProperty(GRANT_TYPE, grantType); END 
    }
","    protected void setGrantType(String grantType) {
        setProperty(GRANT_TYPE, grantType);
    }
"
1125,other name (for example item) instead of extension?,"    private static <T> void printIndented(Iterable<T> strings) {
        for (T extension : strings) {
            System.out.println(""   "" + extension);
        }
    }
","    private static <T> void printIndented(Iterable<T> strings) {
START         for (T extension : strings) { END 
            System.out.println(""   "" + extension);
        }
    }
","    private static <T> void printIndented(Iterable<T> strings) {
        for (T item : strings) {
            System.out.println(""   "" + item);
        }
    }
"
1126,"Can be simplified to

```java
return itemMaterial == null ? 0 : itemMaterial.getMaxDamage();
```","    public int getMaxDamage() {
        if (itemMaterial == null) {
            return 0;
        } else {
            return itemMaterial.getMaxDamage();
        }
    }
","    public int getMaxDamage() {
        if (itemMaterial == null) {
            return 0;
        } else {
            return itemMaterial.getMaxDamage();
START         } END 
    }
","    public int getMaxDamage() {
        return itemMaterial.getMaxDamage();
    }
"
1127,"Return empty list (ImmutableList.of()), not null, if log == null","  public Response handle() throws Exception {
    ServerSideSession session = getDriver().getSession(getRequest().getSession());
    JSONObject payload = getRequest().getPayload();
    String type = payload.getString(""type"");	
    WebDriverLog log = (WebDriverLog) session.getLogManager().getLog(type);
    List<LogEntry> entries = (log == null ? null : log.getAndClearEntries());
    return createResponse(entries);
  }
","  public Response handle() throws Exception {
    ServerSideSession session = getDriver().getSession(getRequest().getSession());
    JSONObject payload = getRequest().getPayload();
    String type = payload.getString(""type"");	
    WebDriverLog log = (WebDriverLog) session.getLogManager().getLog(type);
START     List<LogEntry> entries = (log == null ? null : log.getAndClearEntries()); END 
    return createResponse(entries);
  }
","  public Response handle() throws Exception {
    ServerSideSession session = getDriver().getSession(getRequest().getSession());
    JSONObject payload = getRequest().getPayload();
    String type = payload.getString(""type"");	
    List<LogEntry> entries = session.getLogManager().getLog(type);
    return createResponse(entries);
  }
"
1128,"Could these params just be null, null, null?","    public Cursor selectAll() {
        return select("""", new String[] {}, null);
    }
","    public Cursor selectAll() {
START         return select("""", new String[] {}, null); END 
    }
","    public Cursor selectAll() {
        return select(null, null, null);
    }
"
1129,Well I think at least here we do not need all this try/catch stuff )),"  public int getId() {
    try {
      return id;
    } catch (RuntimeException e) {
      throw logAndPrepareForRethrow(e);
    } catch (Error e) {
      throw logAndPrepareForRethrow(e);
    } catch (Throwable t) {
      throw logAndPrepareForRethrow(t);
    }
  }
","  public int getId() {
    try {
      return id;
    } catch (RuntimeException e) {
      throw logAndPrepareForRethrow(e);
    } catch (Error e) {
      throw logAndPrepareForRethrow(e);
    } catch (Throwable t) {
      throw logAndPrepareForRethrow(t);
START     } END 
  }
","  public int getId() {
    return id;
  }
"
1130,Why should this be catched? Shouldn't this make it to the caller that then can react accordingly?,"		public ADBInfo(HashMap<String,String> env) {
			this.env = env;
			try {
				String dockerHost = env.get(""DOCKER_HOST"");
				URI url = new URI(dockerHost);
				String h = url.getHost();
				openshiftHost = ""https://"" + h;
			} catch(URISyntaxException murle) {
				murle.printStackTrace();
			}
		}
","		public ADBInfo(HashMap<String,String> env) {
			this.env = env;
			try {
				String dockerHost = env.get(""DOCKER_HOST"");
				URI url = new URI(dockerHost);
				String h = url.getHost();
				openshiftHost = ""https://"" + h;
START 			} catch(URISyntaxException murle) { END 
				murle.printStackTrace();
			}
		}
","		public ADBInfo(HashMap<String,String> env) throws URISyntaxException {
			this.env = env;
			String dockerHost = env.get(""DOCKER_HOST"");
			URI url = new URI(dockerHost);
			String h = url.getHost();
			openshiftHost = ""https://"" + h;
		}
"
1131,This test should be adjusted since you removed the strlen change.,"  public void testStrlen()
  {
    assertExpr(""strlen(x)"", 3L);
    assertExpr(""strlen(nonexistent)"", NullHandling.defaultLongValue());
    assertExprFail(""strlen(a)"", AssertionError.class, null);
  }
","  public void testStrlen()
  {
    assertExpr(""strlen(x)"", 3L);
    assertExpr(""strlen(nonexistent)"", NullHandling.defaultLongValue());
START     assertExprFail(""strlen(a)"", AssertionError.class, null); END 
  }
","  public void testStrlen()
  {
    assertExpr(""strlen(x)"", 3L);
    assertExpr(""strlen(nonexistent)"", NullHandling.defaultLongValue());
  }
"
1132,deleteFile(file),"   public boolean deleteFile(File file, boolean recursive)
   {
      if (recursive)
      {
         return this.deleteRecursive(file);
      }
      return file.delete();
   }
","   public boolean deleteFile(File file, boolean recursive)
   {
      if (recursive)
      {
         return this.deleteRecursive(file);
      }
START       return file.delete(); END 
   }
","   public boolean deleteFile(File file, boolean recursive)
   {
      if (recursive)
      {
         return this.deleteRecursive(file);
      }
      return this.deleteFile(file);
   }
"
1133,"> program to an interface, not to an implementation.

Please use `List` instead of `ArrayList` everywhere. I'm just mentioning it here once.","	public ArrayList<Brick> getBricksRequiringResources(int resource) {
		ArrayList<Brick> resourceBrickList = new ArrayList<Brick>();

		for (Brick brick : brickList) {
			if ((brick.getRequiredResources() & resource) > 0) {
				resourceBrickList.add(brick);
			}
		}
		return resourceBrickList;
	}
","	public ArrayList<Brick> getBricksRequiringResources(int resource) {
START 		ArrayList<Brick> resourceBrickList = new ArrayList<Brick>(); END 

		for (Brick brick : brickList) {
			if ((brick.getRequiredResources() & resource) > 0) {
				resourceBrickList.add(brick);
			}
		}
		return resourceBrickList;
	}
","	public List<Brick> getBricksRequiringResources(int resource) {
		List<Brick> resourceBrickList = new ArrayList<Brick>();

		for (Brick brick : brickList) {
			if ((brick.getRequiredResources() & resource) != 0) {
				resourceBrickList.add(brick);
			}
		}
		return resourceBrickList;
	}
"
1134,Should this line be moved up into the above block where the `ServerManager` instance is being created? And maybe just code it like `instance.wsStatus = wsStatus` and get rid of the `setWorkspaceStatus` method. I am assuming the status would only need to be set whenever the server variable is `null`. Is that true?,"    public static ServerManager getInstance( final WorkspaceStatus wsStatus ) {
        if (instance == null) {
            instance = new ServerManager();
        }
        instance.setWorkspaceStatus(wsStatus);
        return instance;
    }
","    public static ServerManager getInstance( final WorkspaceStatus wsStatus ) {
        if (instance == null) {
            instance = new ServerManager();
        }
START         instance.setWorkspaceStatus(wsStatus); END 
        return instance;
    }
","    public static ServerManager getInstance( final WorkspaceStatus wsStatus ) {
        if (instance == null) {
            instance = new ServerManager();
            instance.wsStatus = wsStatus;
        }
        return instance;
    }
"
1135,"Meiner Meinung nach ist die Überprüfung überflüssig. ```userAgent``` darf null sein und es mag auch Fälle geben, wo ein Request *ohne* userAgent gemacht werden soll. Die Abfrage ```addUserAgent(null)``` ist m.E. ein gültiger Verwendung.","    public WebAccess addUserAgent(String userAgent)
    {
        if (Objects.nonNull(userAgent))
            this.userAgent = userAgent;
        return this;
    }
","    public WebAccess addUserAgent(String userAgent)
    {
START         if (Objects.nonNull(userAgent)) END 
            this.userAgent = userAgent;
        return this;
    }
","    public WebAccess addUserAgent(String userAgent)
    {
        this.userAgent = userAgent;
        return this;
    }
"
1136,Make final.,"	public void setPromiscuousBinding(IBinding binding) {
		promiscuousBinding = binding;
	}
","START 	public void END  setPromiscuousBinding(IBinding binding) {
		promiscuousBinding = binding;
	}
","	public final void setPromiscuousBinding(IBinding binding) {
		promiscuousBinding = binding;
	}
"
1137,the null check is necessary because clear is called by the super class in the constructor.,"    public synchronized void clear() {
        fZoom.setFullRange(0L, 0L);
        fZoom.setNewRange(0L, 0L);
        fZoom.stop();
        super.clear();
    }
","START     public synchronized void clear() { END 
        fZoom.setFullRange(0L, 0L);
        fZoom.setNewRange(0L, 0L);
        fZoom.stop();
        super.clear();
    }
","    public synchronized void clear() {
        if (fZoom != null) {
            fZoom.setFullRange(0L, 0L);
            fZoom.setNewRange(0L, 0L);
            fZoom.stop();
        }
        super.clear();
    }
"
1138,what's the point of doing this?,"  public List<Object> getSortedObjects() {
    Set<Object> sorted = newSetFromMap(new LinkedHashMap<>(objectCount));
    for (List<Object> bucket : buckets) {
      if (bucket != null) {
        sorted.addAll(bucket);
      }
    }

    return new ArrayList<>(sorted);
  }
","  public List<Object> getSortedObjects() {
START     Set<Object> sorted = newSetFromMap(new LinkedHashMap<>(objectCount)); END 
    for (List<Object> bucket : buckets) {
      if (bucket != null) {
        sorted.addAll(bucket);
      }
    }

    return new ArrayList<>(sorted);
  }
","  public List<Object> getSortedObjects() {
    List<Object> sorted = new ArrayList<>(objectCount);
    for (List<Object> bucket : buckets) {
      if (bucket != null) {
        sorted.addAll(bucket);
      }
    }

    return sorted;
  }
"
1139,Please use !string.isEmpty().,"	public void setOS(String os) {
		incrementSequenceNumber();
		fOS = os;
		if (fRoot != null && os != null && os.length() > 0) {
			Element nlNode = TargetDefinitionDocumentTools.getChildElement(fRoot,
					TargetDefinitionPersistenceHelper.ENVIRONMENT,
					TargetDefinitionPersistenceHelper.OS);
			nlNode.setTextContent(os);
		} else {
			removeElement(TargetDefinitionPersistenceHelper.ENVIRONMENT, TargetDefinitionPersistenceHelper.OS);
		}
	}
","	public void setOS(String os) {
		incrementSequenceNumber();
		fOS = os;
		if (fRoot != null && os != null && START  os.length() > 0) { END 
			Element nlNode = TargetDefinitionDocumentTools.getChildElement(fRoot,
					TargetDefinitionPersistenceHelper.ENVIRONMENT,
					TargetDefinitionPersistenceHelper.OS);
			nlNode.setTextContent(os);
		} else {
			removeElement(TargetDefinitionPersistenceHelper.ENVIRONMENT, TargetDefinitionPersistenceHelper.OS);
		}
	}
","	public void setOS(String os) {
		incrementSequenceNumber();
		fOS = os;
		if (fRoot != null && os != null && !os.isEmpty()) {
			Element nlNode = TargetDefinitionDocumentTools.getChildElement(fRoot,
					TargetDefinitionPersistenceHelper.ENVIRONMENT,
					TargetDefinitionPersistenceHelper.OS);
			nlNode.setTextContent(os);
		} else {
			removeElement(TargetDefinitionPersistenceHelper.ENVIRONMENT, TargetDefinitionPersistenceHelper.OS);
		}
	}
"
1140,"Stray doublenewline ^
Also the newlines on the individual parts

I'm confused why this isn't formatted exactly the same as the EntityDamaged event, which I think is what you were referencing anyway?
```java
        return new BukkitScriptEntryData(damager != null && damager.isPlayer() ? damager.getDenizenPlayer() : entity.isPlayer() ? entity.getDenizenPlayer() : null,
                damager != null && damager.isCitizensNPC() ? damager.getDenizenNPC() : entity.isCitizensNPC() ? entity.getDenizenNPC() : null);
```","    public ScriptEntryData getScriptEntryData() {
        return new BukkitScriptEntryData(
                hitBy.isPlayer() ? hitBy.getDenizenPlayer() :
                        (entity.isPlayer() ? entity.getDenizenPlayer() : null),

                hitBy.isCitizensNPC() ? hitBy.getDenizenNPC() :
                        (entity.isCitizensNPC() ? entity.getDenizenNPC() : null)
        );
    }
","    public ScriptEntryData getScriptEntryData() {
        return new BukkitScriptEntryData(
                hitBy.isPlayer() ? hitBy.getDenizenPlayer() :
                        (entity.isPlayer() ? entity.getDenizenPlayer() : null),
START  END 
                hitBy.isCitizensNPC() ? hitBy.getDenizenNPC() :
                        (entity.isCitizensNPC() ? entity.getDenizenNPC() : null)
        );
    }
","    public ScriptEntryData getScriptEntryData() {
        return new BukkitScriptEntryData(
                hitBy.isPlayer() ? hitBy.getDenizenPlayer() : entity.isPlayer() ? entity.getDenizenPlayer() : null,
                hitBy.isCitizensNPC() ? hitBy.getDenizenNPC() : entity.isCitizensNPC() ? entity.getDenizenNPC() : null);
    }
"
1141,"This doesn't really matter because Val- and Var-Declaration pass ""false"" for inTailPosition, but it might be better conceptually to also pass ""false"" here.","    public Void visit(Boolean inTailPosition, New newExpr) {
        for (Declaration decl : newExpr.getDecls()) {
            decl.acceptVisitor(this, inTailPosition);
        }
        return null;
    }
","    public Void visit(Boolean inTailPosition, New newExpr) {
        for (Declaration decl : newExpr.getDecls()) {
START             decl.acceptVisitor(this, inTailPosition); END 
        }
        return null;
    }
","    public Void visit(Boolean inTailPosition, New newExpr) {
        for (Declaration decl : newExpr.getDecls()) {
            decl.acceptVisitor(this, false);
        }
        return null;
    }
"
1142,What's the expected benefit for this change? This method is typically called at most once per VM--let's prioritize simplicity for low-traffic methods like this.,"    public ReflectionMappers setColumnNameMatchers(List<ColumnNameMatcher> columnNameMatchers) {
        synchronized (lock) {
            this.columnNameMatchers.clear();
            this.columnNameMatchers.addAll(columnNameMatchers);
        }
        return this;
    }
","    public ReflectionMappers setColumnNameMatchers(List<ColumnNameMatcher> columnNameMatchers) {
        synchronized (lock) {
            this.columnNameMatchers.clear();
            this.columnNameMatchers.addAll(columnNameMatchers);
START         } END 
        return this;
    }
","    public ReflectionMappers setColumnNameMatchers(List<ColumnNameMatcher> columnNameMatchers) {
        this.columnNameMatchers = new ArrayList<>(columnNameMatchers);
        return this;
    }
"
1143,nit: `projection` variable may be avoided.,"  private static MessageType getProjection(MessageType schema,
                                           Collection<SchemaPath> projectionColumns,
                                           List<SchemaPath> columnsNotFound) {
    projectionColumns = adaptColumnsToParquetSchema(projectionColumns, schema);
    List<SchemaPath> schemaColumns = getAllColumnsFrom(schema);
    Set<SchemaPath> selectedSchemaPaths = matchProjectionWithSchemaColumns(projectionColumns, schemaColumns, columnsNotFound);
    MessageType projection = convertSelectedColumnsToMessageType(schema, selectedSchemaPaths);
    return projection;
  }
","  private static MessageType getProjection(MessageType schema,
                                           Collection<SchemaPath> projectionColumns,
                                           List<SchemaPath> columnsNotFound) {
    projectionColumns = adaptColumnsToParquetSchema(projectionColumns, schema);
    List<SchemaPath> schemaColumns = getAllColumnsFrom(schema);
    Set<SchemaPath> selectedSchemaPaths = matchProjectionWithSchemaColumns(projectionColumns, schemaColumns, columnsNotFound);
    MessageType projection = convertSelectedColumnsToMessageType(schema, selectedSchemaPaths);
START     return projection; END 
  }
","  private static MessageType getProjection(MessageType schema,
                                           Collection<SchemaPath> projectionColumns,
                                           List<SchemaPath> columnsNotFound) {
    projectionColumns = adaptColumnsToParquetSchema(projectionColumns, schema);
    List<SchemaPath> schemaColumns = getAllColumnsFrom(schema);
    Set<SchemaPath> selectedSchemaPaths = matchProjectionWithSchemaColumns(projectionColumns, schemaColumns, columnsNotFound);
    return convertSelectedColumnsToMessageType(schema, selectedSchemaPaths);
  }
"
1144,Can you remove the return types for ingest methods since they aren't being used now?,"	private FileObject ingestFileObject(ContentObject parent, Resource parentResc, Resource childResc)
			throws DepositException, IOException {

		if (skipResumed(childResc)) {
			return null;
		}

		// TODO add ACLs
		WorkObject work = (WorkObject) parent;
		FileObject obj = addFileToWork(work, childResc);
		// Add ingestion event for file object
		addIngestionEventForChild(obj);
		addPremisEvents(obj);
		// add MODS
		addDescription(work);
		
		// Increment the count of objects deposited
		addClicks(1);

		log.info(""Created file object {} for deposit {}"", obj.getPid(), getDepositPID());
		
		return obj;
	}
","	private FileObject ingestFileObject(ContentObject parent, Resource parentResc, Resource childResc)
			throws DepositException, IOException {

		if (skipResumed(childResc)) {
START 			return null; END 
		}

		// TODO add ACLs
		WorkObject work = (WorkObject) parent;
		FileObject obj = addFileToWork(work, childResc);
		// Add ingestion event for file object
		addIngestionEventForChild(obj);
		addPremisEvents(obj);
		// add MODS
		addDescription(work);
		
		// Increment the count of objects deposited
		addClicks(1);

		log.info(""Created file object {} for deposit {}"", obj.getPid(), getDepositPID());
		
		return obj;
	}
","	private void ingestFileObject(ContentObject parent, Resource parentResc, Resource childResc)
			throws DepositException, IOException {

		if (skipResumed(childResc)) {
			return;
		}

		// TODO add ACLs
		WorkObject work = (WorkObject) parent;
		FileObject obj = addFileToWork(work, childResc);
		// Add ingestion event for file object
		addIngestionEventForChild(obj);
		addPremisEvents(obj);
		// add MODS
		addDescription(obj);
		
		// Increment the count of objects deposited
		addClicks(1);

		log.info(""Created file object {} for deposit {}"", obj.getPid(), getDepositPID());
	}
"
1145,"shouldn't this be `hash(super.hashCode, ntlmDomain)`... if you do it like this, any changes in the super class will break here.","  public int hashCode() {
    return hash(getHost(), getPort(), getPassword(), getUsername(), getNonProxyHosts(), ntlmDomain);
  }
","  public int hashCode() {
START     return hash(getHost(), getPort(), getPassword(), getUsername(), getNonProxyHosts(), ntlmDomain); END 
  }
","  public int hashCode() {
    return hash(super.hashCode(), ntlmDomain);
  }
"
1146,Would it be simpler to rewrite this block as just `if (subscriptionTryCount != 1)`?,"        public void subscribe(Subscriber<? super RecordsRetrieved> s) {
            subscriber = s;
            ++subscriptionTryCount;
            s.onSubscribe(new Subscription() {
                @Override
                public void request(long n) {
                    if (subscriptionTryCount == 1) {

                    } else {
                        send(n);
                    }
                }

                @Override
                public void cancel() {
                    requested = 0;
                }
            });
        }
","        public void subscribe(Subscriber<? super RecordsRetrieved> s) {
            subscriber = s;
            ++subscriptionTryCount;
            s.onSubscribe(new Subscription() {
                @Override
                public void request(long n) {
START                     if (subscriptionTryCount == 1) { END 

                    } else {
                        send(n);
                    }
                }

                @Override
                public void cancel() {
                    requested = 0;
                }
            });
        }
","        public void subscribe(Subscriber<? super RecordsRetrieved> s) {
            subscriber = s;
            ++subscriptionTryCount;
            s.onSubscribe(new Subscription() {
                @Override
                public void request(long n) {
                    if (subscriptionTryCount != 1) {
                        send(n);
                    }
                }

                @Override
                public void cancel() {
                    requested = 0;
                }
            });
        }
"
1147,please remove the 'java.util.',"    protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
        // check that there isn't another user already attached to this VM:
        boolean returnValue = !vmAssignedToUser(vmId, new java.util.ArrayList<String>());

        // Make sure the Vm is running stateless
        returnValue = returnValue && vmIsRunningStateless(vmId);

        return returnValue;
    }
","    protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
        // check that there isn't another user already attached to this VM:
START         boolean returnValue = !vmAssignedToUser(vmId, new java.util.ArrayList<String>()); END 

        // Make sure the Vm is running stateless
        returnValue = returnValue && vmIsRunningStateless(vmId);

        return returnValue;
    }
","    protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
        // check that there isn't another user already attached to this VM
        // and make sure the Vm is running stateless
        return !vmAssignedToUser(vmId, new ArrayList<String>()) && vmIsRunningStateless(vmId);
    }
"
1148,"The state of the reference is part of ""this"" object. The monitor of ""fListenerNotifierLock"" should be used to cover states in that object, not in ""this"".

You could remove the synchronized block here, and extract to a local variable below.","    public void setInput(Object inputElement) {
        fInputElement = inputElement;
        ITimeGraphEntry[] input = fTimeGraphContentProvider.getElements(inputElement);
        synchronized (fListenerNotifierLock) {
            fListenerNotifier = null;
        }
        if (fTimeGraphCtrl != null) {
            setTimeRange(input);
            setTopIndex(0);
            fSelectionBegin = SWT.DEFAULT;
            fSelectionEnd = SWT.DEFAULT;
            fSelectedEntry = null;
            refreshAllData(input);
        }
    }
","    public void setInput(Object inputElement) {
        fInputElement = inputElement;
        ITimeGraphEntry[] input = fTimeGraphContentProvider.getElements(inputElement);
        synchronized (fListenerNotifierLock) {
START             fListenerNotifier = null; END 
        }
        if (fTimeGraphCtrl != null) {
            setTimeRange(input);
            setTopIndex(0);
            fSelectionBegin = SWT.DEFAULT;
            fSelectionEnd = SWT.DEFAULT;
            fSelectedEntry = null;
            refreshAllData(input);
        }
    }
","    public void setInput(Object inputElement) {
        fInputElement = inputElement;
        ITimeGraphEntry[] input = fTimeGraphContentProvider.getElements(inputElement);
        fListenerNotifier = null;
        if (fTimeGraphCtrl != null) {
            setTimeRange(input);
            setTopIndex(0);
            fSelectionBegin = SWT.DEFAULT;
            fSelectionEnd = SWT.DEFAULT;
            fSelectedEntry = null;
            refreshAllData(input);
        }
    }
"
1149,You should remove console outputs for production,"    public void onAttachOrDetach(AttachEvent event) {
        if (event.isAttached()) {
            index = 0;
            displayCurrent();
            $(contents).on(TRANSITION_END, new Function() {
                @Override
                public void f() {
                    GQuery.console.log(""TRANSITION_END"");
                    activeAnimation = false;
                    $(""[data-remove]"", contents).remove();
                }
            });
        } else {
            $(contents).off(TRANSITION_END);
        }
    }
","    public void onAttachOrDetach(AttachEvent event) {
        if (event.isAttached()) {
            index = 0;
            displayCurrent();
            $(contents).on(TRANSITION_END, new Function() {
                @Override
                public void f() {
START                     GQuery.console.log(""TRANSITION_END""); END 
                    activeAnimation = false;
                    $(""[data-remove]"", contents).remove();
                }
            });
        } else {
            $(contents).off(TRANSITION_END);
        }
    }
","    public void onAttachOrDetach(AttachEvent event) {
        if (event.isAttached()) {
            index = 0;
            displayCurrent();
            $(contents).on(TRANSITION_END, new Function() {
                @Override
                public void f() {
                    activeAnimation = false;
                    $(""[data-remove]"", contents).remove();
                }
            });
        } else {
            $(contents).off(TRANSITION_END);
        }
    }
"
1150,can be info,"    public int prepare(Xid xid) throws XAException {
        if (LOG.isTraceEnabled()) {
            LOG.trace(""DummyXAResource.prepare(xid="" + xid + "")"");
        }

        return 0;
    }
","    public int prepare(Xid xid) throws XAException {
        if (LOG.isTraceEnabled()) {
START             LOG.trace(""DummyXAResource.prepare(xid="" + xid + "")""); END 
        }

        return 0;
    }
","    public int prepare(Xid xid) throws XAException {
        LOG.info(""DummyXAResource.prepare(xid="" + xid + "")"");

        return 0;
    }
"
1151,Why not using here the Constructor where you only pass the RuleBaseElement?,"    public void update(RuleBaseElementId name, String newCode) throws RuleBaseException {
        RuleBaseElement newBean = new RuleBaseElement(name, newCode);

        Map<String, String> metaData = newBean.toMetadata();
        RuleBaseConfiguration conf = new RuleBaseConfiguration(metaData, newBean);

        try {
            rulePersistence.persist(conf);
        } catch (PersistenceException e) {
            throw new RuleBaseException(e);
        }
        builder.reloadPackage(name.getPackageName());
    }
","    public void update(RuleBaseElementId name, String newCode) throws RuleBaseException {
        RuleBaseElement newBean = new RuleBaseElement(name, newCode);

        Map<String, String> metaData = newBean.toMetadata();
START         RuleBaseConfiguration conf = new RuleBaseConfiguration(metaData, newBean); END 

        try {
            rulePersistence.persist(conf);
        } catch (PersistenceException e) {
            throw new RuleBaseException(e);
        }
        builder.reloadPackage(name.getPackageName());
    }
","    public void update(RuleBaseElementId name, String newCode) throws RuleBaseException {
        RuleBaseElement newBean = new RuleBaseElement(name, newCode);
        RuleBaseConfiguration conf = new RuleBaseConfiguration(newBean);

        try {
            rulePersistence.persist(conf);
        } catch (PersistenceException e) {
            throw new RuleBaseException(e);
        }
        builder.reloadPackage(name.getPackageName());
    }
"
1152,superfluous `this`,"    @Override public Pair<SqlNode, RelDataType> validateAndGetType(SqlNode sqlNode)
            throws ValidationException {
        final SqlNode validatedNode = this.validate(sqlNode);
        final RelDataType type = m_validator.getValidatedNodeType(validatedNode);
        return Pair.of(validatedNode, type);
    }
","    @Override public Pair<SqlNode, RelDataType> validateAndGetType(SqlNode sqlNode)
            throws ValidationException {
START         final SqlNode validatedNode = this.validate(sqlNode); END 
        final RelDataType type = m_validator.getValidatedNodeType(validatedNode);
        return Pair.of(validatedNode, type);
    }
","    @Override public Pair<SqlNode, RelDataType> validateAndGetType(SqlNode sqlNode)
            throws ValidationException {
        final SqlNode validatedNode = validate(sqlNode);
        final RelDataType type = m_validator.getValidatedNodeType(validatedNode);
        return Pair.of(validatedNode, type);
    }
"
1153,"I think this should just return null, similar to the default MyFaces implementation of InjectionProvider.","    public Object inject(Object instance) throws InjectionProviderException {
        return instance;
    }
","    public Object inject(Object instance) throws InjectionProviderException {
START         return instance; END 
    }
","    public Object inject(Object instance) throws InjectionProviderException {
        return null;
    }
"
1154,please negate condition and move #121 into the 'then-clause',"    private void validateVnicMappings(Action action) {
        if (!(action.isSetVnicProfileMappings() && action.getVnicProfileMappings().isSetVnicProfileMappings())) {
            return;
        }
        action.getVnicProfileMappings().getVnicProfileMappings().forEach(this::validateVnicProfileMapping);
    }
","    private void validateVnicMappings(Action action) {
       START   if (!(action.isSetVnicProfileMappings() && action.getVnicProfileMappings().isSetVnicProfileMappings())) {
            return;
        }
        action.getVnicProfileMappings().getVnicProfileMappings().forEach(this::validateVnicProfileMapping); END 
    }
","    private void validateVnicMappings(Action action) {
        if (action.isSetVnicProfileMappings() && action.getVnicProfileMappings().isSetVnicProfileMappings()) {
            action.getVnicProfileMappings().getVnicProfileMappings().forEach(this::validateVnicProfileMapping);
        }
    }
"
1155,"you can try this from outside the try catch, before getting an instance to the packagemanager","    public Drawable getDrawable(Context context) {
        final PackageManager packageManager = context.getPackageManager();
        Resources resources;
        try {
            
            if (shortcutPojo.icon != null) {
                return new BitmapDrawable(shortcutPojo.icon);
            }
            
            resources = packageManager.getResourcesForApplication(shortcutPojo.packageName);
            final int id = resources.getIdentifier(shortcutPojo.resourceName, null, null);
            return resources.getDrawable(id);
        } catch (NameNotFoundException e) {

        }
        return null;
    }
","    public Drawable getDrawable(Context context) {
        final PackageManager packageManager = context.getPackageManager();
        Resources resources;
        try {
            
START             if (shortcutPojo.icon != null) { END 
                return new BitmapDrawable(shortcutPojo.icon);
            }
            
            resources = packageManager.getResourcesForApplication(shortcutPojo.packageName);
            final int id = resources.getIdentifier(shortcutPojo.resourceName, null, null);
            return resources.getDrawable(id);
        } catch (NameNotFoundException e) {

        }
        return null;
    }
","    public Drawable getDrawable(Context context) {
        final PackageManager packageManager = context.getPackageManager();
        Resources resources;
        
        if (shortcutPojo.icon != null) {
            return new BitmapDrawable(shortcutPojo.icon);
        }
        
        try {           
            resources = packageManager.getResourcesForApplication(shortcutPojo.packageName);
            final int id = resources.getIdentifier(shortcutPojo.resourceName, null, null);
            return resources.getDrawable(id);
        } catch (NameNotFoundException e) {

        }
        return null;
    }
"
1156,Dianne will tell you to remove this. This is logspam.,"        protected boolean handlePreloadPackage(String packagePath, String libsPath) {
            Log.d(TAG, ""Preload package ********************************************************"");
            Log.d(TAG, ""WebView package = "" + packagePath);
            return false;
        }
","        protected boolean handlePreloadPackage(String packagePath, String libsPath) {
START             Log.d(TAG, ""Preload package ********************************************************"");
            Log.d(TAG, ""WebView package = "" + packagePath); END 
            return false;
        }
","        protected boolean handlePreloadPackage(String packagePath, String libsPath) {
            // TODO: Use preload information to setup the ClassLoader.
            return false;
        }
"
1157,"Style-nit: We don't cuddle onto the same line.  But really isn't this shorter?

  Grant grant = (Grant)o;
  return group.equals(grant.group) && pattern.equals(grant.pattern);","    public boolean equals(Object o) {
      Grant grant = (Grant) o;

      if (!group.equals(grant.group)) return false;
      if (!pattern.equals(grant.pattern)) return false;

      return true;
    }
","    public boolean equals(Object o) {
      Grant grant = (Grant) o;

START       if (!group.equals(grant.group)) return false; END 
      if (!pattern.equals(grant.pattern)) return false;

      return true;
    }
","    public boolean equals(Object o) {
      Grant grant = (Grant) o;
      return group.equals(grant.group) && pattern.equals(grant.pattern);
    }
"
1158,Is this two step handler change needed to avoid some memory leak? Isn't enough just to assign new value?,"    public void onValueChanged(final Consumer<Event> onValueChanged) {
        input.onkeyup = null;
        input.onkeyup = event -> {
            onValueChanged.accept(event);
            return this;
        };
    }
","    public void onValueChanged(final Consumer<Event> onValueChanged) {
        input.onkeyup = null;
START         input.onkeyup = event -> { END 
            onValueChanged.accept(event);
            return this;
        };
    }
","    public void onValueChanged(final Consumer<Event> onValueChanged) {
        input.onkeyup = event -> {
            onValueChanged.accept(event);
            return this;
        };
    }
"
1159,So if the context is immutable why not just return false?,"   public boolean isEntryRemovedInContext(Object key) {
      throw new CacheException(""This context is immutable"");
   }
","   public boolean isEntryRemovedInContext(Object key) {
START       throw new CacheException(""This context is immutable""); END 
   }
","   public boolean isEntryRemovedInContext(Object key) {
      return false;
   }
"
1160,remove curly braces,"    protected ITmfTreeColumnDataProvider getColumnDataProvider() {
        return () -> {
            return ImmutableList.of(
                    createColumn(Messages.AbstractSegmentStoreScatterView_Type, Comparator.comparing(TmfGenericTreeEntry::getName)),
                    new TmfTreeColumnData(Messages.AbstractSegmentStoreScatterView_Legend));
        };
    }
","    protected ITmfTreeColumnDataProvider getColumnDataProvider() {
        return () START -> {
            return ImmutableList.of(
                    createColumn(Messages.AbstractSegmentStoreScatterView_Type, Comparator.comparing(TmfGenericTreeEntry::getName)),
                    new TmfTreeColumnData(Messages.AbstractSegmentStoreScatterView_Legend));
        }; END 
    }
","    protected ITmfTreeColumnDataProvider getColumnDataProvider() {
        return () -> ImmutableList.of(
                    createColumn(Messages.AbstractSegmentStoreScatterView_Type, Comparator.comparing(TmfGenericTreeEntry::getName)),
                    new TmfTreeColumnData(Messages.AbstractSegmentStoreScatterView_Legend));
    }
"
1161,This seems odd here. What is this for?,"    public void buttonStateChanged(VRControllerState_t stateBefore, VRControllerState_t stateAfter, int handIndex) {
        cachedStateBefore = stateBefore;
        cachedStateAfter = stateAfter;
        queuedActions.add(new ControllerAction(InputType.CONTROLLER_BUTTON.getInput(ControllerId.X_AXIS),
                ""OpenVR"", ButtonState.DOWN, 1.0f));
        if (handIndex == 0) {
            handleController0();
        } else {
            handleController1();
        }
    }
","    public void buttonStateChanged(VRControllerState_t stateBefore, VRControllerState_t stateAfter, int handIndex) {
        cachedStateBefore = stateBefore;
        cachedStateAfter = stateAfter;
START         queuedActions.add(new ControllerAction(InputType.CONTROLLER_BUTTON.getInput(ControllerId.X_AXIS), END 
                ""OpenVR"", ButtonState.DOWN, 1.0f));
        if (handIndex == 0) {
            handleController0();
        } else {
            handleController1();
        }
    }
","    public void buttonStateChanged(VRControllerState_t stateBefore, VRControllerState_t stateAfter, int handIndex) {
        cachedStateBefore = stateBefore;
        cachedStateAfter = stateAfter;
        if (handIndex == 0) {
            handleController0();
        } else {
            handleController1();
        }
    }
"
1162,"Now that we close the channel, I think it's useless to remove the publisher from the pipeline. The channel will be garbage collected.","    protected void cancelled() {
        logger.debug(""Subscriber cancelled, ignoring the rest of the body"");

        try {
            future.done();
        } catch (Exception t) {
            // Never propagate exception once we know we are done.
            logger.error(t.getMessage(), t);
        }

        // The subscriber cancelled early - this channel is dead and should be closed.
        channelManager.releaseChannelLock(future.getPartitionKey());
        channelManager.closeChannel(channel);

        channel.pipeline().remove(StreamedResponsePublisher.class);
    }
","    protected void cancelled() {
        logger.debug(""Subscriber cancelled, ignoring the rest of the body"");

        try {
            future.done();
        } catch (Exception t) {
            // Never propagate exception once we know we are done.
            logger.error(t.getMessage(), t);
        }

        // The subscriber cancelled early - this channel is dead and should be closed.
        channelManager.releaseChannelLock(future.getPartitionKey());
        channelManager.closeChannel(channel);

START         channel.pipeline().remove(StreamedResponsePublisher.class); END 
    }
","    protected void cancelled() {
        logger.debug(""Subscriber cancelled, ignoring the rest of the body"");

        try {
            future.done();
        } catch (Exception t) {
            // Never propagate exception once we know we are done.
            logger.debug(t.getMessage(), t);
        }

        // The subscriber cancelled early - this channel is dead and should be closed.
        channelManager.closeChannel(channel);
    }
"
1163,"There should be a null check on the identityProvider, prior to calling its getRoles method. Maybe something like...
`List<String> roles = (identityProvider != null) ? identityProvider.getRoles():null;`","	public static List<String> getAuthenticatedUserRoles(IdentityProvider identityProvider) {
        List<String> roles = identityProvider.getRoles();
        
        if (roles == null || roles.isEmpty()) {
            roles = new ArrayList<>();
            roles.add("""");
        }
        
        return roles;
    }
","	public static List<String> getAuthenticatedUserRoles(IdentityProvider identityProvider) {
START         List<String> roles = identityProvider.getRoles(); END 
        
        if (roles == null || roles.isEmpty()) {
            roles = new ArrayList<>();
            roles.add("""");
        }
        
        return roles;
    }
","	public static List<String> getAuthenticatedUserRoles(IdentityProvider identityProvider) {
        List<String> roles = identityProvider != null ? identityProvider.getRoles() : new ArrayList<>();
        
        if (roles == null || roles.isEmpty()) {
            roles = new ArrayList<>();
            roles.add("""");
        }
        
        return roles;
    }
"
1164,legacy extensions might not use abstractSegmentStatisticsAnalysis,"    public void initializeDataSource(ITmfTrace trace) {
        TmfAbstractAnalysisModule module = createStatisticsAnalysiModule();
        if (!(module instanceof AbstractSegmentStatisticsAnalysis)) {
            // null or not a segment analysis module
            return;
        }
        try {
            module.setTrace(trace);
            module.schedule();
            if (fModule != null) {
                fModule.dispose();
            }
            fModule = (AbstractSegmentStatisticsAnalysis) module;
        } catch (TmfAnalysisException e) {
            Activator.getDefault().logError(""Error initializing statistics analysis module"", e); //$NON-NLS-1$
        }
    }
","    public void initializeDataSource(ITmfTrace trace) {
        TmfAbstractAnalysisModule module = createStatisticsAnalysiModule();
START         if (!(module instanceof AbstractSegmentStatisticsAnalysis)) { END 
            // null or not a segment analysis module
            return;
        }
        try {
            module.setTrace(trace);
            module.schedule();
            if (fModule != null) {
                fModule.dispose();
            }
            fModule = (AbstractSegmentStatisticsAnalysis) module;
        } catch (TmfAnalysisException e) {
            Activator.getDefault().logError(""Error initializing statistics analysis module"", e); //$NON-NLS-1$
        }
    }
","    public void initializeDataSource(ITmfTrace trace) {
        TmfAbstractAnalysisModule module = createStatisticsAnalysiModule();
        if (module == null) {
            return;
        }
        try {
            module.setTrace(trace);
            module.schedule();
            if (fModule != null) {
                fModule.dispose();
            }
            fModule = module;
        } catch (TmfAnalysisException e) {
            Activator.getDefault().logError(""Error initializing statistics analysis module"", e); //$NON-NLS-1$
        }
    }
"
1165,formatting here is off.,"    @Override public void onReceive(Context context, Intent intent) {
      String action = intent.getAction();
      Bundle extras = intent.getExtras();

      if (ACTION_AIRPLANE_MODE_CHANGED.equals(action)) {
          if (extras != null) {
              dispatchAirplaneModeChange(extras.getBoolean(EXTRA_AIRPLANE_STATE, false));
          }
      } else if (CONNECTIVITY_ACTION.equals(action)) {
        dispatchNetworkStateChange(connectivityManager.getActiveNetworkInfo());
      }
    }
","    @Override public void onReceive(Context context, Intent intent) {
      String action = intent.getAction();
      Bundle extras = intent.getExtras();

      if (ACTION_AIRPLANE_MODE_CHANGED.equals(action)) {
          if (extras != null) {
START               dispatchAirplaneModeChange(extras.getBoolean(EXTRA_AIRPLANE_STATE, false)); END 
          }
      } else if (CONNECTIVITY_ACTION.equals(action)) {
        dispatchNetworkStateChange(connectivityManager.getActiveNetworkInfo());
      }
    }
","    @Override public void onReceive(Context context, Intent intent) {
      // On some versions of Android this may be called with a null Intent
      if (null == intent) {
        return;
      }

      String action = intent.getAction();
      Bundle extras = intent.getExtras();

      if (ACTION_AIRPLANE_MODE_CHANGED.equals(action)) {
        dispatchAirplaneModeChange(extras.getBoolean(EXTRA_AIRPLANE_STATE, false));
      } else if (CONNECTIVITY_ACTION.equals(action)) {
        dispatchNetworkStateChange(connectivityManager.getActiveNetworkInfo());
      }
    }
"
1166,"Instead of adding a callback, consider using a ContentObserver wherever changes must be observed (I think SavePageSyncService does this?). This likely allow you to remove the tab change logic as well.","        public void onDelete(@NonNull ReadingList readingList) {
            showDeleteListUndoSnackbar(readingList);
            ReadingList.DAO.removeList(readingList);
            funnel.logDeleteList(readingList, readingLists.size());
            updateLists();
            if (callback() != null) {
                callback().onReadingListModified();
            }
        }
","        public void onDelete(@NonNull ReadingList readingList) {
            showDeleteListUndoSnackbar(readingList);
            ReadingList.DAO.removeList(readingList);
            funnel.logDeleteList(readingList, readingLists.size());
            updateLists();
START             if (callback() != null) { END 
                callback().onReadingListModified();
            }
        }
","        public void onDelete(@NonNull ReadingList readingList) {
            showDeleteListUndoSnackbar(readingList);
            ReadingList.DAO.removeList(readingList);
            funnel.logDeleteList(readingList, readingLists.size());
            updateLists();
        }
"
1167,"I'm pretty certain there is a factory for making these, no public constructor required. (Took a lot of refactoring to achieve that, let's uphold the flag.)","    public RelationTypeSchemaDescriptor( int relTypeId, int... propertyIds )
    {
        this.relTypeId = relTypeId;
        this.propertyIds = propertyIds;
    }
","START     public RelationTypeSchemaDescriptor( int relTypeId, int... propertyIds ) END 
    {
        this.relTypeId = relTypeId;
        this.propertyIds = propertyIds;
    }
","    RelationTypeSchemaDescriptor( int relTypeId, int... propertyIds )
    {
        this.relTypeId = relTypeId;
        this.propertyIds = propertyIds;
    }
"
1168,"What would you think of

```suggestion
		TokenIntrospectionSuccessResponse response = Optional.of(token)
				.map(this.requestEntityConverter::convert)
```","	public Map<String, Object> introspect(String token) {
		TokenIntrospectionSuccessResponse response = Optional.of(this.requestEntityConverter.convert(token))
				.map(this::makeRequest)
				.map(this::adaptToNimbusResponse)
				.map(this::parseNimbusResponse)
				.map(this::castToNimbusSuccess)
				// relying solely on the authorization server to validate this token (not checking 'exp', for example)
				.filter(TokenIntrospectionSuccessResponse::isActive)
				.orElseThrow(() -> new OAuth2IntrospectionException(""Provided token ["" + token + ""] isn't active""));
		return convertClaimsSet(response);
	}
","	public Map<String, Object> introspect(String token) {
START 		TokenIntrospectionSuccessResponse response = Optional.of(this.requestEntityConverter.convert(token)) END 
				.map(this::makeRequest)
				.map(this::adaptToNimbusResponse)
				.map(this::parseNimbusResponse)
				.map(this::castToNimbusSuccess)
				// relying solely on the authorization server to validate this token (not checking 'exp', for example)
				.filter(TokenIntrospectionSuccessResponse::isActive)
				.orElseThrow(() -> new OAuth2IntrospectionException(""Provided token ["" + token + ""] isn't active""));
		return convertClaimsSet(response);
	}
","	public Map<String, Object> introspect(String token) {
		TokenIntrospectionSuccessResponse response = Optional.of(token)
				.map(this.requestEntityConverter::convert)
				.map(this::makeRequest)
				.map(this::adaptToNimbusResponse)
				.map(this::parseNimbusResponse)
				.map(this::castToNimbusSuccess)
				// relying solely on the authorization server to validate this token (not checking 'exp', for example)
				.filter(TokenIntrospectionSuccessResponse::isActive)
				.orElseThrow(() -> new OAuth2IntrospectionException(""Provided token ["" + token + ""] isn't active""));
		return convertClaimsSet(response);
	}
"
1169,shouldn't we perform cold reboot for volatile runs?,"    private boolean isColdReboot() {
        boolean coldReboot = (getVm().isRunOnce() && !getVm().isVolatileRun()) || getVm().isNextRunConfigurationExists();

        log.info(""VM '{}' is performing {} reboot; run once: '{}', running as volatile: '{}', has next run configuration: '{}'"",
                getVm().getName(),
                coldReboot ? ""cold"" : ""warm"",
                getVm().isRunOnce(),
                getVm().isVolatileRun(),
                getVm().isNextRunConfigurationExists());
        return coldReboot;
    }
","    private boolean isColdReboot() {
        boolean coldReboot = (getVm().isRunOnce() && START  !getVm().isVolatileRun()) END  || getVm().isNextRunConfigurationExists();

        log.info(""VM '{}' is performing {} reboot; run once: '{}', running as volatile: '{}', has next run configuration: '{}'"",
                getVm().getName(),
                coldReboot ? ""cold"" : ""warm"",
                getVm().isRunOnce(),
                getVm().isVolatileRun(),
                getVm().isNextRunConfigurationExists());
        return coldReboot;
    }
","    private boolean isColdReboot() {
        boolean coldReboot = (getVm().isRunOnce() && getVm().isVolatileRun()) || getVm().isNextRunConfigurationExists();

        log.info(""VM '{}' is performing {} reboot; run once: '{}', running as volatile: '{}', has next run configuration: '{}'"",
                getVm().getName(),
                coldReboot ? ""cold"" : ""warm"",
                getVm().isRunOnce(),
                getVm().isVolatileRun(),
                getVm().isNextRunConfigurationExists());
        return coldReboot;
    }
"
1170,"Again, I don't understand why this is needed? Isn't it the same thing that happens in AbstractNetworkPopupPresenterWidget?","    public void updateVisibility() {
        super.updateVisibility();
        messageLabel.setVisible(false);
        subnetTab.setVisible(exportEditor.asCheckBox().getValue());
    }
","    public void updateVisibility() {
        super.updateVisibility();
        messageLabel.setVisible(false);
START         subnetTab.setVisible(exportEditor.asCheckBox().getValue()); END 
    }
","    public void updateVisibility() {
        super.updateVisibility();
        messageLabel.setVisible(false);
    }
"
1171,Could you please rename also _result?,"    protected void executeVdsBrokerCommand() {
        _result = getBroker().getStorageDomainStats(getParameters().getStorageDomainId().toString());
        proceedProxyReturnValue();
        StorageDomain domain = buildStorageDynamicFromXmlRpcStruct(_result.storageStats);
        domain.setId(getParameters().getStorageDomainId());
        setReturnValue(domain);
    }
","    protected void executeVdsBrokerCommand() {
START         _result = getBroker().getStorageDomainStats(getParameters().getStorageDomainId().toString()); END 
        proceedProxyReturnValue();
        StorageDomain domain = buildStorageDynamicFromXmlRpcStruct(_result.storageStats);
        domain.setId(getParameters().getStorageDomainId());
        setReturnValue(domain);
    }
","    protected void executeVdsBrokerCommand() {
        result = getBroker().getStorageDomainStats(getParameters().getStorageDomainId().toString());
        proceedProxyReturnValue();
        StorageDomain domain = buildStorageDynamicFromXmlRpcStruct(result.storageStats);
        domain.setId(getParameters().getStorageDomainId());
        setReturnValue(domain);
    }
"
1172,"```Boolean``` for a reason (vs ```boolean```)? Just asking.. Use of ```Boolean``` in my mind always makes me think this is a tri-value ```boolean``` (```true```, ```false```, ```null```)..","    Boolean canEditColumns() {

        final String permission = WorkbenchFeatures.GUIDED_DECISION_TABLE_EDIT_COLUMNS;
        final User user = sessionInfo.getIdentity();

        return authorizationManager.authorize(permission, user);
    }
","START     Boolean canEditColumns() { END 

        final String permission = WorkbenchFeatures.GUIDED_DECISION_TABLE_EDIT_COLUMNS;
        final User user = sessionInfo.getIdentity();

        return authorizationManager.authorize(permission, user);
    }
","    boolean canEditColumns() {

        final String permission = WorkbenchFeatures.GUIDED_DECISION_TABLE_EDIT_COLUMNS;
        final User user = sessionInfo.getIdentity();

        return authorizationManager.authorize(permission, user);
    }
"
1173,"This is a bug, if cinder disks exists return the call back (not null).
Also use the parameter you have added in the previous patch","    public CommandCallback getCallback() {
        return isCinderDisksExist() ? null : new ConcurrentChildCommandsExecutionCallback();
    }
","    public CommandCallback getCallback() {
START         return isCinderDisksExist() ? null : new ConcurrentChildCommandsExecutionCallback(); END 
    }
","    public CommandCallback getCallback() {
        return isCinderDisksExist() ? new ConcurrentChildCommandsExecutionCallback() : null;
    }
"
1174,@NielsCharlier try-with-resources?,"    private Config loadHazelcastConfig(GeoServerResourceLoader rl) throws IOException{
        Resource hzf = getConfigFile(HAZELCAST_FILENAME, HzCluster.class);
        InputStream hzIn = hzf.in();
        try {
            return new XmlConfigBuilder(hzIn).build();
        } finally {
            hzIn.close();
        }
    }
","    private Config loadHazelcastConfig(GeoServerResourceLoader rl) throws IOException{
        Resource hzf = getConfigFile(HAZELCAST_FILENAME, HzCluster.class);
        InputStream hzIn = hzf.in();
        try {
            return new XmlConfigBuilder(hzIn).build();
        } finally {
            hzIn.close();
START         } END 
    }
","    private Config loadHazelcastConfig(GeoServerResourceLoader rl) throws IOException{
        Resource hzf = getConfigFile(HAZELCAST_FILENAME, HzCluster.class);
        try (InputStream hzIn = hzf.in()) {
            return new XmlConfigBuilder(hzIn).build();
        }
    }
"
1175,we likely want specific edge-case as fixtures to ensure deserialization works as needed.,"  public void testDeserialize() throws Exception {
    String data = getFixture(""/v1/accounts/acct_123"");
    Account resource = APIResource.GSON.fromJson(data, Account.class);
    assertNotNull(resource);
    assertNotNull(resource.getId());
  }
","  public void testDeserialize() throws Exception {
    String data = getFixture(""/v1/accounts/acct_123"");
    Account resource = APIResource.GSON.fromJson(data, Account.class);
    assertNotNull(resource);
START     assertNotNull(resource.getId()); END 
  }
","  public void testDeserialize() throws Exception {
    final String data = getFixture(""/v1/accounts/acct_123"");
    final Account resource = APIResource.GSON.fromJson(data, Account.class);
    assertNotNull(resource);
    assertNotNull(resource.getId());
  }
"
1176,"Why not flip this around, have the constructor with the sessionId call the constructor without the parameter? That way you don't have to pass null into the constructor. Functionally it makes no difference, just reads a little nicer IMO.","    public VdcQueryParametersBase(String sessionId) {
        this.sessionId = sessionId;
        refresh = true;
    }
","    public VdcQueryParametersBase(String sessionId) {
START         this.sessionId = sessionId; END 
        refresh = true;
    }
","    public VdcQueryParametersBase(String sessionId) {
        this();
        this.sessionId = sessionId;

    }
"
1177,I'm concerned that this might not be inlined.,"    private int onSpinMisses(int spins) {
        if (UPDATE_STATISTICS) spinMisses.increment();
        if (spins == YIELD_SPINS) {
            spins = 0;
            Thread.yield();
        } else {
            spins++;
            JDKSpecific.onSpinWait();
        }
        return spins;
    }
","    private int onSpinMisses(int spins) {
START         if (UPDATE_STATISTICS) spinMisses.increment(); END 
        if (spins == YIELD_SPINS) {
            spins = 0;
            Thread.yield();
        } else {
            spins++;
            JDKSpecific.onSpinWait();
        }
        return spins;
    }
","    private int onSpinMisses(int spins) {
        if (UPDATE_STATISTICS) spinMisses.increment();
        if (spins == YIELD_SPINS) {
            Thread.yield();
            return 0;
        } 
        JDKSpecific.onSpinWait();
        return spins + 1;
    }
"
1178,No need to assign to a variable,"    private static String resolveKafkaService() {

        final StringBuilder sb = new StringBuilder()
                .append(resolve(KAFKA_SERVICE_HOST))
                .append("":"")
                .append(resolve(KAFKA_SERVICE_PORT));

        return sb.toString();
    }
","    private static String resolveKafkaService() {

START         final StringBuilder sb = new StringBuilder() END 
                .append(resolve(KAFKA_SERVICE_HOST))
                .append("":"")
                .append(resolve(KAFKA_SERVICE_PORT));

        return sb.toString();
    }
","    private static String resolveKafkaService() {

        return new StringBuilder()
                .append(resolve(KAFKA_SERVICE_HOST))
                .append("":"")
                .append(resolve(KAFKA_SERVICE_PORT)).toString();
    }
"
1179,"This correctly cycles back through the pager when the Back button is pressed. However, when the first position is reached, the Back button has no effect (i.e. the dialog should close when Back is pressed).

To handle the final Back case, you could add an `else` here and say the following:

else {
    super.onBackPressed();
}","    public void onBackPressed() {
        if (referencesViewPager.getCurrentItem() > 0) {
            referencesViewPager.setCurrentItem(referencesViewPager.getCurrentItem() - 1, true);
        }
    }
","    public void onBackPressed() {
        if (referencesViewPager.getCurrentItem() > 0) {
            referencesViewPager.setCurrentItem(referencesViewPager.getCurrentItem() - 1, true);
START         } END 
    }
","    public void onBackPressed() {
        if (referencesViewPager.getCurrentItem() > 0) {
            referencesViewPager.setCurrentItem(referencesViewPager.getCurrentItem() - 1, true);
        } else {
            super.onBackPressed();
        }
    }
"
1180,"ditto on readability here:

```
int result = name == null ? 0 : name.hashCode();
```","        public int hashCode() {
            int result = name != null ? name.hashCode() : 0;
            result = 31 * result + (sqlObjectType != null ? sqlObjectType.hashCode() : 0);
            result = 31 * result + (sqlObjectMethod != null ? sqlObjectMethod.hashCode() : 0);
            return result;
        }
","        public int hashCode() {
START             int result = name != null ? name.hashCode() : 0; END 
            result = 31 * result + (sqlObjectType != null ? sqlObjectType.hashCode() : 0);
            result = 31 * result + (sqlObjectMethod != null ? sqlObjectMethod.hashCode() : 0);
            return result;
        }
","        public int hashCode() {
            int result = name == null ? 0 : name.hashCode();
            result = 31 * result + (sqlObjectType != null ? sqlObjectType.hashCode() : 0);
            result = 31 * result + (sqlObjectMethod != null ? sqlObjectMethod.hashCode() : 0);
            return result;
        }
"
1181,Should be done inside start().,"        public Implementation() {
            plugin = this;
            pageRegistry = new PageRegistry();
            pageRegistry.addPageProvider(new DefaultPageProvider());
        }
","        public Implementation() {
            plugin = this;
            START  pageRegistry = new PageRegistry();
            pageRegistry.addPageProvider(new DefaultPageProvider()); END 
        }
","        public Implementation() {
            plugin = this;
        }
"
1182,Looks better to me to have it here :+1:,"    public Symbol cast(DataType<?> targetType, boolean tryCast) {
        if (targetType.equals(valueType())) {
            return this;
        } else if (ArrayType.unnest(targetType).equals(DataTypes.UNTYPED_OBJECT)
                   && valueType().id() == DataTypes.UNTYPED_OBJECT.id()) {
            return this;
        }
        return CastFunctionResolver.generateCastFunction(this, targetType, tryCast);
    }
","    public Symbol cast(DataType<?> targetType, boolean tryCast) {
        if (targetType.equals(valueType())) {
            return this;
START         } else if (ArrayType.unnest(targetType).equals(DataTypes.UNTYPED_OBJECT) END 
                   && valueType().id() == DataTypes.UNTYPED_OBJECT.id()) {
            return this;
        }
        return CastFunctionResolver.generateCastFunction(this, targetType, tryCast);
    }
","    public Symbol cast(DataType<?> targetType, boolean tryCast) {
        if (targetType.equals(valueType())) {
            return this;
        } else if (ArrayType.unnest(targetType).equals(DataTypes.UNTYPED_OBJECT)
                   && valueType().id() == targetType.id()) {
            return this;
        }
        return CastFunctionResolver.generateCastFunction(this, targetType, tryCast);
    }
"
1183,"`LOG.warn(""Unsupported property {}"", propertyName);`","  public static boolean validate() {
    boolean valid = true;
    for (Map.Entry<String, String> entry : toMap().entrySet()) {
      String propertyName = entry.getKey();
      if (!PropertyKey.isValid(propertyName)) {
        LOG.warn(""Unsupported property {}"" + propertyName);
        valid = false;
      }
    }
    return valid;
  }
","  public static boolean validate() {
    boolean valid = true;
    for (Map.Entry<String, String> entry : toMap().entrySet()) {
      String propertyName = entry.getKey();
      if (!PropertyKey.isValid(propertyName)) {
START         LOG.warn(""Unsupported property {}"" + propertyName); END 
        valid = false;
      }
    }
    return valid;
  }
","  public static boolean validate() {
    boolean valid = true;
    for (Map.Entry<String, String> entry : toMap().entrySet()) {
      String propertyName = entry.getKey();
      if (!PropertyKey.isValid(propertyName)) {
        LOG.warn(""Unsupported property {}"", propertyName);
        valid = false;
      }
    }
    return valid;
  }
"
1184,Wrapping the else body in a new method will make it even cleaner.,"	public String BuildJSON() {
		if (swagger != null) {
			updateHostAndBasePath();
		} else {
			synchronized (this) {
				log.info(""Initiating Swagger specification creation"");
				toggleLogs(RestConstants.SWAGGER_LOGS_OFF);
				try {
					initSwagger();
					addPaths();
					addDefaultDefinitions();
					//				addSubclassOperations(); //FIXME uncomment after fixing the method
				}
				catch (Exception e) {
					log.error(""Error while creating Swagger specification"", e);
				}
				finally {
					toggleLogs(RestConstants.SWAGGER_LOGS_ON);
					log.info(""Swagger specification creation complete"");
				}
			}
		}
		return createJSON();
	}
","	public String BuildJSON() {
		if (swagger != null) {
			updateHostAndBasePath();
		} else {
			synchronized (this) {
START 				log.info(""Initiating Swagger specification creation""); END 
				toggleLogs(RestConstants.SWAGGER_LOGS_OFF);
				try {
					initSwagger();
					addPaths();
					addDefaultDefinitions();
					//				addSubclassOperations(); //FIXME uncomment after fixing the method
				}
				catch (Exception e) {
					log.error(""Error while creating Swagger specification"", e);
				}
				finally {
					toggleLogs(RestConstants.SWAGGER_LOGS_ON);
					log.info(""Swagger specification creation complete"");
				}
			}
		}
		return createJSON();
	}
","	private void BuildJSON() {
		synchronized (this) {
			log.info(""Initiating Swagger specification creation"");
			toggleLogs(RestConstants.SWAGGER_LOGS_OFF);
			try {
				initSwagger();
				addPaths();
				addDefaultDefinitions();
				//				addSubclassOperations(); //FIXME uncomment after fixing the method
			}
			catch (Exception e) {
				log.error(""Error while creating Swagger specification"", e);
			}
			finally {
				toggleLogs(RestConstants.SWAGGER_LOGS_ON);
				log.info(""Swagger specification creation complete"");
			}
		}
	}
"
1185,This is bytecode equivalent to using the for-each syntax on an array.,"  static List<TypeName> list(Type[] types) {
    List<TypeName> result = new ArrayList<>(types.length);
    //noinspection ForLoopReplaceableByForEach
    for (int i = 0; i < types.length; i++) {
        result.add(get(types[i]));
    }
    return result;
  }
","  static List<TypeName> list(Type[] types) {
    List<TypeName> result = new ArrayList<>(types.length);
    //noinspection ForLoopReplaceableByForEach
START     for (int i = 0; i < types.length; i++) { END 
        result.add(get(types[i]));
    }
    return result;
  }
","  static List<TypeName> list(Type[] types) {
    List<TypeName> result = new ArrayList<>(types.length);
    for (Type type : types) {
      result.add(get(type));
    }
    return result;
  }
"
1186,"If ``value`` is ``NULL``, ``Boolean.getBoolean(value)`` will return ``FALSE`` anyway, but I understand that this is more explicit.","    private boolean loadDataInMemory() {
        String value = Optional.ofNullable(GeoServerExtensions.getProperty(""WMTS_HISTOGRAM_IN_MEMORY""))
                .orElse(""false"");
        return Boolean.getBoolean(value);
    }
","    private boolean loadDataInMemory() {
        String value = Optional.ofNullable(GeoServerExtensions.getProperty(""WMTS_HISTOGRAM_IN_MEMORY""))
START                 .orElse(""false""); END 
        return Boolean.getBoolean(value);
    }
","    private boolean loadDataInMemory() {
        String value = GeoServerExtensions.getProperty(""WMTS_HISTOGRAM_IN_MEMORY"");
        return Boolean.getBoolean(value);
    }
"
1187,"Since the entire body is synchronized, put the `synchronized` on the method itself.","  public Map<String, Integer> getRemainingQueries() {
    synchronized (this) {
        Map<String, Integer> queriesInfo = new HashMap<String, Integer>();
        queriesInfo.put(""queriesCount"", queries.size());
        queriesInfo.put(""fragmentsCount"", runningFragments.size());
        return queriesInfo;
      }
  }
","  public Map<String, Integer> getRemainingQueries() {
START     synchronized (this) { END 
        Map<String, Integer> queriesInfo = new HashMap<String, Integer>();
        queriesInfo.put(""queriesCount"", queries.size());
        queriesInfo.put(""fragmentsCount"", runningFragments.size());
        return queriesInfo;
      }
  }
","  public synchronized Map<String, Integer> getRemainingQueries() {
        Map<String, Integer> queriesInfo = new HashMap<String, Integer>();
        queriesInfo.put(""queriesCount"", queries.size());
        queriesInfo.put(""fragmentsCount"", runningFragments.size());
        return queriesInfo;
  }
"
1188,You may remove `this.`,"    public void next() {
        RadioDroidApp radioDroidApp = (RadioDroidApp) this.getApplication();
        DataRadioStation station = radioDroidApp.getFavouriteManager().getNextById(currentStationID);
        if (station != null)
            new RadioDroidBrowserService.GetRealLinkAndPlayTask(itsContext, station, itsBinder).execute();
    }
","    public void next() {
START         RadioDroidApp radioDroidApp = (RadioDroidApp) this.getApplication(); END 
        DataRadioStation station = radioDroidApp.getFavouriteManager().getNextById(currentStationID);
        if (station != null)
            new RadioDroidBrowserService.GetRealLinkAndPlayTask(itsContext, station, itsBinder).execute();
    }
","    public void next() {
        RadioDroidApp radioDroidApp = (RadioDroidApp) getApplication();
        DataRadioStation station = radioDroidApp.getFavouriteManager().getNextById(currentStationID);
        if (station != null)
            new GetRealLinkAndPlayTask(itsContext, station, itsBinder).execute();
    }
"
1189,please inline this variable,"    public void connectDisconnect() throws IOException {
        final FtpFacade facade = FtpFacadeTest.mockFacade();
        final FTPClient ftp = new FTPClient();
        try {
            facade.listen();
            ftp.connect(""localhost"");
            final int reply = ftp.getReplyCode();
            MatcherAssert.assertThat(
                FTPReply.isPositiveCompletion(reply),
                Matchers.equalTo(true)
            );
            MatcherAssert.assertThat(
                ftp.logout(),
                Matchers.equalTo(true)
            );
        } finally {
            facade.close();
        }
    }
","    public void connectDisconnect() throws IOException {
        final FtpFacade facade = FtpFacadeTest.mockFacade();
        final FTPClient ftp = new FTPClient();
        try {
            facade.listen();
            ftp.connect(""localhost"");
START             final int reply = ftp.getReplyCode(); END 
            MatcherAssert.assertThat(
                FTPReply.isPositiveCompletion(reply),
                Matchers.equalTo(true)
            );
            MatcherAssert.assertThat(
                ftp.logout(),
                Matchers.equalTo(true)
            );
        } finally {
            facade.close();
        }
    }
","    public void connectDisconnect() throws IOException {
        final FtpFacade facade = FtpFacadeTest.mockFacade();
        final FTPClient ftp = new FTPClient();
        try {
            facade.listen();
            ftp.connect(""localhost"");
            MatcherAssert.assertThat(
                FTPReply.isPositiveCompletion(ftp.getReplyCode()),
                Matchers.equalTo(true)
            );
            MatcherAssert.assertThat(
                ftp.logout(),
                Matchers.equalTo(true)
            );
        } finally {
            facade.close();
        }
    }
"
1190,"Could put this in a `finally` or local try-with-resources in case `endpointGroup.close()` throws for some reason, though it's extremely careful.","  @Override public void close() {
    EndpointGroup endpointGroup = EndpointGroupRegistry.get(""elasticsearch"");
    if (endpointGroup != null) {
      endpointGroup.close();
      EndpointGroupRegistry.unregister(""elasticsearch"");
    }
    factory.close();
  }
","  @Override public void close() {
    EndpointGroup endpointGroup = EndpointGroupRegistry.get(""elasticsearch"");
    if (endpointGroup != null) {
      endpointGroup.close();
      EndpointGroupRegistry.unregister(""elasticsearch"");
    }
START     factory.close(); END 
  }
","  @Override public void close() {
    EndpointGroup endpointGroup = EndpointGroupRegistry.get(""elasticsearch"");
    if (endpointGroup != null) {
      endpointGroup.close();
      EndpointGroupRegistry.unregister(""elasticsearch"");
    }
  }
"
1191,I'm not sure this will work in a concurrent environment. Isn't this a shared channel? Can you instead use [this](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/FileChannel.html#read-java.nio.ByteBuffer-long-)?,"  void doPrefetch(long relativeOffset, long size) throws IOException {
    long sizeToRead = Math.min(size, getMessageInfo().getSize() - relativeOffset);
    prefetchedData = ByteBuffer.allocate((int) sizeToRead);
    getChannel().position(offset.getOffset() + relativeOffset);
    getChannel().read(prefetchedData);
    prefetchedDataRelativeOffset = relativeOffset;
  }
","  void doPrefetch(long relativeOffset, long size) throws IOException {
    long sizeToRead = Math.min(size, getMessageInfo().getSize() - relativeOffset);
    prefetchedData = ByteBuffer.allocate((int) sizeToRead);
START     getChannel().position(offset.getOffset() + relativeOffset); END 
    getChannel().read(prefetchedData);
    prefetchedDataRelativeOffset = relativeOffset;
  }
","  void doPrefetch(long relativeOffset, long size) throws IOException {
    long sizeToRead = Math.min(size, getMessageInfo().getSize() - relativeOffset);
    prefetchedData = ByteBuffer.allocate((int) sizeToRead);
    getChannel().read(prefetchedData, offset.getOffset() + relativeOffset);
    prefetchedDataRelativeOffset = relativeOffset;
  }
"
1192,"this returns the expression, you can combine this line and the next","  public ProcessorExpressionRoute(String expression, Processor processor) {
    super(processor);
    requireNonNull(expression, ""expression can't be null"");
    this.expression = expression;
  }
","  public ProcessorExpressionRoute(String expression, Processor processor) {
    super(processor);
START     requireNonNull(expression, ""expression can't be null""); END 
    this.expression = expression;
  }
","  public ProcessorExpressionRoute(String expression, Processor processor) {
    super(processor);
    this.expression = requireNonNull(expression, ""expression can't be null"");
  }
"
1193,use final,"        public CachingHasher build() throws IllegalArgumentException {
            List<long[]> cache = new ArrayList<long[]>();
            for (byte[] buff : buffers) {
                long[] result = new long[2];
                result[0] = function.apply(buff, 0);
                result[1] = function.apply(buff, 1) - result[0];
                cache.add(result);
            }
            return new CachingHasher(function, cache);
        }
","        public CachingHasher build() throws IllegalArgumentException {
START             List<long[]> cache = new ArrayList<long[]>(); END 
            for (byte[] buff : buffers) {
                long[] result = new long[2];
                result[0] = function.apply(buff, 0);
                result[1] = function.apply(buff, 1) - result[0];
                cache.add(result);
            }
            return new CachingHasher(function, cache);
        }
","        public final CachingHasher build() throws IllegalArgumentException {
            List<long[]> cache = new ArrayList<long[]>();
            for (byte[] buff : buffers) {
                long[] result = new long[2];
                result[0] = function.apply(buff, 0);
                result[1] = function.apply(buff, 1) - result[0];
                cache.add(result);
            }
            return new CachingHasher(function, cache);
        }
"
1194,"Remove extra space for consistent formatting

```suggestion
		public Object merge(Object parent ) {
```","		public Object merge( Object parent ) {
			if (parent == null) {
				return this;
			}
			if (parent instanceof MockHttpServletRequestBuilder) {
				this.mergeable = (Mergeable) parent;
				return this.mergeable;
			} else {
				throw new IllegalArgumentException(""Cannot merge with ["" + parent.getClass().getName() + ""]"");
			}
		}
","START 		public Object merge( Object parent ) { END 
			if (parent == null) {
				return this;
			}
			if (parent instanceof MockHttpServletRequestBuilder) {
				this.mergeable = (Mergeable) parent;
				return this.mergeable;
			} else {
				throw new IllegalArgumentException(""Cannot merge with ["" + parent.getClass().getName() + ""]"");
			}
		}
","		public Object merge(Object parent) {
			if (parent == null) {
				return this;
			}
			if (parent instanceof Mergeable ) {
				this.parent = (Mergeable) parent;
				return this;
			} else {
				throw new IllegalArgumentException(""Cannot merge with ["" + parent.getClass().getName() + ""]"");
			}
		}
"
1195,Lambda here?,"  public Parser<I, Stream<A>, E> repeat1() {
      return bind(a -> repeat().map(new F<Stream<A>, Stream<A>>() {
        public Stream<A> f(final Stream<A> as) {
            return as.cons(a);
        }
    }));
  }
","  public Parser<I, Stream<A>, E> repeat1() {
START       return bind(a -> repeat().map(new F<Stream<A>, Stream<A>>() { END 
        public Stream<A> f(final Stream<A> as) {
            return as.cons(a);
        }
    }));
  }
","  public Parser<I, Stream<A>, E> repeat1() {
      return bind(a -> repeat().map(as -> as.cons(a)));
  }
"
1196,You can do it in one line. More lisibility.,"	public String getLanguage() {
		if (null == this.language) {
			return """"; //$NON-NLS-1$
		}
		return this.language;
	}
","	public String getLanguage() {
START 		if (null == this.language) {
			return """"; //$NON-NLS-1$
		}
		return this.language; END 
	}
","	public String getLanguage() {
		return this.language!=null ? this.language : """" ; //$NON-NLS-1$
	}
"
1197,"Formatting is off here, try should be around each onAttached() so that 1 bad component does not break all of the components.","		public boolean execute(short a, BlockComponentHolder b) {
			try {
                for (Component c : b.values()) {
                    c.onAttached();
                }
			} catch (Exception e) {
				Spout.getLogger().log(Level.SEVERE, ""Unhandled exception attaching block component"", e);
			}
			return true;
		}
","		public boolean execute(short a, BlockComponentHolder b) {
			try {
START                 for (Component c : b.values()) { END 
                    c.onAttached();
                }
			} catch (Exception e) {
				Spout.getLogger().log(Level.SEVERE, ""Unhandled exception attaching block component"", e);
			}
			return true;
		}
","		public boolean execute(short a, BlockComponentHolder b) {
			for (Component c : b.values()) {
				try {
					c.onAttached();
				} catch (Exception e) {
					Spout.getLogger().log(Level.SEVERE, ""Unhandled exception attaching block component"", e);
				}
			}
			return true;
		}
"
1198,"Is the ""1"" here correct? I guess, it should be the same like in ""sumMetricOverOperations"" -> 0 if there is no value?","    protected static double averageMetricOverOperations(ASTClassOrInterfaceDeclaration node, OperationMetricKey key,
                                                        MetricVersion version, boolean includeNested) {

        List<ASTMethodOrConstructorDeclaration> operations = findOperations(node, includeNested);

        double total = 0;
        for (ASTMethodOrConstructorDeclaration op : operations) {
            double val = Metrics.get(key, op, version);
            total += val == Double.NaN ? 1 : val;
        }
        return total / operations.size();
    }
","    protected static double averageMetricOverOperations(ASTClassOrInterfaceDeclaration node, OperationMetricKey key,
                                                        MetricVersion version, boolean includeNested) {

        List<ASTMethodOrConstructorDeclaration> operations = findOperations(node, includeNested);

        double total = 0;
        for (ASTMethodOrConstructorDeclaration op : operations) {
            double val = Metrics.get(key, op, version);
START             total += val == Double.NaN ? 1 : val; END 
        }
        return total / operations.size();
    }
","    protected static double averageMetricOverOperations(ASTClassOrInterfaceDeclaration node, OperationMetricKey key,
                                                        MetricVersion version, boolean includeNested) {

        List<ASTMethodOrConstructorDeclaration> operations = findOperations(node, includeNested);

        double total = 0;
        for (ASTMethodOrConstructorDeclaration op : operations) {
            double val = Metrics.get(key, op, version);
            total += val == Double.NaN ? 0 : val;
        }
        return total / operations.size();
    }
"
1199,"I think we could add a final here:
```suggestion
        final HTMLElement element = typeSelect.getElement();
```","    public void setupSelectComponent(final DataTypeSelect typeSelect) {
        type.innerHTML = """";

        HTMLElement element = typeSelect.getElement();
        if (element instanceof HTMLDivElement) {
            new MenuInitializer((HTMLDivElement) element, "".btn-group"").init();
        }

        type.appendChild(typeSelect.getElement());
    }
","    public void setupSelectComponent(final DataTypeSelect typeSelect) {
        type.innerHTML = """";

START         HTMLElement element = typeSelect.getElement(); END 
        if (element instanceof HTMLDivElement) {
            new MenuInitializer((HTMLDivElement) element, "".btn-group"").init();
        }

        type.appendChild(typeSelect.getElement());
    }
","    public void setupSelectComponent(final DataTypeSelect typeSelect) {
        type.innerHTML = """";

        final HTMLElement element = typeSelect.getElement();

        new MenuInitializer(element, "".btn-group"").init();

        type.appendChild(element);
    }
"
1200,This is counterintuitive. Why do we need to reassign `isExpired`? Can `expireCondition.isMet()` become `false` after returning `true`?,"  public boolean isTriggerExpired() {
    isExpired = isExpired || expireCondition.isMet();
    return isExpired;
  }
","  public boolean isTriggerExpired() {
START     isExpired = isExpired || expireCondition.isMet(); END 
    return isExpired;
  }
","  public boolean isTriggerExpired() {
    return expireCondition.isMet();
  }
"
1201,"I think `validate...` method can return the `Set<ClusterMonitorType>` already avoiding double `commaDelimitedListToSet` call. 
In addition I think we should add `vararg` methods for the Java Config convenience.

But that should be done in the separate JIRA.","	public void setMonitorEventTypes(String monitorEventTypes) {
		HazelcastIntegrationDefinitionValidator.validateEnumType(
				ClusterMonitorType.class, monitorEventTypes);
		final Set<String> monitorTypes = StringUtils
				.commaDelimitedListToSet(monitorEventTypes);
		Assert.notEmpty(monitorTypes, ""'monitorTypes' must have elements"");
		this.monitorTypes = monitorTypes;
	}
","	public void setMonitorEventTypes(String monitorEventTypes) {
		HazelcastIntegrationDefinitionValidator.validateEnumType(
				ClusterMonitorType.class, monitorEventTypes);
		final Set<String> monitorTypes = StringUtils
START 				.commaDelimitedListToSet(monitorEventTypes); END 
		Assert.notEmpty(monitorTypes, ""'monitorTypes' must have elements"");
		this.monitorTypes = monitorTypes;
	}
","	public void setMonitorEventTypes(String monitorEventTypes) {
		final Set<String> monitorTypes = HazelcastIntegrationDefinitionValidator.validateEnumType(
				ClusterMonitorType.class, monitorEventTypes);
		Assert.notEmpty(monitorTypes, ""'monitorTypes' must have elements"");
		this.monitorTypes = monitorTypes;
	}
"
1202,As this method does not change state (unlike the others) I would prefer to declare it `static`.,"	final AbstractInsnNode skipNonOpcodes(AbstractInsnNode cursor) {
		while (cursor != null && (cursor.getType() == AbstractInsnNode.FRAME
				|| cursor.getType() == AbstractInsnNode.LABEL
				|| cursor.getType() == AbstractInsnNode.LINE)) {
			cursor = cursor.getNext();
		}
		return cursor;
	}
","START 	final AbstractInsnNode skipNonOpcodes(AbstractInsnNode cursor) { END 
		while (cursor != null && (cursor.getType() == AbstractInsnNode.FRAME
				|| cursor.getType() == AbstractInsnNode.LABEL
				|| cursor.getType() == AbstractInsnNode.LINE)) {
			cursor = cursor.getNext();
		}
		return cursor;
	}
","	static AbstractInsnNode skipNonOpcodes(AbstractInsnNode cursor) {
		while (cursor != null && (cursor.getType() == AbstractInsnNode.FRAME
				|| cursor.getType() == AbstractInsnNode.LABEL
				|| cursor.getType() == AbstractInsnNode.LINE)) {
			cursor = cursor.getNext();
		}
		return cursor;
	}
"
1203,`return this.urlString == null || httpMethod == null;`,"    public boolean isValid() {
        if (this.urlString == null || httpMethod == null) {
            return true;
        } else {
            return false;
        }
    }
","    public boolean isValid() {
START         if (this.urlString == null || httpMethod == null) { END 
            return true;
        } else {
            return false;
        }
    }
","    protected boolean isValid() {
        return this.urlString == null || httpMethod == null;
    }
"
1204,"Shouldn't it be `sessionFactories` instead of `this.sessionFactories`? If yes, would it be possible to overload `newAspect` instead of changing its signature?","    public UnitOfWorkAspect newAspect(ImmutableMap<String, SessionFactory> sessionFactories) {
        return new UnitOfWorkAspect(this.sessionFactories);
    }
","    public UnitOfWorkAspect newAspect(ImmutableMap<String, SessionFactory> sessionFactories) {
START         return new UnitOfWorkAspect(this.sessionFactories); END 
    }
","    public UnitOfWorkAspect newAspect(ImmutableMap<String, SessionFactory> sessionFactories) {
        return new UnitOfWorkAspect(sessionFactories);
    }
"
1205,"Enum should not be handled here, should be left to `SerializationContext.canMarshall()` because it needs to check that a custom marshaller was defined for the Enum.","   public boolean isMarshallable(Object o) {
      // Protostream can handle all of these type as well
      if (o instanceof String || o instanceof Long || o instanceof Integer || o instanceof Double || o instanceof Float
            || o instanceof Boolean || o instanceof byte[] || o instanceof Enum) {
         return true;
      }
      return getSerializationContext().canMarshall(o.getClass());
   }
","   public boolean isMarshallable(Object o) {
      // Protostream can handle all of these type as well
      if (o instanceof String || o instanceof Long || o instanceof Integer || o instanceof Double || o instanceof Float
START             || o instanceof Boolean || o instanceof byte[] || o instanceof Enum) { END 
         return true;
      }
      return getSerializationContext().canMarshall(o.getClass());
   }
","   public boolean isMarshallable(Object o) {
      // Protostream can handle all of these type as well
      if (o instanceof String || o instanceof Long || o instanceof Integer || o instanceof Double || o instanceof Float
            || o instanceof Boolean || o instanceof byte[]) {
         return true;
      }
      return getSerializationContext().canMarshall(o.getClass());
   }
"
1206,"static import of createRootScope, and requireActivityScope below?","  private void resetScope() {
    MortarScope root =
        Mortar.createRootScope(false, ObjectGraph.create(new ModuleAndBlueprint(""root"")));
    activityScope = Mortar.requireActivityScope(root, new ModuleAndBlueprint(""activity""));
  }
","  private void resetScope() {
    MortarScope root =
START         Mortar.createRootScope(false, ObjectGraph.create(new ModuleAndBlueprint(""root""))); END 
    activityScope = Mortar.requireActivityScope(root, new ModuleAndBlueprint(""activity""));
  }
","  private void resetScope() {
    MortarScope root = createRootScope(false, ObjectGraph.create(new ModuleAndBlueprint(""root"")));
    activityScope = requireActivityScope(root, new ModuleAndBlueprint(""activity""));
  }
"
1207,"can you add safety checks against `null` or empty strings, plz?","		public Builder withOutputFileset(String fileset){
			this.outputFilesets.add(fileset);
			return this;
		}
","		public Builder withOutputFileset(String fileset){
START 			this.outputFilesets.add(fileset); END 
			return this;
		}
","		public Builder withOutputFileset(String fileset){
			if (fileset!=null && !fileset.isEmpty()){
				this.outputFilesets.add(fileset);
			}
			return this;
		}
"
1208,"This doesn't work. e.g., when you want build the deep representation of a method like this one:

``` java
public void toProvider(Provider<? extends T> provider) {
}
```

The result of `getDeepRepresentation` will be: `void toProvider(javax.inject.Provider,)voidprovider{}`.","	public String getDeepRepresentation(CtElement elem) {
		EqualVisitor prThis = new EqualVisitor();
		prThis.scan(elem);
		return  prThis.getRepresentation();
	}
","START 	public String getDeepRepresentation(CtElement elem) { END 
		EqualVisitor prThis = new EqualVisitor();
		prThis.scan(elem);
		return  prThis.getRepresentation();
	}
","	private String getDeepRepresentation(CtElement elem) {
		EqualVisitor prThis = new EqualVisitor();
		prThis.scan(elem);
		return  prThis.getRepresentation();
	}
"
1209,Can you please check to verify that definedSorts is computed by means of processing every production in the definition? Otherwise this might not work as expected.,"    public KSyntax2GrammarStatesFilter(Context context) {
        super(KSyntax2GrammarStatesFilter.class.getName(), context);

        // create a NonTerminal for every declared sort
        for (String sort : context.definedSorts) {
            NonTerminal nt = new NonTerminal(new NonTerminalId(sort));
            grammar.add(nt);
        }
    }
","    public KSyntax2GrammarStatesFilter(Context context) {
        super(KSyntax2GrammarStatesFilter.class.getName(), context);

        // create a NonTerminal for every declared sort
START         for (String sort : context.definedSorts) { END 
            NonTerminal nt = new NonTerminal(new NonTerminalId(sort));
            grammar.add(nt);
        }
    }
","    public KSyntax2GrammarStatesFilter(Context context) {
        super(KSyntax2GrammarStatesFilter.class.getName(), context);

        // create a NonTerminal for every declared sort
        for (String sort : context.definedSorts) {
            grammar.add(new NonTerminal(sort));
        }
    }
"
1210,The order of colors is changed when the content is changed (e.g. checking/unchecking a counter).,"    protected void clearContent() {
        fXYPresentationProvider.clear();
        getSwtChart().getAxisSet().getXAxis(0).getTick().setFormat(null);
        super.clearContent();
    }
","    protected void clearContent() {
START         fXYPresentationProvider.clear(); END 
        getSwtChart().getAxisSet().getXAxis(0).getTick().setFormat(null);
        super.clearContent();
    }
","    protected void clearContent() {
        getSwtChart().getAxisSet().getXAxis(0).getTick().setFormat(null);
        super.clearContent();
    }
"
1211,why not just call directly `closeContextMenu()`?,"    protected void onNewIntent(Intent intent) {
        // This is called when the user press Home again while already browsing MainActivity
        // onResume() will be called right after, hiding the kissbar if any.
        // http://developer.android.com/reference/android/app/Activity.html#onNewIntent(android.content.Intent)
        // Animation can't happen in this method, since the activity is not resumed yet, so they'll happen in the onResume()
        // https://github.com/Neamar/KISS/issues/569
        if (!searchEditText.getText().toString().isEmpty()) {
            Log.i(TAG, ""Clearing search field"");
            searchEditText.setText("""");
        }

        // Hide kissbar when coming back to kiss
        if (isViewingAllApps()) {
            displayKissBar(false);
        }

        // Close the backButton context menu
        MainActivity.this.closeContextMenu();
    }
","    protected void onNewIntent(Intent intent) {
        // This is called when the user press Home again while already browsing MainActivity
        // onResume() will be called right after, hiding the kissbar if any.
        // http://developer.android.com/reference/android/app/Activity.html#onNewIntent(android.content.Intent)
        // Animation can't happen in this method, since the activity is not resumed yet, so they'll happen in the onResume()
        // https://github.com/Neamar/KISS/issues/569
        if (!searchEditText.getText().toString().isEmpty()) {
            Log.i(TAG, ""Clearing search field"");
            searchEditText.setText("""");
        }

        // Hide kissbar when coming back to kiss
        if (isViewingAllApps()) {
            displayKissBar(false);
        }

        // Close the backButton context menu
START         MainActivity.this.closeContextMenu(); END 
    }
","    protected void onNewIntent(Intent intent) {
        // This is called when the user press Home again while already browsing MainActivity
        // onResume() will be called right after, hiding the kissbar if any.
        // http://developer.android.com/reference/android/app/Activity.html#onNewIntent(android.content.Intent)
        // Animation can't happen in this method, since the activity is not resumed yet, so they'll happen in the onResume()
        // https://github.com/Neamar/KISS/issues/569
        if (!searchEditText.getText().toString().isEmpty()) {
            Log.i(TAG, ""Clearing search field"");
            searchEditText.setText("""");
        }

        // Hide kissbar when coming back to kiss
        if (isViewingAllApps()) {
            displayKissBar(false);
        }

        // Close the backButton context menu
        closeContextMenu();
    }
"
1212,Make the method static,"    private void validateRetentionPolicy(String retentionPolicy) throws FalconException {
        if (!retentionPolicy.equalsIgnoreCase(""delete"")) {
            throw new FalconException(""Retention policy \"""" + retentionPolicy + ""\"" is invalid"");
        }
    }
","START     private void validateRetentionPolicy(String retentionPolicy) throws FalconException { END 
        if (!retentionPolicy.equalsIgnoreCase(""delete"")) {
            throw new FalconException(""Retention policy \"""" + retentionPolicy + ""\"" is invalid"");
        }
    }
","    public static void validateRetentionPolicy(String retentionPolicy) throws FalconException {
        if (!retentionPolicy.equalsIgnoreCase(""delete"")) {
            throw new FalconException(""Retention policy \"""" + retentionPolicy + ""\"" is invalid"");
        }
    }
"
1213,Should this above three lines actually happen in this `if` branch? I don't see why we would need to get `base` if the slice is not compact.,"    public byte[] getData()
    {
        Object base = slice.getBase();
        checkState(base instanceof byte[], ""unexpected serialization type %s"", base.getClass());
        byte[] bytes = (byte[]) base;

        if (slice.isCompact()) {
            return bytes;
        }

        // do a copy
        return slice.getBytes();
    }
","    public byte[] getData()
    {
START         Object base = slice.getBase(); END 
        checkState(base instanceof byte[], ""unexpected serialization type %s"", base.getClass());
        byte[] bytes = (byte[]) base;

        if (slice.isCompact()) {
            return bytes;
        }

        // do a copy
        return slice.getBytes();
    }
","    public byte[] getData()
    {
        if (slice.isCompact()) {
            Object base = slice.getBase();
            checkState(base instanceof byte[], ""unexpected serialization type %s"", base.getClass());
            return (byte[]) base;
        }

        // do a copy
        return slice.getBytes();
    }
"
1214,We should check whether the AbsSendTimeEngine is configured with an extension ID (e.g. getExtensionID() != -1).,"    public HeaderExtension getAbsoluteSendTimeExtension(RawPacket packet)
    {
        if( packet.getExtensionBit() && packet.getHeaderExtensionType()
                        == getAbsSendTimeExtensionID() )
        {
            return packet.getHeaderExtension(getAbsSendTimeExtensionID());
        }
        return null;
    }
","    public HeaderExtension getAbsoluteSendTimeExtension(RawPacket packet)
    {
START         if( packet.getExtensionBit() && packet.getHeaderExtensionType() END 
                        == getAbsSendTimeExtensionID() )
        {
            return packet.getHeaderExtension(getAbsSendTimeExtensionID());
        }
        return null;
    }
","    public HeaderExtension getAbsoluteSendTimeExtension(RawPacket packet)
    {
        if( packet.getExtensionBit() &&
                        getAbsSendTimeExtensionID() != -1 )
        {
            return packet.getHeaderExtension(getAbsSendTimeExtensionID());
        }
        return null;
    }
"
1215,"`@SuppressWarnings(""rawtypes"")`","	public RedisPublishingMessageHandler(RedisConnectionFactory connectionFactory) {
		Assert.notNull(connectionFactory, ""connectionFactory must not be null"");
		this.template = new RedisTemplate();
		this.template.setConnectionFactory(connectionFactory);
		this.template.setEnableDefaultSerializer(false);
		this.template.afterPropertiesSet();
	}
","START 	public RedisPublishingMessageHandler(RedisConnectionFactory connectionFactory) { END 
		Assert.notNull(connectionFactory, ""connectionFactory must not be null"");
		this.template = new RedisTemplate();
		this.template.setConnectionFactory(connectionFactory);
		this.template.setEnableDefaultSerializer(false);
		this.template.afterPropertiesSet();
	}
","	public RedisPublishingMessageHandler(RedisConnectionFactory connectionFactory) {
		Assert.notNull(connectionFactory, ""connectionFactory must not be null"");
		this.template = new RedisTemplate<Object, Object>();
		this.template.setConnectionFactory(connectionFactory);
		this.template.setEnableDefaultSerializer(false);
		this.template.afterPropertiesSet();
	}
"
1216,"I think it's nicer to call the `AnnotationCommandTargetResolver` constructor here, with, as suggested earlier, `this` as the sole parameter, so that the `AnnotationCommandTargetResolver` constructor can pull the `identifierAnnotation` and `versionAnnotation` from it.","		public AnnotationCommandTargetResolver build() {
			try {
				return resolver;
			} finally {
				resolver = null; // builder can only be used once.
			}
		}
","		public AnnotationCommandTargetResolver build() {
START 			try { END 
				return resolver;
			} finally {
				resolver = null; // builder can only be used once.
			}
		}
","        public AnnotationCommandTargetResolver build() {
            return new AnnotationCommandTargetResolver(this);
        }
"
1217,"No `e.printStackTrace()`, please, at all.
It doesn't provide much info and just pollutes logs on CI builds","	protected void doPoll(SourcePollingChannelAdapter adapter) {
		try {
			Method method = AbstractPollingEndpoint.class.getDeclaredMethod(""doPoll"");
			method.setAccessible(true);
			method.invoke(adapter);
		}
		catch (Exception e) {
			e.printStackTrace();
			fail(""Failed to invoke doPoll(): "" + e.toString());
		}
	}
","	protected void doPoll(SourcePollingChannelAdapter adapter) {
		try {
			Method method = AbstractPollingEndpoint.class.getDeclaredMethod(""doPoll"");
			method.setAccessible(true);
			method.invoke(adapter);
		}
		catch (Exception e) {
START 			e.printStackTrace(); END 
			fail(""Failed to invoke doPoll(): "" + e.toString());
		}
	}
","	protected void doPoll(SourcePollingChannelAdapter adapter) {
		try {
			Method method = AbstractPollingEndpoint.class.getDeclaredMethod(""doPoll"");
			method.setAccessible(true);
			method.invoke(adapter);
		}
		catch (Exception e) {
			fail(""Failed to invoke doPoll(): "" + e.toString());
		}
	}
"
1218,nitpick: redundant,"	public CLOption(String opt, String val, String param) {
		super();
		this.opt = opt;
		this.val = val;
		this.param = param;
	}
","	public CLOption(String opt, String val, String param) {
START 		super(); END 
		this.opt = opt;
		this.val = val;
		this.param = param;
	}
","	public CLOption(String opt, String val, String param) {
		this.opt = opt;
		this.val = val;
		this.param = param;
	}
"
1219,Method deprecated. Use `clientBuilder.version()` instead.,"   private RemoteCacheManager createExecClient() {
      org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =
            super.createHotRodClientConfigurationBuilder(servers.get(0).getPort());
      clientBuilder.marshaller(new UTF8StringMarshaller());
      clientBuilder.protocolVersion(getProtocolVersion());
      return new InternalRemoteCacheManager(clientBuilder.build());
   }
","   private RemoteCacheManager createExecClient() {
      org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =
            super.createHotRodClientConfigurationBuilder(servers.get(0).getPort());
      clientBuilder.marshaller(new UTF8StringMarshaller());
START       clientBuilder.protocolVersion(getProtocolVersion()); END 
      return new InternalRemoteCacheManager(clientBuilder.build());
   }
","   private RemoteCacheManager createExecClient() {
      org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =
            super.createHotRodClientConfigurationBuilder(servers.get(0).getPort());
      clientBuilder.marshaller(new UTF8StringMarshaller());
      clientBuilder.version(getProtocolVersion());
      return new InternalRemoteCacheManager(clientBuilder.build());
   }
"
1220,"Visibility missing. Synchronized comes before static
Why return an Iterable here? It would be better just to return a List<TerminatlInfoView>","	static synchronized Iterable<TerminalInfoView> getViews() {
		return new ArrayList<TerminalInfoView>(views);
	}
","START 	static synchronized Iterable<TerminalInfoView> getViews() { END 
		return new ArrayList<TerminalInfoView>(views);
	}
","	private static synchronized Iterable<TerminalInfoView> getViews() {
		return new ArrayList<TerminalInfoView>(views);
	}
"
1221,This might as well become if (enable) since the for loop will end gracefully whether it's > 0 or not.,"	private void setWidgetsEnabled(final boolean enabled,
			final Control... controls) {
		for (Control control : controls) {
			control.setEnabled(enabled);
		}
		// set the focus on the fist element of the group.
		if (controls.length > 0 && enabled) {
			for (Control control : controls) {
				if (control instanceof Text) {
					control.setFocus();
					break;
				}
			}
		}
	}
","	private void setWidgetsEnabled(final boolean enabled,
			final Control... controls) {
		for (Control control : controls) {
			control.setEnabled(enabled);
		}
		// set the focus on the fist element of the group.
		if (controls.length > 0 START  && enabled) END  {
			for (Control control : controls) {
				if (control instanceof Text) {
					control.setFocus();
					break;
				}
			}
		}
	}
","	private void setWidgetsEnabled(final boolean enabled,
			final Control... controls) {
		for (Control control : controls) {
			control.setEnabled(enabled);
		}
		// set the focus on the fist element of the group.
		if (enabled) {
			for (Control control : controls) {
				if (control instanceof Text) {
					control.setFocus();
					break;
				}
			}
		}
	}
"
1222,oh yea. A spy :),"        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object object = method.invoke(producer, args);
            if (method.getName().equals(""produce"") && spiedClasses.contains(object.getClass())) {
                object = spy(object);
            }
            return object;
        }
","        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object object = method.invoke(producer, args);
            if (method.getName().equals(""produce"") && spiedClasses.contains(object.getClass())) {
START                 object = spy(object); END 
            }
            return object;
        }
","        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Object object = method.invoke(producer, args);
            if (object != null && method.getName().equals(""produce"") && spiedClasses.contains(object.getClass())) {
                object = spy(object);
            }
            return object;
        }
"
1223,You should only filter if the filter is enabled. Please be very careful and test your code before submitting anything.,"    private boolean filterInvalid(Position position) {
        return filterInvalid && !position.getValid()
               || position.getLatitude() > 90 || position.getLongitude() > 180
               || position.getLatitude() < -90 || position.getLongitude() < -180;
    }
","    private boolean filterInvalid(Position position) {
        return filterInvalid && !position.getValid()
START                || position.getLatitude() > 90 || position.getLongitude() > 180 END 
               || position.getLatitude() < -90 || position.getLongitude() < -180;
    }
","    private boolean filterInvalid(Position position) {
        if (filterInvalid == true) {
           return !position.getValid() || position.getLatitude() > 90
           || position.getLongitude() > 180 || position.getLatitude() < -90
           || position.getLongitude() < -180;
        }
        return false;
    }
"
1224,getparentDiagram() will be null.. you have to set the container before calling the method.,"    public CreateDDiagramElementCommand(final TransactionalEditingDomain domain, final EObject semantic, final EdgeMapping mapping, final EdgeTarget source, final EdgeTarget target) {
        this(domain, semantic);
        edgeCandidate = new DEdgeCandidate(mapping, semantic, source, target, RefreshIdsHolder.getOrCreateHolder(getParentDiagram()));
        /* store source as container to retrieve later parent diagram */
        this.container = (DragAndDropTarget) source;
    }
","    public CreateDDiagramElementCommand(final TransactionalEditingDomain domain, final EObject semantic, final EdgeMapping mapping, final EdgeTarget source, final EdgeTarget target) {
        this(domain, semantic);
        edgeCandidate = new DEdgeCandidate(mapping, semantic, source, target, RefreshIdsHolder.getOrCreateHolder(getParentDiagram()));
        /* store source as container to retrieve later parent diagram */
        START  this.container = (DragAndDropTarget) source; END 
    }
","    public CreateDDiagramElementCommand(final TransactionalEditingDomain domain, final EObject semantic, final EdgeMapping mapping, final EdgeTarget source, final EdgeTarget target) {
        this(domain, semantic);
        /* store source as container to retrieve later parent diagram */
        this.container = (DragAndDropTarget) source;
        edgeCandidate = new DEdgeCandidate(mapping, semantic, source, target, RefreshIdsHolder.getOrCreateHolder(getParentDiagram()));
    }
"
1225,Declare `columnValuesMap` as `Map`,"	public static GermplasmListNewColumnsInfo createGermplasmListNewColumnsInfo(final String columnHeader, final String columnValue) {
		final GermplasmListNewColumnsInfo germplasmListNewColumnsInfo = new GermplasmListNewColumnsInfo(1);
		final LinkedHashMap<String, List<ListDataColumnValues>> columnValuesMap = new LinkedHashMap<>();
		final List<ListDataColumnValues> listDataColumnValues = new ArrayList<>();
		listDataColumnValues.add(new ListDataColumnValues(columnHeader, 1, columnValue));
		columnValuesMap.put(columnHeader, listDataColumnValues);
		germplasmListNewColumnsInfo.setColumnValuesMap(columnValuesMap);
		germplasmListNewColumnsInfo.addColumn(columnHeader);
		return germplasmListNewColumnsInfo;
	}
","	public static GermplasmListNewColumnsInfo createGermplasmListNewColumnsInfo(final String columnHeader, final String columnValue) {
		final GermplasmListNewColumnsInfo germplasmListNewColumnsInfo = new GermplasmListNewColumnsInfo(1);
START 		final LinkedHashMap<String, List<ListDataColumnValues>> columnValuesMap = new LinkedHashMap<>(); END 
		final List<ListDataColumnValues> listDataColumnValues = new ArrayList<>();
		listDataColumnValues.add(new ListDataColumnValues(columnHeader, 1, columnValue));
		columnValuesMap.put(columnHeader, listDataColumnValues);
		germplasmListNewColumnsInfo.setColumnValuesMap(columnValuesMap);
		germplasmListNewColumnsInfo.addColumn(columnHeader);
		return germplasmListNewColumnsInfo;
	}
","	public static GermplasmListNewColumnsInfo createGermplasmListNewColumnsInfo(final String columnHeader, final String columnValue) {
		final GermplasmListNewColumnsInfo germplasmListNewColumnsInfo = new GermplasmListNewColumnsInfo(1);
		final Map<String, List<ListDataColumnValues>> columnValuesMap = new LinkedHashMap<>();
		final List<ListDataColumnValues> listDataColumnValues = new ArrayList<>();
		listDataColumnValues.add(new ListDataColumnValues(columnHeader, 1, columnValue));
		columnValuesMap.put(columnHeader, listDataColumnValues);
		germplasmListNewColumnsInfo.setColumnValuesMap(columnValuesMap);
		germplasmListNewColumnsInfo.addColumn(columnHeader);
		return germplasmListNewColumnsInfo;
	}
"
1226,"If it is metadata only dump, then need to reset all the table parameters related to stats to false.","  public Tuple<Table> table(final String tableName, HiveConf conf) throws HiveException {
    // Column statistics won't be accurate if we are dumping only metadata
    boolean getColStats = !conf.getBoolVar(HiveConf.ConfVars.REPL_DUMP_METADATA_ONLY);
    return new Tuple<>(functionForSpec, () -> db.getTable(dbName, tableName, false, false,
            getColStats));
  }
","  public Tuple<Table> table(final String tableName, HiveConf conf) throws HiveException {
    // Column statistics won't be accurate if we are dumping only metadata
START     boolean getColStats = !conf.getBoolVar(HiveConf.ConfVars.REPL_DUMP_METADATA_ONLY); END 
    return new Tuple<>(functionForSpec, () -> db.getTable(dbName, tableName, false, false,
            getColStats));
  }
","  public Tuple<Table> table(final String tableName, HiveConf conf) throws HiveException {
    // Column statistics won't be accurate if we are dumping only metadata
    boolean getColStats = !conf.getBoolVar(HiveConf.ConfVars.REPL_DUMP_METADATA_ONLY);
    return new Tuple<>(functionForSpec, () -> db.getTable(dbName, tableName, true, false,
            getColStats));
  }
"
1227,What about returning a `Set` to emphasis that there is no specific order in the returned collection?,"  public List<DeprecatedRuleKeyDto> selectAllDeprecatedRuleKeys(DbSession session) {
    return mapper(session).selectAllDeprecatedRuleKeys();
  }
","START   public List<DeprecatedRuleKeyDto> selectAllDeprecatedRuleKeys(DbSession session) { END 
    return mapper(session).selectAllDeprecatedRuleKeys();
  }
","  public Set<DeprecatedRuleKeyDto> selectAllDeprecatedRuleKeys(DbSession session) {
    return mapper(session).selectAllDeprecatedRuleKeys();
  }
"
1228,It is being calles inside the `UserGroupInformation.setConfiguration`. Please remove that. https://github.com/prestodb/presto/pull/11380#discussion_r214222456,"    public static KerberosHadoopAuthentication createKerberosHadoopAuthentication(KerberosAuthentication kerberosAuthentication, HdfsConfigurationUpdater updater)
    {
        Configuration configuration = getInitialConfiguration();
        updater.updateConfiguration(configuration);

        // In order to enable KERBEROS authentication method for HDFS
        // UserGroupInformation.authenticationMethod static field must be set to KERBEROS
        // It is further used in many places in DfsClient
        configuration.set(""hadoop.security.authentication"", ""kerberos"");

        // Set the static configuration to get the rules.
        try {
            HadoopKerberosName.setConfiguration(configuration);
        }
        catch (IOException exception) {
            throw new UncheckedIOException(exception);
        }
        UserGroupInformation.setConfiguration(configuration);

        return new KerberosHadoopAuthentication(kerberosAuthentication);
    }
","    public static KerberosHadoopAuthentication createKerberosHadoopAuthentication(KerberosAuthentication kerberosAuthentication, HdfsConfigurationUpdater updater)
    {
        Configuration configuration = getInitialConfiguration();
        updater.updateConfiguration(configuration);

        // In order to enable KERBEROS authentication method for HDFS
        // UserGroupInformation.authenticationMethod static field must be set to KERBEROS
        // It is further used in many places in DfsClient
        configuration.set(""hadoop.security.authentication"", ""kerberos"");

        // Set the static configuration to get the rules.
        try {
START             HadoopKerberosName.setConfiguration(configuration); END 
        }
        catch (IOException exception) {
            throw new UncheckedIOException(exception);
        }
        UserGroupInformation.setConfiguration(configuration);

        return new KerberosHadoopAuthentication(kerberosAuthentication);
    }
","    public static KerberosHadoopAuthentication createKerberosHadoopAuthentication(KerberosAuthentication kerberosAuthentication, HdfsConfigurationUpdater updater)
    {
        Configuration configuration = getInitialConfiguration();
        updater.updateConfiguration(configuration);

        // In order to enable KERBEROS authentication method for HDFS
        // UserGroupInformation.authenticationMethod static field must be set to KERBEROS
        // It is further used in many places in DfsClient
        configuration.set(""hadoop.security.authentication"", ""kerberos"");

        UserGroupInformation.setConfiguration(configuration);

        return new KerberosHadoopAuthentication(kerberosAuthentication);
    }
"
1229,Does `TemporaryFolder` not take care of cleanup automagically? Is this not one of the reasons to use it?,"  public void tearDown() throws Exception {
    if (this.fileWatcher != null) {
      this.fileWatcher.close();
    }

    // Cleanup directories
    final Path workDir = PATH.getParent();
    if (Files.exists(workDir)) {
      Files.deleteIfExists(PATH);
    }
  }
","  public void tearDown() throws Exception {
    if (this.fileWatcher != null) {
      this.fileWatcher.close();
    }

    // Cleanup directories
    final Path workDir = PATH.getParent();
    if (Files.exists(workDir)) {
START       Files.deleteIfExists(PATH); END 
    }
  }
","  public void tearDown() throws Exception {
    if (this.fileWatcher != null) {
      this.fileWatcher.close();
    }
  }
"
1230,"@vkuchyn didn't get, why these 2 lines are still here?
I thought they were added to cover ""happy path"", no?
If yes, they should be removed","    public List<String> firstTen(final String... args) {
        final List<String> list = new ArrayList<String>(args.length);
        list.addAll(Arrays.asList(args));
        final List<String> result = new LinkedList<>();
        result.addAll(list.subList(0, InvalidDiamondsUsage.TEN));
        return result;
    }
","    public List<String> firstTen(final String... args) {
        final List<String> list = new ArrayList<String>(args.length);
        list.addAll(Arrays.asList(args));
START         final List<String> result = new LinkedList<>(); END 
        result.addAll(list.subList(0, InvalidDiamondsUsage.TEN));
        return result;
    }
","    public List<String> firstTen(final String... args) {
        final List<String> list = new ArrayList<String>(args.length);
        list.addAll(Arrays.asList(args));
        return list;
    }
"
1231,List,"  List<Object> getColumn(int columnIndex) {
    ArrayList<Object> result = new ArrayList<Object>();
    for (Object[] compoundDatum : compoundData) {
      result.add(compoundDatum[columnIndex]);
    }
    return result;
  }
","  List<Object> getColumn(int columnIndex) {
START     ArrayList<Object> result = new ArrayList<Object>(); END 
    for (Object[] compoundDatum : compoundData) {
      result.add(compoundDatum[columnIndex]);
    }
    return result;
  }
","  public List<Object> getColumn(int columnIndex) {
    List<Object> result = new ArrayList<>();
    for (Object[] compoundDatum : compoundData) {
      result.add(compoundDatum[columnIndex]);
    }
    return result;
  }
"
1232,use if else or the ternary,"  private static CharSequence getScreenSecuritySummary(Context context) {
    final int    screenSecurityResId = R.string.preferences__screen_security_summary;
    final String onRes               = context.getString(R.string.ApplicationPreferencesActivity_on);
    final String offRes              = context.getString(R.string.ApplicationPreferencesActivity_off);

    if (TextSecurePreferences.isScreenSecurityEnabled(context))
      return context.getString(screenSecurityResId, onRes);

    return context.getString(screenSecurityResId, offRes);
  }
","  private static CharSequence getScreenSecuritySummary(Context context) {
    final int    screenSecurityResId = R.string.preferences__screen_security_summary;
    final String onRes               = context.getString(R.string.ApplicationPreferencesActivity_on);
    final String offRes              = context.getString(R.string.ApplicationPreferencesActivity_off);

    if (TextSecurePreferences.isScreenSecurityEnabled(context))
      return context.getString(screenSecurityResId, onRes);

START     return context.getString(screenSecurityResId, offRes); END 
  }
","  private static CharSequence getScreenSecuritySummary(Context context) {
    final int    screenSecurityResId = R.string.preferences__screen_security_summary;
    final String onRes               = context.getString(R.string.ApplicationPreferencesActivity_on);
    final String offRes              = context.getString(R.string.ApplicationPreferencesActivity_off);

    if (TextSecurePreferences.isScreenSecurityEnabled(context)) {
      return context.getString(screenSecurityResId, onRes);
    } else {
      return context.getString(screenSecurityResId, offRes);
    }
  }
"
1233,"Does this mean that initially we try to load the data using this callback? We are also loading it manually, right? How do we prevent loading twice?","    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
        // If the total item count is zero and the previous isn't, assume the
        // list is invalidated and should be reset back to initial state
        if (totalItemCount < mPreviousTotalItemCount) {
            mCurrentPage = mStartingPageIndex;
            mPreviousTotalItemCount = totalItemCount;
            if (totalItemCount == 0) {
                mLoading = true;
            }
        }
        // If it's still loading, we check to see if the dataset count has
        // changed, if so we conclude it has finished loading and update the current page
        // number and total item count.
        if (mLoading && (totalItemCount > mPreviousTotalItemCount)) {
            mLoading = false;
            mPreviousTotalItemCount = totalItemCount;
            mCurrentPage++;
        }

        // If it isn't currently loading, we check to see if we have breached
        // the visibleThreshold and need to reload more data.
        // If we do need to reload some more data, we execute onLoadMore to fetch the data.
        if (!mLoading && (totalItemCount - visibleItemCount) <= (firstVisibleItem + mVisibleThreshold)) {
            mLoading = onLoadMore(mCurrentPage + 1, totalItemCount);
        }
    }
","    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
        // If the total item count is zero and the previous isn't, assume the
        // list is invalidated and should be reset back to initial state
        if (totalItemCount < mPreviousTotalItemCount) {
            mCurrentPage = mStartingPageIndex;
            mPreviousTotalItemCount = totalItemCount;
            if (totalItemCount == 0) {
START                 mLoading = true; END 
            }
        }
        // If it's still loading, we check to see if the dataset count has
        // changed, if so we conclude it has finished loading and update the current page
        // number and total item count.
        if (mLoading && (totalItemCount > mPreviousTotalItemCount)) {
            mLoading = false;
            mPreviousTotalItemCount = totalItemCount;
            mCurrentPage++;
        }

        // If it isn't currently loading, we check to see if we have breached
        // the visibleThreshold and need to reload more data.
        // If we do need to reload some more data, we execute onLoadMore to fetch the data.
        if (!mLoading && (totalItemCount - visibleItemCount) <= (firstVisibleItem + mVisibleThreshold)) {
            mLoading = onLoadMore(mCurrentPage + 1, totalItemCount);
        }
    }
","    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
        // If the total item count is zero and the previous isn't, assume the
        // list is invalidated and should be reset back to initial state
        if (totalItemCount < mPreviousTotalItemCount) {
            mCurrentPage = mStartingPageIndex;
            mPreviousTotalItemCount = totalItemCount;
            if (totalItemCount == 0) {
                mLoading = true;
            }
        }
        // If it's still loading, we check to see if the dataset count has
        // changed, if so we conclude it has finished loading and update the current page
        // number and total item count.
        if (mLoading && (totalItemCount > mPreviousTotalItemCount)) {
            mLoading = false;
            mPreviousTotalItemCount = totalItemCount;
            mCurrentPage++;
        }

        // If it isn't currently loading, we check to see if we have breached
        // the visibleThreshold and need to reload more data.
        // If we do need to reload some more data, we execute onLoadMore to fetch the data.
        if (!mLoading && (totalItemCount - visibleItemCount) <= (firstVisibleItem + mVisibleThreshold)) {
            mLoading = onLoadMore(mCurrentPage + 1);
        }
    }
"
1234,Return the String.join directly without creating the new String,"  private String buildJsArray(List<ContentType> types) {
    String typeStr = String.join("","", types.stream().map(t ->  t.id() ).collect(Collectors.toList()));
    return  typeStr ;

  }
","  private String buildJsArray(List<ContentType> types) {
START     String typeStr = String.join("","", types.stream().map(t ->  t.id() ).collect(Collectors.toList())); END 
    return  typeStr ;

  }
","  private String buildJsArray(List<ContentType> types) {
    return String.join("","", types.stream().map(t ->  t.id() ).collect(Collectors.toList()));

  }
"
1235,"This is a tiny micro-optimization but I'll mention it since it might add to readability: 
`Sets.newHashSet(s.split("","")`","    public void setWhiteListedAgencies(String s) {
        if (s != null && !s.equals(""""))
            whiteListedAgencies = new HashSet<String>(Arrays.asList(s.split("","")));
    }
","    public void setWhiteListedAgencies(String s) {
        if (s != null && !s.equals(""""))
START             whiteListedAgencies = new HashSet<String>(Arrays.asList(s.split("",""))); END 
    }
","    public void setWhiteListedAgencies(String s) {
        if (!s.isEmpty()) {
            whiteListedAgencies = new HashSet<>();
            Collections.addAll(whiteListedAgencies, s.split("",""));
        }
    }
"
1236,"I'm a bit confused about the exception catching here.  The getCause can't fail.. So either error is null, or it isn't an ErrorResponse; both cases can be handled with a check.","    private Throwable unwrap(Object error) {
        try {
            return ((ErrorResponse) error).getCause();
        } catch (Exception e) {
            return (Throwable) error;
        }
    }
","    private Throwable unwrap(Object error) {
        try {
            return ((ErrorResponse) error).getCause();
START         } catch (Exception e) { END 
            return (Throwable) error;
        }
    }
","    private Throwable unwrap(Object error) {
        if (error instanceof ErrorResponse) {
            return ((ErrorResponse) error).getCause();
        }

        return (Throwable) error;
    }
"
1237,swallowing the exception? is it intentionally or by mistake?,"        public void run() {
            try {
                this.thread.dispatch();
            } catch (final InterruptedException ex) {
                Thread.currentThread().interrupt();
                Logger.warn(this, ""%s"", ex);
            // @checkstyle IllegalCatch (1 line)
            } catch (final Throwable ex) {
                Logger.error(this, ""%s"", ExceptionUtils.getStackTrace(ex));
            }
        }
","        public void run() {
            try {
                this.thread.dispatch();
            } catch (final InterruptedException ex) {
                Thread.currentThread().interrupt();
                Logger.warn(this, ""%s"", ex);
            // @checkstyle IllegalCatch (1 line)
            } catch (final Throwable ex) {
START                 Logger.error(this, ""%s"", ExceptionUtils.getStackTrace(ex)); END 
            }
        }
","        public void run() {
            try {
                this.thread.dispatch();
            } catch (final InterruptedException ex) {
                Thread.currentThread().interrupt();
                Logger.warn(this, ""%s"", ex);
            }
        }
"
1238,"`proxiedHandler` can be `null` here and in the next method, right?","    public boolean isRedirectRequested(HttpResponse httpResponse, HttpContext httpContext) {
      return proxiedHandler.isRedirectRequested(httpResponse, httpContext);
    }
","    public boolean isRedirectRequested(HttpResponse httpResponse, HttpContext httpContext) {
START       return proxiedHandler.isRedirectRequested(httpResponse, httpContext); END 
    }
","    public boolean isRedirectRequested(HttpResponse httpResponse, HttpContext httpContext) {
      return proxiedHandler != null
          ? proxiedHandler.isRedirectRequested(httpResponse, httpContext) : false;
    }
"
1239,Should be set in field declaration.,"    public Post() {
        this.postContent = randomAlphanumeric(100);
    }
","    public Post() {
START         this.postContent = randomAlphanumeric(100); END 
    }
","    public Post() {}
"
1240,`private` -> `protected`,"    private boolean acceptGroup(NuxeoPrincipal originatingPrincipal, String groupName) {
        return originatingPrincipal.isAdministrator() || originatingPrincipal.getAllGroups().contains(groupName);
    }
","START     private boolean acceptGroup(NuxeoPrincipal originatingPrincipal, String groupName) { END 
        return originatingPrincipal.isAdministrator() || originatingPrincipal.getAllGroups().contains(groupName);
    }
","    protected boolean acceptGroup(NuxeoPrincipal originatingPrincipal, String groupName) {
        return originatingPrincipal.isAdministrator() || originatingPrincipal.getAllGroups().contains(groupName);
    }
"
1241,what for you call load?,"    public void start() throws Exception {
        load();
        VIEW_INJECTED_VARS.setEnabled(getConfiguration().isEnablePermissions());
    }  
","    public void start() throws Exception {
START         load(); END 
        VIEW_INJECTED_VARS.setEnabled(getConfiguration().isEnablePermissions());
    }  
","    public void start() throws Exception {
        VIEW_INJECTED_VARS.setEnabled(getConfiguration().isEnablePermissions());
    }  
"
1242,Could you change this to (i=length-1; i >= 0; i--) such that you don't have to the extra subtraction below.,"  public static SchemaPath getCompoundPath(String... strings) {
    NameSegment s = null;
    final int length = strings.length;
    // loop through strings in reverse order
    for (int i = 0; i < length; i++) {
      s = new NameSegment(strings[length - 1 - i], s);
    }
    return new SchemaPath(s);
  }
","  public static SchemaPath getCompoundPath(String... strings) {
    NameSegment s = null;
    final int length = strings.length;
    // loop through strings in reverse order
START     for (int i = 0; i < length; i++) { END 
      s = new NameSegment(strings[length - 1 - i], s);
    }
    return new SchemaPath(s);
  }
","  public static SchemaPath getCompoundPath(String... strings) {
    NameSegment s = null;
    // loop through strings in reverse order
    for (int i = strings.length - 1; i >= 0; i--) {
      s = new NameSegment(strings[i], s);
    }
    return new SchemaPath(s);
  }
"
1243,Code in register() could be done directly in constructor of SaveSessionWhenNoDialectEditorsListener,"    private void initListeners() {
        this.restoreToSavePointListener = new RestoreToLastSavePointListener(session);
        this.restoreToSavePointListener.register();
        this.saveSessionListener = new SaveSessionWhenNoDialectEditorsListener(session);
        this.saveSessionListener.register();
    }
","    private void initListeners() {
        this.restoreToSavePointListener = new RestoreToLastSavePointListener(session);
        this.restoreToSavePointListener.register();
        this.saveSessionListener = new SaveSessionWhenNoDialectEditorsListener(session);
        START this.saveSessionListener.register(); END 
    }
","    private void initListeners() {
        this.restoreToSavePointListener = new RestoreToLastSavePointListener(session);
        this.saveSessionListener = new SaveSessionWhenNoDialectEditorsListener(session);
        this.saveSessionListener.register();
    }
"
1244,Suggest retaining untranslated strings and translating during rendering.,"    private void prepare(ControlWidget screen) {
        InjectionHelper.inject(screen);
        translator.updateWidget(screen);
        screen.onOpened();
    }
","    private void prepare(ControlWidget screen) {
        InjectionHelper.inject(screen);
START         translator.updateWidget(screen); END 
        screen.onOpened();
    }
","    private void prepare(ControlWidget screen) {
        InjectionHelper.inject(screen);
        screen.onOpened();
    }
"
1245,This is unnecessary,"    public void setWriteBuffer(ByteBuffer buffer) {
        writeBuffer = null;
        writeBuffer = buffer;
    }
","    public void setWriteBuffer(ByteBuffer buffer) {
START         writeBuffer = null; END 
        writeBuffer = buffer;
    }
","    public void setWriteBuffer(ByteBuffer buffer) {
        writeBuffer = buffer;
    }
"
1246,"We don't want to lock inside the try (see the [JavaDoc](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html)). The reason is that if lock.lock() did in fact throw a RuntimeException, then the unlock could cause some unexpected results (since it's re-entrant, it could unlock one more level than intended, for example).","    protected Supplier<?> putSupplier(Map<String,String> map, int key) {
        return (()-> {
            try {
                lock.lock();
                return map.put(""key"" + key, ""value"" + key);
            } finally {
                lock.unlock();
            }
        });
    }
","    protected Supplier<?> putSupplier(Map<String,String> map, int key) {
        return (()-> {
            try {
START                 lock.lock(); END 
                return map.put(""key"" + key, ""value"" + key);
            } finally {
                lock.unlock();
            }
        });
    }
","    protected Supplier<?> putSupplier(Map<String,String> map, int key) {
        return (()-> {
            lock.lock();
            try {
                return map.put(""key"" + key, ""value"" + key);
            } finally {
                lock.unlock();
            }
        });
    }
"
1247,same for thos changes,"    public void init() {
        service = new TransformationEngineService();
        EKBModelGraph graph = EKBModelGraph.getInstance();
        ModelRegistryService registry = ModelRegistryService.getInstance(null);
        registry.setEkbClassLoader(new EKBTestClassLoader());
        registry.setGraphDb(graph);
        service.setModelRegistry(registry);
        service.setGraphDb(graph);
        graph.addModel(getModelADescription());
        graph.addModel(getModelBDescription());
        graph.addModel(getModelCDescription());
    }
","    public void init() {
        service = new TransformationEngineService();
        EKBModelGraph graph = EKBModelGraph.getInstance();
START         ModelRegistryService registry = ModelRegistryService.getInstance(null); END 
        registry.setEkbClassLoader(new EKBTestClassLoader());
        registry.setGraphDb(graph);
        service.setModelRegistry(registry);
        service.setGraphDb(graph);
        graph.addModel(getModelADescription());
        graph.addModel(getModelBDescription());
        graph.addModel(getModelCDescription());
    }
","    public void init() {
        service = new TransformationEngineService();
        EKBModelGraph graph = EKBModelGraph.getInstance();
        ModelRegistryService registry = ModelRegistryService.getInstance(context);
        registry.setEkbClassLoader(new EKBTestClassLoader());
        registry.setGraphDb(graph);
        service.setModelRegistry(registry);
        service.setGraphDb(graph);
        graph.addModel(getModelADescription());
        graph.addModel(getModelBDescription());
        graph.addModel(getModelCDescription());
    }
"
1248,Can we move to https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html yet?,"  public void makeOmeTiff(final String name, final CoreMetadata info)
    throws FormatException, IOException
  {
    final String id = getId(name);
    final OMETiffWriter out = createWriter(name, info, id);
    writeData(name, info, id, out);
    out.close();
  }
","  public void makeOmeTiff(final String name, final CoreMetadata info)
    throws FormatException, IOException
  {
    final String id = getId(name);
    final OMETiffWriter out = createWriter(name, info, id);
    writeData(name, info, id, out);
START     out.close(); END 
  }
","  public void makeOmeTiff(final String name, final CoreMetadata info)
    throws FormatException, IOException
  {
    final String id = getId(name);
    try (OMETiffWriter out = createWriter(name, info, id)) {
      writeData(name, info, id, out);
    }
  }
"
1249,"Again, variable name","	private String removeUnprintableChars(String text) {
		StringBuilder stringbuilder = new StringBuilder();
		
		for(char c0 : text.toCharArray()) {
			if (c0 != 167 && c0 != 127) {
				stringbuilder.append(c0);
			}
		}
		
		return stringbuilder.toString();
	}
","	private String removeUnprintableChars(String text) {
		StringBuilder stringbuilder = new StringBuilder();
		
START 		for(char c0 : text.toCharArray()) { END 
			if (c0 != 167 && c0 != 127) {
				stringbuilder.append(c0);
			}
		}
		
		return stringbuilder.toString();
	}
","	private String removeUnprintableChars(String text) 
	{
		StringBuilder stringbuilder = new StringBuilder();
		
		for(char c0 : text.toCharArray())
			if (c0 != 167 && c0 != 127) 
				stringbuilder.append(c0);
			
		
		
		return stringbuilder.toString();
	}
"
1250,nit: Remove extra brackets,"  public void startLog() {
    (new RangerLoadBegin(sourceDbName, targetDbName, estimatedNumPolicies)).log(LogTag.RANGER_LOAD_START);
  }
","  public void startLog() {
START     (new RangerLoadBegin(sourceDbName, targetDbName, estimatedNumPolicies)).log(LogTag.RANGER_LOAD_START); END 
  }
","  public void startLog() {
    new RangerLoadBegin(sourceDbName, targetDbName, estimatedNumPolicies).log(LogTag.RANGER_LOAD_START);
  }
"
1251,please remove redundant ```final``` modifiers for parameters.,"  public QueryContext(final UserSession session, final DrillbitContext drillbitContext, QueryId queryId) {
    this(session, drillbitContext, queryId, null);
  }
","  public QueryContext(final UserSession session, final DrillbitContext drillbitContext, QueryId queryId) {
START     this(session, drillbitContext, queryId, null); END 
  }
","  public QueryContext(final UserSession session, final DrillbitContext drillbitContext, QueryId queryId) {
    this(session, drillbitContext, queryId, 0);
  }
"
1252,"i would just simply do this (here and method below):
```
        try ( ReadOnlyFulltext indexReader = provider.getReader( BLOOM_NODES, FulltextProvider.FulltextIndexType.NODES ) )
        {
            return queryAsStream( terms, indexReader );
        }
```","    public Stream<Output> bloomFulltextNodes( @Name( ""terms"" ) List<String> terms ) throws Exception
    {
        Stream<Output> stream;
        try ( ReadOnlyFulltext indexReader = provider.getReader( BLOOM_NODES, FulltextProvider.FulltextIndexType.NODES ) )
        {
            stream = queryAsStream( terms, indexReader );
        }
        return stream;
    }
","    public Stream<Output> bloomFulltextNodes( @Name( ""terms"" ) List<String> terms ) throws Exception
    {
START         Stream<Output> stream; END 
        try ( ReadOnlyFulltext indexReader = provider.getReader( BLOOM_NODES, FulltextProvider.FulltextIndexType.NODES ) )
        {
            stream = queryAsStream( terms, indexReader );
        }
        return stream;
    }
","    public Stream<Output> bloomFulltextNodes( @Name( ""terms"" ) List<String> terms ) throws Exception
    {
        try ( ReadOnlyFulltext indexReader = provider.getReader( BLOOM_NODES, FulltextProvider.FulltextIndexType.NODES ) )
        {
            return queryAsStream( terms, indexReader );
        }
    }
"
1253,"DTOs should represent what came from the exchange, this is premature adaptation and should not be here","  public LgoProductCurrency(
      @JsonProperty(""id"") String id,
      @JsonProperty(""increment"") BigDecimal increment,
      @JsonProperty(""limits"") LgoLimit limits) {
    this.id = id;
    this.increment = increment != null ? increment.stripTrailingZeros() : null;
    this.limits = limits;
  }
","  public LgoProductCurrency(
      @JsonProperty(""id"") String id,
      @JsonProperty(""increment"") BigDecimal increment,
      @JsonProperty(""limits"") LgoLimit limits) {
    this.id = id;
START     this.increment = increment != null ? increment.stripTrailingZeros() : null; END 
    this.limits = limits;
  }
","  public LgoProductCurrency(
      @JsonProperty(""id"") String id,
      @JsonProperty(""increment"") BigDecimal increment,
      @JsonProperty(""limits"") LgoLimit limits) {
    this.id = id;
    this.increment = increment;
    this.limits = limits;
  }
"
1254,Put in one line,"private Menu createSortMenu() {
	Menu submenu = new Menu(shell, SWT.DROP_DOWN);
	MenuItem subitem;
	for(int i = 0; i < columnNames.length; i++) {
		subitem = new MenuItem (submenu, SWT.NONE);
		subitem.setText(columnNames [i]);
		final int column = i;
		subitem.addSelectionListener(widgetSelectedAdapter( e -> {
			sort(column);
		}));

	}

	return submenu;
}
","private Menu createSortMenu() {
	Menu submenu = new Menu(shell, SWT.DROP_DOWN);
	MenuItem subitem;
	for(int i = 0; i < columnNames.length; i++) {
		subitem = new MenuItem (submenu, SWT.NONE);
		subitem.setText(columnNames [i]);
		final int column = i;
		subitem.addSelectionListener(widgetSelectedAdapter( e -> {
START 			sort(column); END 
		}));

	}

	return submenu;
}
","private Menu createSortMenu() {
	Menu submenu = new Menu(shell, SWT.DROP_DOWN);
	MenuItem subitem;
	for(int i = 0; i < columnNames.length; i++) {
		subitem = new MenuItem (submenu, SWT.NONE);
		subitem.setText(columnNames [i]);
		final int column = i;
		subitem.addSelectionListener(widgetSelectedAdapter( e -> sort(column)));

	}

	return submenu;
}
"
1255,Could be a try-with-resources.,"    public static Properties loadPropertyFile(Resource f) throws IOException {
        InputStream in = f.in();
        try {
            return loadUniversal(in);
        }
        finally {
            in.close();
        }
    }
","    public static Properties loadPropertyFile(Resource f) throws IOException {
        InputStream in = f.in();
        try {
            return loadUniversal(in);
        }
        finally {
START             in.close(); END 
        }
    }
","    public static Properties loadPropertyFile(Resource f) throws IOException {
        try (InputStream in = f.in()) {
            return loadUniversal(in);
        }
    }
"
1256,keep Optional return parameter in all enums,"  public static ETwitterCardType getTwitterCardType(@Nullable String identifier) {
    return ID_MAP.get(identifier).get();
  }
","START   public static ETwitterCardType getTwitterCardType(@Nullable String identifier) { END 
    return ID_MAP.get(identifier).get();
  }
","  public static Optional<ETwitterCardType> getTwitterCardType(@Nullable String identifier) {
    return ID_MAP.get(identifier);
  }
"
1257,wondering if we should also warm up level1 cache when there is a miss in l1 cache and hit in l2 cache ?,"  public byte[] get(NamedKey key)
  {
    byte[] res = level1.get(key);
    if (res == null) {
      res = level2.get(key);
    }
    if (res == null) {
      missCount.incrementAndGet();
    } else {
      put(key, res);
      hitCount.incrementAndGet();
    }
    return res;
  }
","  public byte[] get(NamedKey key)
  {
    byte[] res = level1.get(key);
    if (res == null) {
START       res = level2.get(key); END 
    }
    if (res == null) {
      missCount.incrementAndGet();
    } else {
      put(key, res);
      hitCount.incrementAndGet();
    }
    return res;
  }
","  public byte[] get(NamedKey key)
  {
    byte[] res = level1.get(key);
    if (res == null) {
      res = level2.get(key);
      if(res != null) {
        level1.put(key, res);
        hitCount.incrementAndGet();
        return res;
      }
      missCount.incrementAndGet();
    }
    if (res != null) {
      hitCount.incrementAndGet();
    }
    return res;
  }
"
1258,private?,"    public Statistic createHugePagesFree(HugePage page) {
        return setDatum(
                create(""hugepages."" + page.getSizeKB() + "".free"", ""Amount of free huge pages of the given size"", GAUGE, NONE, INTEGER),
                page.getAmount());
    }
","    START  public Statistic END  createHugePagesFree(HugePage page) {
        return setDatum(
                create(""hugepages."" + page.getSizeKB() + "".free"", ""Amount of free huge pages of the given size"", GAUGE, NONE, INTEGER),
                page.getAmount());
    }
","    private Statistic createHugePagesFree(HugePage page) {
        return setDatum(
                create(""hugepages."" + page.getSizeKB() + "".free"", ""Amount of free huge pages of the given size"", GAUGE, NONE, INTEGER),
                page.getAmount());
    }
"
1259,"imho we can do the equals check once in the constructor, store the result in an field and so reduce the overhead even more..","    private void encodeComponent(CharSequence s) {
        if (CharsetUtil.UTF_8.equals(charset)) {
            encodeUtf8Component(s);
        } else {
            encodeNonUtf8Component(s);
        }
    }
","    private void encodeComponent(CharSequence s) {
START         if (CharsetUtil.UTF_8.equals(charset)) { END 
            encodeUtf8Component(s);
        } else {
            encodeNonUtf8Component(s);
        }
    }
","    private void encodeComponent(CharSequence s) {
        if (charset == null) {
            encodeUtf8Component(s);
        } else {
            encodeNonUtf8Component(s);
        }
    }
"
1260,not necessary since JVM initializes all object fields to null,"   public MatchingApplicabilityTagsRule(IAtsClient atsClient) {
      this.atsClient = atsClient;
      featureDefinitionData = null;
      validFeatureValues = null;
   }
","   public MatchingApplicabilityTagsRule(IAtsClient atsClient) {
      this.atsClient = atsClient;
      featureDefinitionData = null;
START       validFeatureValues = null; END 
   }
","   public MatchingApplicabilityTagsRule(IAtsClient atsClient) {
      this.atsClient = atsClient;
   }
"
1261,"```
 Assert.assertTrue(jq(""$innerLabel"").exists());
 Assert.assertEquals(jq(""$innerLabel"").text(), ""someValue"");
```","    public void test() {
        connect();
        Assert.assertEquals(jq(""$innerLabel"").text(), ""someValue"");
    }
","    public void test() {
START         connect(); END 
        Assert.assertEquals(jq(""$innerLabel"").text(), ""someValue"");
    }
","    public void test() {
        connect();
        Assert.assertTrue(jq(""$innerLabel"").exists());
        Assert.assertEquals(jq(""$innerLabel"").text(), ""someValue"");
    }
"
1262,final,"    public void addResolverListener(String expression, ResolverListener listener)
            throws CloudnameException {
        DynamicExpression dynamicExpression =
                new DynamicExpression(expression, listener, this, zkGetter);

        synchronized (dynamicAddressMonitor) {
            DynamicExpression previousExpression = dynamicAddressesByListener.put(
                    listener, dynamicExpression);
            if (previousExpression != null) {
                throw new IllegalArgumentException(""It is not legal to register a listener twice."");
            }
        }
        dynamicExpression.start();
    }
","    public void addResolverListener(String expression, ResolverListener listener)
            throws CloudnameException {
START         DynamicExpression dynamicExpression = END 
                new DynamicExpression(expression, listener, this, zkGetter);

        synchronized (dynamicAddressMonitor) {
            DynamicExpression previousExpression = dynamicAddressesByListener.put(
                    listener, dynamicExpression);
            if (previousExpression != null) {
                throw new IllegalArgumentException(""It is not legal to register a listener twice."");
            }
        }
        dynamicExpression.start();
    }
","    public void addResolverListener(String expression, ResolverListener listener)
            throws CloudnameException {
        final DynamicExpression dynamicExpression =
                new DynamicExpression(expression, listener, this, zkGetter);

        synchronized (dynamicAddressMonitor) {
            DynamicExpression previousExpression = dynamicAddressesByListener.put(
                    listener, dynamicExpression);
            if (previousExpression != null) {
                throw new IllegalArgumentException(""It is not legal to register a listener twice."");
            }
        }
        dynamicExpression.start();
    }
"
1263,"I think we should extend the DBConnection interface to have a clearCache() & have the hibernate implementation call this clear.
Having it in here ties the context object to close to the hibernate implementation (which I want to avoid if we ever want to drop hibernate).","    public void clearCache() throws SQLException {
    	((Session)this.getDBConnection().getSession()).clear();
    }
","    public void clearCache() throws SQLException {
START     	((Session)this.getDBConnection().getSession()).clear(); END 
    }
","    public void clearCache() throws SQLException {
    	this.getDBConnection().clearCache();
    }
"
1264,`RuntimeException`?,"    private Optional<LocalMemoryContext> getSystemMemoryContext()
    {
        try {
            return Optional.of(systemMemoryContextSupplier.get());
        }
        catch (Exception ignored) {
            // This is possible with races, e.g., a task is created and then immediately aborted,
            // so that the task context hasn't been created yet (as a result there's no memory context available).
        }
        return Optional.empty();
    }
","    private Optional<LocalMemoryContext> getSystemMemoryContext()
    {
        try {
            return Optional.of(systemMemoryContextSupplier.get());
        }
START         catch (Exception ignored) { END 
            // This is possible with races, e.g., a task is created and then immediately aborted,
            // so that the task context hasn't been created yet (as a result there's no memory context available).
        }
        return Optional.empty();
    }
","    private Optional<LocalMemoryContext> getSystemMemoryContext()
    {
        try {
            return Optional.of(systemMemoryContextSupplier.get());
        }
        catch (RuntimeException ignored) {
            // This is possible with races, e.g., a task is created and then immediately aborted,
            // so that the task context hasn't been created yet (as a result there's no memory context available).
        }
        return Optional.empty();
    }
"
1265,Missing filter expression?,"    private boolean isFilterExpressionValid(InetAddress inetAddress, String filterExpression) {
        // Consider profiles without filter expression or an empty one as matching.
        if (Strings.isNullOrEmpty(filterExpression)) {
            return true;
        } else {
            try {
                return filterDao.isValid(inetAddress.getHostAddress(), filterExpression);
            } catch (FilterParseException e) {
                LOG.warn(""Filter expression '{}' is invalid. "", e);
            }
        }
        return false;
    }
","    private boolean isFilterExpressionValid(InetAddress inetAddress, String filterExpression) {
        // Consider profiles without filter expression or an empty one as matching.
        if (Strings.isNullOrEmpty(filterExpression)) {
            return true;
        } else {
            try {
                return filterDao.isValid(inetAddress.getHostAddress(), filterExpression);
            } catch (FilterParseException e) {
START                 LOG.warn(""Filter expression '{}' is invalid. "", e); END 
            }
        }
        return false;
    }
","    private boolean isFilterExpressionValid(InetAddress inetAddress, String filterExpression) {
        // Consider profiles without filter expression or an empty one as matching.
        if (Strings.isNullOrEmpty(filterExpression)) {
            return true;
        } else {
            try {
                return filterDao.isValid(inetAddress.getHostAddress(), filterExpression);
            } catch (FilterParseException e) {
                LOG.warn(""Filter expression '{}' is invalid. "", filterExpression, e);
            }
        }
        return false;
    }
"
1266,"```suggestion
        assertNull(r.jenkins.getNode(""foo""));
```

since it is not otherwise obvious that the node’s name did not change somewhere in here.","    public void replaceNodeShouldRemoveOldNode() throws Exception {
        Node oldNode = r.createSlave(""foo"", """", null);
        Node newNode = r.createSlave(""foo-new"", """", null);
        r.jenkins.addNode(oldNode);
        r.jenkins.getNodesObject().replaceNode(oldNode, newNode);
        r.jenkins.getNodesObject().load();
        assertNull(r.jenkins.getNode(oldNode.getNodeName()));
    }
","    public void replaceNodeShouldRemoveOldNode() throws Exception {
        Node oldNode = r.createSlave(""foo"", """", null);
        Node newNode = r.createSlave(""foo-new"", """", null);
        r.jenkins.addNode(oldNode);
        r.jenkins.getNodesObject().replaceNode(oldNode, newNode);
        r.jenkins.getNodesObject().load();
START         assertNull(r.jenkins.getNode(oldNode.getNodeName())); END 
    }
","    public void replaceNodeShouldRemoveOldNode() throws Exception {
        Node oldNode = r.createSlave(""foo"", """", null);
        Node newNode = r.createSlave(""foo-new"", """", null);
        r.jenkins.addNode(oldNode);
        r.jenkins.getNodesObject().replaceNode(oldNode, newNode);
        r.jenkins.getNodesObject().load();
        assertNull(r.jenkins.getNode(""foo""));
    }
"
1267,"Don't have it as a parameter then!

I guess it was just easier to copy and paste the code used before, but now delegate to the View interface.","    protected void rename() {
        if ( isDirty() ) {
            view.showYesNoCancelPopup( CommonConstants.INSTANCE.Information(),
                    Constants.INSTANCE.modelEditor_confirm_save_before_rename(),
                    new Command() {
                        @Override
                        public void execute() {
                            rename( true );
                        }
                    },
                    new Command() {
                        @Override
                        public void execute() {
                            rename( false );
                        }
                    },
                    new Command() {
                        @Override
                        public void execute() {
                            //do nothing.
                        }
                    }
            );
        } else {
            //just rename.
            rename( false );
        }
    }
","    protected void rename() {
        if ( isDirty() ) {
            view.showYesNoCancelPopup( CommonConstants.INSTANCE.Information(),
                    Constants.INSTANCE.modelEditor_confirm_save_before_rename(),
                    new Command() {
                        @Override
                        public void execute() {
                            rename( true );
                        }
                    },
                    new Command() {
                        @Override
                        public void execute() {
                            rename( false );
                        }
                    },
START                     new Command() { END 
                        @Override
                        public void execute() {
                            //do nothing.
                        }
                    }
            );
        } else {
            //just rename.
            rename( false );
        }
    }
","    protected void rename() {
        if ( isDirty() ) {
            view.showYesNoCancelPopup( CommonConstants.INSTANCE.Information(),
                    Constants.INSTANCE.modelEditor_confirm_save_before_rename(),
                    new Command() {
                        @Override
                        public void execute() {
                            rename( true );
                        }
                    },
                    new Command() {
                        @Override
                        public void execute() {
                            rename( false );
                        }
                    } );
        } else {
            //just rename.
            rename( false );
        }
    }
"
1268,I'm not clear on why this one is needed.,"	public void removeThreadFilters(IExecutionDMContext[] threads) throws CoreException {
		synchronized (fFilteredThreadsByTarget) {
			if (threads != null && threads.length > 0) {
				IContainerDMContext target = DMContexts.getAncestorOfType(threads[0], IContainerDMContext.class);
				Set<IExecutionDMContext> set = fFilteredThreadsByTarget.get(target);
				if (set != null) {
					set.removeAll(Arrays.asList(threads));
					if (set.isEmpty()) {
						fFilteredThreadsByTarget.remove(target);
					}
				}
			}
		}
	}
","	public void removeThreadFilters(IExecutionDMContext[] threads) throws CoreException {
START 		synchronized (fFilteredThreadsByTarget) { END 
			if (threads != null && threads.length > 0) {
				IContainerDMContext target = DMContexts.getAncestorOfType(threads[0], IContainerDMContext.class);
				Set<IExecutionDMContext> set = fFilteredThreadsByTarget.get(target);
				if (set != null) {
					set.removeAll(Arrays.asList(threads));
					if (set.isEmpty()) {
						fFilteredThreadsByTarget.remove(target);
					}
				}
			}
		}
	}
","    public void removeThreadFilters( IExecutionDMContext[] threads ) throws CoreException {
        if ( threads != null && threads.length > 0 ) {
            IContainerDMContext target = DMContexts.getAncestorOfType(threads[0], IContainerDMContext.class);
            Set<IExecutionDMContext> set = fFilteredThreadsByTarget.get( target );
            if ( set != null ) {
            	set.removeAll( Arrays.asList( threads ) );
            	if ( set.isEmpty() ) {
            		fFilteredThreadsByTarget.remove( target );
            	}
            }
        }
    }
"
1269,Doesn't look like the above store object is being used.  Suggest removing it.,"   public Collection<IAtsTeamWorkflow> getSiblingTeamWorkflows(IAtsTeamWorkflow teamWf) {
      List<IAtsTeamWorkflow> teams = new LinkedList<IAtsTeamWorkflow>();
      teamWf.getStoreObject();
      Object action = getAction(teamWf);
      for (Object teamArt : atsServices.getRelationResolver().getRelated(action,
         AtsRelationTypes.ActionToWorkflow_WorkFlow)) {
         if (!teamArt.equals(teamWf)) {
            teams.add(atsServices.getWorkItemFactory().getTeamWf(teamArt));
         }
      }
      return teams;
   }
","   public Collection<IAtsTeamWorkflow> getSiblingTeamWorkflows(IAtsTeamWorkflow teamWf) {
      List<IAtsTeamWorkflow> teams = new LinkedList<IAtsTeamWorkflow>();
START       teamWf.getStoreObject(); END 
      Object action = getAction(teamWf);
      for (Object teamArt : atsServices.getRelationResolver().getRelated(action,
         AtsRelationTypes.ActionToWorkflow_WorkFlow)) {
         if (!teamArt.equals(teamWf)) {
            teams.add(atsServices.getWorkItemFactory().getTeamWf(teamArt));
         }
      }
      return teams;
   }
","   public Collection<IAtsTeamWorkflow> getSiblingTeamWorkflows(IAtsTeamWorkflow teamWf) {
      List<IAtsTeamWorkflow> teams = new LinkedList<IAtsTeamWorkflow>();
      Object action = getAction(teamWf);
      for (Object teamArt : atsServices.getRelationResolver().getRelated(action,
         AtsRelationTypes.ActionToWorkflow_WorkFlow)) {
         if (!teamArt.equals(teamWf)) {
            teams.add(atsServices.getWorkItemFactory().getTeamWf(teamArt));
         }
      }
      return teams;
   }
"
1270,"The first `iterator` method in AbstractDatabaseEngine had this signature:  
```
public synchronized ResultIterator iterator(String query)
```
Then people added more iterator methods, some of them `synchronized`, some of them not.
I think all methods that use the connection should be `synchronized`; this means this one would need to be `synchronized`, but all other `iterator` methods call this one and don't need to be.","    public ResultIterator iterator(String query, int fetchSize, int readTimeoutOverride) throws DatabaseEngineException {
        try {
            getConnection();
            Statement stmt = createSelectStatement(readTimeoutOverride);
            stmt.setFetchSize(fetchSize);
            logger.trace(query);
            return createResultIterator(stmt, query);

        } catch (final DatabaseEngineTimeoutException e) {
            throw e;

        } catch (final Exception e) {
            throw new DatabaseEngineException(""Error querying"", e);
        }
    }
","START     public ResultIterator iterator(String query, int fetchSize, int readTimeoutOverride) throws DatabaseEngineException { END 
        try {
            getConnection();
            Statement stmt = createSelectStatement(readTimeoutOverride);
            stmt.setFetchSize(fetchSize);
            logger.trace(query);
            return createResultIterator(stmt, query);

        } catch (final DatabaseEngineTimeoutException e) {
            throw e;

        } catch (final Exception e) {
            throw new DatabaseEngineException(""Error querying"", e);
        }
    }
","    public synchronized ResultIterator iterator(String query, int fetchSize, int readTimeoutOverride) throws DatabaseEngineException {
        try {
            getConnection();
            Statement stmt = createSelectStatement(readTimeoutOverride);
            stmt.setFetchSize(fetchSize);
            logger.trace(query);
            return createResultIterator(stmt, query);

        } catch (final DatabaseEngineTimeoutException e) {
            throw e;

        } catch (final Exception e) {
            throw new DatabaseEngineException(""Error querying"", e);
        }
    }
"
1271,suggest changing `prefetchDataNodeIndex == i ? true : false` to `prefetchDataNodeIndex == i`.,"  public void initializeServers(NotificationSystem notificationSystem) {
    List<MockDataNodeId> dataNodes = clusterMap.getDataNodes();
    for (int i = 0; i < dataNodes.size(); i++) {
      if (sslEnabledDataCenterList != null) {
        dataNodes.get(i).setSslEnabledDataCenters(sslEnabledDataCenterList);
      }
      initializeServer(dataNodes.get(i), sslProps, enableHardDeletes, prefetchDataNodeIndex == i ? true : false,
          notificationSystem, time);
    }
  }
","  public void initializeServers(NotificationSystem notificationSystem) {
    List<MockDataNodeId> dataNodes = clusterMap.getDataNodes();
    for (int i = 0; i < dataNodes.size(); i++) {
      if (sslEnabledDataCenterList != null) {
        dataNodes.get(i).setSslEnabledDataCenters(sslEnabledDataCenterList);
      }
START       initializeServer(dataNodes.get(i), sslProps, enableHardDeletes, prefetchDataNodeIndex == i ? true : false, END 
          notificationSystem, time);
    }
  }
","  public void initializeServers(NotificationSystem notificationSystem) {
    List<MockDataNodeId> dataNodes = clusterMap.getDataNodes();
    for (int i = 0; i < dataNodes.size(); i++) {
      if (sslEnabledDataCenterList != null) {
        dataNodes.get(i).setSslEnabledDataCenters(sslEnabledDataCenterList);
      }
      initializeServer(dataNodes.get(i), sslProps, enableHardDeletes, prefetchDataNodeIndex == i, notificationSystem,
          time);
    }
  }
"
1272,"why object class?, maybe set type to null could be a better idea","	public Payload(final Object data,
				   final Visibility visibility,
				   final String visibilityId) {

		if(null == data){
			this.type = Object.class.getName();
		}else{
			this.type = data.getClass().getName();
		}
		this.data = data;
		this.visibility = visibility;
		this.visibilityId = visibilityId;
	}
","	public Payload(final Object data,
				   final Visibility visibility,
				   final String visibilityId) {

		if(null == data){
START 			this.type = Object.class.getName(); END 
		}else{
			this.type = data.getClass().getName();
		}
		this.data = data;
		this.visibility = visibility;
		this.visibilityId = visibilityId;
	}
","	public Payload(final Object data,
				   final Visibility visibility,
				   final String visibilityId) {

		this.type = data.getClass().getName();
		this.data = data;
		this.visibility = visibility;
		this.visibilityId = visibilityId;
	}
"
1273,"nitpick: `e -> e.getKey()` could be replaced by `CacheEntry::getKey`. the same for the change below.
ps. not sure which one is more efficient.","      public CloseableIterator<CacheEntry<K, V>> iterator() {
         return new CloseableIteratorMapper<>(new RemovableCloseableIterator<>(Closeables.iterator(stream()), cache,
                 e -> e.getKey()), e -> new EntryWrapper<>(cache, e));
      }
","      public CloseableIterator<CacheEntry<K, V>> iterator() {
         return new CloseableIteratorMapper<>(new RemovableCloseableIterator<>(Closeables.iterator(stream()), cache,
START                  e -> e.getKey()), e -> new EntryWrapper<>(cache, e)); END 
      }
","      public CloseableIterator<CacheEntry<K, V>> iterator() {
         return new CloseableIteratorMapper<>(new RemovableCloseableIterator<>(Closeables.iterator(stream()), cache,
                 CacheEntry::getKey), e -> new EntryWrapper<>(cache, e));
      }
"
1274,"```suggestion
    autoLimitRowCount = 0;
```","  public void disableAutoLimit() {
    autoLimitRowCount = null;
  }
","  public void disableAutoLimit() {
START     autoLimitRowCount = null; END 
  }
","  public void disableAutoLimit() {
    autoLimitRowCount = 0;
  }
"
1275,Do we need those 2 lines here?,"   public void testScriptCallFromJavascript() throws Exception {
      cacheManager.getCache().remove(""a"");
      assertNull(cacheManager.getCache().get(""a""));

      String result = (String) scriptingManager.runScript(""testInnerScriptCall.js"",
              new TaskContext().cache(cacheManager.getCache(""test_cache"")).addParameter(""a"", ""ahoj"")).get();

      assertEquals(""script1:additionFromJavascript"", result);
      assertEquals(""ahoj"", cacheManager.getCache().get(""a""));
   }
","   public void testScriptCallFromJavascript() throws Exception {
START       cacheManager.getCache().remove(""a""); END 
      assertNull(cacheManager.getCache().get(""a""));

      String result = (String) scriptingManager.runScript(""testInnerScriptCall.js"",
              new TaskContext().cache(cacheManager.getCache(""test_cache"")).addParameter(""a"", ""ahoj"")).get();

      assertEquals(""script1:additionFromJavascript"", result);
      assertEquals(""ahoj"", cacheManager.getCache().get(""a""));
   }
","   public void testScriptCallFromJavascript() throws Exception {
      String result = (String) scriptingManager.runScript(""testInnerScriptCall.js"",
              new TaskContext().cache(cacheManager.getCache(""test_cache"")).addParameter(""a"", ""ahoj"")).get();

      assertEquals(""script1:additionFromJavascript"", result);
      assertEquals(""ahoj"", cacheManager.getCache().get(""a""));
   }
"
1276,"Please remove unnecessary brackets:

 return (RestartVdsReturnValue) super.getReturnValue();","    public RestartVdsReturnValue getReturnValue() {
        return (RestartVdsReturnValue)(super.getReturnValue());
    }
","    public RestartVdsReturnValue getReturnValue() {
START         return (RestartVdsReturnValue)(super.getReturnValue()); END 
    }
","    public RestartVdsReturnValue getReturnValue() {
        return (RestartVdsReturnValue) super.getReturnValue();
    }
"
1277,idem,"    public void closeThisNode(long endtime) {
        super.closeThisNode(endtime);
        fListeners.stream().forEach(l -> l.nodeClosed(this, endtime));
    }
","    public void closeThisNode(long endtime) {
        super.closeThisNode(endtime);
START         fListeners.stream().forEach(l -> l.nodeClosed(this, endtime)); END 
    }
","    public void closeThisNode(long endtime) {
        super.closeThisNode(endtime);
        fListeners.forEach(l -> l.nodeClosed(this, endtime));
    }
"
1278,why the `addAll()`?,"   public Set<Integer> getSegments() {
      synchronized (segments) {
         Set<Integer> segmentsCopy = new HashSet<Integer>(segments);
         segmentsCopy.addAll(segments);
         return segmentsCopy;
      }
   }
","   public Set<Integer> getSegments() {
      synchronized (segments) {
         Set<Integer> segmentsCopy = new HashSet<Integer>(segments);
START          segmentsCopy.addAll(segments); END 
         return segmentsCopy;
      }
   }
","   public Set<Integer> getSegments() {
      synchronized (segments) {
         return new HashSet<Integer>(segments);
      }
   }
"
1279,"> Use this.h.removeCallbacksAndMessages(null) instead.

Done in Patch set 2","    public void dispose() {
        //Remove all message from the queue
        this.h.removeCallbacksAndMessages(null);
        
        this.parent.dispose();
        this.h = null;
        this.owner = null;
        this.parent = null;
    }
","    public void dispose() {
        //Remove all message from the queue
START         this.h.removeCallbacksAndMessages(null); END 
        
        this.parent.dispose();
        this.h = null;
        this.owner = null;
        this.parent = null;
    }
","    public void dispose() {
    }
"
1280,I think we should use the `contentlet.isHost()` method here rather than recreating it,"	private boolean isHost(final Permissionable permissionable) {

		return permissionable instanceof Host ||
				(permissionable instanceof Contentlet && Host.class.getSimpleName().equals(((Contentlet) permissionable).getContentType().name())) ||
				(null != permissionable && permissionable instanceof PermissionableProxy
						&& Host.class.getName().equals(PermissionableProxy.class.cast(permissionable).getType()));
	}
","	private boolean isHost(final Permissionable permissionable) {

		return permissionable instanceof Host ||
START 				(permissionable instanceof Contentlet && Host.class.getSimpleName().equals(((Contentlet) permissionable).getContentType().name())) || END 
				(null != permissionable && permissionable instanceof PermissionableProxy
						&& Host.class.getName().equals(PermissionableProxy.class.cast(permissionable).getType()));
	}
","	private boolean isHost(final Permissionable permissionable) {

		return permissionable instanceof Host ||
				(permissionable instanceof Contentlet && ((Contentlet) permissionable).isHost()) ||
				(null != permissionable && permissionable instanceof PermissionableProxy
						&& Host.class.getName().equals(PermissionableProxy.class.cast(permissionable).getType()));
	}
"
1281,Don't need parens around repos.getAccount().getEmail().equals(getAuthor().getEmail()),"	public boolean isMine() {
		IRepository repos = getReview() != null ? getReview().getRepository() : null;
		return getAuthor() != null
				&& repos != null
				&& (repos.getAccount() == getAuthor() || (repos.getAccount() != null && (repos.getAccount().getEmail().equals(getAuthor().getEmail()))));
	}
","	public boolean isMine() {
		IRepository repos = getReview() != null ? getReview().getRepository() : null;
		return getAuthor() != null
				&& repos != null
START 				&& (repos.getAccount() == getAuthor() || (repos.getAccount() != null && (repos.getAccount().getEmail().equals(getAuthor().getEmail())))); END 
	}
","	public boolean isMine() {
		IRepository repos = getReview() != null ? getReview().getRepository() : null;
		return getAuthor() != null
				&& repos != null
				&& (repos.getAccount() == getAuthor() || (repos.getAccount() != null && repos.getAccount().getEmail().equals(getAuthor().getEmail())));
	}
"
1282,@janos-ss I would rather catch the `IOException` inside `createContext `.,"  private void runSe(String filename) {
    JavaScriptVisitorContext context;
    try {
      context = createContext(new TestInputFile(""src/test/resources/se/"", filename));
      verifier.scanExpectedIssues(context);
      SeChecksDispatcher seChecksDispatcher = new SeChecksDispatcher(ImmutableList.of((SeCheck) verifier));
      seChecksDispatcher.scanTree(context);
    } catch (IOException e) {
      Throwables.propagate(e);
    }
  }
","  private void runSe(String filename) {
    JavaScriptVisitorContext context;
START     try { END 
      context = createContext(new TestInputFile(""src/test/resources/se/"", filename));
      verifier.scanExpectedIssues(context);
      SeChecksDispatcher seChecksDispatcher = new SeChecksDispatcher(ImmutableList.of((SeCheck) verifier));
      seChecksDispatcher.scanTree(context);
    } catch (IOException e) {
      Throwables.propagate(e);
    }
  }
","  private void runSe(String filename) {
    JavaScriptVisitorContext context = createContext(new TestInputFile(""src/test/resources/se/"", filename));
    verifier.scanExpectedIssues(context);
    SeChecksDispatcher seChecksDispatcher = new SeChecksDispatcher(ImmutableList.of((SeCheck) verifier));
    seChecksDispatcher.scanTree(context);
  }
"
1283,"Meh: This is a vararg method. I think you can just say `.containsExactly(1, 2, 3, 4, 5)`","    public void testReturnKey() throws Exception
    {
        long[] ids = b.insertNames(""a"", ""b"", ""c"", ""d"", ""e"");
        assertThat(ids).containsExactly(new long[] { 1, 2, 3, 4, 5 });
    }
","    public void testReturnKey() throws Exception
    {
        long[] ids = b.insertNames(""a"", ""b"", ""c"", ""d"", ""e"");
START         assertThat(ids).containsExactly(new long[] { 1, 2, 3, 4, 5 }); END 
    }
","    public void testReturnKey() throws Exception
    {
        long[] ids = b.insertNames(""a"", ""b"", ""c"", ""d"", ""e"");
        assertThat(ids).containsExactly(1, 2, 3, 4, 5);
    }
"
1284,exists is statically imported.,"    public void testIndexSeekAndScan() throws Exception
    {
        updateAndCommit( asList(
                IndexEntryUpdate.add( 1L, index, ""a"" ),
                IndexEntryUpdate.add( 2L, index, ""a"" ),
                IndexEntryUpdate.add( 3L, index, ""b"" ) ) );

        assertThat( query( exact( 1, ""a"" ) ), equalTo( asList( 1L, 2L ) ) );
        assertThat( query( IndexQuery.exists( 1 ) ), equalTo( asList( 1L, 2L, 3L ) ) );
    }
","    public void testIndexSeekAndScan() throws Exception
    {
        updateAndCommit( asList(
                IndexEntryUpdate.add( 1L, index, ""a"" ),
                IndexEntryUpdate.add( 2L, index, ""a"" ),
                IndexEntryUpdate.add( 3L, index, ""b"" ) ) );

        assertThat( query( exact( 1, ""a"" ) ), equalTo( asList( 1L, 2L ) ) );
START         assertThat( query( IndexQuery.exists( 1 ) ), equalTo( asList( 1L, 2L, 3L ) ) ); END 
    }
","    public void testIndexSeekAndScan() throws Exception
    {
        updateAndCommit( asList(
                IndexEntryUpdate.add( 1L, index, ""a"" ),
                IndexEntryUpdate.add( 2L, index, ""a"" ),
                IndexEntryUpdate.add( 3L, index, ""b"" ) ) );

        assertThat( query( exact( 1, ""a"" ) ), equalTo( asList( 1L, 2L ) ) );
        assertThat( query( exists( 1 ) ), equalTo( asList( 1L, 2L, 3L ) ) );
    }
"
1285,"Shouldn't you be clearing out the entry in participantStatusMap.
Similarly whenever compensate or complete callbacks finish successfully.","    Response forget(URI lraId, URI parentId) {
        return invokeParticipantMethod(forgetMethod, lraId, parentId, FORGET);
    }
","    Response forget(URI lraId, URI parentId) {
START         return invokeParticipantMethod(forgetMethod, lraId, parentId, FORGET); END 
    }
","    synchronized Response forget(URI lraId, URI parentId) {
        return invokeParticipantMethod(forgetMethod, lraId, parentId, FORGET);
    }
"
1286,I think that this may overlap with concurrent updates to the authorities by other threads,"  private void resetAuthorities(String username) {
    UserDetails userDetails = userDetailsService.loadUserByUsername(username);
    Collection<? extends GrantedAuthority> updatedAuthorities = userDetails.getAuthorities();

    Object principal = toPrincipal(username);
    principalSecurityContextRegistry
        .getSecurityContexts(principal)
        .forEach(securityContext -> resetAuthorities(securityContext, updatedAuthorities));
  }
","START   private void resetAuthorities(String username) { END 
    UserDetails userDetails = userDetailsService.loadUserByUsername(username);
    Collection<? extends GrantedAuthority> updatedAuthorities = userDetails.getAuthorities();

    Object principal = toPrincipal(username);
    principalSecurityContextRegistry
        .getSecurityContexts(principal)
        .forEach(securityContext -> resetAuthorities(securityContext, updatedAuthorities));
  }
","  private synchronized void resetAuthorities(String username) {
    UserDetails userDetails = userDetailsService.loadUserByUsername(username);
    Collection<? extends GrantedAuthority> updatedAuthorities = userDetails.getAuthorities();

    Object principal = toPrincipal(username);
    principalSecurityContextRegistry
        .getSecurityContexts(principal)
        .forEach(securityContext -> resetAuthorities(securityContext, updatedAuthorities));
  }
"
1287,"similar approach should be taken here, but the condition is simpler:

  try {
    endWithFailure();
  } finally {
     if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) {
            compensate();
        }
  }","    private void internalEndWithFailure() {
        log.error(""Ending command '{}' with failure."", getClass().getName());
        endWithFailure();
        rollbackQuota();
        if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) {
            compensate();
        }
    }
","    private void internalEndWithFailure() {
        log.error(""Ending command '{}' with failure."", getClass().getName());
        endWithFailure();
        rollbackQuota();
START         if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) { END 
            compensate();
        }
    }
","    private void internalEndWithFailure() {
        log.error(""Ending command '{}' with failure."", getClass().getName());
        try {
            endWithFailure();
        } finally {
            if (getCommandCompensationPhase() == CommandCompensationPhase.END_COMMAND) {
                compensate();
            }
        }
        rollbackQuota();
    }
"
1288,Why we cannot continue to reuse a single `MockProcessorSupplier`?,"    public void testCountWithInternalStore() {
        final StreamsBuilder builder = new StreamsBuilder();
        final String input = ""count-test-input"";

        final MockProcessorSupplier<String, Object> supplier = new MockProcessorSupplier<>();
        builder
            .table(input, consumed)
            .groupBy(MockMapper.selectValueKeyValueMapper(), stringSerialized)
            .count()
            .toStream()
            .process(supplier);

        testCountHelper(builder, input, supplier);
    }
","    public void testCountWithInternalStore() {
        final StreamsBuilder builder = new StreamsBuilder();
        final String input = ""count-test-input"";

START         final MockProcessorSupplier<String, Object> supplier = new MockProcessorSupplier<>(); END 
        builder
            .table(input, consumed)
            .groupBy(MockMapper.selectValueKeyValueMapper(), stringSerialized)
            .count()
            .toStream()
            .process(supplier);

        testCountHelper(builder, input, supplier);
    }
","    public void testCountWithInternalStore() {
        final StreamsBuilder builder = new StreamsBuilder();
        final String input = ""count-test-input"";

        builder
            .table(input, consumed)
            .groupBy(MockMapper.selectValueKeyValueMapper(), stringSerialized)
            .count()
            .toStream()
            .process(supplier);

        testCountHelper(builder, input, supplier);
    }
"
1289,new IllegalArgumentException is more appropriate,"  private static URL mapToURL(String path) {
    try {
        return new URL(path); 
    } catch (MalformedURLException e) {
      try {
        return new File(path).toURI().toURL();
      } catch (MalformedURLException e1) {
        throw new IllegalStateException(e1);
      }
    }
  }
","  private static URL mapToURL(String path) {
    try {
        return new URL(path); 
    } catch (MalformedURLException e) {
      try {
        return new File(path).toURI().toURL();
      } catch (MalformedURLException e1) {
START         throw new IllegalStateException(e1); END 
      }
    }
  }
","  private static URL mapToURL(String path) {
    try {
        return new URL(path); 
    } catch (MalformedURLException e) {
      try {
        return new File(path).toURI().toURL();
      } catch (MalformedURLException e1) {
        throw new IllegalArgumentException(e1);
      }
    }
  }
"
1290,"unchecked cast, in class below there's a checked cast. Isn't it necessary here too?","    protected void addSearchFilter(final ActiveFilterItem filter,
                                   final ColumnFilter columnFilter) {
        ((CoreFunctionFilter)columnFilter).setLabelValue(filter.getLabelValue());
        basicFilterAddEvent.fire(new BasicFilterAddEvent(getDataSetId(),
                                                         filter,
                                                         columnFilter));
    }
","    protected void addSearchFilter(final ActiveFilterItem filter,
                                   final ColumnFilter columnFilter) {
START         ((CoreFunctionFilter)columnFilter).setLabelValue(filter.getLabelValue()); END 
        basicFilterAddEvent.fire(new BasicFilterAddEvent(getDataSetId(),
                                                         filter,
                                                         columnFilter));
    }
","    protected void addSearchFilter(final ActiveFilterItem filter,
                                   final ColumnFilter columnFilter) {
        if (columnFilter instanceof CoreFunctionFilter) {
            ((CoreFunctionFilter) columnFilter).setLabelValue(filter.getLabelValue());
        }
        basicFilterAddEvent.fire(new BasicFilterAddEvent(getDataSetId(),
                                                         filter,
                                                         columnFilter));
    }
"
1291,protected,"    void addAdditionalDependencies(Set<String> back) throws Exception {
        if (additionalDependencies != null) {
            for (Dependency dependency : additionalDependencies) {
                addToClasspath(factory.createDependencyArtifact(dependency), back, false);
            }
        }
    }
","START     void addAdditionalDependencies(Set<String> back) throws Exception { END 
        if (additionalDependencies != null) {
            for (Dependency dependency : additionalDependencies) {
                addToClasspath(factory.createDependencyArtifact(dependency), back, false);
            }
        }
    }
","    protected void addAdditionalDependencies(Set<String> back) throws Exception {
        if (additionalDependencies != null) {
            for (Dependency dependency : additionalDependencies) {
                addToClasspath(factory.createDependencyArtifact(dependency), back, false);
            }
        }
    }
"
1292,Possible deadlock: remove this call to sleep(). It's possible that no events will ever arrive.,"	private void runEventLoopUntilEmpty() {
		Display display = Display.getCurrent();
		while (display.readAndDispatch()) {
		}
		display.sleep();
		return;
	}
","	private void runEventLoopUntilEmpty() {
		Display display = Display.getCurrent();
		while (display.readAndDispatch()) {
		}
START 		display.sleep(); END 
		return;
	}
","	private void runEventLoopUntilEmpty() {
		Display display = Display.getCurrent();
		while (display.readAndDispatch()) {
		}
		return;
	}
"
1293,"OK, thanks for the size improvement. As for the synchronized issue, let's open a jira then and do nothing for now.","      private Map<String, List<Entry<T>>> copy(final Map<String, List<Entry<T>>> original) {
         final Map<String, List<Entry<T>>> copy = new HashMap<>();
         original.forEach((key, value) -> copy.put(key, new CopyOnWriteArrayList<>(value)));
         return copy;
      }
","      private Map<String, List<Entry<T>>> copy(final Map<String, List<Entry<T>>> original) {
         final Map<String, List<Entry<T>>> copy = new HashMap<>();
         original.forEach((key, value) -> copy.put(key, new CopyOnWriteArrayList<>(value)));
START          return copy; END 
      }
","      private Map<String, List<Entry<T>>> copy(final Map<String, List<Entry<T>>> original) {
         final Map<String, List<Entry<T>>> copy = new HashMap<>(original.size());
         original.forEach((key, value) -> copy.put(key, new CopyOnWriteArrayList<>(value)));
         return copy;
      }
"
1294,You can leave it as `double` to avoid auto boxing.,"  @Override public void track(TrackPayload track) {
    super.track(track);
    Double value = track.properties().getDouble(""value"", Double.MIN_VALUE);
    if (value.equals(Double.MIN_VALUE)) {
      Apptimize.track(track.event());
    } else {
      Apptimize.track(track.event(), value);
    }
  }
","  @Override public void track(TrackPayload track) {
    super.track(track);
START     Double value = track.properties().getDouble(""value"", Double.MIN_VALUE); END 
    if (value.equals(Double.MIN_VALUE)) {
      Apptimize.track(track.event());
    } else {
      Apptimize.track(track.event(), value);
    }
  }
","  @Override public void track(TrackPayload track) {
    super.track(track);
    double value = track.properties().getDouble(""value"", Double.MIN_VALUE);
    if (value == Double.MIN_VALUE) {
      Apptimize.track(track.event());
    } else {
      Apptimize.track(track.event(), value);
    }
  }
"
1295,Can the constructor be private?,"	public ContentTypeManager() {
		super(null, InstanceScope.INSTANCE);
	}
","START 	public ContentTypeManager() { END 
		super(null, InstanceScope.INSTANCE);
	}
","	private ContentTypeManager() {
		super(null, InstanceScope.INSTANCE);
	}
"
1296,You may also check responses from callback.,"    public void testStartAndCompleteTaskUseOfAsyncResponseHandler() {
        ResponseCallback callback = new BlockingResponseCallback(null);
        testStartAndCompleteTask(new AsyncResponseHandler(callback));
    }
","    public void testStartAndCompleteTaskUseOfAsyncResponseHandler() {
START         ResponseCallback callback = new BlockingResponseCallback(null); END 
        testStartAndCompleteTask(new AsyncResponseHandler(callback));
    }
","    public void testStartAndCompleteTaskUseOfAsyncResponseHandler() throws Exception {
        ResponseCallback callback = new BlockingResponseCallback(null);
        testStartAndCompleteTask(new AsyncResponseHandler(callback));
    }
"
1297,I believe this is wrong: it would also return true for maps with integer keys. We will need to create separate subclasses or find another way to distinguish list element deletions from other cases.,"    Delete(String keyspace, String table, List<Selector> columns) {
        super(keyspace);
        this.table = table;
        this.columns = columns;
        this.where = new Where(this);
        this.usings = new Options(this);
        this.conditions = new Conditions(this);

        // This is for JAVA-1089, if the query deletes an element in a list, the statement should be non-idempotent.
        for (Selector sel : columns) {
            if (sel instanceof CollectionElementSelector) {
                if (((CollectionElementSelector) sel).key instanceof Integer) {
                    setNonIdempotentOps();
                }
            }
        }
    }
","    Delete(String keyspace, String table, List<Selector> columns) {
        super(keyspace);
        this.table = table;
        this.columns = columns;
        this.where = new Where(this);
        this.usings = new Options(this);
        this.conditions = new Conditions(this);

        // This is for JAVA-1089, if the query deletes an element in a list, the statement should be non-idempotent.
        for (Selector sel : columns) {
            if (sel instanceof CollectionElementSelector) {
START                 if (((CollectionElementSelector) sel).key instanceof Integer) { END 
                    setNonIdempotentOps();
                }
            }
        }
    }
","    Delete(String keyspace, String table, List<Selector> columns) {
        this(keyspace, table, null, null, columns);
    }
"
1298,"minor: can put both conditions together with a ""&&""?","    File remove(long sizeInBytes) {
      File reserveFile = null;
      Queue<File> reserveFilesForSize = internalMap.get(sizeInBytes);
      if (reserveFilesForSize != null) {
        if (reserveFilesForSize.size() != 0) {
          reserveFile = reserveFilesForSize.remove();
        }
      }
      return reserveFile;
    }
","    File remove(long sizeInBytes) {
      File reserveFile = null;
      Queue<File> reserveFilesForSize = internalMap.get(sizeInBytes);
START       if (reserveFilesForSize != null) { END 
        if (reserveFilesForSize.size() != 0) {
          reserveFile = reserveFilesForSize.remove();
        }
      }
      return reserveFile;
    }
","    File remove(long sizeInBytes) {
      File reserveFile = null;
      Queue<File> reserveFilesForSize = internalMap.get(sizeInBytes);
      if (reserveFilesForSize != null && reserveFilesForSize.size() != 0) {
        reserveFile = reserveFilesForSize.remove();
      }
      return reserveFile;
    }
"
1299,"This was like this before, but shouldn't we make this 

List<StoreConfiguration> stores = new ArrayList<StoreConfiguration>(stores.size()); 

instead.  LinkedList should only really be used when removing or adding not from the tail.","   public PersistenceConfiguration create() {
      List<StoreConfiguration> stores = new LinkedList<StoreConfiguration>();
      for (StoreConfigurationBuilder<?, ?> loader : this.stores)
         stores.add(loader.create());
      return new PersistenceConfiguration(passivation, stores);
   }
","   public PersistenceConfiguration create() {
START       List<StoreConfiguration> stores = new LinkedList<StoreConfiguration>(); END 
      for (StoreConfigurationBuilder<?, ?> loader : this.stores)
         stores.add(loader.create());
      return new PersistenceConfiguration(passivation, stores);
   }
","   public PersistenceConfiguration create() {
      List<StoreConfiguration> stores = new ArrayList<StoreConfiguration>(this.stores.size());
      for (StoreConfigurationBuilder<?, ?> loader : this.stores)
         stores.add(loader.create());
      return new PersistenceConfiguration(passivation, stores);
   }
"
1300,`container` is not specified in @param.,"  private void setAmbryHeadersForPut(JSONObject headers, String ttlInSecs, String serviceId, Container container,
      String contentType, String ownerId) throws JSONException {
    setAmbryHeadersForPut(headers, ttlInSecs, serviceId, container, contentType, ownerId, true, true);
  }
","START   private void setAmbryHeadersForPut(JSONObject headers, String ttlInSecs, String serviceId, Container container, END 
      String contentType, String ownerId) throws JSONException {
    setAmbryHeadersForPut(headers, ttlInSecs, serviceId, container, contentType, ownerId, true, true);
  }
","  private void setAmbryHeadersForPut(JSONObject headers, String ttlInSecs, String serviceId, Container container,
      String contentType, String ownerId) throws JSONException {
    setAmbryHeadersForPut(headers, ttlInSecs, serviceId, container, contentType, ownerId, true);
  }
"
1301,"Could simplify to:
```java
if (args.isEmpty()) {
```","    public void validateArguments(List<Expr> args)
    {
      if (!(args.size() > 0)) {
        throw new IAE(""Function[%s] needs at least 1 argument"", name());
      }
    }
","    public void validateArguments(List<Expr> args)
    {
START       if (!(args.size() > 0)) { END 
        throw new IAE(""Function[%s] needs at least 1 argument"", name());
      }
    }
","    public void validateArguments(List<Expr> args)
    {
      if (args.isEmpty()) {
        throw new IAE(""Function[%s] needs at least 1 argument"", name());
      }
    }
"
1302,I'd remove the empty lines before and after this one.,"    public boolean setValue(T newValue) {
        if (!validator.validate(newValue))
            return false;

        PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue);

        this.value = newValue;

        dispatchChangedEvent(event);

        return true;
    }
","    public boolean setValue(T newValue) {
        if (!validator.validate(newValue))
            return false;

        PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue);

START         this.value = newValue; END 

        dispatchChangedEvent(event);

        return true;
    }
","    public boolean setValue(T newValue) {
        if (!validate(newValue)) {
            return false;
        }

        PropertyChangeEvent event = new PropertyChangeEvent(this, id.toString(), this.value, newValue);
        this.value = newValue;
        dispatchChangedEvent(event);

        return true;
    }
"
1303,Here is the same issue like in line 208 (resume being void),"	public void testNestedInvalidateAndApplyCompletes() throws Exception {
		final AtomicBoolean hasRun = new AtomicBoolean();
		final SideEffect innerSideEffect = SideEffect.createPaused(() -> {
		}).resume();

		SideEffect.createPaused(() -> {
			// Make sure that there are no infinite loops.
			assertFalse(hasRun.get());
			hasRun.set(true);
			innerSideEffect.markDirty();
			innerSideEffect.runIfDirty();
		}).resume();

		runAsync();
		assertTrue(hasRun.get());
	}
","	public void testNestedInvalidateAndApplyCompletes() throws Exception {
		final AtomicBoolean hasRun = new AtomicBoolean();
START 		final SideEffect innerSideEffect = SideEffect.createPaused(() -> { END 
		}).resume();

		SideEffect.createPaused(() -> {
			// Make sure that there are no infinite loops.
			assertFalse(hasRun.get());
			hasRun.set(true);
			innerSideEffect.markDirty();
			innerSideEffect.runIfDirty();
		}).resume();

		runAsync();
		assertTrue(hasRun.get());
	}
","	public void testNestedInvalidateAndApplyCompletes() throws Exception {
		AtomicBoolean hasRun = new AtomicBoolean();
		SideEffect innerSideEffect = SideEffect.createPaused(() -> {
		});

		innerSideEffect.resume();

		SideEffect.createPaused(() -> {
			// Make sure that there are no infinite loops.
			assertFalse(hasRun.get());
			hasRun.set(true);
			innerSideEffect.markDirty();
			innerSideEffect.runIfDirty();
		}).resume();

		runAsync();
		assertTrue(hasRun.get());
	}
"
1304,"Use a concurrentHasMap, then you can remove the synchronized on the public methods.","		SubscribedRepository(String name) {
			this.name = name;
			subscribeSpecs = new HashMap<String, SubscribeSpec>();
		}
","		SubscribedRepository(String name) {
			this.name = name;
START 			subscribeSpecs = new HashMap<String, SubscribeSpec>(); END 
		}
","		private SubscribedRepository(String name) {
			this.name = name;
			subscribeSpecs = new HashSet<SubscribeSpec>();
		}
"
1305,"Simpler: `Double[] params = { MEAN, VARIANCE }`","  public void testFixedMeanFixedVariance() {
    Double[] params = new Double[2];
    params[0] = MEAN;
    params[1] = VARIANCE;
    UnivarGaussian gaussian = new UnivarGaussian();
    gaussian.setParams(params);
    testGaussian(gaussian);
  }
","  public void testFixedMeanFixedVariance() {
    Double[] params = new Double[2];
    params[0] = MEAN;
START     params[1] = VARIANCE; END 
    UnivarGaussian gaussian = new UnivarGaussian();
    gaussian.setParams(params);
    testGaussian(gaussian);
  }
","  public void testFixedMeanFixedVariance() {
    Double[] params = { MEAN, VARIANCE };
    UnivarGaussian gaussian = new UnivarGaussian();
    gaussian.setParams(params);
    testGaussian(gaussian);
  }
"
1306,"I can't see it here, but probably it's now blocking while it shouldn't (at least not always).","        public void saveSessionBackupFromResult( final BackupResult backupResult ) throws IOException {
            final byte[] data = backupResult.getData();
            if ( data != null ) {
                final String key = _sessionIdFormat.createBackupKey( _session.getId() );
                _memcached.set( key, toMemcachedExpiration(_session.getMemcachedExpirationTimeToSet()), data );
            }
            else {
                _log.warn( ""No data set for backupResultStatus "" + backupResult.getStatus() + "" for sessionId ""
                        + _session.getIdInternal() + "", skipping backup""
                        + "" of non-sticky session in secondary memcached."" );
            }
        }
","START         public void saveSessionBackupFromResult( final BackupResult backupResult ) throws IOException { END 
            final byte[] data = backupResult.getData();
            if ( data != null ) {
                final String key = _sessionIdFormat.createBackupKey( _session.getId() );
                _memcached.set( key, toMemcachedExpiration(_session.getMemcachedExpirationTimeToSet()), data );
            }
            else {
                _log.warn( ""No data set for backupResultStatus "" + backupResult.getStatus() + "" for sessionId ""
                        + _session.getIdInternal() + "", skipping backup""
                        + "" of non-sticky session in secondary memcached."" );
            }
        }
","        public void saveSessionBackupFromResult( final BackupResult backupResult ) {
            final byte[] data = backupResult.getData();
            if ( data != null ) {
                final String key = _sessionIdFormat.createBackupKey( _session.getId() );
                _memcached.set( key, toMemcachedExpiration(_session.getMemcachedExpirationTimeToSet()), data );
            }
            else {
                _log.warn( ""No data set for backupResultStatus "" + backupResult.getStatus() + "" for sessionId ""
                        + _session.getIdInternal() + "", skipping backup""
                        + "" of non-sticky session in secondary memcached."" );
            }
        }
"
1307,Something per-method needs to assign null to lifeCycleManager.,"    public void teardown()
            throws Exception
    {
        if (lifeCycleManager != null) {
            lifeCycleManager.stop();
        }
    }
","    public void teardown()
            throws Exception
    {
        if (lifeCycleManager != null) {
START             lifeCycleManager.stop(); END 
        }
    }
","    public void teardown()
            throws Exception
    {
        if (lifeCycleManager != null) {
            lifeCycleManager.stop();
            lifeCycleManager = null;
        }
    }
"
1308,Could be replaced with executorIsShutdown?,"    protected void queueRequest(final ITmfDataRequest request) {

        if (fExecutor == null || fExecutor.isShutdown()) {
            request.cancel();
            return;
        }

        TmfEventThread thread = new TmfEventThread(this, request);

        if (TmfCoreTracer.isRequestTraced()) {
            TmfCoreTracer.traceRequest(request, ""QUEUED""); //$NON-NLS-1$
        }

        fExecutor.execute(thread);
    }
","    protected void queueRequest(final ITmfDataRequest request) {

START         if (fExecutor == null || fExecutor.isShutdown()) { END 
            request.cancel();
            return;
        }

        TmfEventThread thread = new TmfEventThread(this, request);

        if (TmfCoreTracer.isRequestTraced()) {
            TmfCoreTracer.traceRequest(request, ""QUEUED""); //$NON-NLS-1$
        }

        fExecutor.execute(thread);
    }
","    protected void queueRequest(final ITmfDataRequest request) {

        if (fExecutor.isShutdown()) {
            request.cancel();
            return;
        }

        TmfEventThread thread = new TmfEventThread(this, request);

        if (TmfCoreTracer.isRequestTraced()) {
            TmfCoreTracer.traceRequest(request, ""QUEUED""); //$NON-NLS-1$
        }

        fExecutor.execute(thread);
    }
"
1309,Implement equals in AvoidRoadInfo,"		public boolean isDuplicate(@NonNull AvoidRoadInfo item) {
			for (AvoidRoadInfo existingItem : existingItems) {
				if (item.latitude == existingItem.latitude
						&& item.longitude == existingItem.longitude
						&& item.name.equals(existingItem.name)) {
					return true;
				}
			}
			return false;
		}
","		public boolean isDuplicate(@NonNull AvoidRoadInfo item) {
			for (AvoidRoadInfo existingItem : existingItems) {
START 				if (item.latitude == existingItem.latitude END 
						&& item.longitude == existingItem.longitude
						&& item.name.equals(existingItem.name)) {
					return true;
				}
			}
			return false;
		}
","		public boolean isDuplicate(@NonNull AvoidRoadInfo item) {
			return existingItems.contains(item);
		}
"
1310,nit: inline,"        public void onCompleted() {
            long r = get();
            if (r != Long.MIN_VALUE) {
                actual.onCompleted();
            }
        }
","        public void onCompleted() {
START             long r = get(); END 
            if (r != Long.MIN_VALUE) {
                actual.onCompleted();
            }
        }
","        public void onCompleted() {
            if (get() != Long.MIN_VALUE) {
                actual.onCompleted();
            }
        }
"
1311,"Again, now this initializer will have to be repeated in any additional constructors added.","    public Extensions() {
        factories = new CopyOnWriteArrayList<>();
    }
","    public Extensions() {
START         factories = new CopyOnWriteArrayList<>(); END 
    }
","    public Extensions() {}
"
1312,this still needed?,"    public void export_credentials_provider_extension_credentials() throws Exception {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ConfigurationAsCode.get().export(out);
        System.out.println(out.toString());
        assertThat(out.toString(), containsString(""username: \""user1\""""));
        assertThat(out.toString(), containsString(""id: \""sudo_password\""""));
    }
","    public void export_credentials_provider_extension_credentials() throws Exception {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ConfigurationAsCode.get().export(out);
START         System.out.println(out.toString()); END 
        assertThat(out.toString(), containsString(""username: \""user1\""""));
        assertThat(out.toString(), containsString(""id: \""sudo_password\""""));
    }
","    public void export_credentials_provider_extension_credentials() throws Exception {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ConfigurationAsCode.get().export(out);
        assertThat(out.toString(), containsString(""username: \""user1\""""));
        assertThat(out.toString(), containsString(""id: \""sudo_password\""""));
    }
"
1313,"Missing a blank after ""if""
If `propertyToList` returns empty list, check `if (!includeLists.isEmpty())`","    private Predicate<String> createPredicate() {
        if(includeLists != null) {
            return e -> includeLists.contains(e);
        } else if (excludeLists != null) {
            return e -> !excludeLists.contains(e);
        } else {
            return e -> true; 
        }
    }
","    private Predicate<String> createPredicate() {
START         if(includeLists != null) { END 
            return e -> includeLists.contains(e);
        } else if (excludeLists != null) {
            return e -> !excludeLists.contains(e);
        } else {
            return e -> true; 
        }
    }
","    private Predicate<String> createPredicate() {
        if (includeLists.isPresent()) {
            return e -> includeLists.get().contains(e);
        } else if (excludeLists.isPresent()) {
            return e -> !excludeLists.get().contains(e);
        } else {
            return e -> true; 
        }
    }
"
1314,You're missing 64 here. `<=` would be better.,"	public void testEmailWith64CharacterLocalPartIsValid() {
		// Local part should allow up to 64 octets: https://tools.ietf.org/html/rfc5321#section-4.5.3.1.1
		for (int num = 1; num < 64; num++) {
			isValidEmail( stringOfLength( num ) + ""@foo.com"" );
		}
	}
","	public void testEmailWith64CharacterLocalPartIsValid() {
		// Local part should allow up to 64 octets: https://tools.ietf.org/html/rfc5321#section-4.5.3.1.1
START 		for (int num = 1; num < 64; num++) { END 
			isValidEmail( stringOfLength( num ) + ""@foo.com"" );
		}
	}
","	public void testEmailWith64CharacterLocalPartIsValid() {
		// Local part should allow up to 64 octets: https://tools.ietf.org/html/rfc5321#section-4.5.3.1.1
		for (int num = 1; num <= 64; num++) {
			isValidEmail( stringOfLength( num ) + ""@foo.com"" );
		}
	}
"
1315,No need to set null here ...,"    public void save(AuditLog event) {
        Map<String, Object> returnVal = null;
        if (event.isExternal()) {
            returnVal = getCallsHandler().executeModification(""InsertExternalAuditLog"", getExternalEventSqlMapper(event));
        }
        else {
            returnVal = getCallsHandler().executeModification(""InsertAuditLog"", getSqlMapper(event));
        }
        event.setAuditLogId((Integer) returnVal.get(""audit_log_id""));
    }
","    public void save(AuditLog event) {
START         Map<String, Object> returnVal = null; END 
        if (event.isExternal()) {
            returnVal = getCallsHandler().executeModification(""InsertExternalAuditLog"", getExternalEventSqlMapper(event));
        }
        else {
            returnVal = getCallsHandler().executeModification(""InsertAuditLog"", getSqlMapper(event));
        }
        event.setAuditLogId((Integer) returnVal.get(""audit_log_id""));
    }
","    public void save(AuditLog event) {
        if (event.isExternal()) {
            getCallsHandler().executeModification(""InsertExternalAuditLog"", getExternalEventSqlMapper(event));
        }
        else {
            getCallsHandler().executeModification(""InsertAuditLog"", getSqlMapper(event));
        }
    }
"
1316,"Not critical but there is `queryBuilder()` method that implicitly performs `client.queryBuilder()`, also there is `run` method for those queries that does not need to return any result (check `ClusterTest` class).","  public void testCrossSourceMultiFragmentJoin() throws Exception {
    try {
      client.alterSession(ExecConstants.SLICE_TARGET, 1);
      client.queryBuilder()
          .sql(""select x.person_id, y.salary from h2.drill_h2_test.person x ""
              + ""join %s y on x.person_id = y.person_id "", TABLE_NAME)
          .run();
    } finally {
      client.resetSession(ExecConstants.SLICE_TARGET);
    }
  }
","  public void testCrossSourceMultiFragmentJoin() throws Exception {
    try {
      client.alterSession(ExecConstants.SLICE_TARGET, 1);
START       client.queryBuilder() END 
          .sql(""select x.person_id, y.salary from h2.drill_h2_test.person x ""
              + ""join %s y on x.person_id = y.person_id "", TABLE_NAME)
          .run();
    } finally {
      client.resetSession(ExecConstants.SLICE_TARGET);
    }
  }
","  public void testCrossSourceMultiFragmentJoin() throws Exception {
    try {
      client.alterSession(ExecConstants.SLICE_TARGET, 1);
      run(""select x.person_id, y.salary from h2.drill_h2_test.person x ""
              + ""join %s y on x.person_id = y.person_id "", TABLE_NAME);
    } finally {
      client.resetSession(ExecConstants.SLICE_TARGET);
    }
  }
"
1317,names.forEach( name -> comboBox.add(name)); would be more concise,"	private static void setDropdown(Combo comboBox, INamedElement el, List<String> names) {
		comboBox.removeAll();
		for (String name : names) {
			comboBox.add(name);
		}
		// pre-selects the elements that are now in the action:
		comboBox.select((null == el) ? names.size() - 1 : comboBox.indexOf(el.getName()));
	}
","	private static void setDropdown(Combo comboBox, INamedElement el, List<String> names) {
		comboBox.removeAll();
START 		for (String name : names) {
			comboBox.add(name);
		} END 
		// pre-selects the elements that are now in the action:
		comboBox.select((null == el) ? names.size() - 1 : comboBox.indexOf(el.getName()));
	}
","	private static void setDropdown(Combo comboBox, INamedElement el, List<String> names) {
		comboBox.removeAll();
		names.forEach(comboBox::add);
		// pre-selects the elements that are now in the action:
		comboBox.select((null == el) ? names.size() - 1 : comboBox.indexOf(el.getName()));
	}
"
1318,"I am not sure that it is 'closed' for a non recovery reader.

Maybe I need a coffee :)","    boolean isHandleWritable() {
        return !getLedgerMetadata().isClosed();
    }
","    boolean isHandleWritable() {
START         return !getLedgerMetadata().isClosed(); END 
    }
","    protected boolean isHandleWritable() {
        return !getLedgerMetadata().isClosed();
    }
"
1319,"Don't leave this empty - better to add the call to _super()_ - even though it is implicit, as this enables placing a debug breakpoint in the constructor.","        public SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX()
        {}
","        public SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX()
START         {} END 
","        public SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX() {
            super();
        }
"
1320,"I see a ConcurrentModificationException in all derived tests from StructuredViewerTest#testDeleteInput.

java.util.ConcurrentModificationException
	at java.util.Vector$Itr.checkForComodification(Vector.java:1210)
	at java.util.Vector$Itr.next(Vector.java:1163)
	at org.eclipse.jface.tests.viewers.TestModel.fireModelChanged(TestModel.java:40)
	at org.eclipse.jface.tests.viewers.TestElement.deleteChild(TestElement.java:134)
	at org.eclipse.jface.tests.viewers.TestElement.deleteChild(TestElement.java:128)
	at org.eclipse.jface.tests.viewers.StructuredViewerTest.testDeleteInput(StructuredViewerTest.java:164)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at junit.framework.TestCase.runTest(TestCase.java:176)
	at junit.framework.TestCase.runBare(TestCase.java:141)
	at junit.framework.TestResult$1.protect(TestResult.java:122)
	at junit.framework.TestResult.runProtected(TestResult.java:142)
	at junit.framework.TestResult.run(TestResult.java:125)
	at junit.framework.TestCase.run(TestCase.java:129)
	at junit.framework.TestSuite.runTest(TestSuite.java:252)
	at junit.framework.TestSuite.run(TestSuite.java:247)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)
	at org.junit.runners.Suite.runChild(Suite.java:128)
	at org.junit.runners.Suite.runChild(Suite.java:27)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runners.Suite.runChild(Suite.java:128)
	at org.junit.runners.Suite.runChild(Suite.java:27)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:89)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:41)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:542)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:764)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:464)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:210)","	public void fireModelChanged(TestModelChange change) {
		for (ITestModelListener listener : fListeners) {
			listener.testModelChanged(change);
		}
	}
","	public void fireModelChanged(TestModelChange change) {
START 		for (ITestModelListener listener : fListeners) { END 
			listener.testModelChanged(change);
		}
	}
","	public void fireModelChanged(TestModelChange change) {
		for (int i = 0; i < fListeners.size(); ++i) {
			ITestModelListener listener = fListeners.get(i);
			listener.testModelChanged(change);
		}
	}
"
1321,"really only btw :) .... wouldn't 
`return path.isFound() ? path.getWeight() : Double.POSITIVE_INFINITY;`
be slightly better as you used the ternary op in the line above?","    public double approximate(int currentNode) {
        Dijkstra dijkstra = new Dijkstra(graph, weighting, traversalMode);
        Path path = reverse ? dijkstra.calcPath(to, currentNode) : dijkstra.calcPath(currentNode, to);
        if (path.isFound()) return path.getWeight(); else return Double.POSITIVE_INFINITY;
    }
","    public double approximate(int currentNode) {
        Dijkstra dijkstra = new Dijkstra(graph, weighting, traversalMode);
        Path path = reverse ? dijkstra.calcPath(to, currentNode) : dijkstra.calcPath(currentNode, to);
START         if (path.isFound()) return path.getWeight(); else return Double.POSITIVE_INFINITY; END 
    }
","    public double approximate(int currentNode) {
        Dijkstra dijkstra = new Dijkstra(graph, weighting, traversalMode);
        Path path = reverse ? dijkstra.calcPath(to, currentNode) : dijkstra.calcPath(currentNode, to);
        return path.isFound() ? path.getWeight() : Double.POSITIVE_INFINITY;
    }
"
1322,You should call `.isEmpty()`,"  public boolean isValidAuthorizations(String user, List<ByteBuffer> auths) throws AccumuloSecurityException {
    if (auths.size() == 0) {
      // avoid deserializing auths from ZK cache
      return true;
    }

    Authorizations userauths = getCachedUserAuthorizations(user);

    for (ByteBuffer auth : auths) {
      if (!userauths.contains(ByteBufferUtil.toBytes(auth))) {
        return false;
      }
    }

    return true;
  }
","  public boolean isValidAuthorizations(String user, List<ByteBuffer> auths) throws AccumuloSecurityException {
START     if (auths.size() == 0) { END 
      // avoid deserializing auths from ZK cache
      return true;
    }

    Authorizations userauths = getCachedUserAuthorizations(user);

    for (ByteBuffer auth : auths) {
      if (!userauths.contains(ByteBufferUtil.toBytes(auth))) {
        return false;
      }
    }

    return true;
  }
","  public boolean isValidAuthorizations(String user, List<ByteBuffer> auths) throws AccumuloSecurityException {
    if (auths.isEmpty()) {
      // avoid deserializing auths from ZK cache
      return true;
    }

    Authorizations userauths = getCachedUserAuthorizations(user);

    for (ByteBuffer auth : auths) {
      if (!userauths.contains(ByteBufferUtil.toBytes(auth))) {
        return false;
      }
    }

    return true;
  }
"
1323,"scaledData, thread safety and all","    public synchronized long getTimestamp(final int offset) {
        HistogramScaledData scaledData = fScaledData;
        if (scaledData != null) {
            return fScaledData.fFirstBucketTime + Math.round(scaledData.fBucketDuration * offset);
        }
        return 0;
    }
","    public synchronized long getTimestamp(final int offset) {
        HistogramScaledData scaledData = fScaledData;
        if (scaledData != null) {
            return START  fScaledData.fFirstBucketTime END  + Math.round(scaledData.fBucketDuration * offset);
        }
        return 0;
    }
","    public synchronized long getTimestamp(final int offset) {
        HistogramScaledData scaledData = fScaledData;
        if (scaledData != null) {
            return scaledData.fFirstBucketTime + Math.round(scaledData.fBucketDuration * offset);
        }
        return 0;
    }
"
1324,I think lines 71-74 don't need to be inside the try block. It would be nice to take them out in order to keep the try block as small as possible.,"	private String serializeToXmlString(EntityDescriptor entityDescriptor) {
		try {
			Marshaller marshaller = XMLObjectProviderRegistrySupport.getMarshallerFactory().getMarshaller(entityDescriptor);
			if (marshaller == null) {
				throw new Saml2Exception(""Unable to resolve Marshaller"");
			}
			Element element = marshaller.marshall(entityDescriptor);
			return SerializeSupport.prettyPrintXML(element);
		} catch (Exception e) {
			throw new Saml2Exception(e);
		}
	}
","	private String serializeToXmlString(EntityDescriptor entityDescriptor) {
		try {
START 			Marshaller marshaller = XMLObjectProviderRegistrySupport.getMarshallerFactory().getMarshaller(entityDescriptor); END 
			if (marshaller == null) {
				throw new Saml2Exception(""Unable to resolve Marshaller"");
			}
			Element element = marshaller.marshall(entityDescriptor);
			return SerializeSupport.prettyPrintXML(element);
		} catch (Exception e) {
			throw new Saml2Exception(e);
		}
	}
","	private String serializeToXmlString(EntityDescriptor entityDescriptor) {
		Marshaller marshaller = XMLObjectProviderRegistrySupport.getMarshallerFactory().getMarshaller(entityDescriptor);
		if (marshaller == null) {
			throw new Saml2Exception(""Unable to resolve Marshaller"");
		}
		Element element;
		try {
			element = marshaller.marshall(entityDescriptor);
		} catch (Exception e) {
			throw new Saml2Exception(e);
		}
		return SerializeSupport.prettyPrintXML(element);
	}
"
1325,just my personal opinion but not sure this helps code readability,"	public boolean isInIdClass() {
		return isInIdClass != null ? isInIdClass : ( parent != null && parent.isInIdClass() );
	}
","	public boolean isInIdClass() {
START 		return isInIdClass != null ? isInIdClass : ( parent != null && parent.isInIdClass() ); END 
	}
","	public boolean isInIdClass() {
		if ( isInIdClass != null ) {
			return isInIdClass;
		}
		if ( parent != null ) {
			return parent.isInIdClass();
		}
		return false;
	}
"
1326,"Not sure if you notice, a method reference can be used here:
```
        this.original =
                Optional.ofNullable(
                                (ServletRequestAttributes)
                                        RequestContextHolder.getRequestAttributes())
                        .map(ServletRequestAttributes::getRequest);
```","    public FakeHttpServletRequest(
            Map<String, String> parameterMap, Cookie[] cookies, String workspace) {
        this.parameterMap = parameterMap;
        this.cookies = cookies;
        this.workspace = workspace;
        // grab the original request from Spring to forward security related attributes
        // such as requests host, ports and headers
        this.original =
                Optional.ofNullable(
                                (ServletRequestAttributes)
                                        RequestContextHolder.getRequestAttributes())
                        .map(atts -> atts.getRequest());
    }
","    public FakeHttpServletRequest(
            Map<String, String> parameterMap, Cookie[] cookies, String workspace) {
        this.parameterMap = parameterMap;
        this.cookies = cookies;
        this.workspace = workspace;
        // grab the original request from Spring to forward security related attributes
        // such as requests host, ports and headers
        this.original =
                Optional.ofNullable(
                                (ServletRequestAttributes)
                                        RequestContextHolder.getRequestAttributes())
START                         .map(atts -> atts.getRequest()); END 
    }
","    public FakeHttpServletRequest(
            Map<String, String> parameterMap, Cookie[] cookies, String workspace) {
        this.parameterMap = parameterMap;
        this.cookies = cookies;
        this.workspace = workspace;
        // grab the original request from Spring to forward security related attributes
        // such as requests host, ports and headers
        this.original =
                Optional.ofNullable(
                                (ServletRequestAttributes)
                                        RequestContextHolder.getRequestAttributes())
                        .map(ServletRequestAttributes::getRequest);
    }
"
1327,minor: no need to add explicit type argument here,"        AbstractBuilder(int initialCapacity) {
            this.list = new ArrayList<T>(initialCapacity);
        }
","        AbstractBuilder(int initialCapacity) {
START             this.list = new ArrayList<T>(initialCapacity); END 
        }
","        AbstractBuilder(int initialCapacity) {
            this.list = new ArrayList<>(initialCapacity);
        }
"
1328,"The above two checks can be moved to a common parent class, as the same is repeated in GlusterHookStatusChangeCommand as well.","    protected boolean canDoAction() {
        if (!super.canDoAction()) {
            return false;
        }

        if (Guid.isNullOrEmpty(getParameters().getHookId())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_ID_IS_REQUIRED);
            return false;
        }

        if (getGlusterHook() == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_DOES_NOT_EXIST);
            return false;
        }

        if (getMissingServerHooks().isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_NO_CONFLICT_SERVERS);
            return false;
        }

        return true;
    }
","    protected boolean canDoAction() {
        if (!super.canDoAction()) {
            return false;
        }

        if (Guid.isNullOrEmpty(getParameters().getHookId())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_ID_IS_REQUIRED);
            return false;
        }

        if (getGlusterHook() == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_DOES_NOT_EXIST);
            return false;
START         } END 

        if (getMissingServerHooks().isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_NO_CONFLICT_SERVERS);
            return false;
        }

        return true;
    }
","    protected boolean canDoAction() {
        if (!super.canDoAction()) {
            return false;
        }

        if (getMissingServerHooks().isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_HOOK_NO_CONFLICT_SERVERS);
            return false;
        }

        return true;
    }
"
1329,Can we use logger ?,"    private void displayDetails(String period, String unit, String dataType)
            throws Exception {
        System.out.println(""***********************************************"");
        System.out.println(""executing for:"");
        System.out.println(unit + ""("" + period + "")"");
        System.out.println(""dataType="" + dataType);
        System.out.println(""***********************************************"");
    }
","    private void displayDetails(String period, String unit, String dataType)
            throws Exception {
START         System.out.println(""***********************************************""); END 
        System.out.println(""executing for:"");
        System.out.println(unit + ""("" + period + "")"");
        System.out.println(""dataType="" + dataType);
        System.out.println(""***********************************************"");
    }
","    private void displayDetails(String period, String unit, String dataType)
            throws Exception {
        logger.info(""***********************************************"");
        logger.info(""executing for:"");
        logger.info(unit + ""("" + period + "")"");
        logger.info(""dataType="" + dataType);
        logger.info(""***********************************************"");
    }
"
1330,This doesn't exactly work anymore.  We need to implement the same behavior in the database code.,"  static Module module() {
    return new CacheModule() {
      @Override
      protected void configure() {
        final String cacheName = CACHE_NAME;
        final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type =
            new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {};
        core(type, cacheName) //
            .memoryLimit(1024) // reasonable default for many sites
            .maxAge(12, HOURS) // expire sessions if they are inactive
            .evictionPolicy(EvictionPolicy.LRU) // keep most recently used
        ;
        bind(WebSession.class).in(RequestScoped.class);
      }
    };
  }
","  static Module module() {
    return new CacheModule() {
      @Override
      protected void configure() {
        final String cacheName = CACHE_NAME;
        final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type =
            new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {};
        core(type, cacheName) //
            .memoryLimit(1024) // reasonable default for many sites
START             .maxAge(12, HOURS) // expire sessions if they are inactive END 
            .evictionPolicy(EvictionPolicy.LRU) // keep most recently used
        ;
        bind(WebSession.class).in(RequestScoped.class);
      }
    };
  }
","  static Module module() {
    return new CacheModule() {
      @Override
      protected void configure() {
        final TypeLiteral<Cache<ActiveSession.Key, ActiveSession>> type =
            new TypeLiteral<Cache<ActiveSession.Key, ActiveSession>>() {};
        core(type, CACHE_NAME) //
            .memoryLimit(1024) // reasonable default for many sites
            .maxAge(12, HOURS) // expire sessions if they are inactive
            .evictionPolicy(EvictionPolicy.LRU) // keep most recently used
        ;
        bind(WebSession.class).in(RequestScoped.class);
      }
    };
  }
"
1331,"`Http.Context.current().request().setUsername(email);`

Tu pourras donc aussi enlever le import de Controller","    private void setUsernameInRequest() {
        Http.Session session = Http.Context.current().session();
        String email = session.get(ConstantsManager.COOKIE_EMAIL_FIELD_NAME);
        Controller.request().setUsername(email);
    }
","    private void setUsernameInRequest() {
        Http.Session session = Http.Context.current().session();
        String email = session.get(ConstantsManager.COOKIE_EMAIL_FIELD_NAME);
START         Controller.request().setUsername(email); END 
    }
","    private void setUsernameInRequest() {
        Http.Session session = Http.Context.current().session();
        String email = session.get(ConstantsManager.COOKIE_EMAIL_FIELD_NAME);
        Http.Context.current().request().setUsername(email);
    }
"
1332,"Optional: Can be written as ProtocolVersion.V2.equals(transferConfig.protocolVersion), since we know that ProtocolVersion.V2 is never null.","	private boolean useProtocolV2() {
		return Objects.equals(transferConfig.protocolVersion,
					ProtocolVersion.V2)
				&& clientRequestedV2;
	}
","	private boolean useProtocolV2() {
START 		return Objects.equals(transferConfig.protocolVersion, END 
					ProtocolVersion.V2)
				&& clientRequestedV2;
	}
","	private boolean useProtocolV2() {
		return ProtocolVersion.V2.equals(transferConfig.protocolVersion)
				&& clientRequestedV2;
	}
"
1333,"I would remove the if an always log the number of entries removed, which can be 0","	private synchronized int purgeExpiredRecallRequests(long expirationTime, int purgeSize) {

		int n = new TapeRecallCatalog().purgeCatalog(expirationTime, purgeSize);
		if (n == 0) {
			log.trace(""No entries have been purged from tape_recall table"");
		} else {
			log.info(""{} entries have been purged from tape_recall table"", n);
		}
		return n;
	}
","	private synchronized int purgeExpiredRecallRequests(long expirationTime, int purgeSize) {

		int n = new TapeRecallCatalog().purgeCatalog(expirationTime, purgeSize);
		if (n == 0) {
START 			log.trace(""No entries have been purged from tape_recall table""); END 
		} else {
			log.info(""{} entries have been purged from tape_recall table"", n);
		}
		return n;
	}
","	private synchronized int purgeExpiredRecallRequests(long expirationTime, int purgeSize) {

		return new TapeRecallCatalog().purgeCatalog(expirationTime, purgeSize);
	}
"
1334,"should just be `return supplier.f()`.
In FJ we do not special on case `null` imput value: protecting each input parameter against null would litter the code with garbage, maybe also impact perf and, in this case, hide root issue by propagating a null value.

Only dedicated APIs like `Option.fromNull` explicitly deal with `null`.","    public A value() {
      return supplier != null ? supplier.f() : null;
    }
","    public A value() {
START       return supplier != null ? supplier.f() : null; END 
    }
","    public final A value() {
      return supplier.f();
    }
"
1335,Please move the annotation to its own line,"    @Override public void onDestroyView() {
        super.onDestroyView();
        if (disposable != null) {
            disposable.dispose();
        }
    }
","START     @Override public void onDestroyView() { END 
        super.onDestroyView();
        if (disposable != null) {
            disposable.dispose();
        }
    }
","    public void onDestroyView() {
        super.onDestroyView();
        if (disposable != null) {
            disposable.dispose();
        }
    }
"
1336,"Why?
It seems that this cannot happen","    void generateParameterValueSet(ActivationClassBuilder acb) throws StandardException {
        Vector parameterList = getCompilerContext().getParameterList();
        int numberOfParameters = (parameterList == null) ? 0 : parameterList.size();

        if (numberOfParameters < 0)
            return;

        ParameterNode.generateParameterValueSet
                (acb, numberOfParameters, parameterList);
    }
","    void generateParameterValueSet(ActivationClassBuilder acb) throws StandardException {
        Vector parameterList = getCompilerContext().getParameterList();
        int numberOfParameters = (parameterList == null) ? 0 : parameterList.size();

START         if (numberOfParameters < 0) END 
            return;

        ParameterNode.generateParameterValueSet
                (acb, numberOfParameters, parameterList);
    }
","    void generateParameterValueSet(ActivationClassBuilder acb) throws StandardException {
        Vector parameterList = getCompilerContext().getParameterList();
        int numberOfParameters = (parameterList == null) ? 0 : parameterList.size();

        ParameterNode.generateParameterValueSet
                (acb, numberOfParameters, parameterList);
    }
"
1337,seems odd to return null here even if it had been explicitly set to FALSE,"	public Boolean getXD_JMX_ENABLED() {
		return (jmxEnabled != null && jmxEnabled) ? jmxEnabled : null;
	}
","	public Boolean getXD_JMX_ENABLED() {
START 		return (jmxEnabled != null && jmxEnabled) ? jmxEnabled : null; END 
	}
","	public Boolean getXD_JMX_ENABLED() {
		return jmxEnabled;
	}
"
1338,"This looks like a C style equality check. Also, it does not account for case mismatches. Conside using if(""resourceDoc"".equalsIgnoreCase(xmlTag))... instead.","   private void validateTag(String xmlTag) {

      Conditions.checkNotNullOrEmpty(xmlTag, ""xmlTag"");
      // resources can only have three tags: ""resourceDoc"", ""applicationDocs"" or ""grammars""
      boolean valid = false;
      if (xmlTag.compareTo(""resourceDoc"") == 0) {
         valid = true;
      } else if (xmlTag.compareTo(""applicationDocs"") == 0) {
         valid = true;
      } else if (xmlTag.compareTo(""grammars"") == 0) {
         valid = true;
      }
      if (!valid) {
         throw new OseeArgumentException(""Invalid resource document tag"");
      }
   }
","   private void validateTag(String xmlTag) {

      Conditions.checkNotNullOrEmpty(xmlTag, ""xmlTag"");
      // resources can only have three tags: ""resourceDoc"", ""applicationDocs"" or ""grammars""
START       boolean valid = false; END 
      if (xmlTag.compareTo(""resourceDoc"") == 0) {
         valid = true;
      } else if (xmlTag.compareTo(""applicationDocs"") == 0) {
         valid = true;
      } else if (xmlTag.compareTo(""grammars"") == 0) {
         valid = true;
      }
      if (!valid) {
         throw new OseeArgumentException(""Invalid resource document tag"");
      }
   }
","   private void validateTag(String xmlTag) {

      Conditions.checkNotNullOrEmpty(xmlTag, ""xmlTag"");
      // resources can only have three tags: ""resourceDoc"", ""applicationDocs"" or ""grammars""
      boolean valid = false;
      if (xmlTag.equals(""resourceDoc"")) {
         valid = true;
      } else if (xmlTag.equals(""applicationDocs"")) {
         valid = true;
      } else if (xmlTag.equals(""grammars"")) {
         valid = true;
      }
      if (!valid) {
         throw new OseeArgumentException(""Invalid resource document tag"");
      }
   }
"
1339,Should include other properties to break ties here,"	public int compareTo(ModuleMetadata other) {
		return this.getName().compareTo(other.getName());
	}
","	public int compareTo(ModuleMetadata other) {
START 		return this.getName().compareTo(other.getName()); END 
	}
","	public int compareTo(ModuleMetadata other) {
		return this.getId().compareTo(other.getId());
	}
"
1340,static,"  private BlockingQueue<Runnable> newQueue(boolean needPrioritySort) {
    return needPrioritySort ? new PriorityBlockingQueue<>() : new LinkedBlockingQueue<>();
  }
","START   private BlockingQueue<Runnable> newQueue(boolean needPrioritySort) { END 
    return needPrioritySort ? new PriorityBlockingQueue<>() : new LinkedBlockingQueue<>();
  }
","  private static BlockingQueue<Runnable> newQueue(boolean needPrioritySort) {
    return needPrioritySort ? new PriorityBlockingQueue<>() : new LinkedBlockingQueue<>();
  }
"
1341,missing braces,"			public void run() {
				if (historyPage.getCurrentRepo() == null)
					return;

				dialog = new GitHistoryRefFilterConfigurationDialog(
						historyPage.getSite().getWorkbenchWindow().getShell(),
						historyPage.getCurrentRepo(), historyPage.helper);
				if (dialog.open() == Window.OK) {
					historyPage.refresh(historyPage.selectedCommit());
				}
			}
","			public void run() {
START 				if (historyPage.getCurrentRepo() == null) END 
					return;

				dialog = new GitHistoryRefFilterConfigurationDialog(
						historyPage.getSite().getWorkbenchWindow().getShell(),
						historyPage.getCurrentRepo(), historyPage.helper);
				if (dialog.open() == Window.OK) {
					historyPage.refresh(historyPage.selectedCommit());
				}
			}
","			public void run() {
				if (historyPage.getCurrentRepo() == null) {
					return;
				}

				dialog = new GitHistoryRefFilterConfigurationDialog(
						historyPage.getSite().getWorkbenchWindow().getShell(),
						historyPage.getCurrentRepo(), historyPage.helper);
				if (dialog.open() == Window.OK) {
					historyPage.refresh(historyPage.selectedCommit());
				}
			}
"
1342,Could this ever be null since `getString()` is passed a default?,"  public String getAccumuloClasspath() {
    return verifyNotNull(ADMIN_ACCUMULO_CLASSPATH_PROP, getString(ADMIN_ACCUMULO_CLASSPATH_PROP, ADMIN_ACCUMULO_CLASSPATH_DEFAULT));
  }
","  public String getAccumuloClasspath() {
START     return verifyNotNull(ADMIN_ACCUMULO_CLASSPATH_PROP, getString(ADMIN_ACCUMULO_CLASSPATH_PROP, ADMIN_ACCUMULO_CLASSPATH_DEFAULT)); END 
  }
","  public String getAccumuloClasspath() {
    return getString(ADMIN_ACCUMULO_CLASSPATH_PROP, ADMIN_ACCUMULO_CLASSPATH_DEFAULT);
  }
"
1343,I'm not seeing the added benefit of this one since `AuthenticationWebFilter` displays the same information. Is it necessary?,"	private AuthenticationException onError(JwtException e) {
		if (logger.isDebugEnabled()) {
			logger.debug(""Authentication error for Jwt Token: "" + e.getMessage());
		}
		if (e instanceof BadJwtException) {
			return new InvalidBearerTokenException(e.getMessage(), e);
		} else {
			return new AuthenticationServiceException(e.getMessage(), e);
		}
	}
","	private AuthenticationException onError(JwtException e) {
START 		if (logger.isDebugEnabled()) { END 
			logger.debug(""Authentication error for Jwt Token: "" + e.getMessage());
		}
		if (e instanceof BadJwtException) {
			return new InvalidBearerTokenException(e.getMessage(), e);
		} else {
			return new AuthenticationServiceException(e.getMessage(), e);
		}
	}
","	private AuthenticationException onError(JwtException e) {
		if (e instanceof BadJwtException) {
			return new InvalidBearerTokenException(e.getMessage(), e);
		} else {
			return new AuthenticationServiceException(e.getMessage(), e);
		}
	}
"
1344,Maybe we could also pass the root cause when creating the new exception.,"	private void validateCallbackUrl(String callbackUrl) {

		try {
			new URL(callbackUrl);
		} catch (MalformedURLException e) {
			throw new IllegalArgumentException(""Callback URL must be valid if provided!"");
		}

	}
","	private void validateCallbackUrl(String callbackUrl) {

		try {
			new URL(callbackUrl);
		} catch (MalformedURLException e) {
START 			throw new IllegalArgumentException(""Callback URL must be valid if provided!""); END 
		}

	}
","	private void validateCallbackUrl(String callbackUrl) {

		try {
			new URL(callbackUrl);
		} catch (MalformedURLException e) {
			throw new IllegalArgumentException(""Callback URL must be valid if provided!"", e);
		}

	}
"
1345,"BTW can be written more concisely with an effectively final variable:

``` java
Authentication auth = user.impersonate();
SecurityContext initialContext = ACL.impersonate(auth);
try {
    return EnvInjectPlugin.canViewInjectedVars(run);
} finally {
    SecurityContextHolder.setContext(initialContext);
}
```

(There are also two newer overloads with closures, but neither are suitable for Java 8 lambdas.)","    private boolean canViewInjectedVars(@Nonnull User user, @Nonnull Run<?,?> run) 
            throws UsernameNotFoundException {
        SecurityContext initialContext = null;
        try {
            Authentication auth = user.impersonate();
            initialContext = hudson.security.ACL.impersonate(auth);
            return EnvInjectPlugin.canViewInjectedVars(run);
        } finally {
            if (initialContext != null) {
                SecurityContextHolder.setContext(initialContext);
            }
        }
    }
","    private boolean canViewInjectedVars(@Nonnull User user, @Nonnull Run<?,?> run) 
            throws UsernameNotFoundException {
        SecurityContext initialContext = null;
        try {
            Authentication auth = user.impersonate();
            initialContext = hudson.security.ACL.impersonate(auth);
            return EnvInjectPlugin.canViewInjectedVars(run);
        } finally {
            if (initialContext != null) {
                SecurityContextHolder.setContext(initialContext);
            }
START         } END 
    }
","    private boolean canViewInjectedVars(@Nonnull User user, @Nonnull Run<?,?> run) 
            throws UsernameNotFoundException {
        SecurityContext initialContext = null;
        Authentication auth = user.impersonate();
        initialContext = hudson.security.ACL.impersonate(auth);
        try {
            return EnvInjectPlugin.canViewInjectedVars(run);
        } finally {
            SecurityContextHolder.setContext(initialContext);
        }
    }
"
1346,"so why is this an error and not a warning? Since the system proceeds without giving up, I think it should be a warning","  public void doPrefetch(int index, long relativeOffset, long size) {
    try {
      readOptions.get(index).doPrefetch(relativeOffset, size);
    } catch (Exception e) {
      logger.error(""Data Prefetch failed"", e);
    }
  }
","  public void doPrefetch(int index, long relativeOffset, long size) {
    try {
      readOptions.get(index).doPrefetch(relativeOffset, size);
    } catch (Exception e) {
START       logger.error(""Data Prefetch failed"", e); END 
    }
  }
","  public void doPrefetch(int index, long relativeOffset, long size) throws IOException {
    readOptions.get(index).doPrefetch(relativeOffset, size);
  }
"
1347,This should probably be removed,"    public void latchAwaitSeconds(int sec) throws InterruptedException {
        System.out.println(""AWAIT "" + latch);
        if (!latch.await(sec, TimeUnit.SECONDS)) {
            throw new RuntimeException(""Await failed"");
        }
    }
","    public void latchAwaitSeconds(int sec) throws InterruptedException {
START         System.out.println(""AWAIT "" + latch); END 
        if (!latch.await(sec, TimeUnit.SECONDS)) {
            throw new RuntimeException(""Await failed"");
        }
    }
","    public void latchAwaitSeconds(int sec) throws InterruptedException {
        if (!latch.await(sec, TimeUnit.SECONDS)) {
            throw new RuntimeException(""Await failed"");
        }
    }
"
1348,"you can simplify it with a single line by replacing the method's body with:

  return validate(hostExists()) && validate(hostStatusValid());","    protected boolean canDoAction() {
        if (!(validate(hostExists()) && validate(hostStatusValid()))){
            return false;
        }
        return true;
    }
","START     protected boolean canDoAction() { END 
        if (!(validate(hostExists()) && validate(hostStatusValid()))){
            return false;
        }
        return true;
    }
","    protected boolean canDoAction() {
        return validate(hostExists()) && validate(hostStatusValid());
    }
"
1349,"Changing from returning null to returning an empty collection changes the SDK's interface, which might affect applications that are using it. I'd prefer not to make a breaking change unless it's absolutely neccessary.","	public List<ID3v2ChapterFrameData> getChapters() {
		if (obseleteFormat) {
			return Collections.emptyList();
		}

		return extractChapterFrameData(ID_CHAPTER);
	}
","	public List<ID3v2ChapterFrameData> getChapters() {
		if (obseleteFormat) {
START 			return Collections.emptyList(); END 
		}

		return extractChapterFrameData(ID_CHAPTER);
	}
","	public ArrayList<ID3v2ChapterFrameData> getChapters() {
		if (obseleteFormat) {
			return null;
		}

		return new ArrayList<>(extractChapterFrameData(ID_CHAPTER));
	}
"
1350,"checkImage(); should be below buildStatusPanel();

loadSupport();

buildImageViewer();

buildStatusPanel();

checkImage();","    ImageEditorPanel(MainFrame mainFrame, BufferedImage image, String name) {
        this.image = image;
        this.name = name;

        setTransferHandler(new ImageTransferHandler(mainFrame));

        checkImage();

        setOpaque(false);
        setLayout(new BorderLayout());

        loadSupport();
        buildImageViewer();
        buildStatusPanel();
    }
","    ImageEditorPanel(MainFrame mainFrame, BufferedImage image, String name) {
        this.image = image;
        this.name = name;

        setTransferHandler(new ImageTransferHandler(mainFrame));

        checkImage();

        setOpaque(false);
        setLayout(new BorderLayout());

        loadSupport();
START         buildImageViewer(); END 
        buildStatusPanel();
    }
","    ImageEditorPanel(MainFrame mainFrame, BufferedImage image, String name) {
        this.image = image;
        this.name = name;

        setTransferHandler(new ImageTransferHandler(mainFrame));

        setOpaque(false);
        setLayout(new BorderLayout());

        loadSupport();
        buildImageViewer();
        buildStatusPanel();

        checkImage();
    }
"
1351,Shouldn't this be this.variableName. This is a Potential Null pointer Exception.,"    public void setIdentifiers(List<Identifier> identifiers) {
        Identifiers = identifiers;
    }
","    public void setIdentifiers(List<Identifier> identifiers) {
START         Identifiers = identifiers; END 
    }
","    public void setIdentifiers(List<Identifier> identifiers) {
        this.identifiers = identifiers;
    }
"
1352,Seems like a lot of work just to verify that the json is valid. Perhaps there is some 3rd party utility to do that for us? Something to consider,"  public String getActionClass( ) {
    return environmentVariables.get( actionClass );
  }
","  public String getActionClass( ) {
    return environmentVariables.get( actionClass );
START   } END 
","  public String getActionClass( ) {
    return actionClass;
  }
"
1353,Why not use the synchronized in updateAvailableNetworks?,"    public void handleMessage(Message msg) {
        switch (msg.what) {
            case EVENT_QUALIFIED_NETWORKS_CHANGED:
                synchronized (this) {
                    AsyncResult ar = (AsyncResult) msg.obj;
                    List<QualifiedNetworks> networks = (List<QualifiedNetworks>) ar.result;
                    updateAvailableNetworks(networks);
                }
                break;
            default:
                loge(""Unexpected event "" + msg.what);
                break;
        }
    }
","    public void handleMessage(Message msg) {
        switch (msg.what) {
            case EVENT_QUALIFIED_NETWORKS_CHANGED:
                START  synchronized (this) { END 
                    AsyncResult ar = (AsyncResult) msg.obj;
                    List<QualifiedNetworks> networks = (List<QualifiedNetworks>) ar.result;
                    updateAvailableNetworks(networks);
                }
                break;
            default:
                loge(""Unexpected event "" + msg.what);
                break;
        }
    }
","    public void handleMessage(Message msg) {
        switch (msg.what) {
            case EVENT_QUALIFIED_NETWORKS_CHANGED:
                AsyncResult ar = (AsyncResult) msg.obj;
                List<QualifiedNetworks> networks = (List<QualifiedNetworks>) ar.result;
                updateAvailableNetworks(networks);
                break;
            default:
                loge(""Unexpected event "" + msg.what);
                break;
        }
    }
"
1354,"Is there any value to this null check? Even if it is null, this operation doesn't make any sense if we can't access the session.","    private void saveStateParamForIdpToRequestSession(String state, String idpOriginKey, HttpServletRequest request) {
        if (request != null) {
            request.getSession().setAttribute(""xoauth-state-"" + idpOriginKey, state);
        }
    }
","    private void saveStateParamForIdpToRequestSession(String state, String idpOriginKey, HttpServletRequest request) {
        if (request != null) {
            request.getSession().setAttribute(""xoauth-state-"" + idpOriginKey, state);
START         } END 
    }
","    private void saveStateParamForIdpToRequestSession(String state, String idpOriginKey, HttpServletRequest request) {
        request.getSession().setAttribute(""xoauth-state-"" + idpOriginKey, state);
    }
"
1355,"![MAJOR](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/severity-major.png) Make ""logMeasureByResource"" a ""static"" method. [![rule](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/rule.png)](https://dory.sonarsource.com/coding_rules#rule_key=squid%3AS2325)","  private void logMeasureByResource(Resource resource, Measure measure) {
    if (LOG.isDebugEnabled()) {
      Measure alreadySaved = MEASURES_BY_RESOURCE.get(resource);
      if (alreadySaved == null) {
        MEASURES_BY_RESOURCE.put(resource, measure);
      } else {
        LOG.debug(""Measure {} already saved for resource {}"", measure, resource);
      }
    }
  }
","START   private void logMeasureByResource(Resource resource, Measure measure) { END 
    if (LOG.isDebugEnabled()) {
      Measure alreadySaved = MEASURES_BY_RESOURCE.get(resource);
      if (alreadySaved == null) {
        MEASURES_BY_RESOURCE.put(resource, measure);
      } else {
        LOG.debug(""Measure {} already saved for resource {}"", measure, resource);
      }
    }
  }
","  private static void logMeasureByResource(Resource resource, Measure measure) {
    if (LOG.isDebugEnabled()) {
      Measure alreadySaved = MEASURES_BY_RESOURCE.get(resource);
      if (alreadySaved == null) {
        MEASURES_BY_RESOURCE.put(resource, measure);
      } else {
        LOG.debug(""Measure {} already saved for resource {}"", measure, resource);
      }
    }
  }
"
1356,"If we could get rid of null check, `addChildrenProducerBatch` and `getChildrenProducerBatch` could be removed as well.","    private List<ProducerBatch> getChildrenProducerBatch() {
        if (childrenProducerBatch == null) {
            return Collections.emptyList();
        }
        return childrenProducerBatch;
    }
","START     private List<ProducerBatch> getChildrenProducerBatch() { END 
        if (childrenProducerBatch == null) {
            return Collections.emptyList();
        }
        return childrenProducerBatch;
    }
","    private synchronized List<ProducerBatch> getChildrenProducerBatch() {
        if (childrenProducerBatch == null) {
            return Collections.emptyList();
        }
        return childrenProducerBatch;
    }
"
1357,Use braces {} - see https://www.dwheeler.com/essays/apple-goto-fail.html,"  private String getSetting(String settingName) {
    SettingKey key = settingKeyDAO.findByName(settingName);
    if (key != null) {
      Setting setting = settingDAO.findByKey(key);
      
      if (setting != null)
        return setting.getValue();
    }
    
    return null;
  }
","  private String getSetting(String settingName) {
    SettingKey key = settingKeyDAO.findByName(settingName);
    if (key != null) {
      Setting setting = settingDAO.findByKey(key);
      
      if (setting != null)
START         return setting.getValue(); END 
    }
    
    return null;
  }
","  private String getSetting(String settingName) {
    SettingKey key = settingKeyDAO.findByName(settingName);
    if (key != null) {
      Setting setting = settingDAO.findByKey(key);
      
      if (setting != null) {
        return setting.getValue();
      }
    }
    
    return null;
  }
"
1358,`Float.max()` is since 1.8 so it won't work on Android and GWT. Use `Math.max()` instead.,"	public float getPrefHeight () {
		// Min of borders + text height or drawable height
		layout = new GlyphLayout(style.font, model.getValue().toString());
		return Float.max(style.background.getMinHeight(),
			style.background.getTopHeight() + style.background.getBottomHeight() + layout.height);
	}
","	public float getPrefHeight () {
		// Min of borders + text height or drawable height
		layout = new GlyphLayout(style.font, model.getValue().toString());
START 		return Float.max(style.background.getMinHeight(), END 
			style.background.getTopHeight() + style.background.getBottomHeight() + layout.height);
	}
","	public float getPrefHeight () {
		// Max of borders + text height or drawable height
		return Math.max(style.background.getMinHeight(),
			style.background.getTopHeight() + style.background.getBottomHeight() + layout.height);
	}
"
1359,"no need for the wait, DefaultShell already has the wait inside","	private void removeIncludeExcludeWithHandler() {
		new PushButton(""Remove..."").click();
		new WaitUntil(new ShellIsAvailable(""Confirmation""));
		new DefaultShell(""Confirmation"");
		new PushButton(""OK"").click();
	}
","	private void removeIncludeExcludeWithHandler() {
		new PushButton(""Remove..."").click();
START 		new WaitUntil(new ShellIsAvailable(""Confirmation"")); END 
		new DefaultShell(""Confirmation"");
		new PushButton(""OK"").click();
	}
","	private void removeIncludeExcludeWithHandler() {
		new PushButton(""Remove..."").click();
		new DefaultShell(""Confirmation"");
		new PushButton(""OK"").click();
	}
"
1360,"This will only be logged if debug is enabled since it is in this block you might want to reorder if statements
```
if (!m_dataSourcesClosing.remove(tableName, partition)) <log info message>
else if (log.isDebugEnabled()) <log closed message>
```","    public synchronized void onClosedSource(String tableName, int partition) {
        boolean removed = m_dataSourcesClosing.remove(tableName, partition);
        if (exportLog.isDebugEnabled()) {
            if (removed) {
                exportLog.debug(""Closed "" + tableName + "", partition "" + partition);
            }
            else {
                exportLog.info(""Closed untracked "" + tableName + "", partition "" + partition + "" (ok on shutdown)"");
            }
        }
    }
","    public synchronized void onClosedSource(String tableName, int partition) {
        boolean removed = m_dataSourcesClosing.remove(tableName, partition);
        if (exportLog.isDebugEnabled()) {
            if (removed) {
                exportLog.debug(""Closed "" + tableName + "", partition "" + partition);
            }
            else {
START                 exportLog.info(""Closed untracked "" + tableName + "", partition "" + partition + "" (ok on shutdown)""); END 
            }
        }
    }
","    public synchronized void onClosedSource(String tableName, int partition) {
        boolean removed = m_dataSourcesClosing.remove(tableName, partition);
        if (exportLog.isDebugEnabled()) {
            if (removed) {
                exportLog.debug(""Closed "" + tableName + "", partition "" + partition);
            }
            else {
                exportLog.debug(""Closed untracked "" + tableName + "", partition "" + partition + "" (ok on shutdown)"");
            }
        }
    }
"
1361,shouldn't there be a default so this never happens ?,"	public String getJBossDiscoveryDirectory() {
		// use commandline override -Djboss.discovery.directory.url
		String directory = System.getProperty(JBOSS_DISCOVERY_DIRECTORY, null);
		if (directory == null) {
			IPropertiesProvider pp = PropertiesHelper.getPropertiesProvider();
			try {
				directory = pp.getValue(JBOSS_DISCOVERY_DIRECTORY,  new NullProgressMonitor());
			} catch (CoreException e) {
				throw new RuntimeException(e);
			}
		}
		return directory;
	}
","	public String getJBossDiscoveryDirectory() {
		// use commandline override -Djboss.discovery.directory.url
		String directory = System.getProperty(JBOSS_DISCOVERY_DIRECTORY, null);
		if (directory == null) {
			IPropertiesProvider pp = PropertiesHelper.getPropertiesProvider();
			try {
				directory = pp.getValue(JBOSS_DISCOVERY_DIRECTORY,  new NullProgressMonitor());
			} catch (CoreException e) {
START 				throw new RuntimeException(e); END 
			}
		}
		return directory;
	}
","	public String getJBossDiscoveryDirectory() {
		// use commandline override -Djboss.discovery.directory.url
		String directory = System.getProperty(JBOSS_DISCOVERY_DIRECTORY, null);
		if (directory == null) {
			IPropertiesProvider pp = PropertiesHelper.getPropertiesProvider();
			directory = pp.getValue(JBOSS_DISCOVERY_DIRECTORY);
		}
		return directory;
	}
"
1362,"No need... 
getImage().setActive(active)","    public void setActive(boolean active) {
        getImage().setActive(true == active);
    }
","    public void setActive(boolean active) {
START         getImage().setActive(true == active); END 
    }
","    public void setActive(boolean active) {
        getImage().setActive(active);
    }
"
1363,What does this call do?,"    public MainDrawerHandler(WikiDrawerLayout slidingPane, Activity parentActivity) {
        this.slidingPane = slidingPane;
        this.parentActivity = parentActivity;
        ButterKnife.bind(this.slidingPane);
        setUpViews();

    }
","    public MainDrawerHandler(WikiDrawerLayout slidingPane, Activity parentActivity) {
        this.slidingPane = slidingPane;
        this.parentActivity = parentActivity;
        START  ButterKnife.bind(this.slidingPane); END 
        setUpViews();

    }
","    MainDrawerHandler(WikiDrawerLayout slidingPane, Activity parentActivity) {
        this.slidingPane = slidingPane;
        this.parentActivity = parentActivity;
        setUpViews();
    }
"
1364,"We can use try-with-resources now.
I know this is only a refactoring but we can take this opportunity to clean up code","    public KeyStore loadKeyStore() throws IOException, GeneralSecurityException {
        KeyStore ks = keyStoreInstance();
        InputStream inputStream = null;
        try {
            inputStream = new FileInputStream(new File(keyStorePath));
            ks.load(inputStream, passwordStringToCharArray(keyStorePassword));
            return ks;
        } finally {
            forceClose(inputStream);
        }
    }
","    public KeyStore loadKeyStore() throws IOException, GeneralSecurityException {
        KeyStore ks = keyStoreInstance();
START         InputStream inputStream = null; END 
        try {
            inputStream = new FileInputStream(new File(keyStorePath));
            ks.load(inputStream, passwordStringToCharArray(keyStorePassword));
            return ks;
        } finally {
            forceClose(inputStream);
        }
    }
","    public KeyStore loadKeyStore() throws IOException, GeneralSecurityException {
        try (InputStream inputStream = new FileInputStream(new File(keyStorePath))) {
            KeyStore ks = keyStoreInstance();
            ks.load(inputStream, passwordStringToCharArray(keyStorePassword));
            return ks;
        }
    }
"
1365,you could just return upVolumesWithSuggestedCapacityAndNotInMasterCluster here,"    private List<GlusterVolumeEntity> getEligibleVolumesList(Set<GlusterVolumeEntity> upVolumesWithSuggestedCapacityAndNotInMasterCluster, Set<GlusterVolumeEntity> existingSessionSlaveVolumes) {
        List<GlusterVolumeEntity> eligibleVolumes = new ArrayList<GlusterVolumeEntity>();
        upVolumesWithSuggestedCapacityAndNotInMasterCluster.removeAll(existingSessionSlaveVolumes);
        eligibleVolumes.addAll(upVolumesWithSuggestedCapacityAndNotInMasterCluster);
        return eligibleVolumes;
    }
","    private List<GlusterVolumeEntity> getEligibleVolumesList(Set<GlusterVolumeEntity> upVolumesWithSuggestedCapacityAndNotInMasterCluster, Set<GlusterVolumeEntity> existingSessionSlaveVolumes) {
        List<GlusterVolumeEntity> eligibleVolumes = new ArrayList<GlusterVolumeEntity>();
START         upVolumesWithSuggestedCapacityAndNotInMasterCluster.removeAll(existingSessionSlaveVolumes); END 
        eligibleVolumes.addAll(upVolumesWithSuggestedCapacityAndNotInMasterCluster);
        return eligibleVolumes;
    }
","    private Set<GlusterVolumeEntity> getEligibleVolumesList(Set<GlusterVolumeEntity> upVolumesWithSuggestedCapacityAndNotInMasterCluster, Set<GlusterVolumeEntity> existingSessionSlaveVolumes) {
        upVolumesWithSuggestedCapacityAndNotInMasterCluster.removeAll(existingSessionSlaveVolumes);
        return upVolumesWithSuggestedCapacityAndNotInMasterCluster;
    }
"
1366,please use the Diamond Operator for initialization,"  public EclipseReferencePointManager() {
    referencePointToProjectMapper =
        new ConcurrentHashMap<IReferencePoint, org.eclipse.core.resources.IProject>();
  }
","  public EclipseReferencePointManager() {
    referencePointToProjectMapper =
START         new ConcurrentHashMap<IReferencePoint, org.eclipse.core.resources.IProject>(); END 
  }
","  public EclipseReferencePointManager() {
    referencePointToProjectMapper = new ConcurrentHashMap<>();
  }
"
1367,this doesn't belong here,"  public void setSchedulerService(SchedulerService schedulerService) throws InitialisationException {
    this.schedulerService = schedulerService;
    initialise();
  }
","  public void setSchedulerService(SchedulerService schedulerService) throws InitialisationException {
    this.schedulerService = schedulerService;
START     initialise(); END 
  }
","  void setSchedulerService(SchedulerService schedulerService) {
    this.schedulerService = schedulerService;
  }
"
1368,`while (loop < maxRetry)` will get rid of the extra `if break` condition.,"    public void evictExpiredEntries(int expirationPercentage) {
        long now = Clock.currentTimeMillis();
        int maxIterationCount = getMaxIterationCount(size(), expirationPercentage);
        int evictedCount = 0;
        int maxRetry = 3;
        int loop = 0;
        while (true) {
            evictedCount += evictExpiredInternal(maxIterationCount, now);
            if (evictedCount >= maxIterationCount) {
                break;
            }
            loop++;
            if (loop > maxRetry) {
                break;
            }
        }
    }
","    public void evictExpiredEntries(int expirationPercentage) {
        long now = Clock.currentTimeMillis();
        int maxIterationCount = getMaxIterationCount(size(), expirationPercentage);
        int evictedCount = 0;
        int maxRetry = 3;
        int loop = 0;
START         while (true) { END 
            evictedCount += evictExpiredInternal(maxIterationCount, now);
            if (evictedCount >= maxIterationCount) {
                break;
            }
            loop++;
            if (loop > maxRetry) {
                break;
            }
        }
    }
","    public void evictExpiredEntries(int expirationPercentage) {
        long now = Clock.currentTimeMillis();
        int maxIterationCount = getMaxIterationCount(size(), expirationPercentage);
        int evictedCount = 0;
        int maxRetry = 3;
        int loop = 0;
        while (loop < maxRetry) {
            evictedCount += evictExpiredInternal(maxIterationCount, now);
            if (evictedCount >= maxIterationCount) {
                break;
            }
            loop++;
        }
    }
"
1369,Why forceStart call is required when org.jboss.ide.eclipse.as.management.as71 is declared as a dependency for test plugin?,"	public static IJBoss7ManagerService findService(String runtimeType) {
		forceStart(""org.jboss.ide.eclipse.as.core"");
		forceStart(""org.jboss.ide.eclipse.as.management.as71"");
		forceStart(""org.jboss.ide.eclipse.as.management.wildfly8"");
		try {
			return JBoss7ManagerUtil.getService(runtimeType);
		} catch(JBoss7ManangerException ise) {
			return null;
		}
	}
","	public static IJBoss7ManagerService findService(String runtimeType) {
		forceStart(""org.jboss.ide.eclipse.as.core"");
START 		forceStart(""org.jboss.ide.eclipse.as.management.as71""); END 
		forceStart(""org.jboss.ide.eclipse.as.management.wildfly8"");
		try {
			return JBoss7ManagerUtil.getService(runtimeType);
		} catch(JBoss7ManangerException ise) {
			return null;
		}
	}
","	public static IJBoss7ManagerService findService(String runtimeType) {
		try {
			return JBoss7ManagerUtil.getService(runtimeType);
		} catch(JBoss7ManangerException ise) {
			return null;
		}
	}
"
1370,Should break line before dot,"  private List<Iterator<Entry<KeyType>>> getGroupersIterator(boolean sorted)
  {
    return groupers.stream()
                   .map(grouper -> {
                     synchronized (grouper) {
                       return grouper.iterator(sorted);
                     }
                   }).collect(Collectors.toList());
  }
","  private List<Iterator<Entry<KeyType>>> getGroupersIterator(boolean sorted)
  {
    return groupers.stream()
                   .map(grouper -> {
                     synchronized (grouper) {
                       return grouper.iterator(sorted);
                     }
START                    }).collect(Collectors.toList()); END 
  }
","  private List<Iterator<Entry<KeyType>>> getGroupersIterator(boolean sorted)
  {
    return groupers.stream()
                   .map(grouper -> grouper.iterator(sorted))
                   .collect(Collectors.toList());
  }
"
1371,Shouldn't you return an error code in this case?,"    private void waitForAppToFinish() {
        workers.shutdown();
        try {
            boolean finishedInTime = workers.
                    awaitTermination(durationMs + APPLICATION_TIMEOUT_IN_MS, TimeUnit.MILLISECONDS);
            String livenessState = finishedInTime ? ""Success"" : ""Fail"";
            Correctness.recordOperation(""Liveness, "" + livenessState, false);
            if (!finishedInTime) {
                System.exit(0);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            taskProducer.shutdownNow();
            checkpointer.shutdownNow();
        }
    }
","    private void waitForAppToFinish() {
        workers.shutdown();
        try {
            boolean finishedInTime = workers.
                    awaitTermination(durationMs + APPLICATION_TIMEOUT_IN_MS, TimeUnit.MILLISECONDS);
            String livenessState = finishedInTime ? ""Success"" : ""Fail"";
            Correctness.recordOperation(""Liveness, "" + livenessState, false);
            if (!finishedInTime) {
START                 System.exit(0); END 
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            taskProducer.shutdownNow();
            checkpointer.shutdownNow();
        }
    }
","    private void waitForAppToFinish() {
        workers.shutdown();
        try {
            boolean finishedInTime = workers.
                    awaitTermination(durationMs + APPLICATION_TIMEOUT_IN_MS, TimeUnit.MILLISECONDS);
            String livenessState = finishedInTime ? ""Success"" : ""Fail"";
            Correctness.recordOperation(""Liveness, "" + livenessState, false);
            if (!finishedInTime) {
                System.exit(1);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            taskProducer.shutdownNow();
            checkpointer.shutdownNow();
        }
    }
"
1372,I think .run(key) is more faster than this if we keep JedisClusterCommand.run(String or byte[]).,"    public Boolean scriptExists(final String sha1, final String key) {
    return new JedisClusterCommand<Boolean>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Boolean execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(1,key);
    }
","    public Boolean scriptExists(final String sha1, final String key) {
    return new JedisClusterCommand<Boolean>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Boolean execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
START     }.run(1,key); END 
    }
","    public Boolean scriptExists(final String sha1, final String key) {
    return new JedisClusterCommand<Boolean>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Boolean execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(key);
    }
"
1373,Maybe it would be better to use some sort of map? That way we would avoid potential out of bounds exceptions when someone adds new subscription but doesn't update that declaration.,"    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mSubscriptions = new Disposable[2];
        mRepository = (Repository) getArguments().getSerializable(""repo"");
        mRef = getArguments().getString(""ref"");
    }
","    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
START         mSubscriptions = new Disposable[2]; END 
        mRepository = (Repository) getArguments().getSerializable(""repo"");
        mRef = getArguments().getString(""ref"");
    }
","    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mRepository = (Repository) getArguments().getSerializable(""repo"");
        mRef = getArguments().getString(""ref"");
    }
"
1374,Either no brackets or put invalidate on its own line.,"    public void dispatchInvalidateOptionsMenu() {
        if (BuildConfig.DEBUG) Log.d(TAG, ""[dispatchInvalidateOptionsMenu]"");

        mActivity.getWindow().invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);

        if (mMenu != null) { mMenu.invalidate(); }
    }
","    public void dispatchInvalidateOptionsMenu() {
        if (BuildConfig.DEBUG) Log.d(TAG, ""[dispatchInvalidateOptionsMenu]"");

        mActivity.getWindow().invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);

START         if (mMenu != null) { mMenu.invalidate(); } END 
    }
","    public void dispatchInvalidateOptionsMenu() {
        if (BuildConfig.DEBUG) Log.d(TAG, ""[dispatchInvalidateOptionsMenu]"");

        mActivity.getWindow().invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);

        if (mMenu != null) mMenu.invalidate();
    }
"
1375,"Since the categories never change, it would be better to make the value of `SUPPORTED_CATEGORIES` unmodifiable from the start.","    public Collection<String> getSupportedCategories()
    {
        return Collections.unmodifiableCollection(SUPPORTED_CATEGORIES);
    }
","    public Collection<String> getSupportedCategories()
    {
START         return Collections.unmodifiableCollection(SUPPORTED_CATEGORIES); END 
    }
","    public Collection<String> getSupportedCategories()
    {
        return SUPPORTED_CATEGORIES;
    }
"
1376,Shouldn't you interrupt the controller first?,"   public List<Runnable> shutdownNow() {
      shutdown = true;
      List<Runnable> runnableList = new LinkedList<>();
      runnableList.addAll(executorService.shutdownNow());
      runnableList.addAll(blockedTasks);
      controllerThread.interrupt();
      return runnableList;
   }
","   public List<Runnable> shutdownNow() {
      shutdown = true;
      List<Runnable> runnableList = new LinkedList<>();
      runnableList.addAll(executorService.shutdownNow());
      runnableList.addAll(blockedTasks);
START       controllerThread.interrupt(); END 
      return runnableList;
   }
","   public List<Runnable> shutdownNow() {
      shutdown = true;
      controllerThread.interrupt();
      List<Runnable> runnableList = new LinkedList<>();
      runnableList.addAll(executorService.shutdownNow());
      runnableList.addAll(blockedTasks);
      return runnableList;
   }
"
1377,"Style-nit: Don't assign then replace.  Instead use a proper if-else:

  if (user.isBatchUser) {
    return queues.getBatchQueue();
  } else {
    return queues.getInteractiveQueue();
  }","  public WorkQueue.Executor get() {
    CurrentUser user = userProvider.get();
    WorkQueue.Executor executor = queues.getInteractiveQueue();
    if (user.isBatchUser()) {
      executor = queues.getBatchQueue();
    }
    return executor;
  }
","  public WorkQueue.Executor get() {
    CurrentUser user = userProvider.get();
START     WorkQueue.Executor executor = queues.getInteractiveQueue(); END 
    if (user.isBatchUser()) {
      executor = queues.getBatchQueue();
    }
    return executor;
  }
","  public WorkQueue.Executor get() {
    WorkQueue.Executor executor;
    if (user.isBatchUser()) {
      executor = queues.getBatchQueue();
    } else {
      executor = queues.getInteractiveQueue();
    }
    return executor;
  }
"
1378,Is there any reason to explicitly set to the default?,"    final AppConfig getAppConfig(CascadeStrategy defaultStrategy) throws ConfigException {
        return DefaultAppConfig.builder()
                .withDefaultCascadingStrategy(defaultStrategy)
                .withApplicationConfigName(DefaultAppConfig.DEFAULT_APP_CONFIG_NAME)
                .build();
    }
","    final AppConfig getAppConfig(CascadeStrategy defaultStrategy) throws ConfigException {
        return DefaultAppConfig.builder()
                .withDefaultCascadingStrategy(defaultStrategy)
START                 .withApplicationConfigName(DefaultAppConfig.DEFAULT_APP_CONFIG_NAME) END 
                .build();
    }
","    final AppConfig getAppConfig(CascadeStrategy defaultStrategy) throws ConfigException {
        return DefaultAppConfig.builder()
                .withDefaultCascadingStrategy(defaultStrategy)
                .build();
    }
"
1379,"```suggestion
        return writer.getBuffer().toString();
```","    public static String moduleToJsonString(Module module) throws IOException {
        JsonFactory jsonFactory = createJsonFactory();

        StringWriter writer = new StringWriter();
        JsonGenerator jsonGenerator = jsonFactory.createJsonGenerator(writer);
        jsonGenerator.useDefaultPrettyPrinter();

        jsonGenerator.writeObject(module);
        String result = writer.getBuffer().toString();
        return result;
    }
","    public static String moduleToJsonString(Module module) throws IOException {
        JsonFactory jsonFactory = createJsonFactory();

        StringWriter writer = new StringWriter();
        JsonGenerator jsonGenerator = jsonFactory.createJsonGenerator(writer);
        jsonGenerator.useDefaultPrettyPrinter();

        jsonGenerator.writeObject(module);
START         String result = writer.getBuffer().toString(); END 
        return result;
    }
","    public static String moduleToJsonString(Module module) throws IOException {
        JsonFactory jsonFactory = createJsonFactory();

        StringWriter writer = new StringWriter();
        JsonGenerator jsonGenerator = jsonFactory.createJsonGenerator(writer);
        jsonGenerator.useDefaultPrettyPrinter();

        jsonGenerator.writeObject(module);
        return writer.getBuffer().toString();
    }
"
1380,please squash this with first commit,"    private String createResults()
    {
        QueryResults queryResults = new QueryResults(
                ""20160128_214710_00012_rk68b"",
                server.url(""/query.html?20160128_214710_00012_rk68b"").uri(),
                null,
                null,
                ImmutableList.of(new Column(""_col0"", BigintType.BIGINT)),
                ImmutableList.of(ImmutableList.of(123)),
                StatementStats.builder().setState(""FINISHED"").build(),
                //new StatementStats(""FINISHED"", false, true, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null),
                null,
                null,
                null,
                null);
        return QUERY_RESULTS_CODEC.toJson(queryResults);
    }
","    private String createResults()
    {
        QueryResults queryResults = new QueryResults(
                ""20160128_214710_00012_rk68b"",
                server.url(""/query.html?20160128_214710_00012_rk68b"").uri(),
                null,
                null,
                ImmutableList.of(new Column(""_col0"", BigintType.BIGINT)),
                ImmutableList.of(ImmutableList.of(123)),
                StatementStats.builder().setState(""FINISHED"").build(),
                //new StatementStats(""FINISHED"", false, true, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null),
                null,
                null,
START                 null, END 
                null);
        return QUERY_RESULTS_CODEC.toJson(queryResults);
    }
","    private String createResults()
    {
        QueryResults queryResults = new QueryResults(
                ""20160128_214710_00012_rk68b"",
                server.url(""/query.html?20160128_214710_00012_rk68b"").uri(),
                null,
                null,
                ImmutableList.of(new Column(""_col0"", BigintType.BIGINT)),
                ImmutableList.of(ImmutableList.of(123)),
                StatementStats.builder().setState(""FINISHED"").build(),
                //new StatementStats(""FINISHED"", false, true, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, null),
                null,
                ImmutableList.of(),
                null,
                null);
        return QUERY_RESULTS_CODEC.toJson(queryResults);
    }
"
1381,"Program to interface, not to implementation - please change return type to `Map<String, Object>`","    protected HashMap<String, Object> buildGitEnv(String url,
                                                  String username,
                                                  String password,
                                                  boolean mirror) {
        return new HashMap<String, Object>() {{
            put(""origin"",
                url);
            put(SCHEME,
                GitRepository.SCHEME.toString());
            put(""replaceIfExists"",
                true);
            put(""username"",
                username);
            put(""password"",
                password);
            put(MIRROR,
                mirror);
        }};
    }
","START     protected HashMap<String, Object> buildGitEnv(String url, END 
                                                  String username,
                                                  String password,
                                                  boolean mirror) {
        return new HashMap<String, Object>() {{
            put(""origin"",
                url);
            put(SCHEME,
                GitRepository.SCHEME.toString());
            put(""replaceIfExists"",
                true);
            put(""username"",
                username);
            put(""password"",
                password);
            put(MIRROR,
                mirror);
        }};
    }
","    protected Map<String, Object> buildGitEnv(String url,
                                                  String username,
                                                  String password,
                                                  boolean mirror) {
        return new HashMap<String, Object>() {{
            put(""origin"",
                url);
            put(SCHEME,
                GitRepository.SCHEME.toString());
            put(""replaceIfExists"",
                true);
            put(""username"",
                username);
            put(""password"",
                password);
            put(MIRROR,
                mirror);
        }};
    }
"
1382,this.m_,"    public void setDefinitions(List<Definition> definitions) {
        this.m_definitions = definitions;
    }
","    public void setDefinitions(List<Definition> definitions) {
START         this.m_definitions = definitions; END 
    }
","    public void setDefinitions(List<Definition> definitions) {
        m_definitions = definitions;
    }
"
1383,We also need to clear the cache when user switching occurs.,"    protected void cleanUp(UserAccount userAccount) {
        SalesforceAnalyticsManager.reset(userAccount);
        RestClient.clearCaches(userAccount);
        UserAccountManager.getInstance().clearCachedCurrentUser(userAccount);
    }
","    protected void cleanUp(UserAccount userAccount) {
        SalesforceAnalyticsManager.reset(userAccount);
        RestClient.clearCaches(userAccount);
START         UserAccountManager.getInstance().clearCachedCurrentUser(userAccount); END 
    }
","    protected void cleanUp(UserAccount userAccount) {
        SalesforceAnalyticsManager.reset(userAccount);
        RestClient.clearCaches(userAccount);
        UserAccountManager.getInstance().clearCachedCurrentUser();
    }
"
1384,"I'm probably missing something, why not using the constructor taking a Throwable?","    protected static int parseFraction(String string, int sign, String text) {
        if (string == null || string.length() == 0) {
            return 0;
        }
        try {
            string = (string + ""000000000"").substring(0, 9);
            return Integer.parseInt(string) * sign;
        } catch (NumberFormatException | ArithmeticException e) {
            throw (DateTimeParseException) new DateTimeParseException(
                    ""Text cannot be parsed to a PeriodAndDuration: fraction"", text, 0).initCause(e);
        }
    }
","    protected static int parseFraction(String string, int sign, String text) {
        if (string == null || string.length() == 0) {
            return 0;
        }
        try {
            string = (string + ""000000000"").substring(0, 9);
            return Integer.parseInt(string) * sign;
        } catch (NumberFormatException | ArithmeticException e) {
START             throw (DateTimeParseException) new DateTimeParseException( END 
                    ""Text cannot be parsed to a PeriodAndDuration: fraction"", text, 0).initCause(e);
        }
    }
","    protected static int parseFraction(String string, int sign, String text) {
        if (string == null || string.length() == 0) {
            return 0;
        }
        try {
            string = (string + ""000000000"").substring(0, 9);
            return Integer.parseInt(string) * sign;
        } catch (NumberFormatException | ArithmeticException e) {
            throw new DateTimeParseException(""Text cannot be parsed to a PeriodAndDuration: fraction"", text, 0, e);
        }
    }
"
1385,Please always use curly braces in 'for' statements.,"	public IASTName[] getNames() {
		IASTName[] result = new IASTName[fQualifierPos + (fLastName == null ? 1 : 2)];
		int idx = 0;
		for (ICPPASTNameSpecifier nameSpecifier : getQualifier())
			if (nameSpecifier instanceof IASTName)
				result[idx++] = (IASTName) nameSpecifier;
			else
				throw new UnsupportedOperationException(""Can't use getNames() on a "" +  //$NON-NLS-1$
						""qualified name that includes a decltype-specifier. Use "" +     //$NON-NLS-1$
						""getQualifier() and getLastName() instead"");                    //$NON-NLS-1$
		if (fLastName != null)
			result[fQualifierPos + 1] = fLastName;
		return result;
	}
","	public IASTName[] getNames() {
		IASTName[] result = new IASTName[fQualifierPos + (fLastName == null ? 1 : 2)];
		int idx = 0;
START 		for (ICPPASTNameSpecifier nameSpecifier : getQualifier()) END 
			if (nameSpecifier instanceof IASTName)
				result[idx++] = (IASTName) nameSpecifier;
			else
				throw new UnsupportedOperationException(""Can't use getNames() on a "" +  //$NON-NLS-1$
						""qualified name that includes a decltype-specifier. Use "" +     //$NON-NLS-1$
						""getQualifier() and getLastName() instead"");                    //$NON-NLS-1$
		if (fLastName != null)
			result[fQualifierPos + 1] = fLastName;
		return result;
	}
","	public IASTName[] getNames() {
		IASTName[] result = new IASTName[fQualifierPos + (fLastName == null ? 1 : 2)];
		int idx = 0;
		for (ICPPASTNameSpecifier nameSpecifier : getQualifier()) {
			if (nameSpecifier instanceof IASTName) {
				result[idx++] = (IASTName) nameSpecifier;
			} else {
				throw new UnsupportedOperationException(""Can't use getNames() on a "" +  //$NON-NLS-1$
						""qualified name that includes a decltype-specifier. Use "" +     //$NON-NLS-1$
						""getQualifier() and getLastName() instead"");                    //$NON-NLS-1$
			}
		}
		if (fLastName != null)
			result[fQualifierPos + 1] = fLastName;
		return result;
	}
"
1386,"who catches that?
I'd return a message instead;","    private String getConsoleModelErrorMessage(Object sender, ErrorCodeEventArgs e) {
        String translatedError = consoleErrorCodeTranslator.translateErrorCode(e.getErrorCode());

        if (sender instanceof SpiceConsoleModel) {
            return ConstantsManager.getInstance()
                    .getMessages()
                    .errConnectingVmUsingSpiceMsg(translatedError);
        } else if (sender instanceof RdpConsoleModel) {
            return ConstantsManager.getInstance()
                    .getMessages()
                    .errConnectingVmUsingRdpMsg(translatedError);
        }

        throw new IllegalArgumentException(""Message recieved from an unknown model "" + sender.getClass().getName()); //$NON-NLS-1$
    }
","    private String getConsoleModelErrorMessage(Object sender, ErrorCodeEventArgs e) {
        String translatedError = consoleErrorCodeTranslator.translateErrorCode(e.getErrorCode());

        if (sender instanceof SpiceConsoleModel) {
            return ConstantsManager.getInstance()
                    .getMessages()
                    .errConnectingVmUsingSpiceMsg(translatedError);
        } else if (sender instanceof RdpConsoleModel) {
            return ConstantsManager.getInstance()
                    .getMessages()
                    .errConnectingVmUsingRdpMsg(translatedError);
        }

START         throw new IllegalArgumentException(""Message recieved from an unknown model "" + sender.getClass().getName()); //$NON-NLS-1$ END 
    }
","    private String getConsoleModelErrorMessage(Object sender, ErrorCodeEventArgs e) {
        String translatedError = consoleErrorCodeTranslator.translateErrorCode(e.getErrorCode());

        if (sender instanceof SpiceConsoleModel) {
            return ConstantsManager.getInstance()
                    .getMessages()
                    .errConnectingVmUsingSpiceMsg(translatedError);
        } else if (sender instanceof RdpConsoleModel) {
            return ConstantsManager.getInstance()
                    .getMessages()
                    .errConnectingVmUsingRdpMsg(translatedError);
        }

        return translatedError;
    }
"
1387,"> this [](start = 8, length = 4)

no this. please","    public final void setExtendedExpiresOn(final Date extendedExpiresOn) {
        this.mExtendedExpiresOn = extendedExpiresOn;
    }
","    public final void setExtendedExpiresOn(final Date extendedExpiresOn) {
START         this.mExtendedExpiresOn = extendedExpiresOn; END 
    }
","    public final void setExtendedExpiresOn(final Date extendedExpiresOn) {
        mExtendedExpiresOn = extendedExpiresOn;
    }
"
1388,"I would put this on the failure path:

  if (!d.mkdir()) {
    if (skipExisting && d.isDirectory())
      return;

    throw new IOException(...);
  }

Because odds are the caller wants to make a new directory and we can reasonably assume it doesn't exist yet.  If it does, we'll fail on the mkdir and check its mode, if its a directory, we're fine, if its not, we fail.","	public static void mkdir(final File d, boolean skipExisting)
			throws IOException {
		if (skipExisting && d.exists() && d.isDirectory())
			return;

		if (!d.mkdir())
			throw new IOException(MessageFormat.format(
					JGitText.get().mkDirFailed, d.getAbsolutePath()));
	}
","	public static void mkdir(final File d, boolean skipExisting)
			throws IOException {
START 		if (skipExisting && d.exists() && d.isDirectory()) END 
			return;

		if (!d.mkdir())
			throw new IOException(MessageFormat.format(
					JGitText.get().mkDirFailed, d.getAbsolutePath()));
	}
","	public static void mkdir(final File d, boolean skipExisting)
			throws IOException {
		if (!d.mkdir()) {
			if (skipExisting && d.isDirectory())
				return;
			throw new IOException(MessageFormat.format(
					JGitText.get().mkDirFailed, d.getAbsolutePath()));
		}
	}
"
1389,IMHO can you a no-argument C'tor.,"    protected void initDiskVmElement() {
        setDiskVmElement(new DiskVmElement(new VmDeviceId(null, null)));
    }
","    protected void initDiskVmElement() {
        setDiskVmElement(new DiskVmElement(new START  VmDeviceId(null, null))); END 
    }
","    protected void initDiskVmElement() {
        setDiskVmElement(new DiskVmElement());
    }
"
1390,"better to remove if if statement, just set the value, the user of the entity can than use the getUseFreemarkerTemplate function to choose to use the template of not.","	public void setHtmlTemplate(FreemarkerTemplate htmlTemplate)
	{
		if (this.getUseFreemarkerTemplate())
		{
			set(LANDING_PAGE_HTML_TEMPLATE, htmlTemplate);
		}
	}
","	public void setHtmlTemplate(FreemarkerTemplate htmlTemplate)
	{
START 		if (this.getUseFreemarkerTemplate()) END 
		{
			set(LANDING_PAGE_HTML_TEMPLATE, htmlTemplate);
		}
	}
","	public void setHtmlTemplate(FreemarkerTemplate htmlTemplate)
	{
		set(LANDING_PAGE_HTML_TEMPLATE, htmlTemplate);
	}
"
1391,nit: it seems like we prefer to not put else after return elsewhere in the codebase,"        public PhysicalOperation visitExchange(ExchangeNode node, LocalExecutionPlanContext context)
        {
            checkArgument(node.getScope() == LOCAL, ""Only local exchanges are supported in the local planner"");

            if (node.getOrderingScheme().isPresent()) {
                return createLocalMerge(node, context);
            }
            else {
                return createLocalExchange(node, context);
            }
        }
","        public PhysicalOperation visitExchange(ExchangeNode node, LocalExecutionPlanContext context)
        {
            checkArgument(node.getScope() == LOCAL, ""Only local exchanges are supported in the local planner"");

            if (node.getOrderingScheme().isPresent()) {
                return createLocalMerge(node, context);
            }
            else {
                return createLocalExchange(node, context);
START             } END 
        }
","        public PhysicalOperation visitExchange(ExchangeNode node, LocalExecutionPlanContext context)
        {
            checkArgument(node.getScope() == LOCAL, ""Only local exchanges are supported in the local planner"");

            if (node.getOrderingScheme().isPresent()) {
                return createLocalMerge(node, context);
            }

            return createLocalExchange(node, context);
        }
"
1392,"This could be typed as CacheEntryEvent<? extends K, ? extends V> and the cast wouldn't be needed on the next line.","   public void onCreated(Iterable<CacheEntryEvent<? extends K, ? extends V>> events) throws CacheEntryListenerException {

      for (Object event1 : events) {
         CacheEntryEvent event = (CacheEntryEvent) event1;
         Assert.assertEquals(EventType.CREATED, event.getEventType());
         this.created.incrementAndGet();
         event.getKey();
         event.getValue();
         event.getSource();
      }

   }
","   public void onCreated(Iterable<CacheEntryEvent<? extends K, ? extends V>> events) throws CacheEntryListenerException {

START       for (Object event1 : events) { END 
         CacheEntryEvent event = (CacheEntryEvent) event1;
         Assert.assertEquals(EventType.CREATED, event.getEventType());
         this.created.incrementAndGet();
         event.getKey();
         event.getValue();
         event.getSource();
      }

   }
","   public void onCreated(Iterable<CacheEntryEvent<? extends K, ? extends V>> events) throws CacheEntryListenerException {

      for (CacheEntryEvent<? extends K, ? extends V> event : events) {
         Assert.assertEquals(EventType.CREATED, event.getEventType());
         this.created.incrementAndGet();
      }

   }
"
1393,"this line is redundant, you can use keyId directly","    private static PendingIntent buildIntent(Context context, long keyId) {
        Intent intent = new Intent(BROADCAST_ACTION_PASSPHRASE_CACHE_SERVICE);
        intent.putExtra(EXTRA_KEY_ID, keyId);
        //request code should be unique for each call for pending intent so we have taken requestcode
        //as keyId which is unique for each call as keyId is unique for each passphrase
        long requestcode = keyId;
        return PendingIntent.getBroadcast(context, (int)requestcode, intent,
                PendingIntent.FLAG_CANCEL_CURRENT);
    }
","    private static PendingIntent buildIntent(Context context, long keyId) {
        Intent intent = new Intent(BROADCAST_ACTION_PASSPHRASE_CACHE_SERVICE);
        intent.putExtra(EXTRA_KEY_ID, keyId);
        //request code should be unique for each call for pending intent so we have taken requestcode
        //as keyId which is unique for each call as keyId is unique for each passphrase
START         long requestcode = keyId; END 
        return PendingIntent.getBroadcast(context, (int)requestcode, intent,
                PendingIntent.FLAG_CANCEL_CURRENT);
    }
","    private static PendingIntent buildIntent(Context context, long keyId) {
        Intent intent = new Intent(BROADCAST_ACTION_PASSPHRASE_CACHE_SERVICE);
        intent.putExtra(EXTRA_KEY_ID, keyId);
        //request code should be unique for each call for pending intent so we have taken requestcode
        //as keyId which is unique for each call as keyId is unique for each passphrase
        return PendingIntent.getBroadcast(context, (int)keyId, intent,
                PendingIntent.FLAG_CANCEL_CURRENT);
    }
"
1394,Does it make sense to declare `throws RuntimeException`?,"    public boolean hasTxLogs() throws RuntimeException
    {
        File[] files = storeDir.listFiles( LogFiles.FILENAME_FILTER );
        if ( files == null )
        {
            throw new RuntimeException( ""Files was null. Incorrect directory or I/O error?"" );
        }

        return files.length > 0;
    }
","START     public boolean hasTxLogs() throws RuntimeException END 
    {
        File[] files = storeDir.listFiles( LogFiles.FILENAME_FILTER );
        if ( files == null )
        {
            throw new RuntimeException( ""Files was null. Incorrect directory or I/O error?"" );
        }

        return files.length > 0;
    }
","    public boolean hasTxLogs()
    {
        File[] files = storeDir.listFiles( LogFiles.FILENAME_FILTER );
        if ( files == null )
        {
            throw new RuntimeException( ""Files was null. Incorrect directory or I/O error?"" );
        }

        return files.length > 0;
    }
"
1395,"??? 
Does it work?
Really it has to be `super.`. IDEA shows the recursion for me","	public void setTaskScheduler(TaskScheduler taskScheduler) {
		setTaskScheduler(taskScheduler);
	}
","	public void setTaskScheduler(TaskScheduler taskScheduler) {
START 		setTaskScheduler(taskScheduler); END 
	}
","	public void setTaskScheduler(TaskScheduler taskScheduler) {
		super.setTaskScheduler(taskScheduler);
	}
"
1396,"Oh right, I remember, the parser does some funky stuff internally with the Token and KList classes. Okay. I am persuaded that it makes sense to go this route for now. Please make sure it is clear that developers should never call this constructor from outside the parser kernel, then.","    public Constant(Sort sort, String value) {
        super(sort, null);
        this.value = value;
    }
","START     public Constant(Sort sort, String value) { END 
        super(sort, null);
        this.value = value;
    }
","    public Constant(Sort sort, String value) {
        super(sort, null);
        assert value != null;
        this.value = value;
    }
"
1397,"This is a duplicated check, as this is only invoked after `command.hasFlows()` is true, so not required to invoke it again. If you absolutely want this check, I'd opt for 

```java
if (hasFlows != null) {
 ...
}
```
as it is much easier to read.","    private void addCriteriaForFlows(final OnmsCriteria criteria, final Boolean hasFlows) {
        if (hasFlows == null) {
            return;
        }
        criteria.add(Restrictions.eq(""node.hasFlows"", hasFlows));
    }
","    private void addCriteriaForFlows(final OnmsCriteria criteria, final Boolean hasFlows) {
START         if (hasFlows == null) { END 
            return;
        }
        criteria.add(Restrictions.eq(""node.hasFlows"", hasFlows));
    }
","    private void addCriteriaForFlows(final OnmsCriteria criteria, final Boolean hasFlows) {
        criteria.add(Restrictions.eq(""node.hasFlows"", hasFlows));
    }
"
1398,It is always good to return an empty list instead. Avoids NPEs,"    public List<String> getJobsForAnExtension(final String extensionName) throws FalconException {
        List<ExtensionJobsBean> extensionJobs = metaStore.getJobsForAnExtension(extensionName);
        if (null != extensionJobs && !extensionJobs.isEmpty()){
            List<String> extensionJobNames = new ArrayList<>();
            for (ExtensionJobsBean extensionJobsBean: extensionJobs) {
                extensionJobNames.add(extensionJobsBean.getJobName());
            }
            return extensionJobNames;
        } else {
            return null;
        }
    }
","    public List<String> getJobsForAnExtension(final String extensionName) throws FalconException {
        List<ExtensionJobsBean> extensionJobs = metaStore.getJobsForAnExtension(extensionName);
        if (null != extensionJobs && !extensionJobs.isEmpty()){
            List<String> extensionJobNames = new ArrayList<>();
            for (ExtensionJobsBean extensionJobsBean: extensionJobs) {
                extensionJobNames.add(extensionJobsBean.getJobName());
            }
            return extensionJobNames;
START         } else { END 
            return null;
        }
    }
","    public List<String> getJobsForAnExtension(final String extensionName) throws FalconException {
        List<ExtensionJobsBean> extensionJobs = metaStore.getJobsForAnExtension(extensionName);
        List<String> extensionJobNames = new ArrayList<>();
        if (null != extensionJobs && !extensionJobs.isEmpty()) {
            for (ExtensionJobsBean extensionJobsBean : extensionJobs) {
                extensionJobNames.add(extensionJobsBean.getJobName());
            }
        }
        return extensionJobNames;
    }
"
1399,This test is not needed since the event bundle is filtered regarding the events defined to trigger the listener in its descriptor.,"    public void handleEvent(EventBundle events) {
        for (Event event : events) {
            if (DOCUMENT_REMOVED.equals(event.getName())) {
                DocumentEventContext context = (DocumentEventContext) event.getContext();
                DocumentModel docModel = context.getSourceDocument();
                if (DOCUMENT_ROUTE_DOCUMENT_TYPE.equals(docModel.getType())) {
                    deleteOrphanTasks(context.getCoreSession(), docModel.getId());
                }
            }
        }
    }
","    public void handleEvent(EventBundle events) {
        for (Event event : events) {
START             if (DOCUMENT_REMOVED.equals(event.getName())) { END 
                DocumentEventContext context = (DocumentEventContext) event.getContext();
                DocumentModel docModel = context.getSourceDocument();
                if (DOCUMENT_ROUTE_DOCUMENT_TYPE.equals(docModel.getType())) {
                    deleteOrphanTasks(context.getCoreSession(), docModel.getId());
                }
            }
        }
    }
","    public void handleEvent(EventBundle events) {
        for (Event event : events) {
            DocumentEventContext context = (DocumentEventContext) event.getContext();
            DocumentModel docModel = context.getSourceDocument();
            if (DOCUMENT_ROUTE_DOCUMENT_TYPE.equals(docModel.getType())) {
                deleteOrphanTasks(context.getCoreSession(), docModel.getId());
            }
        }
    }
"
1400,Yes am assuming it should be a SortedSet and the ordering would be based on the sortWeight of the orders.,"	public Set<Order> getOrders() {
		if (orders == null) {
			orders = new LinkedHashSet<Order>();
		}
		return orders;
	}
","	public Set<Order> getOrders() {
		if (orders == null) {
START 			orders = new LinkedHashSet<Order>(); END 
		}
		return orders;
	}
","	public List<Order> getOrders() {
		if (orders == null) {
			orders = new ArrayList<Order>();
		}
		return orders;
	}
"
1401,The call to `put` can be extracted from the `if-else` statement in order to remove the duplication.,"  private void executeIdentifier(IdentifierTree tree) {
    Symbol symbol = tree.symbol();
    SymbolicValue value = programState.getValue(symbol);
    if (value == null) {
      value = constraintManager.createSymbolicValue(tree);
      programState = programState.stackValue(value);
      learnIdentifierNullConstraints(tree, value);
      programState = programState.put(symbol, value);
    } else {
      programState = programState.stackValue(value);
      programState = programState.put(symbol, value);
    }
  }
","  private void executeIdentifier(IdentifierTree tree) {
    Symbol symbol = tree.symbol();
    SymbolicValue value = programState.getValue(symbol);
    if (value == null) {
      value = constraintManager.createSymbolicValue(tree);
      programState = programState.stackValue(value);
      learnIdentifierNullConstraints(tree, value);
      programState = programState.put(symbol, value);
    } else {
      programState = programState.stackValue(value);
START       programState = programState.put(symbol, value); END 
    }
  }
","  private void executeIdentifier(IdentifierTree tree) {
    Symbol symbol = tree.symbol();
    SymbolicValue value = programState.getValue(symbol);
    if (value == null) {
      value = constraintManager.createSymbolicValue(tree);
      programState = programState.stackValue(value);
      learnIdentifierNullConstraints(tree, value);
    } else {
      programState = programState.stackValue(value);
    }
    programState = programState.put(symbol, value);
  }
"
1402,Not needed in this change.,"  public AutoRegisterModules(String pluginName,
      PluginGuiceEnvironment env,
      JarFile jarFile,
      ClassLoader classLoader) {
    this.pluginName = pluginName;
    this.env = env;
    this.jarFile = jarFile;
    this.classLoader = classLoader;
    this.sshGen = env.hasSshModule() ? env.newSshModuleGenerator() : null;
    this.httpGen = env.hasHttpModule() ? env.newHttpModuleGenerator() : null;
  }
","  START  public AutoRegisterModules(String END  pluginName,
      PluginGuiceEnvironment env,
      JarFile jarFile,
      ClassLoader classLoader) {
    this.pluginName = pluginName;
    this.env = env;
    this.jarFile = jarFile;
    this.classLoader = classLoader;
    this.sshGen = env.hasSshModule() ? env.newSshModuleGenerator() : null;
    this.httpGen = env.hasHttpModule() ? env.newHttpModuleGenerator() : null;
  }
","  AutoRegisterModules(String pluginName,
      PluginGuiceEnvironment env,
      JarFile jarFile,
      ClassLoader classLoader) {
    this.pluginName = pluginName;
    this.env = env;
    this.jarFile = jarFile;
    this.classLoader = classLoader;
    this.sshGen = env.hasSshModule() ? env.newSshModuleGenerator() : null;
    this.httpGen = env.hasHttpModule() ? env.newHttpModuleGenerator() : null;
  }
"
1403,"Please use:

  return !steps.isEmpty();","    public boolean checkIfJobHasTasks(Guid jobId) {
        List<Step> steps = step.getStepsByJobIdForVdsmAndGluster(jobId);

        return steps.size() > 0;
    }
","    public boolean checkIfJobHasTasks(Guid jobId) {
        List<Step> steps = step.getStepsByJobIdForVdsmAndGluster(jobId);

START         return steps.size() > 0; END 
    }
","    public boolean checkIfJobHasTasks(Guid jobId) {
        List<Step> steps = step.getStepsByJobIdForVdsmAndGluster(jobId);

        return !steps.isEmpty();
    }
"
1404,nit: extra space,"  public String getUserNameForChannel(UUID channelId) throws UnauthenticatedException {

    try (LockResource clientsLockShared = new LockResource(mClientsLock.readLock())) {
      if (mChannels.containsKey(channelId)) {
        AuthenticatedChannelInfo clientInfo = mChannels.get(channelId);
        return mChannels.get(channelId).getUserName();
      } else {
        throw new UnauthenticatedException(
            String.format(""Client:%s needs to be authenticated"", channelId.toString()));
      }
    }
  }
","  public String getUserNameForChannel(UUID channelId) throws UnauthenticatedException {
START  END 
    try (LockResource clientsLockShared = new LockResource(mClientsLock.readLock())) {
      if (mChannels.containsKey(channelId)) {
        AuthenticatedChannelInfo clientInfo = mChannels.get(channelId);
        return mChannels.get(channelId).getUserName();
      } else {
        throw new UnauthenticatedException(
            String.format(""Client:%s needs to be authenticated"", channelId.toString()));
      }
    }
  }
","  public String getUserNameForChannel(UUID channelId) throws UnauthenticatedException {
    if (mChannels.containsKey(channelId)) {
      AuthenticatedChannelInfo clientInfo = mChannels.get(channelId);
      return clientInfo.getUserName();
    } else {
      throw new UnauthenticatedException(
          String.format(""Client:%s needs to be authenticated"", channelId.toString()));
    }
  }
"
1405,"I'd just go ahead and return false here. The logic you have here doesn't prevent trying to parse when the input value is null or empty.

And when you have that fixed, go ahead and merge at will. :smiley:","    public static boolean isValidSingleVersion( final String version )
    {
        boolean result = true;
        if ( version == null || version.trim().length() < 1 )
        {
            result = false;
        }
        try
        {
            SingleVersion singleVersion = new VersionParser( version ).single();
        }
        catch ( final ParseException e )
        {
            result = false;
        }
        catch ( final TokenMgrError e )
        {
            result = false;
        }
        return result;
    }
","    public static boolean isValidSingleVersion( final String version )
    {
        boolean result = true;
        if ( version == null || version.trim().length() < 1 )
        {
START             result = false; END 
        }
        try
        {
            SingleVersion singleVersion = new VersionParser( version ).single();
        }
        catch ( final ParseException e )
        {
            result = false;
        }
        catch ( final TokenMgrError e )
        {
            result = false;
        }
        return result;
    }
","    public static boolean isValidSingleVersion( final String version )
    {
        boolean result = true;
        
        if ( version == null || version.trim().length() < 1 )
        {
            return false;
        }
        try
        {
            SingleVersion singleVersion = new VersionParser( version ).single();
        }
        catch ( final ParseException e )
        {
            result = false;
        }
        catch ( final TokenMgrError e )
        {
            result = false;
        }
        return result;
    }
"
1406,`break` statement is missing here and below,"  public void handle(DataServerConnection connection, int rpcType, ByteBuf pBody, ByteBuf dBody,
                     ResponseSender sender) throws RpcException {
    switch (rpcType) {
      case RpcType.REQ_RUNTIME_FILTER_VALUE : {
        handleRuntimeFilterRequest(pBody, dBody, sender);
      }

      case RpcType.REQ_RECORD_BATCH_VALUE : {
        handleRecordBatchRequest(pBody, dBody, sender);
      }

      default:
        throw new RpcException(""Not yet supported."");
    }
  }
","  public void handle(DataServerConnection connection, int rpcType, ByteBuf pBody, ByteBuf dBody,
                     ResponseSender sender) throws RpcException {
    switch (rpcType) {
      case RpcType.REQ_RUNTIME_FILTER_VALUE : {
        handleRuntimeFilterRequest(pBody, dBody, sender);
      }

START       case RpcType.REQ_RECORD_BATCH_VALUE : { END 
        handleRecordBatchRequest(pBody, dBody, sender);
      }

      default:
        throw new RpcException(""Not yet supported."");
    }
  }
","  public void handle(DataServerConnection connection, int rpcType, ByteBuf pBody, ByteBuf dBody,
                     ResponseSender sender) throws RpcException {
    switch (rpcType) {
      case RpcType.REQ_RUNTIME_FILTER_VALUE : {
        handleRuntimeFilterRequest(pBody, dBody, sender);
        break;
      }

      case RpcType.REQ_RECORD_BATCH_VALUE : {
        handleRecordBatchRequest(pBody, dBody, sender);
        break;
      }

      default:
        throw new RpcException(""Not yet supported."");
    }
  }
"
1407,`Collections.addAll` saves the wrapper object... although we don't need to go full-on nit picky on allocations like we would something in a library.,"    public Builder addModifiers(Modifier... modifiers) {
      this.modifiers.addAll(Arrays.asList(modifiers));
      return this;
    }
","    public Builder addModifiers(Modifier... modifiers) {
START       this.modifiers.addAll(Arrays.asList(modifiers)); END 
      return this;
    }
","    public Builder addModifiers(Modifier... modifiers) {
      Collections.addAll(this.modifiers, modifiers);
      return this;
    }
"
1408,should be named `resource`,"  public void testCreate() throws StripeException {
    Map<String, Object> params = new HashMap<String, Object>();
    params.put(""amount"", 100);
    params.put(""currency"", ""usd"");
    params.put(""destination"", ""acct_123"");

    Transfer transfer = Transfer.create(params);

    assertNotNull(transfer);
    verifyRequest(
        APIResource.RequestMethod.POST,
        ""/v1/transfers"",
        params
    );
  }
","  public void testCreate() throws StripeException {
    Map<String, Object> params = new HashMap<String, Object>();
    params.put(""amount"", 100);
    params.put(""currency"", ""usd"");
    params.put(""destination"", ""acct_123"");

START     Transfer transfer = Transfer.create(params); END 

    assertNotNull(transfer);
    verifyRequest(
        APIResource.RequestMethod.POST,
        ""/v1/transfers"",
        params
    );
  }
","  public void testCreate() throws StripeException {
    final Map<String, Object> params = new HashMap<String, Object>();
    params.put(""amount"", 100);
    params.put(""currency"", ""usd"");
    params.put(""destination"", ""acct_123"");

    final Transfer transfer = Transfer.create(params);

    assertNotNull(transfer);
    verifyRequest(
        APIResource.RequestMethod.POST,
        ""/v1/transfers"",
        params
    );
  }
"
1409,static here and later,"  private boolean isGlobalFailure(ITestResult result) {
    ITestNGMethod m = result.getMethod();
    return m.isBeforeTestConfiguration() || m.isBeforeSuiteConfiguration();
  }
","START   private boolean isGlobalFailure(ITestResult result) { END 
    ITestNGMethod m = result.getMethod();
    return m.isBeforeTestConfiguration() || m.isBeforeSuiteConfiguration();
  }
","  private static boolean isGlobalFailure(ITestResult result) {
    ITestNGMethod m = result.getMethod();
    return m.isBeforeTestConfiguration() || m.isBeforeSuiteConfiguration();
  }
"
1410,no need to create a variable here. Use EmailValidator.getInstance().isvalid(),"    private static void validateEmail(String value) throws WSSecurityException {
        final EmailValidator validator = EmailValidator.getInstance();
        if (!validator.isValid(value)) {
            throw new WSSecurityException(ErrorCode.FAILURE, ""Not a valid email address."");
        }

    }
","    private static void validateEmail(String value) throws WSSecurityException {
START         final EmailValidator validator = EmailValidator.getInstance(); END 
        if (!validator.isValid(value)) {
            throw new WSSecurityException(ErrorCode.FAILURE, ""Not a valid email address."");
        }

    }
","    private static void validateEmail(String value) throws WSSecurityException {
        if (!EmailValidator.getInstance().isValid(value)) {
            throw new WSSecurityException(ErrorCode.FAILURE, ""Not a valid email address."");
        }

    }
"
1411,"change to
```java
this.myArrayList.ensureCapacity(this.myArrayList.size() + length);
```","    private void addAll(Object array) throws JSONException {
        if (array.getClass().isArray()) {
            int length = Array.getLength(array);
            this.myArrayList.ensureCapacity(length);
            for (int i = 0; i < length; i += 1) {
                this.put(JSONObject.wrap(Array.get(array, i)));
            }
        } else {
            throw new JSONException(
                    ""JSONArray initial value should be a string or collection or array."");
        }
    }
","    private void addAll(Object array) throws JSONException {
        if (array.getClass().isArray()) {
            int length = Array.getLength(array);
START             this.myArrayList.ensureCapacity(length); END 
            for (int i = 0; i < length; i += 1) {
                this.put(JSONObject.wrap(Array.get(array, i)));
            }
        } else {
            throw new JSONException(
                    ""JSONArray initial value should be a string or collection or array."");
        }
    }
","    private void addAll(Object array) throws JSONException {
        if (array.getClass().isArray()) {
            int length = Array.getLength(array);
            this.myArrayList.ensureCapacity(this.myArrayList.size() + length);
            for (int i = 0; i < length; i += 1) {
                this.put(JSONObject.wrap(Array.get(array, i)));
            }
        } else {
            throw new JSONException(
                    ""JSONArray initial value should be a string or collection or array."");
        }
    }
"
1412,I don't think this should be public (NetworkStack version is still public for legacy reasons),"    public static synchronized IBinder makeConnector(Context context) {
        if (sConnector == null) {
            sConnector = new TetheringConnector(context);
        }
        return sConnector;
    }
","    START  public static END  synchronized IBinder makeConnector(Context context) {
        if (sConnector == null) {
            sConnector = new TetheringConnector(context);
        }
        return sConnector;
    }
","    private static synchronized IBinder makeConnector(Context context) {
        if (sConnector == null) {
            sConnector = new TetheringConnector(context);
        }
        return sConnector;
    }
"
1413,Can leftWidth ever be negative?,"  protected void setSplitterPosition(int leftWidth, int rightWidth) {
    try {
      if (lockSplitter.acquire()) {
        double total = leftWidth + rightWidth;
        if (total > 0) {
          double d = leftWidth / total;
          getSwingContainer().setDividerLocation(d);
          getSwingContainer().setResizeWeight(d);
        }
      }
    }
    finally {
      lockSplitter.release();
    }
  }
","  protected void setSplitterPosition(int leftWidth, int rightWidth) {
    try {
      if (lockSplitter.acquire()) {
START         double total = leftWidth + rightWidth; END 
        if (total > 0) {
          double d = leftWidth / total;
          getSwingContainer().setDividerLocation(d);
          getSwingContainer().setResizeWeight(d);
        }
      }
    }
    finally {
      lockSplitter.release();
    }
  }
","  protected void setSplitterPosition(int leftWidth, int rightWidth) {
    if (leftWidth < 0 || rightWidth < 0) {
      return;
    }
    try {
      if (lockSplitter.acquire()) {
        double total = leftWidth + rightWidth;
        if (total > 0) {
          double d = leftWidth / total;
          getSwingContainer().setDividerLocation(d);
          getSwingContainer().setResizeWeight(d);
        }
      }
    }
    finally {
      lockSplitter.release();
    }
  }
"
1414,"there is a confusion, the goal is that client code indeed never has to write this. 

so the implementation RootPackage.setSimpleName would simply be ... empty.

do you see what I mean?","    public void process(CtElement element) {
        if(element instanceof CtPackage && element != getFactory().Package().getRootPackage()){
            ((CtPackage) element).setSimpleName(""newtest"");
        }
    }
","    public void process(CtElement element) {
START         if(element instanceof CtPackage && element != getFactory().Package().getRootPackage()){ END 
            ((CtPackage) element).setSimpleName(""newtest"");
        }
    }
","    public void process(CtElement element) {
        if(element instanceof CtPackage){
            ((CtPackage) element).setSimpleName(""newtest"");
        }
    }
"
1415,"shouldn't it be 

  return withCompensationContext(new *NoOpCompensationContext*())

or even

  return withCompensationContext(NoOpCompensationContext.getInstance())","    public CommandContext withoutCompensationContext() {
        return withCompensationContext(new DefaultCompensationContext());
    }
","    public CommandContext withoutCompensationContext() {
START         return withCompensationContext(new DefaultCompensationContext()); END 
    }
","    public CommandContext withoutCompensationContext() {
        return withCompensationContext(null);
    }
"
1416,`@CheckForNull` return. And why is this declared to throw `NotExportableException`?,"    public <T> Model<T> getOrNull(Class<T> type, @CheckForNull Class<?> propertyOwner, @Nullable String property) throws NotExportableException {
        Model m = models.get(type);
        if(m==null && type.getAnnotation(ExportedBean.class) != null) {
            m = new Model<T>(this, type, propertyOwner, property);
        }
        return m;
    }
","START     public <T> Model<T> getOrNull(Class<T> type, @CheckForNull Class<?> propertyOwner, @Nullable String property) throws NotExportableException { END 
        Model m = models.get(type);
        if(m==null && type.getAnnotation(ExportedBean.class) != null) {
            m = new Model<T>(this, type, propertyOwner, property);
        }
        return m;
    }
","    public <T> Model<T> getOrNull(Class<T> type, @CheckForNull Class<?> propertyOwner, @Nullable String property) {
        Model<T> m = models.get(type);
        if(m==null && type.getAnnotation(ExportedBean.class) != null) {
            m = new Model<T>(this, type, propertyOwner, property);
        }
        return m;
    }
"
1417,"It would be great to have tests for

1. Multiple `@BeforeParam` methods
1. Multiple `@AfterParam` methods
1. `@AfterParam` methods with parameters
1. `@BeforeParam` methods without parameters
1. Parameterized tests with more than one parameter","    public void beforeParamAndAfterParamAreRun() {
        fLog = """";
        final Result result = JUnitCore.runClasses(BeforeParamAndAfterParam.class);
        assertEquals(0, result.getFailureCount());
        assertEquals(""beforeClass before(A) first(A) second(A) afterParam ""
                + ""before(B) first(B) second(B) afterParam afterClass "", fLog);
    }
","START     public void beforeParamAndAfterParamAreRun() { END 
        fLog = """";
        final Result result = JUnitCore.runClasses(BeforeParamAndAfterParam.class);
        assertEquals(0, result.getFailureCount());
        assertEquals(""beforeClass before(A) first(A) second(A) afterParam ""
                + ""before(B) first(B) second(B) afterParam afterClass "", fLog);
    }
","    public void beforeParamAndAfterParamAreRun() {
        fLog = """";
        Result result = JUnitCore.runClasses(BeforeParamAndAfterParam.class);
        assertEquals(0, result.getFailureCount());
        assertEquals(""beforeClass before(A) first(A) second(A) afterParam ""
                + ""before(B) first(B) second(B) afterParam afterClass "", fLog);
    }
"
1418,shell should be disposed in teardown,"	public void setup() {
		Section section = new Section(new Shell(), SWT.NONE);
		event = new ExpansionEvent(section, true);
		expansionEventConsumer = new ExpansionEventConsumer();
	}
","	public void setup() {
START 		Section section = new Section(new Shell(), SWT.NONE); END 
		event = new ExpansionEvent(section, true);
		expansionEventConsumer = new ExpansionEventConsumer();
	}
","	public void setup() {
		event = new ExpansionEvent(section, true);
		expansionEventConsumer = new ExpansionEventConsumer();
	}
"
1419,"What happens if the user is ""brooklyn""? Is it sensible behaviour? Can/should we add an else block with an assertion for that?","    public void testGenerateGroupId() {
        String user = System.getProperty(""user.name"");

        String vcloudGroupId = JcloudsLocation.generateGroupId(""vcloud"");
        assertTrue(vcloudGroupId.startsWith(""br-""));

        String fooGroupId = JcloudsLocation.generateGroupId(""foo"");
        if (!""brooklyn"".equals(user))
            assertTrue(fooGroupId.startsWith(""brooklyn-""+user));
    }
","    public void testGenerateGroupId() {
        String user = System.getProperty(""user.name"");

        String vcloudGroupId = JcloudsLocation.generateGroupId(""vcloud"");
        assertTrue(vcloudGroupId.startsWith(""br-""));

        String fooGroupId = JcloudsLocation.generateGroupId(""foo"");
START         if (!""brooklyn"".equals(user)) END 
            assertTrue(fooGroupId.startsWith(""brooklyn-""+user));
    }
","    public void testGenerateGroupId() {
        String user = System.getProperty(""user.name"");

        String vcloudGroupId = JcloudsLocation.generateGroupId(""vcloud"");
        assertTrue(vcloudGroupId.startsWith(""br-""));

        String fooGroupId = JcloudsLocation.generateGroupId(""foo"");
        if (""brooklyn"".equals(user)) {
            // skip check -- we don't write   brooklyn-brooklyn-  because that looks funny
            // (and running as user brooklyn is common) 
        } else {
            assertTrue(fooGroupId.startsWith(""brooklyn-""+user));
        }
    }
"
1420,"`protected`, to allow easy subclassing.","    private void checkPasswordValidity(DocumentModel userModel) throws InvalidPasswordException {
        String schema = dirService.getDirectorySchema(userDirectoryName);
        String passwordField = dirService.getDirectory(userDirectoryName).getPasswordField();

        Property passwordProperty = userModel.getProperty(String.format(""%s:%s"", schema, passwordField));

        if (passwordProperty.isDirty()) {
            String clearPassword = passwordProperty.getValue(String.class);
            if (StringUtils.isNotBlank(clearPassword) && !validatePassword(clearPassword)) {
                throw new InvalidPasswordException();
            }
        }
    }
","START     private void checkPasswordValidity(DocumentModel userModel) throws InvalidPasswordException { END 
        String schema = dirService.getDirectorySchema(userDirectoryName);
        String passwordField = dirService.getDirectory(userDirectoryName).getPasswordField();

        Property passwordProperty = userModel.getProperty(String.format(""%s:%s"", schema, passwordField));

        if (passwordProperty.isDirty()) {
            String clearPassword = passwordProperty.getValue(String.class);
            if (StringUtils.isNotBlank(clearPassword) && !validatePassword(clearPassword)) {
                throw new InvalidPasswordException();
            }
        }
    }
","    protected void checkPasswordValidity(DocumentModel userModel) throws InvalidPasswordException {
        String schema = dirService.getDirectorySchema(userDirectoryName);
        String passwordField = dirService.getDirectory(userDirectoryName).getPasswordField();

        Property passwordProperty = userModel.getProperty(String.format(""%s:%s"", schema, passwordField));

        if (passwordProperty.isDirty()) {
            String clearPassword = passwordProperty.getValue(String.class);
            if (StringUtils.isNotBlank(clearPassword) && !validatePassword(clearPassword)) {
                throw new InvalidPasswordException();
            }
        }
    }
"
1421,"There is no harm in setting the confirmWindow to null, but since you are not actually setting it, there is no need to set it to null.","    protected void cancel() {
        setWindow(null);
        setConfirmWindow(null);
    }
","    protected void cancel() {
        setWindow(null);
START         setConfirmWindow(null); END 
    }
","    protected void cancel() {
        setWindow(null);
    }
"
1422,already done in the super?,"    public RemoveUnregisteredVmCommand(T parameters, CommandContext cmdContext) {
        super(parameters, cmdContext);
        setStorageDomainId(parameters.getStorageDomainId());
    }
","    public RemoveUnregisteredVmCommand(T parameters, CommandContext cmdContext) {
        super(parameters, cmdContext);
START         setStorageDomainId(parameters.getStorageDomainId()); END 
    }
","    public RemoveUnregisteredVmCommand(T parameters, CommandContext cmdContext) {
        super(parameters, cmdContext);
    }
"
1423,"tokenizer.skipString() I guess. No need to convert Utf8 to String here, just use the stream.skip().","  public String skipString() throws IOException {
    return tokenizer.readString();
  }
","  public String skipString() throws IOException {
START     return tokenizer.readString(); END 
  }
","  public void skipString() throws IOException {
    readString();
  }
"
1424,Why public?,"        public AbstractCursorWrappingIndexHits( int size, float score )
        {
            this.size = size;
            this.score = score;
        }
","START         public AbstractCursorWrappingIndexHits( int size, float score ) END 
        {
            this.size = size;
            this.score = score;
        }
","        AbstractCursorWrappingIndexHits( int size, float score )
        {
            this.size = size;
            this.score = score;
        }
"
1425,"'testsSize' is not very descriptive name, please use something like 'maxConfigurations' (is it really number of configurations that have executed this test?)","   public ReportDocument(String targetDir, String testName, int testsSize, boolean separateClusterCharts) {
      super(targetDir, String.format(""test_%s.html"", testName), ""Test "" + testName);

      this.testSize = testsSize;
      this.testName = testName;
      this.separateClusterCharts = separateClusterCharts;
   }
","START    public ReportDocument(String targetDir, String testName, int testsSize, boolean separateClusterCharts) { END 
      super(targetDir, String.format(""test_%s.html"", testName), ""Test "" + testName);

      this.testSize = testsSize;
      this.testName = testName;
      this.separateClusterCharts = separateClusterCharts;
   }
","   public ReportDocument(String targetDir, String testName, int testsSize, boolean separateClusterCharts) {
      super(targetDir, String.format(""test_%s.html"", testName), ""Test "" + testName);

      this.testName = testName;
      this.testSize = testsSize;
      this.separateClusterCharts = separateClusterCharts;
   }
"
1426,"@yesamer 
Please, do not do that, and follow what we agreed upon: a fixed static part (ScesimExpression) followed by ""-"" and a  randomly generated two digit number. 
Beside that, for each ""Object"" there can be only one ""expression"" property, so that count has no meaning; if you need to take this in account, there is something wrong in the code","    public void populateExpressionProperty(FactModelTree factModelTree) {
        if (factModelTree.getSimpleProperties().containsValue(ConstantsHolder.EXPRESSION_CLASSNAME)) {
            return;
        }
        final String expressionName = factModelTree.getFactName() + ConstantsHolder.EXPRESSION_SUFFIX;
        long count = factModelTree.getSimpleProperties().keySet().stream().filter(key -> key.startsWith(expressionName)).count();
        factModelTree.addSimpleProperty(count > 0 ? expressionName + ""_"" + count : expressionName, ConstantsHolder.EXPRESSION_CLASSNAME);
    }
","    public void populateExpressionProperty(FactModelTree factModelTree) {
        if (factModelTree.getSimpleProperties().containsValue(ConstantsHolder.EXPRESSION_CLASSNAME)) {
            return;
        }
        final String expressionName = factModelTree.getFactName() + ConstantsHolder.EXPRESSION_SUFFIX;
        long count = factModelTree.getSimpleProperties().keySet().stream().filter(key -> key.startsWith(expressionName)).count();
START         factModelTree.addSimpleProperty(count > 0 ? expressionName + ""_"" + count : expressionName, ConstantsHolder.EXPRESSION_CLASSNAME); END 
    }
","    public void populateExpressionProperty(FactModelTree factModelTree) {
        factModelTree.addSimpleProperty(factModelTree.getFactName() + ConstantsHolder.EXPRESSION_SUFFIX, ConstantsHolder.EXPRESSION_CLASSNAME);
    }
"
1427,why this is in vmCommand? should be in stopBase command,"    public VmCommand(T parameters) {
        super(parameters);
        setVmId(parameters.getVmId());
        setReason(parameters.getReason());
    }
","    public VmCommand(T parameters) {
        super(parameters);
        setVmId(parameters.getVmId());
START         setReason(parameters.getReason()); END 
    }
","    public VmCommand(T parameters) {
        super(parameters);
        setVmId(parameters.getVmId());
    }
"
1428,"""else"" is redundant here. Consider dropping it.","    public String retrieve(VeluxBridgeProvider bridge) {
        logger.trace(""retrieve() called."");

        logger.trace(""retrieve() About to query device status."");
        BCgetDeviceStatus.Response response = bridge.bridgeCommunicate(new BCgetDeviceStatus());
        if ((response == null) || (!response.getResult())) {
            logger.trace(""retrieve() finished with failure."");
            return null;
        } else {
            logger.trace(""retrieve() finished successfully with result {}."", response.getDeviceStatus());
            return response.getDeviceStatus();
        }
    }
","    public String retrieve(VeluxBridgeProvider bridge) {
        logger.trace(""retrieve() called."");

        logger.trace(""retrieve() About to query device status."");
        BCgetDeviceStatus.Response response = bridge.bridgeCommunicate(new BCgetDeviceStatus());
        if ((response == null) || (!response.getResult())) {
            logger.trace(""retrieve() finished with failure."");
            return null;
START         } else { END 
            logger.trace(""retrieve() finished successfully with result {}."", response.getDeviceStatus());
            return response.getDeviceStatus();
        }
    }
","    public String retrieve(VeluxBridgeProvider bridge) {
        logger.trace(""retrieve() called."");

        logger.trace(""retrieve() About to query device status."");
        BCgetDeviceStatus.Response response = bridge.bridgeCommunicate(new BCgetDeviceStatus());
        if ((response == null) || (!response.getResult())) {
            logger.trace(""retrieve() finished with failure."");
            return null;
        }
        logger.trace(""retrieve() finished successfully with result {}."", response.getDeviceStatus());
        return response.getDeviceStatus();
    }
"
1429,"whole function can be

return math.max(numberOfSlots / SLOTS_PER_CONTROLLER, 1);","    private static int getNeededNumberOfUsbControllers(int numberOfSlots) {
        int numOfcontrollers = numberOfSlots / SLOTS_PER_CONTROLLER;
        if (numOfcontrollers == 0) {
            numOfcontrollers = 1;
        }
        return numOfcontrollers;
    }
","    private static int getNeededNumberOfUsbControllers(int numberOfSlots) {
        int numOfcontrollers = numberOfSlots / SLOTS_PER_CONTROLLER;
        if (numOfcontrollers == 0) {
            numOfcontrollers = 1;
        }
START         return numOfcontrollers; END 
    }
","    private static int getNeededNumberOfUsbControllers(int numberOfSlots) {
        int numOfcontrollers = numberOfSlots / SLOTS_PER_CONTROLLER;
        if (numberOfSlots > 0 && numOfcontrollers == 0) {
            numOfcontrollers = 1;
        }
        return numOfcontrollers;
    }
"
1430,can this be primitive long to avoid the unnecessary wrapping?,"    public synchronized Long size()
    {
      final File file = path.toFile();
      Long size = (file.exists() && !file.isDirectory()) ? file.length() : 0l;
      if (childSize < 0l || childModCount > lastSizeCheck) {
        Long childSize = 0l;
        lastSizeCheck = childModCount;
        for (FileCopyResult child : children) {
          childSize += child.size();
        }
        this.childSize = childSize;
      }
      size += childSize;
      return size;
    }
","START     public synchronized Long size() END 
    {
      final File file = path.toFile();
      Long size = (file.exists() && !file.isDirectory()) ? file.length() : 0l;
      if (childSize < 0l || childModCount > lastSizeCheck) {
        Long childSize = 0l;
        lastSizeCheck = childModCount;
        for (FileCopyResult child : children) {
          childSize += child.size();
        }
        this.childSize = childSize;
      }
      size += childSize;
      return size;
    }
","    public long size()
    {
      return size;
    }
"
1431,please no exceptions in the constructor,"    public RngDeviceParameters(VmRngDevice rngDevice, boolean vm) {
        if (rngDevice == null) {
            throw new IllegalArgumentException(""RNG Device must be specified."");
        }
        this.rngDevice = rngDevice;
        isVm = vm;
    }
","    public RngDeviceParameters(VmRngDevice rngDevice, boolean vm) {
START         if (rngDevice == null) { END 
            throw new IllegalArgumentException(""RNG Device must be specified."");
        }
        this.rngDevice = rngDevice;
        isVm = vm;
    }
","    public RngDeviceParameters(VmRngDevice rngDevice, boolean vm) {
        this.rngDevice = rngDevice;
        isVm = vm;
    }
"
1432,Simpler: (pair.second & context) != 0,"	private static boolean isInContext(Pair<IErrorParserNamed, Integer> pair, int context) {
		return (pair.second & context) == context;
	}
","	private static boolean isInContext(Pair<IErrorParserNamed, Integer> pair, int context) {
START 		return (pair.second & context) == context; END 
	}
","	private static boolean isInContext(Pair<IErrorParserNamed, Integer> pair, int context) {
		return (pair.second & context) != 0;
	}
"
1433,Hard to say in Gerrit (I still have to pull in the change into Eclipse) but the checks are already done in the protected addAlwaysOff method. Is this method called in places where these checks are not already done?,"	private void removeAlwaysOn(IActionSetDescriptor descriptor) {
		if (descriptor == null) {
			return;
		}
		if (!alwaysOnActionSets.contains(descriptor)) {
			return;
		}

		alwaysOnActionSets.remove(descriptor);
		if (page != null) {
			page.perspectiveActionSetChanged(this, descriptor, ActionSetManager.CHANGE_HIDE);
		}
	}
","START 	private void removeAlwaysOn(IActionSetDescriptor descriptor) { END 
		if (descriptor == null) {
			return;
		}
		if (!alwaysOnActionSets.contains(descriptor)) {
			return;
		}

		alwaysOnActionSets.remove(descriptor);
		if (page != null) {
			page.perspectiveActionSetChanged(this, descriptor, ActionSetManager.CHANGE_HIDE);
		}
	}
","	private void removeAlwaysOn(IActionSetDescriptor descriptor) {
		if (!alwaysOnActionSets.contains(descriptor)) {
			return;
		}
		alwaysOnActionSets.remove(descriptor);
		page.perspectiveActionSetChanged(this, descriptor, ActionSetManager.CHANGE_HIDE);
	}
"
1434,"I think there is an invalid order of the groups. The way it is implemented now, this test creates this relation:
2
|
3
|
4
And calling `createGroupUnion(sess, group4, group2, false)` tries to import members from group2 to group4. This causes a cycle, and I am not sure if we can detect this in the current implementation. Also, the test passes because of the error which I have pointed out above.
```suggestion
		groupsManagerBl.createGroupUnion(sess, group2, group4, false);
```","	public void createGroupUnionForIndirectRelationship() throws Exception {
		System.out.println(CLASS_NAME + ""createGroupUnionForIndirectRelationship"");

		Vo vo = setUpVo();
		groupsManagerBl.createGroup(sess, vo, group2);
		groupsManagerBl.createGroup(sess, group2, group3);
		groupsManagerBl.createGroup(sess, group3, group4);

		groupsManagerBl.createGroupUnion(sess, group4, group2, false);
	}
","	public void createGroupUnionForIndirectRelationship() throws Exception {
		System.out.println(CLASS_NAME + ""createGroupUnionForIndirectRelationship"");

		Vo vo = setUpVo();
		groupsManagerBl.createGroup(sess, vo, group2);
		groupsManagerBl.createGroup(sess, group2, group3);
		groupsManagerBl.createGroup(sess, group3, group4);

START 		groupsManagerBl.createGroupUnion(sess, group4, group2, false); END 
	}
","	public void createGroupUnionForIndirectRelationship() throws Exception {
		System.out.println(CLASS_NAME + ""createGroupUnionForIndirectRelationship"");

		Vo vo = setUpVo();
		groupsManagerBl.createGroup(sess, vo, group2);
		groupsManagerBl.createGroup(sess, group2, group3);
		groupsManagerBl.createGroup(sess, group3, group4);

		groupsManagerBl.createGroupUnion(sess, group2, group4, false);
	}
"
1435,final missing,"	private SelectionListener createListener() {
		final SelectionListener listener = new SelectionListener() {

			@Override
			public void widgetSelected(SelectionEvent e) {
				resetProperties();
			}

			@Override
			public void widgetDefaultSelected(SelectionEvent e) {
				// nothing to do
			}
		};
		return listener;
	}
","	private SelectionListener createListener() {
		final SelectionListener listener = new SelectionListener() {

			@Override
			public void START widgetSelected(SelectionEvent e) { END 
				resetProperties();
			}

			@Override
			public void widgetDefaultSelected(SelectionEvent e) {
				// nothing to do
			}
		};
		return listener;
	}
","	private SelectionListener createListener() {
		final SelectionListener listener = new SelectionListener() {

			@Override
			public void widgetSelected(final SelectionEvent e) {
				resetProperties();
			}

			@Override
			public void widgetDefaultSelected(final SelectionEvent e) {
				// nothing to do
			}
		};
		return listener;
	}
"
1436,"I would flip the condition since the special case is when we have protocol, not otherwise:

``` java
if (expectedUrl.startsWith(""http://"")) {
  expectedUrl = expectedPath
}
```","  public void testOur404Handler(String wiki, String inputPath, String expectedPath) {
    String wikiBase = urlBuilder.getUrlForWiki(wiki);
    String inputUrl = wikiBase + inputPath;
    String expectedUrl = expectedPath;

    if (!expectedUrl.startsWith(""http://"")) {
      expectedUrl = wikiBase + expectedUrl;
    }

    driver.get(inputUrl);
    String actualUrl = driver.getCurrentUrl();
    Assertion.assertEquals(actualUrl, expectedUrl);
  }
","  public void testOur404Handler(String wiki, String inputPath, String expectedPath) {
    String wikiBase = urlBuilder.getUrlForWiki(wiki);
    String inputUrl = wikiBase + inputPath;
    String expectedUrl = expectedPath;

START     if (!expectedUrl.startsWith(""http://"")) { END 
      expectedUrl = wikiBase + expectedUrl;
    }

    driver.get(inputUrl);
    String actualUrl = driver.getCurrentUrl();
    Assertion.assertEquals(actualUrl, expectedUrl);
  }
","  public void testOur404Handler(String wiki, String inputPath, String expectedPath) {
    String wikiBase = urlBuilder.getUrlForWiki(wiki);
    String inputUrl = wikiBase + inputPath;
    String expectedUrl = wikiBase + expectedPath;

    // Special case for favicon:
    if (expectedPath.startsWith(""http://"")) {
      expectedUrl = expectedPath;
    }

    driver.get(inputUrl);
    String actualUrl = driver.getCurrentUrl();
    Assertion.assertEquals(actualUrl, expectedUrl);
  }
"
1437,What exception is possibly thrown from this close(false) call?,"    public void closeDirty() {
        try {
            close(false);
        } catch (final RuntimeException e) {
            log.warn(String.format(""Ignoring uncaught error in unclean close of standby task %s"", id), e);
        }

        log.info(""Closed dirty"");
    }
","    public void closeDirty() {
        try {
            close(false);
        } catch (final RuntimeException e) {
START             log.warn(String.format(""Ignoring uncaught error in unclean close of standby task %s"", id), e); END 
        }

        log.info(""Closed dirty"");
    }
","    public void closeDirty() {
        close(false);

        log.info(""Closed dirty"");
    }
"
1438,Just `IRenderHandler` (use an import),"    public boolean renderClouds(int cloudTicks, float partialTicks)
    {
        net.minecraftforge.client.IRenderHandler renderer = this.client.world.provider.getCloudRenderer();
        if (renderer != null)
        {
            renderer.render(partialTicks, this.client.world, this.client);
            return true;
        }
        return cloudRenderer.render(cloudTicks, partialTicks);
    }
","    public boolean renderClouds(int cloudTicks, float partialTicks)
    {
START         net.minecraftforge.client.IRenderHandler renderer = this.client.world.provider.getCloudRenderer(); END 
        if (renderer != null)
        {
            renderer.render(partialTicks, this.client.world, this.client);
            return true;
        }
        return cloudRenderer.render(cloudTicks, partialTicks);
    }
","    public boolean renderClouds(int cloudTicks, float partialTicks)
    {
        IRenderHandler renderer = this.client.world.provider.getCloudRenderer();
        if (renderer != null)
        {
            renderer.render(partialTicks, this.client.world, this.client);
            return true;
        }
        return cloudRenderer.render(cloudTicks, partialTicks);
    }
"
1439,Don't need this if statement either,"	private ValueType getResultILType(GenContext ctx) {

		Arrow a = (Arrow) this.type;

        if(
            isGeneric() &&
            a.getResult() instanceof UnresolvedType &&
            ((UnresolvedType) a.getResult()).getName().equals(this.genTypeName)
          ) {
            return new NominalType(new Variable(GENERIC_PREFACE), GENERIC_MEMBER);
        }
        return ((Arrow)type).getResult().getILType(ctx);
	}
","	private ValueType getResultILType(GenContext ctx) {

		Arrow a = (Arrow) this.type;

START         if( END 
            isGeneric() &&
            a.getResult() instanceof UnresolvedType &&
            ((UnresolvedType) a.getResult()).getName().equals(this.genTypeName)
          ) {
            return new NominalType(new Variable(GENERIC_PREFACE), GENERIC_MEMBER);
        }
        return ((Arrow)type).getResult().getILType(ctx);
	}
","	private ValueType getResultILType(GenContext ctx) {
		Arrow a = (Arrow) this.type;
        return a.getResult().getILType(ctx);
	}
"
1440,"that seems like a hack to me. Shouldn't the boolean `driver` indicate if the seat is the driver seat? Which doesn't change based on the presence of a actual driver entity. I did not take a deeper look at this, but my assumption is that the boolean is not correctly set after reloading the entity from a save file","	public Entity getControllingPassenger()
	{
		List<Entity> _passengers = getPassengers();
		if(_passengers.isEmpty())
		{
			setDriverState(false);
			return null;
		}
		else
		{
			setDriverState(true);
			return _passengers.get(0);
		}
	}
","	public Entity getControllingPassenger()
	{
		List<Entity> _passengers = getPassengers();
		if(_passengers.isEmpty())
		{
			setDriverState(false);
			return null;
		}
		else
		{
START 			setDriverState(true); END 
			return _passengers.get(0);
		}
	}
","	public Entity getControllingPassenger()
	{
		return getPassengers().isEmpty() ? null : getPassengers().get(0);
	}
"
1441,"I don't think you need this new flag. You should immediately return `null` from `fetchNextReady()` if the child has already been closed, which you can test with `child.isOpen()` or `child.eos()`. @jingjingwang do you agree?","  public Limit(@Nonnull final Long limit, final Operator child) {
    super(child);
    this.limit = Objects.requireNonNull(limit, ""limit"");
    Preconditions.checkArgument(limit >= 0L, ""limit must be non-negative"");
    toEmit = this.limit;
    done = false;
  }
","  public Limit(@Nonnull final Long limit, final Operator child) {
    super(child);
    this.limit = Objects.requireNonNull(limit, ""limit"");
    Preconditions.checkArgument(limit >= 0L, ""limit must be non-negative"");
    toEmit = this.limit;
START     done = false; END 
  }
","  public Limit(@Nonnull final Long limit, final Operator child) {
    super(child);
    this.limit = Objects.requireNonNull(limit, ""limit"");
    Preconditions.checkArgument(limit >= 0L, ""limit must be non-negative"");
    toEmit = this.limit;
  }
"
1442,"Not quite (did not check column qualifier or visibility), you can use `key.equals(k, PartialKey.ROW_COLFAM_COLQUAL_COLVIS)` and it checks row and all three column fields.","  public void add(Key k, Value v) {

    if (key == null) {
      key = k;
      timeStamps.add(k.getTimestamp());
      values.add(v);
      size++;
    } else if (key.compareRow(k.getRow()) == 0
        && key.compareColumnFamily(k.getColumnFamily()) == 0) {
      timeStamps.add(k.getTimestamp());
      values.add(v);
    } else {
      //TODO: what happens here
    }
  }
","  public void add(Key k, Value v) {

    if (key == null) {
      key = k;
      timeStamps.add(k.getTimestamp());
      values.add(v);
      size++;
    } else if (key.compareRow(k.getRow()) == 0
START         && key.compareColumnFamily(k.getColumnFamily()) == 0) { END 
      timeStamps.add(k.getTimestamp());
      values.add(v);
    } else {
      //TODO: what happens here
    }
  }
","  public void add(Key k, Value v) throws IllegalArgumentException {
    add(k, v.get());
  }
"
1443,The version check should come before the call to `loadTemplates()`.,"    public STGroup getTemplates() {
        if (templates == null) {
            templates = loadTemplates();
            String version = getVersion();
            if (version == null || !version.equals(Tool.VERSION)) {
                gen.tool.errMgr.toolError(ErrorType.INCOMPATIBLE_TOOL_AND_TEMPLATES, version, Tool.VERSION, language);
            }
        }

		return templates;
	}
","    public STGroup getTemplates() {
        if (templates == null) {
            templates = loadTemplates();
START             String version = getVersion(); END 
            if (version == null || !version.equals(Tool.VERSION)) {
                gen.tool.errMgr.toolError(ErrorType.INCOMPATIBLE_TOOL_AND_TEMPLATES, version, Tool.VERSION, language);
            }
        }

		return templates;
	}
","    public STGroup getTemplates() {
        if (templates == null) {
            String version = getVersion();
            if (version == null || !version.equals(Tool.VERSION)) {
                gen.tool.errMgr.toolError(ErrorType.INCOMPATIBLE_TOOL_AND_TEMPLATES, version, Tool.VERSION, language);
            }
            templates = loadTemplates();
        }

		return templates;
	}
"
1444,"This line triggers a `java.lang.NumberFormatException` for the following code: 
```
$a = 012_345;
```","  private boolean isException(String value) {
    return value.length() == 4 || Integer.parseInt(value) < 8;
  }
","  private boolean isException(String value) {
START     return value.length() == 4 || Integer.parseInt(value) < 8; END 
  }
","  private static boolean isException(String value) {
    return value.length() == 4 || Integer.parseInt(value) < 8;
  }
"
1445,Same here...one thing I've noticed is that if location == null NPE exceptions get thrown.  We should probably check on null here.,"	public LatLng getGoogleMapsLocation() {
		ParseGeoPoint pGP = (ParseGeoPoint) getClient().get(""location"");
		return new LatLng(pGP.getLatitude(), pGP.getLongitude());
	}
","	public LatLng getGoogleMapsLocation() {
START 		ParseGeoPoint pGP = (ParseGeoPoint) getClient().get(""location""); END 
		return new LatLng(pGP.getLatitude(), pGP.getLongitude());
	}
","	public LatLng getGoogleMapsLocation() {
		return getClient().getGoogleMapsLocation();
	}
"
1446,"If the parent is null, this does nothing and the caller/log gets no indication that there was a problem.  Is this desired?","   public void saveSMA(IAtsChangeSet changes) {
      super.saveSMA(changes);
      try {
         ActionArtifact parentAction = getParentActionArtifact();
         if (parentAction != null) {
            ActionArtifactRollup rollup = new ActionArtifactRollup(parentAction);
            rollup.resetAttributesOffChildren();
            changes.add(parentAction);
         }
      } catch (Exception ex) {
         OseeLog.log(Activator.class, OseeLevel.SEVERE_POPUP, ""Can't reset Action parent of children"", ex);
      }
   }
","   public void saveSMA(IAtsChangeSet changes) {
      super.saveSMA(changes);
      try {
         ActionArtifact parentAction = getParentActionArtifact();
         if (parentAction != null) {
            ActionArtifactRollup rollup = new ActionArtifactRollup(parentAction);
            rollup.resetAttributesOffChildren();
            changes.add(parentAction);
START          } END 
      } catch (Exception ex) {
         OseeLog.log(Activator.class, OseeLevel.SEVERE_POPUP, ""Can't reset Action parent of children"", ex);
      }
   }
","   public void saveSMA(IAtsChangeSet changes) {
      super.saveSMA(changes);
      try {
         ActionArtifact parentAction = getParentActionArtifact();
         ActionArtifactRollup rollup = new ActionArtifactRollup(parentAction);
         rollup.resetAttributesOffChildren();
         changes.add(parentAction);
      } catch (Exception ex) {
         OseeLog.log(Activator.class, OseeLevel.SEVERE_POPUP, ""Can't reset Action parent of children"", ex);
      }
   }
"
1447,usar generics no tipo de retorno,"    public List getArquivosOriginais()
    {
        return arquivosIniciais;
    }
","START     public List getArquivosOriginais() END 
    {
        return arquivosIniciais;
    }
","    public List<File> getArquivosOriginais()
    {
        return arquivosIniciais;
    }
"
1448,"nit
```java
for (long filter : filters) {
    combined |= filter;
}","    private static long combineFilters(long[] filters)
    {
        if (filters == null) {
            return 0;
        }

        int combined = 0;
        for (int i = 0; i < filters.length; i++) {
            combined |= filters[i];
        }
        return combined;
    }
","    private static long combineFilters(long[] filters)
    {
        if (filters == null) {
            return 0;
        }

        int combined = 0;
START         for (int i = 0; i < filters.length; i++) { END 
            combined |= filters[i];
        }
        return combined;
    }
","    private static long combineFilters(long[] filters)
    {
        if (filters == null) {
            return 0;
        }

        int combined = 0;
        for (long filter : filters) {
            combined |= filter;
        }
        return combined;
    }
"
1449,"Extra whitespace forming neat little columns makes the code arguably HARDER to read and inarguably harder to write and maintain -- turning future single-line changes into multi-line mostly whitespace changes , so PLEASE DESIST.","    private boolean matchExpressionAndColumnRef(AbstractExpression statementExpr,
                                                ColumnRef          indexColRef,
                                                StmtTableScan      tableScan) {
        if (statementExpr instanceof TupleValueExpression) {
            TupleValueExpression tve = (TupleValueExpression)statementExpr;
            if (tve.getTableAlias().equals(tableScan.getTableAlias()) &&
                    tve.getColumnName().equals(indexColRef.getColumn().getTypeName())) {
                // NB: m_emptyBindings is a null list.  That means
                //     we matched, but with no bindings.
                return true;
            }
        }
        return false;
    }
","    private boolean matchExpressionAndColumnRef(AbstractExpression statementExpr,
                                                ColumnRef          indexColRef,
START                                                 StmtTableScan      tableScan) { END 
        if (statementExpr instanceof TupleValueExpression) {
            TupleValueExpression tve = (TupleValueExpression)statementExpr;
            if (tve.getTableAlias().equals(tableScan.getTableAlias()) &&
                    tve.getColumnName().equals(indexColRef.getColumn().getTypeName())) {
                // NB: m_emptyBindings is a null list.  That means
                //     we matched, but with no bindings.
                return true;
            }
        }
        return false;
    }
","    private static boolean matchExpressionAndColumnRef(AbstractExpression statementExpr,
                                                       ColumnRef indexColRef,
                                                       StmtTableScan tableScan) {
        if (statementExpr instanceof TupleValueExpression) {
            TupleValueExpression tve = (TupleValueExpression)statementExpr;
            if (tve.getTableAlias().equals(tableScan.getTableAlias()) &&
                    tve.getColumnName().equals(indexColRef.getColumn().getTypeName())) {
                return true;
            }
        }
        return false;
    }
"
1450,"Why localized? We usually don't localize log message, if somebody gets a translated IOException in the log would be hard to understand later when they submit the bug","	public static void log(Throwable e) {
		log(new Status(IStatus.ERROR, PLUGIN_ID, IStatus.OK, e.getLocalizedMessage(), e));
	}
","	public static void log(Throwable e) {
START 		log(new Status(IStatus.ERROR, PLUGIN_ID, IStatus.OK, e.getLocalizedMessage(), e)); END 
	}
","	public static void log(Throwable e) {
		log(new Status(IStatus.ERROR, PLUGIN_ID, IStatus.OK, e.getMessage(), e));
	}
"
1451,"You can use Boolean.TRUE.equals(obj) if you want, though it's less explicit, so I don't mind :-)","    private boolean isNotTimeshiftedOrHd(Channel channel) {
        boolean timeshifted = MoreObjects.firstNonNull(channel.getTimeshifted(), false);
        boolean hd = MoreObjects.firstNonNull(channel.getHighDefinition(), false);

        return !(timeshifted || hd);
    }
","    private boolean isNotTimeshiftedOrHd(Channel channel) {
START         boolean timeshifted = MoreObjects.firstNonNull(channel.getTimeshifted(), false); END 
        boolean hd = MoreObjects.firstNonNull(channel.getHighDefinition(), false);

        return !(timeshifted || hd);
    }
","    boolean isNotTimeshiftedOrHd(Channel channel) {
        boolean timeshifted = MoreObjects.firstNonNull(channel.getTimeshifted(), false);
        boolean hd = MoreObjects.firstNonNull(channel.getHighDefinition(), false);

        return !(timeshifted || hd);
    }
"
1452,"So we lose the typing on `CacheContainerAdmin`, should we define that on this method or as a generic on `CacheContainer` at least?","   default CacheContainerAdmin administration() {
      throw new UnsupportedOperationException();
   }
","   default CacheContainerAdmin administration() {
START       throw new UnsupportedOperationException(); END 
   }
","   default CacheContainerAdmin<?> administration() {
      throw new UnsupportedOperationException();
   }
"
1453,Original query was not cacheable. This one is. I think the third param should be false.,"    public RegistrationData findByToken(Context context, String token) throws SQLException {
        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
        CriteriaQuery criteriaQuery = getCriteriaQuery(criteriaBuilder, RegistrationData.class);
        Root<RegistrationData> registrationDataRoot = criteriaQuery.from(RegistrationData.class);
        criteriaQuery.select(registrationDataRoot);
        criteriaQuery.where(criteriaBuilder.equal(registrationDataRoot.get(RegistrationData_.token), token));
        return uniqueResult(context, criteriaQuery, true, RegistrationData.class, -1, -1);
    }
","    public RegistrationData findByToken(Context context, String token) throws SQLException {
        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
        CriteriaQuery criteriaQuery = getCriteriaQuery(criteriaBuilder, RegistrationData.class);
        Root<RegistrationData> registrationDataRoot = criteriaQuery.from(RegistrationData.class);
        criteriaQuery.select(registrationDataRoot);
        criteriaQuery.where(criteriaBuilder.equal(registrationDataRoot.get(RegistrationData_.token), token));
START         return uniqueResult(context, criteriaQuery, true, RegistrationData.class, -1, -1); END 
    }
","    public RegistrationData findByToken(Context context, String token) throws SQLException {
        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
        CriteriaQuery criteriaQuery = getCriteriaQuery(criteriaBuilder, RegistrationData.class);
        Root<RegistrationData> registrationDataRoot = criteriaQuery.from(RegistrationData.class);
        criteriaQuery.select(registrationDataRoot);
        criteriaQuery.where(criteriaBuilder.equal(registrationDataRoot.get(RegistrationData_.token), token));
        return uniqueResult(context, criteriaQuery, false, RegistrationData.class, -1, -1);
    }
"
1454,Saving preferences inside a setter  is not appropriate. Please follow the pattern used for other preferences.,"	public static void setReindexOnConfigChange(IProject project, boolean shouldReindexOnConfigChange) {
		if (shouldReindexOnConfigChange != getReindexOnConfigChange(project)) {
			getProjectPreferences(project).putBoolean(KEY_REINDEX_ON_CONFIG_CHANGE, shouldReindexOnConfigChange);
			CCoreInternals.savePreferences(project, true);
		}
	}
","	public static void setReindexOnConfigChange(IProject project, boolean shouldReindexOnConfigChange) {
		if (shouldReindexOnConfigChange != getReindexOnConfigChange(project)) {
			getProjectPreferences(project).putBoolean(KEY_REINDEX_ON_CONFIG_CHANGE, shouldReindexOnConfigChange);
START 			CCoreInternals.savePreferences(project, true); END 
		}
	}
","	public static void setReindexOnConfigChange(IProject project, boolean shouldReindexOnConfigChange) {
		if (shouldReindexOnConfigChange != getReindexOnConfigChange(project)) {
			getProjectPreferences(project).putBoolean(KEY_REINDEX_ON_CONFIG_CHANGE, shouldReindexOnConfigChange);
		}
	}
"
1455,"@vilchik-elena It looks like problemMap is actually a noProblemMap. Suggestion: invert the meaning of the Boolean: true for problem, false for no problem.","  public void beforeBlockElement(ProgramState currentState, Tree element) {
    T tree = getTree(element);

    if (tree != null) {
      boolean isProblem = isProblem(tree, currentState);
      if (!isProblem) {
        problemMap.put(tree, true);
      } else if (!problemMap.containsKey(tree)) {
        problemMap.put(tree, false);
      }
    }
  }
","  public void beforeBlockElement(ProgramState currentState, Tree element) {
    T tree = getTree(element);

    if (tree != null) {
      boolean isProblem = isProblem(tree, currentState);
      if (!isProblem) {
        problemMap.put(tree, true);
START       } else if (!problemMap.containsKey(tree)) { END 
        problemMap.put(tree, false);
      }
    }
  }
","  public void beforeBlockElement(ProgramState currentState, Tree element) {
    T tree = getTree(element);

    if (tree != null) {
      boolean isProblem = isProblem(tree, currentState);
      if (!isProblem) {
        problemMap.put(tree, false);
      } else if (!problemMap.containsKey(tree)) {
        problemMap.put(tree, true);
      }
    }
  }
"
1456,extra `this.`,"    public String toString()
    {
        return toStringHelper(this)
                .omitNullValues()
                .add(""outputSymbolAliases"", this.outputSymbolAliases)
                .add(""expectedOutputSymbolCount"", expectedOutputSymbolCount)
                .add(""expectedRows"", expectedRows)
                .toString();
    }
","    public String toString()
    {
        return toStringHelper(this)
                .omitNullValues()
START                 .add(""outputSymbolAliases"", this.outputSymbolAliases) END 
                .add(""expectedOutputSymbolCount"", expectedOutputSymbolCount)
                .add(""expectedRows"", expectedRows)
                .toString();
    }
","    public String toString()
    {
        return toStringHelper(this)
                .omitNullValues()
                .add(""outputSymbolAliases"", outputSymbolAliases)
                .add(""expectedOutputSymbolCount"", expectedOutputSymbolCount)
                .add(""expectedRows"", expectedRows)
                .toString();
    }
"
1457,These two checks seem unrelated to the actual check you want to perform.,"    public void testSinglePartUnknownEncoding_throwsUnsupportedEncodingException() throws Exception {
        MimeMessage msg = parseWithoutRecurse(toStream(
                ""From: <adam@example.org>\r\n"" +
                        ""To: <eva@example.org>\r\n"" +
                        ""Subject: Testmail\r\n"" +
                        ""MIME-Version: 1.0\r\n"" +
                        ""Content-type: text/plain\r\n"" +
                        ""Content-Transfer-Encoding: utf-8\r\n"" +
                        ""\r\n"" +
                        ""dGhpcyBpcyBzb21lIG1vcmUgdGVzdCB0ZXh0Lg==\r\n""));

        checkAddresses(msg.getFrom(), ""adam@example.org"");
        checkAddresses(msg.getRecipients(RecipientType.TO), ""eva@example.org"");
        streamToString(MimeUtility.decodeBody(msg.getBody()));
    }
","    public void testSinglePartUnknownEncoding_throwsUnsupportedEncodingException() throws Exception {
        MimeMessage msg = parseWithoutRecurse(toStream(
                ""From: <adam@example.org>\r\n"" +
                        ""To: <eva@example.org>\r\n"" +
                        ""Subject: Testmail\r\n"" +
                        ""MIME-Version: 1.0\r\n"" +
                        ""Content-type: text/plain\r\n"" +
                        ""Content-Transfer-Encoding: utf-8\r\n"" +
                        ""\r\n"" +
                        ""dGhpcyBpcyBzb21lIG1vcmUgdGVzdCB0ZXh0Lg==\r\n""));

        checkAddresses(msg.getFrom(), ""adam@example.org"");
START         checkAddresses(msg.getRecipients(RecipientType.TO), ""eva@example.org""); END 
        streamToString(MimeUtility.decodeBody(msg.getBody()));
    }
","    public void testSinglePartUnknownEncoding_throwsUnsupportedEncodingException() throws Exception {
        MimeMessage msg = parseWithoutRecurse(toStream(
                ""From: <adam@example.org>\r\n"" +
                        ""To: <eva@example.org>\r\n"" +
                        ""Subject: Testmail\r\n"" +
                        ""MIME-Version: 1.0\r\n"" +
                        ""Content-type: text/plain\r\n"" +
                        ""Content-Transfer-Encoding: utf-8\r\n"" +
                        ""\r\n"" +
                        ""dGhpcyBpcyBzb21lIG1vcmUgdGVzdCB0ZXh0Lg==\r\n""));

        MimeUtility.decodeBody(msg.getBody());
    }
"
1458,I'd make this `protected`.,"    public UpdateSite createDefaultUpdateSite() {
        return new UpdateSite(PREDEFINED_UPDATE_SITE_ID, config.getUpdateCenterUrl() + ""update-center.json"");
    }
","START     public UpdateSite createDefaultUpdateSite() { END 
        return new UpdateSite(PREDEFINED_UPDATE_SITE_ID, config.getUpdateCenterUrl() + ""update-center.json"");
    }
","    protected UpdateSite createDefaultUpdateSite() {
        return new UpdateSite(PREDEFINED_UPDATE_SITE_ID, config.getUpdateCenterUrl() + ""update-center.json"");
    }
"
1459,You can make this method private,"    private void assertCorrectGetManagedInterfaceForVdsResult(VdsNetworkInterface result) {
        assertNotNull(result);
        assertTrue(result.getIsManagement());
    }
","START     private void assertCorrectGetManagedInterfaceForVdsResult(VdsNetworkInterface result) { END 
        assertNotNull(result);
        assertTrue(result.getIsManagement());
    }
","    static private void assertCorrectGetManagedInterfaceForVdsResult(VdsNetworkInterface result) {
        assertNotNull(result);
        assertTrue(result.getIsManagement());
    }
"
1460,Define a constant for `1`?,"  public static RequestControlAdminRequest readFrom(DataInputStream stream, AdminRequest adminRequest)
      throws IOException {
    Short versionId = stream.readShort();
    if (!versionId.equals(VERSION_V1)) {
      throw new IllegalStateException(""Unrecognized version for RequestControlAdminRequest: "" + VERSION_V1);
    }
    RequestOrResponseType requestType = RequestOrResponseType.values()[stream.readShort()];
    boolean enable = stream.readByte() == 1;
    return new RequestControlAdminRequest(requestType, enable, adminRequest);
  }
","  public static RequestControlAdminRequest readFrom(DataInputStream stream, AdminRequest adminRequest)
      throws IOException {
    Short versionId = stream.readShort();
    if (!versionId.equals(VERSION_V1)) {
      throw new IllegalStateException(""Unrecognized version for RequestControlAdminRequest: "" + VERSION_V1);
    }
    RequestOrResponseType requestType = RequestOrResponseType.values()[stream.readShort()];
START     boolean enable = stream.readByte() == 1; END 
    return new RequestControlAdminRequest(requestType, enable, adminRequest);
  }
","  public static RequestControlAdminRequest readFrom(DataInputStream stream, AdminRequest adminRequest)
      throws IOException {
    Short versionId = stream.readShort();
    if (!versionId.equals(VERSION_V1)) {
      throw new IllegalStateException(""Unrecognized version for RequestControlAdminRequest: "" + versionId);
    }
    RequestOrResponseType requestType = RequestOrResponseType.values()[stream.readShort()];
    boolean enable = stream.readByte() == 1;
    return new RequestControlAdminRequest(requestType, enable, adminRequest);
  }
"
1461,"Are you expecting to get Workflow jobs here? If so, I think it will not work.","	public void buildDependencyGraph(AbstractProject owner, DependencyGraph graph) {
		// Can only add dependencies in Hudson 1.341 or higher
		if (!canDeclare(owner)) return;

		for (BuildTriggerConfig config : configs) {
			List<AbstractProject> projectList = Util.filter(config.getProjectList(owner.getParent(), null), AbstractProject.class);
			for (AbstractProject project : projectList)
				ParameterizedDependency.add(owner, project, config, graph);
		}
	}
","	public void buildDependencyGraph(AbstractProject owner, DependencyGraph graph) {
		// Can only add dependencies in Hudson 1.341 or higher
		if (!canDeclare(owner)) return;

		for (BuildTriggerConfig config : configs) {
START 			List<AbstractProject> projectList = Util.filter(config.getProjectList(owner.getParent(), null), AbstractProject.class); END 
			for (AbstractProject project : projectList)
				ParameterizedDependency.add(owner, project, config, graph);
		}
	}
","	public void buildDependencyGraph(AbstractProject owner, DependencyGraph graph) {
		// Can only add dependencies in Hudson 1.341 or higher
		if (!canDeclare(owner)) return;

		for (BuildTriggerConfig config : configs) {
			List<AbstractProject> projectList = config.getProjectList(owner.getParent(), null);
			for (AbstractProject project : projectList) {
				ParameterizedDependency.add(owner, project, config, graph);
			}
		}
	}
"
1462,"This method returns an Option<DRepresentation>, so the API clearly says it can be null. You must check 'if getRepresentation().some()"" before.","    public DAnalysis getDAnalysis() {
        DAnalysis dAnalysis = null;
        DRepresentation representation = getRepresentation().get();
        DRepresentationDescriptor representationDescriptor = new DRepresentationQuery(representation).getRepresentationDescriptor();
        EObject rootContainer = EcoreUtil.getRootContainer(representationDescriptor, false);
        if (rootContainer instanceof DAnalysis) {
            dAnalysis = (DAnalysis) rootContainer;
        }
        return dAnalysis;
    }
","    public DAnalysis getDAnalysis() {
        DAnalysis dAnalysis = null;
        DRepresentation representation = START  getRepresentation().get(); END 
        DRepresentationDescriptor representationDescriptor = new DRepresentationQuery(representation).getRepresentationDescriptor();
        EObject rootContainer = EcoreUtil.getRootContainer(representationDescriptor, false);
        if (rootContainer instanceof DAnalysis) {
            dAnalysis = (DAnalysis) rootContainer;
        }
        return dAnalysis;
    }
","    public DAnalysis getDAnalysis() {
        DAnalysis dAnalysis = null;
        DRepresentation representation = getRepresentation().get();
        if (representation != null) {
            DRepresentationDescriptor representationDescriptor = new DRepresentationQuery(representation).getRepresentationDescriptor();
            EObject rootContainer = EcoreUtil.getRootContainer(representationDescriptor, false);
            if (rootContainer instanceof DAnalysis) {
                dAnalysis = (DAnalysis) rootContainer;
            }
        }
        return dAnalysis;
    }
"
1463,Unnecessary; the call to this(...) does it,"	public ASTNode(HasLocation hasLocation) {
		this(hasLocation.getLocation());
    metadataSet = new HashSet<>();
	}
","	public ASTNode(HasLocation hasLocation) {
		this(hasLocation.getLocation());
START     metadataSet = new HashSet<>(); END 
	}
","	public ASTNode(HasLocation hasLocation) {
		this(hasLocation.getLocation());
	}
"
1464,"You should also clear the map. The EMF observable value holds the EObject after even after disposal which may prevent the GC to collect the model if this observable is retained. For similar reasons, please set 'match' to null here.","    public synchronized void dispose() {
        for (Entry<String, IObservableValue> entry : expressionMap.entrySet()) {
            entry.getValue().dispose();
        }
        super.dispose();
    }
","    public synchronized void dispose() {
        for (Entry<String, IObservableValue> entry : expressionMap.entrySet()) {
            entry.getValue().dispose();
        }
START         super.dispose(); END 
    }
","    public synchronized void dispose() {
        for (Entry<String, IObservableValue> entry : expressionMap.entrySet()) {
            entry.getValue().dispose();
        }
        expressionMap.clear();
        super.dispose();
    }
"
1465,"As discussed in main issue, this should be in the check for the entire method.
Maybe this should be moved to the `isCheckedMethod` method?","    private void visitParameterDef(DetailAST parameterDef) {
        final DetailAST grandParentAST = parameterDef.getParent().getParent();

        if (grandParentAST.getType() == TokenTypes.METHOD_DEF
            && isCheckedMethod(grandParentAST)
            && isVerifiable(grandParentAST)
            && !AnnotationUtil.containsAnnotation(grandParentAST, ""Override"")) {
            checkClassName(parameterDef);
        }
    }
","    private void visitParameterDef(DetailAST parameterDef) {
        final DetailAST grandParentAST = parameterDef.getParent().getParent();

        if (grandParentAST.getType() == TokenTypes.METHOD_DEF
            && isCheckedMethod(grandParentAST)
            && isVerifiable(grandParentAST)
START             && !AnnotationUtil.containsAnnotation(grandParentAST, ""Override"")) { END 
            checkClassName(parameterDef);
        }
    }
","    private void visitParameterDef(DetailAST parameterDef) {
        final DetailAST grandParentAST = parameterDef.getParent().getParent();

        if (grandParentAST.getType() == TokenTypes.METHOD_DEF && isCheckedMethod(grandParentAST)) {
            checkClassName(parameterDef);
        }
    }
"
1466,"The implementation can just ""return false"".","	public static boolean hasPushStatusBug(int[] version) {
		int cmp = compare(version, v1_7_8_6);
		if (cmp < 0)
			return true; // Everything before 1.7.8.6 is known broken.
		else if (cmp == 0)
			return false; // 1.7.8.6 contained the bug fix.

		if (compare(version, v1_7_9) <= 0)
			return true; // 1.7.9 shipped before 1.7.8.6 and has the bug.
		return false; // 1.7.9.1 and later are fixed.
	}
","	public static boolean hasPushStatusBug(int[] version) {
START 		int cmp = compare(version, v1_7_8_6); END 
		if (cmp < 0)
			return true; // Everything before 1.7.8.6 is known broken.
		else if (cmp == 0)
			return false; // 1.7.8.6 contained the bug fix.

		if (compare(version, v1_7_9) <= 0)
			return true; // 1.7.9 shipped before 1.7.8.6 and has the bug.
		return false; // 1.7.9.1 and later are fixed.
	}
","	public static boolean hasPushStatusBug(int[] version) {
		return false;
	}
"
1467,Why removing the NPE check?,"	protected void addListeners() {
		this.resourceSetListener = new UpdateTableContentListener(getTableManager(), this);
		getTableEditingDomain().addResourceSetListener(this.resourceSetListener);
	}
","	protected void addListeners() {
		this.resourceSetListener = new UpdateTableContentListener(getTableManager(), this);
START 		getTableEditingDomain().addResourceSetListener(this.resourceSetListener); END 
	}
","	protected void addListeners() {
		this.resourceSetListener = new UpdateTableContentListener(getTableManager(), this);
		if (getTableEditingDomain() != null) {
			getTableEditingDomain().addResourceSetListener(this.resourceSetListener);
		}
	}
"
1468,Let's use multi-catch here.,"	public static ExpectedCondition<WebDriverElement> visible(final Hook hook) {
		return new ExpectedCondition<WebDriverElement>() {
			@Override
			public WebDriverElement apply(WebDriver driver) {
				try {
					WebElement element = findElement(hook, driver);
					return element.isDisplayed()? createWebDriverElement(hook, element, driver) : null;
				} catch (CandybeanException e) {
					return null;
				} catch (StaleElementReferenceException e) {
					return null;
				}
			}

			@Override
			public String toString() {
				return ""visibility of "" + hook;
			}
		};
	}
","	public static ExpectedCondition<WebDriverElement> visible(final Hook hook) {
		return new ExpectedCondition<WebDriverElement>() {
			@Override
			public WebDriverElement apply(WebDriver driver) {
				try {
					WebElement element = findElement(hook, driver);
					return element.isDisplayed()? createWebDriverElement(hook, element, driver) : null;
START 				} catch (CandybeanException e) { END 
					return null;
				} catch (StaleElementReferenceException e) {
					return null;
				}
			}

			@Override
			public String toString() {
				return ""visibility of "" + hook;
			}
		};
	}
","	public static ExpectedCondition<WebDriverElement> visible(final Hook hook) {
		return new ExpectedCondition<WebDriverElement>() {
			@Override
			public WebDriverElement apply(WebDriver driver) {
				try {
					WebElement element = findElement(hook, driver);
					return element.isDisplayed()? createWebDriverElement(hook, element, driver) : null;
				} catch (CandybeanException | StaleElementReferenceException e) {
					return null;
				}
			}

			@Override
			public String toString() {
				return ""visibility of "" + hook;
			}
		};
	}
"
1469,"Not really the fault of this PR, but it feels really weird to have everything in the Environment **except** the zk connection string","	public ApplicationListener<?> xdInitializer(ApplicationContext context) {
		XdConfigLoggingInitializer delegate = new XdConfigLoggingInitializer(true);
		delegate.setEnvironment(context.getEnvironment());
		if (zooKeeperConnection != null) {
			delegate.setZkConnectString(zooKeeperConnection.getClient().getZookeeperClient().getCurrentConnectionString());
		}
		return new SourceFilteringListener(context, delegate);
	}
","	public ApplicationListener<?> xdInitializer(ApplicationContext context) {
		XdConfigLoggingInitializer delegate = new XdConfigLoggingInitializer(true);
		delegate.setEnvironment(context.getEnvironment());
START 		if (zooKeeperConnection != null) { END 
			delegate.setZkConnectString(zooKeeperConnection.getClient().getZookeeperClient().getCurrentConnectionString());
		}
		return new SourceFilteringListener(context, delegate);
	}
","	public ApplicationListener<?> xdInitializer(ApplicationContext context) {
		XdConfigLoggingInitializer delegate = new XdConfigLoggingInitializer(true);
		delegate.setEnvironment(context.getEnvironment());
		return new SourceFilteringListener(context, delegate);
	}
"
1470,"specify array length (based on codecs.size) to optimize.
http://stackoverflow.com/a/5982478/4142153","    public String[] getCodecs() {
        return this.codecs.toArray(new String[]{});
    }
","    public String[] getCodecs() {
START         return this.codecs.toArray(new String[]{}); END 
    }
","    public String[] getCodecs() {
        return this.codecs.toArray(new String[codecs.size()]);
    }
"
1471,minor `return dateFormatter.parse(dateString).getTime()`,"  public static Long getTimeFromDateString(String dateString) {
    try {
      SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
      Date date = dateFormatter.parse(dateString);
      return date.getTime();
    } catch (ParseException e) {
      logger.warn(""Could not parse milliseconds from an HTTP date header ("" + dateString + "")."");
      return null;
    }
  }
","  public static Long getTimeFromDateString(String dateString) {
    try {
      SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
      Date date = dateFormatter.parse(dateString);
START       return date.getTime(); END 
    } catch (ParseException e) {
      logger.warn(""Could not parse milliseconds from an HTTP date header ("" + dateString + "")."");
      return null;
    }
  }
","  public static Long getTimeFromDateString(String dateString) {
    try {
      SimpleDateFormat dateFormatter = new SimpleDateFormat(HTTP_DATE_FORMAT, Locale.US);
      return dateFormatter.parse(dateString).getTime();
    } catch (ParseException e) {
      logger.warn(""Could not parse milliseconds from an HTTP date header ("" + dateString + "")."");
      return null;
    }
  }
"
1472,Please remove the `public` modifier,"		public OpaqueTokenConfigurer(ApplicationContext context) {
			this.context = context;
		}
","START 		public OpaqueTokenConfigurer(ApplicationContext context) { END 
			this.context = context;
		}
","		OpaqueTokenConfigurer(ApplicationContext context) {
			this.context = context;
		}
"
1473,"For consistency, could we use `!Objects.isNull(this.onValueInputBlur) && !Objects.isNull(target)` please?","    public void onDateInputBlur(final BlurEvent blurEvent) {

        final Object target = getEventTarget(blurEvent);
        if (this.onValueInputBlur != null && !Objects.isNull(target)) {
            onValueInputBlur.accept(blurEvent);
        }
    }
","    public void onDateInputBlur(final BlurEvent blurEvent) {

        final Object target = getEventTarget(blurEvent);
START         if (this.onValueInputBlur != null && !Objects.isNull(target)) { END 
            onValueInputBlur.accept(blurEvent);
        }
    }
","    public void onDateInputBlur(final BlurEvent blurEvent) {

        final Object target = getEventTarget(blurEvent);
        if (!Objects.isNull(onValueInputBlur) && !Objects.isNull(target)) {
            onValueInputBlur.accept(blurEvent);
        }
    }
"
1474,The new registerAt method has the same implementation as the existing registerAfter method. Possible case for reuse.,"	public void registerAt(Class<? extends Filter> filter,
			Class<? extends Filter> atFilter) {
		Integer position = getOrder(atFilter);
		if (position == null) {
			throw new IllegalArgumentException(
					""Cannot register after unregistered Filter "" + atFilter);
		}

		put(filter, position + 1);
	}
","START 	public void registerAt(Class<? extends Filter> filter, END 
			Class<? extends Filter> atFilter) {
		Integer position = getOrder(atFilter);
		if (position == null) {
			throw new IllegalArgumentException(
					""Cannot register after unregistered Filter "" + atFilter);
		}

		put(filter, position + 1);
	}
","	public void registerAt(Class<? extends Filter> filter,
			Class<? extends Filter> atFilter) {
		Integer position = getOrder(atFilter);
		if (position == null) {
			throw new IllegalArgumentException(
					""Cannot register after unregistered Filter "" + atFilter);
		}

		put(filter, position);
	}
"
1475,"Just a little otimization: if one pattern matches, you don't need to check the others. To do this, write

 if (pattern.matcher(packageName).matches())
     return true;","    public boolean matches(String packageName) {
        if (packageName == null || packageName.isEmpty()) {
            return false;
        }
        boolean result = false;
        for (Pattern pattern : patterns) {
            result |= pattern.matcher(packageName).matches();
        }
        return result;
    }
","    public boolean matches(String packageName) {
        if (packageName == null || packageName.isEmpty()) {
            return false;
        }
        boolean result = false;
        for (Pattern pattern : patterns) {
            START  result |= pattern.matcher(packageName).matches(); END 
        }
        return result;
    }
","    public boolean matches(String packageName) {
        if (StringUtils.isEmpty(packageName)) {
            return false;
        }
        for (Pattern pattern : patterns) {
            if (pattern.matcher(packageName).matches()) {
                return true;
            }
        }
        return false;
    }
"
1476,you can pass directly `map` to the `ImmutableDomainWildcardMapping` constructor (it will make the copy internally),"    public Mapping<String, V> build() {
        return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map));
    }
","    public Mapping<String, V> build() {
START         return new ImmutableDomainWildcardMapping<V>(defaultValue, new LinkedHashMap<String, V>(map)); END 
    }
","    public Mapping<String, V> build() {
        return new ImmutableDomainWildcardMapping<V>(defaultValue, map);
    }
"
1477,"```suggestion
  private static boolean isFixedWidth(ValueVector vv) {  return (vv instanceof FixedWidthVector); }
```","  static boolean isFixedWidth(ValueVector vv) {  return (vv instanceof FixedWidthVector); }
","START   static boolean isFixedWidth(ValueVector vv) {  return (vv instanceof FixedWidthVector); } END 
","  private static boolean isFixedWidth(ValueVector vv) {  return (vv instanceof FixedWidthVector); }
"
1478,"Maybe a `Mono.error` would be more proper?

Generally we would like an error early than late.","    public static Mono<byte[]> downloadFileAsync(String url, HttpPipeline httpPipeline) {
        FileService service = RestProxy.create(FileService.class, httpPipeline);
        try {
            return service.download(getHost(url), getPathAndQuery(url))
                .flatMap(response -> FluxUtil.collectBytesInByteBufferStream(response.getValue()));
        } catch (MalformedURLException ex) {
            return Mono.empty();
        }
    }
","    public static Mono<byte[]> downloadFileAsync(String url, HttpPipeline httpPipeline) {
        FileService service = RestProxy.create(FileService.class, httpPipeline);
        try {
            return service.download(getHost(url), getPathAndQuery(url))
                .flatMap(response -> FluxUtil.collectBytesInByteBufferStream(response.getValue()));
        } catch (MalformedURLException ex) {
START             return Mono.empty(); END 
        }
    }
","    public static Mono<byte[]> downloadFileAsync(String url, HttpPipeline httpPipeline) {
        FileService service = RestProxy.create(FileService.class, httpPipeline);
        try {
            return service.download(getHost(url), getPathAndQuery(url))
                .flatMap(response -> FluxUtil.collectBytesInByteBufferStream(response.getValue()));
        } catch (MalformedURLException ex) {
            return Mono.error(() -> ex);
        }
    }
"
1479,"Can you add an explicit else block

```
if (condition) {

}
else {

}
```","    public long getOldestWriteTimstamp() {
        // When there is no data in the buffer return the max possible timestamp
        // so that no query's timestamp is less than this timestamp
        if(writes.size() == 0) {
            return Long.MAX_VALUE;
        }
        Write oldestWrite = writes.get(0);
        return oldestWrite.getVersion();
    }
","    public long getOldestWriteTimstamp() {
        // When there is no data in the buffer return the max possible timestamp
        // so that no query's timestamp is less than this timestamp
        if(writes.size() == 0) {
            return Long.MAX_VALUE;
        }
START         Write oldestWrite = writes.get(0); END 
        return oldestWrite.getVersion();
    }
","    public long getOldestWriteTimstamp() {
        // When there is no data in the buffer return the max possible timestamp
        // so that no query's timestamp is less than this timestamp
        if(writes.size() == 0) {
            return Long.MAX_VALUE;
        }
        else {
            Write oldestWrite = writes.get(0);
            return oldestWrite.getVersion();
        }

    }
"
1480,We are asuming we will allways have that argument. Is that the case ?,"    private static String getAddonDirectory(List<String> arguments)
    {
        int addDirectoryIndex = arguments.indexOf(""--immutableAddonDir"") + 1;
        return arguments.get(addDirectoryIndex);
    }
","    private static String getAddonDirectory(List<String> arguments)
START     { END 
        int addDirectoryIndex = arguments.indexOf(""--immutableAddonDir"") + 1;
        return arguments.get(addDirectoryIndex);
    }
","    private static String getAddonDirectory(List<String> arguments)
    {
        int index = arguments.indexOf(""--immutableAddonDir"");
        if (index == -1) {
            return """";
        }
        return arguments.get(++index);
    }
"
1481,Are these changes relevant to this patch?,"    private void updateWatchdogModels() {
        updateWatchdogModels(getOSType().getSelectedItem());
    }
","    private void updateWatchdogModels() {
START         updateWatchdogModels(getOSType().getSelectedItem()); END 
    }
","    private void updateWatchdogModels() {
        updateWatchdogModels((Integer) getOSType().getSelectedItem());
    }
"
1482,I don't understand the purpose of local variable ele here: IMHO you can just remove this variable and the first if.,"		public ScanningMode enter(CtElement element) {
			CtElement ele = element;
			if (ele.hasParent(ignoredParent)) {
				if (element.hasParent(ignoredParent)) {
					return ScanningMode.SKIP_ALL;
				}
			}
			if (element instanceof CtType) {
				nrOfNestedLocalClasses++;
			}
			return ScanningMode.NORMAL;
		}
","		public ScanningMode enter(CtElement element) {
START 			CtElement ele = element; END 
			if (ele.hasParent(ignoredParent)) {
				if (element.hasParent(ignoredParent)) {
					return ScanningMode.SKIP_ALL;
				}
			}
			if (element instanceof CtType) {
				nrOfNestedLocalClasses++;
			}
			return ScanningMode.NORMAL;
		}
","		public ScanningMode enter(CtElement element) {
			if (element.hasParent(ignoredParent)) {
				return ScanningMode.SKIP_ALL;
			}
			if (element instanceof CtType) {
				nrOfNestedLocalClasses++;
			}
			return ScanningMode.NORMAL;
		}
"
1483,"Is this correct? When deleting a product, I would assume that this reports the parent as not interesting and we never see the file delta.","	protected boolean isInterestingFolder(IFolder folder) {
		return !findProductFiles(folder, false).isEmpty();
	}
","	protected boolean isInterestingFolder(IFolder folder) {
START 		return !findProductFiles(folder, false).isEmpty(); END 
	}
","	protected boolean isInterestingFolder(IFolder folder) {
		return true;
	}
"
1484,"This is the only place you put an ""else"" after the ""if"" returns -- for consistency, change this to not use an else statement.","    protected Short getNetworkAccessPointTypeCode(String hostAddress) {
        if (InetAddressValidator.getInstance().isValid(hostAddress)) {
            return AuditTransformConstants.NETWORK_ACCESSOR_PT_TYPE_CODE_IP;
        } else {
            return AuditTransformConstants.NETWORK_ACCESSOR_PT_TYPE_CODE_NAME;
        }
    }
","    protected Short getNetworkAccessPointTypeCode(String hostAddress) {
        if (InetAddressValidator.getInstance().isValid(hostAddress)) {
            return AuditTransformConstants.NETWORK_ACCESSOR_PT_TYPE_CODE_IP;
START         } else { END 
            return AuditTransformConstants.NETWORK_ACCESSOR_PT_TYPE_CODE_NAME;
        }
    }
","    protected Short getNetworkAccessPointTypeCode(String hostAddress) {
        if (InetAddressValidator.getInstance().isValid(hostAddress)) {
            return AuditTransformConstants.NETWORK_ACCESSOR_PT_TYPE_CODE_IP;
        }
        return AuditTransformConstants.NETWORK_ACCESSOR_PT_TYPE_CODE_NAME;

    }
"
1485,"Just wondering, does this mean we did not used to check if all the offsets actually belonged to auto-assigned partitions? Or did we just straight throw the `CommitFailedException`? Is this a behavioral change?","    public void commitAsync(final Map<TopicPartition, OffsetAndMetadata> offsets, OffsetCommitCallback callback) {
        acquireAndEnsureOpen();
        try {
            maybeThrowInvalidGroupIdException();
            maybeThrowIfCommitOffsetsNotOwned(offsets);
            log.debug(""Committing offsets: {}"", offsets);
            offsets.forEach(this::updateLastSeenEpochIfNewer);
            coordinator.commitOffsetsAsync(new HashMap<>(offsets), callback);
        } catch (CommitFailedException e) {
            log.error(""Failed to commit offsets asynchronously because they do not belong to dynamically assigned partitions"");
            callback.onComplete(offsets, e);
        } finally {
            release();
        }
    }
","    public void commitAsync(final Map<TopicPartition, OffsetAndMetadata> offsets, OffsetCommitCallback callback) {
        acquireAndEnsureOpen();
        try {
            maybeThrowInvalidGroupIdException();
            maybeThrowIfCommitOffsetsNotOwned(offsets);
            log.debug(""Committing offsets: {}"", offsets);
            offsets.forEach(this::updateLastSeenEpochIfNewer);
            coordinator.commitOffsetsAsync(new HashMap<>(offsets), callback);
        } catch (CommitFailedException e) {
START             log.error(""Failed to commit offsets asynchronously because they do not belong to dynamically assigned partitions""); END 
            callback.onComplete(offsets, e);
        } finally {
            release();
        }
    }
","    public void commitAsync(final Map<TopicPartition, OffsetAndMetadata> offsets, OffsetCommitCallback callback) {
        acquireAndEnsureOpen();
        try {
            maybeThrowInvalidGroupIdException();
            log.debug(""Committing offsets: {}"", offsets);
            offsets.forEach(this::updateLastSeenEpochIfNewer);
            coordinator.commitOffsetsAsync(new HashMap<>(offsets), callback);
        } finally {
            release();
        }
    }
"
1486,"The trace log doesn't allow you to easily see how many entries there are, so it's actually less informative than the debug log :)
Long lines in the log can also be a PITA to deal with, I would suggest logging just the number of entries at debug level and a separate line for each processed/skipped entry.","   public void applyState(XSiteState[] chunk) throws Exception {
      if (trace) {
         log.tracef(""Received state: %s"", extractKeys(chunk));
      } else if (debug) {
         log.debugf(""Received state: %s keys"", chunk.length);
      }
      if (transactionManager != null) {
         applyStateInTransaction(chunk);
      } else {
         applyStateInNonTransaction(chunk);
      }
   }
","   public void applyState(XSiteState[] chunk) throws Exception {
      if (trace) {
         log.tracef(""Received state: %s"", extractKeys(chunk));
      } else if (debug) {
START          log.debugf(""Received state: %s keys"", chunk.length); END 
      }
      if (transactionManager != null) {
         applyStateInTransaction(chunk);
      } else {
         applyStateInNonTransaction(chunk);
      }
   }
","   public void applyState(XSiteState[] chunk) throws Exception {
      if (debug) {
         log.debugf(""Received state: %s keys"", chunk.length);
      }
      if (transactionManager != null) {
         applyStateInTransaction(chunk);
      } else {
         applyStateInNonTransaction(chunk);
      }
   }
"
1487,Can we define enums for operation type,"    protected CallbackTracker(RestRequest restRequest, String operationType, Histogram operationTimeTracker,
        Histogram callbackProcessingTimeTracker) {
      this.restRequest = restRequest;
      this.operationType = operationType;
      this.operationTimeTracker = operationTimeTracker;
      this.callbackProcessingTimeTracker = callbackProcessingTimeTracker;
      blobId = RestUtils.getOperationOrBlobIdFromUri(restRequest);
    }
","    protected CallbackTracker(RestRequest restRequest, String operationType, Histogram operationTimeTracker,
        Histogram callbackProcessingTimeTracker) {
      this.restRequest = restRequest;
START       this.operationType = operationType; END 
      this.operationTimeTracker = operationTimeTracker;
      this.callbackProcessingTimeTracker = callbackProcessingTimeTracker;
      blobId = RestUtils.getOperationOrBlobIdFromUri(restRequest);
    }
","    CallbackTracker(RestRequest restRequest, String operationType, Histogram operationTimeTracker,
        Histogram callbackProcessingTimeTracker) {
      this.restRequest = restRequest;
      this.operationType = operationType;
      this.operationTimeTracker = operationTimeTracker;
      this.callbackProcessingTimeTracker = callbackProcessingTimeTracker;
      blobId = RestUtils.getOperationOrBlobIdFromUri(restRequest);
    }
"
1488,Can this move closer to the end of this method?  The app remove can happen after the shell is disposed since it's TBR is already false.,"	public void dispose() {
		app.getChildren().remove(windowModel);
		coolBarManager.dispose();
		menuManager.dispose();
		statusLineManager.dispose();
		windowModel.getContext().deactivate();
		windowModel.getContext().dispose();
		((Shell) windowModel.getWidget()).dispose();
	}
","	public void dispose() {
START 		app.getChildren().remove(windowModel); END 
		coolBarManager.dispose();
		menuManager.dispose();
		statusLineManager.dispose();
		windowModel.getContext().deactivate();
		windowModel.getContext().dispose();
		((Shell) windowModel.getWidget()).dispose();
	}
","	public void dispose() {
		coolBarManager.dispose();
		menuManager.dispose();
		statusLineManager.dispose();
		windowModel.getContext().deactivate();
		windowModel.getContext().dispose();
		((Shell) windowModel.getWidget()).dispose();
		app.getChildren().remove(windowModel);
	}
"
1489,"Nit, but
```
return metadata.getType().getMinorType() == MinorType.MAP ||
       metadata.getType().getMinorType() == MinorType.UNION ||
       metadata.getType().getMinorType() == MinorType.LIST;
```

And below.","    public boolean isComplex() {
      if (metadata.getType().getMinorType() == MinorType.MAP ||
        metadata.getType().getMinorType() == MinorType.UNION ||
        metadata.getType().getMinorType() == MinorType.LIST) {
        return true;
      }
      return false;
    }
","    public boolean isComplex() {
      if (metadata.getType().getMinorType() == MinorType.MAP ||
        metadata.getType().getMinorType() == MinorType.UNION ||
        metadata.getType().getMinorType() == MinorType.LIST) {
        return true;
      }
START       return false; END 
    }
","    public boolean isComplex() {
      return metadata.getType().getMinorType() == MinorType.MAP ||
        metadata.getType().getMinorType() == MinorType.UNION ||
        metadata.getType().getMinorType() == MinorType.LIST;
    }
"
1490,"Remove this from this list. The preferred way is to install it as part of the `ShipyardHttpApiModule`, which has already been done.","      protected Builder() {
         super(ShipyardApi.class);
         id(""shipyard"")
           .name(""Shipyard Remote Docker Management API"")
           .identityName(""<shipyard-service-key>"")
           .credentialName(""not used"")
           .documentation(URI.create(""http://shipyard-project.com/docs/api/""))
           .version(""2.0.4"")
           .defaultEndpoint(""https://127.0.0.1:8080"")
           .defaultProperties(ShipyardApiMetadata.defaultProperties())
           .defaultModules(ImmutableSet.<Class<? extends Module>>of(
                   OkHttpCommandExecutorServiceModule.class,
                   ShipyardHttpApiModule.class));
      }
","      protected Builder() {
         super(ShipyardApi.class);
         id(""shipyard"")
           .name(""Shipyard Remote Docker Management API"")
           .identityName(""<shipyard-service-key>"")
           .credentialName(""not used"")
           .documentation(URI.create(""http://shipyard-project.com/docs/api/""))
           .version(""2.0.4"")
           .defaultEndpoint(""https://127.0.0.1:8080"")
           .defaultProperties(ShipyardApiMetadata.defaultProperties())
           .defaultModules(ImmutableSet.<Class<? extends Module>>of(
START                    OkHttpCommandExecutorServiceModule.class, END 
                   ShipyardHttpApiModule.class));
      }
","      protected Builder() {
         super(ShipyardApi.class);
         id(""shipyard"")
           .name(""Shipyard Remote Docker Management API"")
           .identityName(""<shipyard-service-key>"")
           .credentialName(""not used"")
           .documentation(URI.create(""http://shipyard-project.com/docs/api/""))
           .version(""2.0.4"")
           .defaultEndpoint(""https://127.0.0.1:8080"")
           .defaultProperties(ShipyardApiMetadata.defaultProperties())
           .defaultModules(ImmutableSet.<Class<? extends Module>>of(
                   ShipyardHttpApiModule.class));
      }
"
1491,optional: import UTF_8 static,"	PrintWriter createErrorWriter() {
		return new PrintWriter(
				new OutputStreamWriter(System.err, StandardCharsets.UTF_8));
	}
","	PrintWriter createErrorWriter() {
		return new PrintWriter(
				new OutputStreamWriter(System.err, START  StandardCharsets.UTF_8)); END 
	}
","	PrintWriter createErrorWriter() {
		return new PrintWriter(new OutputStreamWriter(System.err, UTF_8));
	}
"
1492,"If we are not doing anything when file is a directory, this check is not necessary.","    public void selectAll(){
        int numberOfFiles = mAdapter.getCount();
        for(int i = 0; i < numberOfFiles; i++){
            File file = (File) mAdapter.getItem(i);
            if (file != null) {
                /// Click on a directory
                if (file.isDirectory()) {                    
                } else {    /// Click on a file
                    getListView().setItemChecked(i, true);
                       
                    // notify the change to the container Activity
                    mContainerActivity.onFileClick(file);
                }
            }
        }
    }
","    public void selectAll(){
        int numberOfFiles = mAdapter.getCount();
        for(int i = 0; i < numberOfFiles; i++){
            File file = (File) mAdapter.getItem(i);
            if (file != null) {
                /// Click on a directory
START                 if (file.isDirectory()) {                     END 
                } else {    /// Click on a file
                    getListView().setItemChecked(i, true);
                       
                    // notify the change to the container Activity
                    mContainerActivity.onFileClick(file);
                }
            }
        }
    }
","    public void selectAll(){
        int numberOfFiles = mAdapter.getCount();
        for(int i = 0; i < numberOfFiles; i++){
            File file = (File) mAdapter.getItem(i);
            if (file != null) {                
                if (!file.isDirectory()) {  
                    /// Click on a file
                    getListView().setItemChecked(i, true);                       
                    // notify the change to the container Activity
                    mContainerActivity.onFileClick(file);
                }
            }
        }
    }
"
1493,"I tend to agree, but I used the existing naming pattern. So I think either we'd fix everything, or nothing to be consistent.","        public VersionNumber getNeededDependenciesMinimumJavaVersion() {
            VersionNumber versionNumber = null;
            try {
                versionNumber = minimumJavaVersion == null ? null : new VersionNumber(minimumJavaVersion);
            } catch (NumberFormatException nfe) {
                logBadMinJavaVersion(""'minimumJavaVersion' was specified for plugin ''{0}'' but unparseable (received {1})"", this.name,
                                     minimumJavaVersion);
            }
            for (Plugin p: getNeededDependencies()) {
                VersionNumber v = p.getNeededDependenciesMinimumJavaVersion();
                if (v == null) {
                    continue;
                }
                if (versionNumber == null || v.isNewerThan(versionNumber)) {
                    versionNumber = v;
                }
            }
            return versionNumber;
        }
","START         public VersionNumber getNeededDependenciesMinimumJavaVersion() { END 
            VersionNumber versionNumber = null;
            try {
                versionNumber = minimumJavaVersion == null ? null : new VersionNumber(minimumJavaVersion);
            } catch (NumberFormatException nfe) {
                logBadMinJavaVersion(""'minimumJavaVersion' was specified for plugin ''{0}'' but unparseable (received {1})"", this.name,
                                     minimumJavaVersion);
            }
            for (Plugin p: getNeededDependencies()) {
                VersionNumber v = p.getNeededDependenciesMinimumJavaVersion();
                if (v == null) {
                    continue;
                }
                if (versionNumber == null || v.isNewerThan(versionNumber)) {
                    versionNumber = v;
                }
            }
            return versionNumber;
        }
","        public VersionNumber getNeededDependenciesMinimumJavaVersion() {
            VersionNumber versionNumber = null;
            try {
                versionNumber = minimumJavaVersion == null ? null : new VersionNumber(minimumJavaVersion);
            } catch (NumberFormatException nfe) {
                logBadMinJavaVersion();
            }
            for (Plugin p: getNeededDependencies()) {
                VersionNumber v = p.getNeededDependenciesMinimumJavaVersion();
                if (v == null) {
                    continue;
                }
                if (versionNumber == null || v.isNewerThan(versionNumber)) {
                    versionNumber = v;
                }
            }
            return versionNumber;
        }
"
1494,you could throw a ```RuntimeException``` to have a better simulation.,"      public void validate() {
         throw new CacheConfigurationException(""MODULE ERROR"");
      }
","      public void validate() {
START          throw new CacheConfigurationException(""MODULE ERROR""); END 
      }
","      public void validate() {
         throw new RuntimeException(""MODULE ERROR"");
      }
"
1495,remove empty line,"    public void addPages() {
        addPage(fSelectPage);
        addPage(fSelectDirectories);
        addPage(fScanPage);
        addPage(fImportOptions);

    }
","    public void addPages() {
        addPage(fSelectPage);
        addPage(fSelectDirectories);
        addPage(fScanPage);
        addPage(fImportOptions);
START  END 
    }
","    public void addPages() {
        addPage(fSelectPage);
        addPage(fSelectDirectories);
        addPage(fScanPage);
    }
"
1496,"You can replace by:

this((GraphicalEditPart) editPartBot.part());","    public CheckEditPartResized(SWTBotGefEditPart editPartBot) {
        this.graphicalEditPart = (GraphicalEditPart) editPartBot.part();
        this.initialSize = graphicalEditPart.getFigure().getBounds().getSize().getCopy();
    }
","    public CheckEditPartResized(SWTBotGefEditPart editPartBot) {
        START  this.graphicalEditPart = (GraphicalEditPart) editPartBot.part();
        this.initialSize = graphicalEditPart.getFigure().getBounds().getSize().getCopy(); END 
    }
","    public CheckEditPartResized(SWTBotGefEditPart editPartBot) {
        this((GraphicalEditPart) editPartBot.part());
    }
"
1497,"looks like this explicit cast was done to prevent overflow, hence I am not sure if it is safe to remove this cast

same question for the other occurrences below","	public static long getBaseSize(byte[] delta) {
		int p = 0;
		long baseLen = 0;
		int c, shift = 0;
		do {
			c = delta[p++] & 0xff;
			baseLen |= ((c & 0x7f) << shift);
			shift += 7;
		} while ((c & 0x80) != 0);
		return baseLen;
	}
","	public static long getBaseSize(byte[] delta) {
		int p = 0;
		long baseLen = 0;
		int c, shift = 0;
		do {
			c = delta[p++] & 0xff;
START 			baseLen |= ((c & 0x7f) << shift); END 
			shift += 7;
		} while ((c & 0x80) != 0);
		return baseLen;
	}
","	public static long getBaseSize(byte[] delta) {
		int p = 0;
		long baseLen = 0;
		int c, shift = 0;
		do {
			c = delta[p++] & 0xff;
			baseLen |= ((long) (c & 0x7f)) << shift;
			shift += 7;
		} while ((c & 0x80) != 0);
		return baseLen;
	}
"
1498,static import ExpressionExtractor.extractExpressionsNonRecursive,"        public Result apply(N node, Captures captures, Context context)
        {
            Map<DereferenceExpression, VariableReferenceExpression> expressions =
                    getDereferenceSymbolMap(ExpressionExtractor.extractExpressionsNonRecursive(node), context, metadata, sqlParser);

            if (expressions.isEmpty()) {
                return Result.empty();
            }

            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), rewrite(context, node, HashBiMap.create(expressions)), identityAssignmentsAsSymbolReferences(node.getOutputVariables())));
        }
","        public Result apply(N node, Captures captures, Context context)
        {
            Map<DereferenceExpression, VariableReferenceExpression> expressions =
START                     getDereferenceSymbolMap(ExpressionExtractor.extractExpressionsNonRecursive(node), context, metadata, sqlParser); END 

            if (expressions.isEmpty()) {
                return Result.empty();
            }

            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), rewrite(context, node, HashBiMap.create(expressions)), identityAssignmentsAsSymbolReferences(node.getOutputVariables())));
        }
","        public Result apply(N node, Captures captures, Context context)
        {
            Map<DereferenceExpression, VariableReferenceExpression> expressions =
                    getDereferenceSymbolMap(extractExpressionsNonRecursive(node), context, metadata, sqlParser);

            if (expressions.isEmpty()) {
                return Result.empty();
            }

            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), rewrite(context, node, HashBiMap.create(expressions)), identityAssignmentsAsSymbolReferences(node.getOutputVariables())));
        }
"
1499,"Move this call to the start of the method, since that's generally how it's done.","	protected void onResume() {
		String action = getIntent().getAction();
		if (action == null || !action.equals(""Already created"")) {
			// don't restart if action is present
			Intent intent = new Intent(this, AddBudgetActivity.class);
			startActivity(intent);
			finish();
		} else {
			// remove the unique action so the next time onResume
			// call will force restart
			getIntent().setAction(null);
		}

		super.onResume();
	}
","	protected void onResume() {
		String action = getIntent().getAction();
		if (action == null || !action.equals(""Already created"")) {
			// don't restart if action is present
			Intent intent = new Intent(this, AddBudgetActivity.class);
			startActivity(intent);
			finish();
		} else {
			// remove the unique action so the next time onResume
			// call will force restart
			getIntent().setAction(null);
		}

START 		super.onResume(); END 
	}
","	protected void onResume() {
		super.onResume();

		String action = getIntent().getAction();
		if (action == null || !action.equals(""Already created"")) {
			// don't restart if action is present
			Intent intent = new Intent(this, AddBudgetActivity.class);
			startActivity(intent);
			finish();
		} else {
			// remove the unique action so the next time onResume
			// call will force restart
			getIntent().setAction(null);
		}
	}
"
1500,"I think we want to make the string computation lazy, but not lose info. We could do that by overriding `toString`.","    public QuotaViolationException(MetricName metricName, double value, double bound) {
        super(metricName + "" violated quota."");
        this.metricName = metricName;
        this.value = value;
        this.bound = bound;
    }
","    public QuotaViolationException(MetricName metricName, double value, double bound) {
START         super(metricName + "" violated quota.""); END 
        this.metricName = metricName;
        this.value = value;
        this.bound = bound;
    }
","    public QuotaViolationException(MetricName metricName, double value, double bound) {
        this.metricName = metricName;
        this.value = value;
        this.bound = bound;
    }
"
1501,needs cloning,"	public VViewModelProperties inherit() {
		final VDefaultViewModelProperties properties = VViewFactory.eINSTANCE.createDefaultViewModelProperties();
		properties.getInheritableProperties().addAll(getInheritableProperties().entrySet());
		return properties;
	}
","	public VViewModelProperties inherit() {
		final VDefaultViewModelProperties properties = VViewFactory.eINSTANCE.createDefaultViewModelProperties();
START 		properties.getInheritableProperties().addAll(getInheritableProperties().entrySet()); END 
		return properties;
	}
","	public VViewModelProperties inherit() {
		final VDefaultViewModelProperties properties = VViewFactory.eINSTANCE.createDefaultViewModelProperties();
		for (final Entry<String, Object> entry : getInheritableProperties().entrySet()) {
			properties.getInheritableProperties().put(entry.getKey(), entry.getValue());
		}
		return properties;
	}
"
1502,sync,"    public static XmlDataProviderManager getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new XmlDataProviderManager();
        }
        return INSTANCE;
    }
","START     public static XmlDataProviderManager getInstance() { END 
        if (INSTANCE == null) {
            INSTANCE = new XmlDataProviderManager();
        }
        return INSTANCE;
    }
","    public static synchronized XmlDataProviderManager getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new XmlDataProviderManager();
        }
        return INSTANCE;
    }
"
1503,It's just a bug in the code that happens to compile and work (with a warning). I'll remove the extra one.,"    private void handleFailure(Throwable t)
    {
        if (message.doCallbackOnFailure())
        {
            MessageOut response = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE)
                                                .withParameter(ParameterType.FAILURE_RESPONSE, MessagingService.ONE_BYTE);

            if (t instanceof TombstoneOverwhelmingException)
            {
                response = response.withParameter(ParameterType.FAILURE_REASON.FAILURE_REASON, Shorts.checkedCast(RequestFailureReason.READ_TOO_MANY_TOMBSTONES.code));
            }

            MessagingService.instance().sendReply(response, id, message.from);
        }
    }
","    private void handleFailure(Throwable t)
    {
        if (message.doCallbackOnFailure())
        {
            MessageOut response = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE)
                                                .withParameter(ParameterType.FAILURE_RESPONSE, MessagingService.ONE_BYTE);

            if (t instanceof TombstoneOverwhelmingException)
            {
START                 response = response.withParameter(ParameterType.FAILURE_REASON.FAILURE_REASON, Shorts.checkedCast(RequestFailureReason.READ_TOO_MANY_TOMBSTONES.code)); END 
            }

            MessagingService.instance().sendReply(response, id, message.from);
        }
    }
","    private void handleFailure(Throwable t)
    {
        if (message.doCallbackOnFailure())
        {
            MessageOut response = new MessageOut(MessagingService.Verb.INTERNAL_RESPONSE)
                                                .withParameter(ParameterType.FAILURE_RESPONSE, MessagingService.ONE_BYTE);

            if (t instanceof TombstoneOverwhelmingException)
            {
                response = response.withParameter(ParameterType.FAILURE_REASON, Shorts.checkedCast(RequestFailureReason.READ_TOO_MANY_TOMBSTONES.code));
            }

            MessagingService.instance().sendReply(response, id, message.from);
        }
    }
"
1504,I'm surprised that getRequestParameter does not return an Optional :),"    public Optional<UsernamePasswordCredentials> extract(WebContext context) {
        final String username = context.getRequestParameter(this.usernameParameter);
        final String password = context.getRequestParameter(this.passwordParameter);
        if (username == null || password == null) {
            return Optional.empty();
        }

        return Optional.of(new UsernamePasswordCredentials(username, password));
    }
","    public Optional<UsernamePasswordCredentials> extract(WebContext context) {
START         final String username = context.getRequestParameter(this.usernameParameter); END 
        final String password = context.getRequestParameter(this.passwordParameter);
        if (username == null || password == null) {
            return Optional.empty();
        }

        return Optional.of(new UsernamePasswordCredentials(username, password));
    }
","    public Optional<UsernamePasswordCredentials> extract(WebContext context) {
        final Optional<String> username = context.getRequestParameter(this.usernameParameter);
        final Optional<String> password = context.getRequestParameter(this.passwordParameter);
        if (username.isPresent() && password.isPresent()) {
            return Optional.of(
                new UsernamePasswordCredentials(username.get(), password.get())
            );
        }
        return Optional.empty();
    }
"
1505,"This causes now editor not to open (sometimes) on BP hit if the debug view is hidden - all in a single window.

Open Java perspective, start debugging, close editor, hide view, resume after few times editor is not opened...","	public void partHidden(IWorkbenchPartReference partRef) {
		setActive(partRef, false);
	}
","	public void partHidden(IWorkbenchPartReference partRef) {
START 		setActive(partRef, END  false);
	}
","	public void partHidden(IWorkbenchPartReference partRef) {
	}
"
1506,again I don't think we should modify the generated methods. If we need to we should set this on merge.,"	public boolean isSelected() {
		if (parent != null) {
			return parent.isSelected();
		}
		return selected;
	}
","	public boolean isSelected() {
START 		if (parent != null) { END 
			return parent.isSelected();
		}
		return selected;
	}
","	public boolean isSelected() {
		return selected;
	}
"
1507,could be `final`.,"    public A value() {
      return trampoline().run();
    }
","START     public A value() { END 
      return trampoline().run();
    }
","    public final A value() {
      return trampoline().run();
    }
"
1508,operands can be directly initialized : this.leftOp = leftOp; and so only super() constructor is required.,"  private RelationalSymbolicValue(Kind kind, SymbolicValue leftOp, SymbolicValue rightOp) {
    super(leftOp, rightOp);
    this.kind = kind;
  }
","  private RelationalSymbolicValue(Kind kind, SymbolicValue leftOp, SymbolicValue rightOp) {
START     super(leftOp, rightOp); END 
    this.kind = kind;
  }
","  private RelationalSymbolicValue(Kind kind, SymbolicValue leftOp, SymbolicValue rightOp) {
    this.kind = kind;
    this.leftOp = leftOp;
    this.rightOp = rightOp;
  }
"
1509,please name all 4 loop vars either node or delta,"	private void mapNodes() {
		if (fNodesList == null) {
			fNodesMap = new HashMap<>(1);
			return;
		}
		// Create a map with capacity for all child nodes.
		fNodesMap = new HashMap<>(fNodesList.size() * 4 / 3);
		for (ModelDelta element : fNodesList) {
			mapNode( element );
		}
	}
","	private void mapNodes() {
		if (fNodesList == null) {
			fNodesMap = new HashMap<>(1);
			return;
		}
		// Create a map with capacity for all child nodes.
		fNodesMap = new HashMap<>(fNodesList.size() * 4 / 3);
		for (ModelDelta START  element : END  fNodesList) {
			mapNode( element );
		}
	}
","	private void mapNodes() {
		if (fNodesList == null) {
			fNodesMap = new HashMap<>(1);
			return;
		}
		// Create a map with capacity for all child nodes.
		fNodesMap = new HashMap<>(fNodesList.size() * 4 / 3);
		for (ModelDelta node : fNodesList) {
			mapNode( node );
		}
	}
"
1510,Please use [try-with-resources](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) statement instead of handling this manually.,"    public File generateMultipleDockets(Collection<DocketData> docketData, URI xslFileUri) throws IOException {
        ExportDocket exportDocket = new ExportDocket();

        File file = new File(""docket_multipage.pdf"");
        FileOutputStream fileOutputStream = new FileOutputStream(file);

        try {
            exportDocket.startExport(docketData, fileOutputStream, new File(xslFileUri));
        } catch (IOException e) {
            throw new IOException(e.getMessage());
        } finally {
            fileOutputStream.flush();
            fileOutputStream.close();
        }

        return file;
    }
","    public File generateMultipleDockets(Collection<DocketData> docketData, URI xslFileUri) throws IOException {
        ExportDocket exportDocket = new ExportDocket();

        File file = new File(""docket_multipage.pdf"");
        FileOutputStream fileOutputStream = new FileOutputStream(file);

START         try { END 
            exportDocket.startExport(docketData, fileOutputStream, new File(xslFileUri));
        } catch (IOException e) {
            throw new IOException(e.getMessage());
        } finally {
            fileOutputStream.flush();
            fileOutputStream.close();
        }

        return file;
    }
","    public File generateMultipleDockets(Collection<DocketData> docketData, URI xslFileUri) throws IOException {
        ExportDocket exportDocket = new ExportDocket();

        File file = new File(""docket_multipage.pdf"");

        try (FileOutputStream fileOutputStream = new FileOutputStream(file)) {
            exportDocket.startExport(docketData, fileOutputStream, new File(xslFileUri));
        } catch (IOException e) {
            throw new IOException(e.getMessage());
        }

        return file;
    }
"
1511,style nit: missing braces,"	private ContentSource source(AbstractTreeIterator iterator) {
		if (iterator instanceof WorkingTreeIterator)
			return ContentSource.create((WorkingTreeIterator) iterator);
		return ContentSource.create(db.newObjectReader());
	}
","	private ContentSource source(AbstractTreeIterator iterator) {
START 		if (iterator instanceof WorkingTreeIterator) END 
			return ContentSource.create((WorkingTreeIterator) iterator);
		return ContentSource.create(db.newObjectReader());
	}
","	private ContentSource source(AbstractTreeIterator iterator) {
		if (iterator instanceof WorkingTreeIterator) {
			return ContentSource.create((WorkingTreeIterator) iterator);
		}
		return ContentSource.create(db.newObjectReader());
	}
"
1512,No submonitor is needed in this method. The original monitor can be passed to mutually exclusive method calls as is.,"	public void copy(IFileStore destination, int options, IProgressMonitor monitor) throws CoreException {
		SubMonitor subMonitor = SubMonitor.convert(monitor, 1);
		final IFileInfo sourceInfo = fetchInfo(EFS.NONE, null);
		if (sourceInfo.isDirectory()) {
			copyDirectory(sourceInfo, destination, options, subMonitor.split(1));
		} else {
			copyFile(sourceInfo, destination, options, subMonitor.split(1));
		}
	}
","	public void copy(IFileStore destination, int options, IProgressMonitor monitor) throws CoreException {
		SubMonitor START  subMonitor = END  SubMonitor.convert(monitor, 1);
		final IFileInfo sourceInfo = fetchInfo(EFS.NONE, null);
		if (sourceInfo.isDirectory()) {
			copyDirectory(sourceInfo, destination, options, subMonitor.split(1));
		} else {
			copyFile(sourceInfo, destination, options, subMonitor.split(1));
		}
	}
","	public void copy(IFileStore destination, int options, IProgressMonitor monitor) throws CoreException {
		final IFileInfo sourceInfo = fetchInfo(EFS.NONE, null);
		if (sourceInfo.isDirectory()) {
			copyDirectory(sourceInfo, destination, options, monitor);
		} else {
			copyFile(sourceInfo, destination, options, monitor);
		}
	}
"
1513,I think you meant to have brackets encapsulate the entire rest of the method?,"   public void stopTransport() {
      if (transport != null && transportStatus == ComponentStatus.RUNNING)
         transport.stop();
         transportStatus = ComponentStatus.TERMINATED;
      try {
         unregisterServerMBeans();
      } catch (Exception e) {
         throw new CacheException(e);
      }
   }
","   public void stopTransport() {
      if (transport != null && transportStatus == ComponentStatus.RUNNING)
START          transport.stop(); END 
         transportStatus = ComponentStatus.TERMINATED;
      try {
         unregisterServerMBeans();
      } catch (Exception e) {
         throw new CacheException(e);
      }
   }
","   public void stopTransport() {
      if (transport != null && transportStatus == ComponentStatus.RUNNING) {
         transport.stop();
         transportStatus = ComponentStatus.TERMINATED;
         try {
            unregisterServerMBeans();
         } catch (Exception e) {
            throw new CacheException(e);
         }
      }
   }
"
1514,"In this case jadx replace `continue` with `else` and I think this is correct change. Anyway, jadx don't have any information to restore such code.
Or I miss something?

P.S. Next time for complex code write `check` method to check that method logic not changed after transformations during decompilation (as example see [`TestSwitchWithFallThroughCase`](https://github.com/skylot/jadx/blob/e1f4955286f73a6ca4525fc27b11fd02106f7f08/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchWithFallThroughCase.java#L44) test) because sometimes code changed heavily but logic is preserved and is hard to check such case with ""eye"".","	public void test43() throws Exception {
		ClassNode cls = getClassNode(TestCls.class);
		String code = cls.getCode().toString();

		assertThat(code, containsOne(""continue;""));
	}
","	public void test43() throws Exception {
		ClassNode cls = getClassNode(TestCls.class);
		String code = cls.getCode().toString();

START 		assertThat(code, containsOne(""continue;"")); END 
	}
","	public void test43() throws Exception {
		getClassNode(TestCls.class);
	}
"
1515,`Collections#unmodifiableList` could be better there.,"    public List<DocumentType> getSpecialDocumentTypes() {
        checkDirty();
        return specialDocumentTypes.values().stream().collect(Collectors.toList());
    }
","    public List<DocumentType> getSpecialDocumentTypes() {
        checkDirty();
START         return specialDocumentTypes.values().stream().collect(Collectors.toList()); END 
    }
","    public Set<String> getSpecialDocumentTypes() {
        checkDirty();
        return specialDocumentTypes;
    }
"
1516,"Is it worth extending this timeout?  AFIACT it won't effect the correct working of the latch, but could prevent issues if the tests are running on an especially slow device/simulator.","        public void postReport(String urlString,
                               Report report,
                               Map<String, String> headers)
            throws NetworkException, BadResponseException {
            try {
                nullCheckLatch.await(20, TimeUnit.MILLISECONDS);
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
            super.postReport(urlString, report, headers);
        }
","        public void postReport(String urlString,
                               Report report,
                               Map<String, String> headers)
            throws NetworkException, BadResponseException {
            try {
START                 nullCheckLatch.await(20, TimeUnit.MILLISECONDS); END 
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
            super.postReport(urlString, report, headers);
        }
","        public void postReport(String urlString,
                               Report report,
                               Map<String, String> headers)
            throws NetworkException, BadResponseException {
            try {
                nullCheckLatch.await(100, TimeUnit.MILLISECONDS);
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
            super.postReport(urlString, report, headers);
        }
"
1517,this method can be non-static and private - it isn't used outside of the class,"    public static String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
        return composeObjectId(logable, logType, logable.getUserId());
    }
","    START  public static String END  composeObjectId(AuditLogableBase logable, AuditLogType logType) {
        return composeObjectId(logable, logType, logable.getUserId());
    }
","    private String composeObjectId(AuditLogableBase logable, AuditLogType logType) {
        return composeObjectId(logable, logType, logable.getUserId());
    }
"
1518,you can remove by seq... no?,"    private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
        AcctUtils.reportRecords(reason,
                getPrincipalName(sessionId),
                (ExtMap) getData(sessionId, AUTH_RECORD_PARAMETER_NAME, false),
                (ExtMap) getData(sessionId, PRINCIPAL_RECORD_PARAMETER_NAME, false),
                message,
                msgArgs
                );
        sessionInfoMap.remove(sessionId);
        getDbFacade().getEngineSessionDao().removeBySessionId(sessionId);
    }
","    private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
        AcctUtils.reportRecords(reason,
                getPrincipalName(sessionId),
                (ExtMap) getData(sessionId, AUTH_RECORD_PARAMETER_NAME, false),
                (ExtMap) getData(sessionId, PRINCIPAL_RECORD_PARAMETER_NAME, false),
                message,
                msgArgs
                );
        sessionInfoMap.remove(sessionId);
START         getDbFacade().getEngineSessionDao().removeBySessionId(sessionId); END 
    }
","    private void removeSessionImpl(String sessionId, int reason, String message, Object... msgArgs) {
        AcctUtils.reportRecords(reason,
                getPrincipalName(sessionId),
                (ExtMap) getData(sessionId, AUTH_RECORD_PARAMETER_NAME, false),
                (ExtMap) getData(sessionId, PRINCIPAL_RECORD_PARAMETER_NAME, false),
                message,
                msgArgs
                );
        getDbFacade().getEngineSessionDao().removeBySessionId(sessionId);
        sessionInfoMap.remove(sessionId);
    }
"
1519,"The `temporalValidationTolerance` cannot be null either (and you don't have the null check in the `equals()` method anyway).

Will change.","	private int createHashCode() {
		int result = System.identityHashCode( scriptEvaluatorFactory );
		result = 31 * result + System.identityHashCode( clockProvider );
		result = 31 * result + ( temporalValidationTolerance != null ? temporalValidationTolerance.hashCode() : 0 );
		result = 31 * result + System.identityHashCode( constraintValidatorPayload );
		return result;
	}
","	private int createHashCode() {
		int result = System.identityHashCode( scriptEvaluatorFactory );
		result = 31 * result + System.identityHashCode( clockProvider );
START 		result = 31 * result + ( temporalValidationTolerance != null ? temporalValidationTolerance.hashCode() : 0 ); END 
		result = 31 * result + System.identityHashCode( constraintValidatorPayload );
		return result;
	}
","	private int createHashCode() {
		int result = System.identityHashCode( scriptEvaluatorFactory );
		result = 31 * result + System.identityHashCode( clockProvider );
		result = 31 * result + temporalValidationTolerance.hashCode();
		result = 31 * result + System.identityHashCode( constraintValidatorPayload );
		return result;
	}
"
1520,"I suspect this code is unused (or maybe lightly used) or else someone would have complained by now that it doesn't work when you only have one processor. It should be `max(1, Runtime.getRuntime().availableProcessors() - 1)`.","  public int getNumThreads()
  {
    int numThreadsConfigured = getNumThreadsConfigured();
    if (numThreadsConfigured != DEFAULT_NUM_THREADS) {
      return numThreadsConfigured;
    } else {
      return Runtime.getRuntime().availableProcessors() - 1;
    }
  }
","  public int getNumThreads()
  {
    int numThreadsConfigured = getNumThreadsConfigured();
    if (numThreadsConfigured != DEFAULT_NUM_THREADS) {
      return numThreadsConfigured;
    } else {
START       return Runtime.getRuntime().availableProcessors() - 1; END 
    }
  }
","  public int getNumThreads()
  {
    int numThreadsConfigured = getNumThreadsConfigured();
    if (numThreadsConfigured != DEFAULT_NUM_THREADS) {
      return numThreadsConfigured;
    } else {
      return Math.max(Runtime.getRuntime().availableProcessors() - 1, 1);
    }
  }
"
1521,If it shouldn't be possible to store an Application without a slug then this abstract implementation should have control over it and not rely on an implementation calling this method.,"    protected String generateSlug(Id id) {
        return ""app-"" + idCodec.encode(id.toBigInteger());
    }
","START     protected String generateSlug(Id id) { END 
        return ""app-"" + idCodec.encode(id.toBigInteger());
    }
","    private String generateSlug(Id id) {
        return ""app-"" + idCodec.encode(id.toBigInteger());
    }
"
1522,"Invoking `setRetainInstance(true)` on a fragment with UI is quite risky (we might/will leak all the views), do we really need it? Moreover, `SignupBottomSheetDialogFragment` currently holds a reference to the Activity, which will also leak after a configuration change. Wdyt?","    public Dialog onCreateDialog(Bundle savedInstanceState) {
        setRetainInstance(true);
        return new BottomSheetDialog(requireContext(), getTheme());
    }
","    public Dialog onCreateDialog(Bundle savedInstanceState) {
START         setRetainInstance(true); END 
        return new BottomSheetDialog(requireContext(), getTheme());
    }
","    public Dialog onCreateDialog(Bundle savedInstanceState) {
        return new BottomSheetDialog(requireContext(), getTheme());
    }
"
1523,Redundant instanceof and casts,"  public boolean onBlockStartBreak(ItemStack stack, BlockPos pos, EntityPlayer player) {
    if(!ToolHelper.isBroken(stack) && this instanceof IAoeTool && ((IAoeTool) this).isAoeHarvestTool()) {
      for(BlockPos extraPos : ((IAoeTool) this).getAOEBlocks(stack, player.worldObj, player, pos)) {
        breakBlock(stack, player, extraPos, pos);
      }
    }

    return super.onBlockStartBreak(stack, pos, player);
  }
","  public boolean onBlockStartBreak(ItemStack stack, BlockPos pos, EntityPlayer player) {
START     if(!ToolHelper.isBroken(stack) && this instanceof IAoeTool && ((IAoeTool) this).isAoeHarvestTool()) { END 
      for(BlockPos extraPos : ((IAoeTool) this).getAOEBlocks(stack, player.worldObj, player, pos)) {
        breakBlock(stack, player, extraPos, pos);
      }
    }

    return super.onBlockStartBreak(stack, pos, player);
  }
","  public boolean onBlockStartBreak(ItemStack stack, BlockPos pos, EntityPlayer player) {
    if(!ToolHelper.isBroken(stack) && this.isAoeHarvestTool()) {
      for(BlockPos extraPos : ((IAoeTool) this).getAOEBlocks(stack, player.worldObj, player, pos)) {
        breakBlock(stack, player, extraPos, pos);
      }
    }

    return super.onBlockStartBreak(stack, pos, player);
  }
"
1524,Should subclasses be allowed to override this method?,"  protected void setRefLogIdent(final PatchSetApproval submitAudit) {
    if (submitAudit != null) {
      branchUpdate.setRefLogIdent(mArguments.identifiedUserFactory.create(
          submitAudit.getAccountId()).newRefLogIdent());
    }
  }
","START   protected void setRefLogIdent(final PatchSetApproval submitAudit) { END 
    if (submitAudit != null) {
      branchUpdate.setRefLogIdent(mArguments.identifiedUserFactory.create(
          submitAudit.getAccountId()).newRefLogIdent());
    }
  }
","  protected final void setRefLogIdent(final PatchSetApproval submitAudit) {
    if (submitAudit != null) {
      branchUpdate.setRefLogIdent(mArguments.identifiedUserFactory.create(
          submitAudit.getAccountId()).newRefLogIdent());
    }
  }
"
1525,mag 1 try weg?,"	public PipeRunResult doPipe(Message message, IPipeLineSession session) throws PipeRunException {
		try {
			try (MessageOutputStream target=MessageOutputStream.getTargetStream(this, session, getNextPipe())) {
				try (OutputStream out = target.asStream()) {
					pgpAction.run(message.asInputStream(), out);
				}
				return target.getPipeRunResult();
			}
		} catch (Exception e) {
			throw new PipeRunException(this, ""Exception was thrown during PGPPipe execution."", e);
		}
	}
","	public PipeRunResult doPipe(Message message, IPipeLineSession session) throws PipeRunException {
START 		try {
			try (MessageOutputStream target=MessageOutputStream.getTargetStream(this, session, getNextPipe())) {
				try (OutputStream out = target.asStream()) { END 
					pgpAction.run(message.asInputStream(), out);
				}
				return target.getPipeRunResult();
			}
		} catch (Exception e) {
			throw new PipeRunException(this, ""Exception was thrown during PGPPipe execution."", e);
		}
	}
","	public PipeRunResult doPipe(Message message, IPipeLineSession session) throws PipeRunException {
		try (MessageOutputStream target=MessageOutputStream.getTargetStream(this, session, getNextPipe())) {
			try (OutputStream out = target.asStream()) {
				pgpAction.run(message.asInputStream(), out);
			}
			return target.getPipeRunResult();
		} catch (Exception e) {
			throw new PipeRunException(this, ""Exception was thrown during PGPPipe execution."", e);
		}
	}
"
1526,"it seems using `&&` is more in line with existing coding pattern, though minor.","	public void saveRevisionData(Session session, Object revisionData) {
		session.save( revisionInfoEntityName, revisionData );
		if ( revisionInfoNumberReader != null ) {
			if ( revisionInfoNumberReader.getRevisionNumber( revisionData ).longValue() < 0 ) {
				throw new AuditException( ""Negative revision numbers are not allowed"" );
			}
		}
		sessionCacheCleaner.scheduleAuditDataRemoval( session, revisionData );
	}
","	public void saveRevisionData(Session session, Object revisionData) {
		session.save( revisionInfoEntityName, revisionData );
		if ( revisionInfoNumberReader != null ) {
START 			if ( revisionInfoNumberReader.getRevisionNumber( revisionData ).longValue() < 0 ) { END 
				throw new AuditException( ""Negative revision numbers are not allowed"" );
			}
		}
		sessionCacheCleaner.scheduleAuditDataRemoval( session, revisionData );
	}
","	public void saveRevisionData(Session session, Object revisionData) {
		session.save( revisionInfoEntityName, revisionData );
		if ( revisionInfoNumberReader != null && revisionInfoNumberReader.getRevisionNumber( revisionData ).longValue() < 0 ) {
			throw new AuditException( ""Negative revision numbers are not allowed"" );
		}
		sessionCacheCleaner.scheduleAuditDataRemoval( session, revisionData );
	}
"
1527,"Using `false` is enough here, without constant","  private static boolean isRootPrivate(Component root, Map<String, ComponentDto> existingDtosByKeys) {
    String rootKey = root.getKey();
    ComponentDto rootDto = existingDtosByKeys.get(rootKey);
    if (rootDto == null) {
      if (Component.Type.VIEW == root.getType()) {
        return NEW_VIEWS_SHOULD_BE_PRIVATE;
      }
      throw new IllegalStateException(String.format(""The project '%s' is not stored in the database, during a project analysis."", rootKey));
    }
    return rootDto.isPrivate();
  }
","  private static boolean isRootPrivate(Component root, Map<String, ComponentDto> existingDtosByKeys) {
    String rootKey = root.getKey();
    ComponentDto rootDto = existingDtosByKeys.get(rootKey);
    if (rootDto == null) {
      if (Component.Type.VIEW == root.getType()) {
START         return NEW_VIEWS_SHOULD_BE_PRIVATE; END 
      }
      throw new IllegalStateException(String.format(""The project '%s' is not stored in the database, during a project analysis."", rootKey));
    }
    return rootDto.isPrivate();
  }
","  private static boolean isRootPrivate(Component root, Map<String, ComponentDto> existingDtosByKeys) {
    String rootKey = root.getKey();
    ComponentDto rootDto = existingDtosByKeys.get(rootKey);
    if (rootDto == null) {
      if (Component.Type.VIEW == root.getType()) {
        return false;
      }
      throw new IllegalStateException(String.format(""The project '%s' is not stored in the database, during a project analysis."", rootKey));
    }
    return rootDto.isPrivate();
  }
"
1528,"I might be missing something, but it seems that this method doesn't throws a SAXException. Perhaps it should ""throw e"" at the end?","        public void error(SAXParseException e) throws SAXException {
            if (firstException == null) {
                firstException = e;
                messageBuffer = new StringBuilder(64);
                messageBuffer.append('\'').append(resourceId).append('\'').append(""' validation error:"");
            }
            messageBuffer.append('\n').append(e.toString());
        }
","START         public void error(SAXParseException e) throws SAXException { END 
            if (firstException == null) {
                firstException = e;
                messageBuffer = new StringBuilder(64);
                messageBuffer.append('\'').append(resourceId).append('\'').append(""' validation error:"");
            }
            messageBuffer.append('\n').append(e.toString());
        }
","        public void error(SAXParseException e) {
            if (firstException == null) {
                firstException = e;
                messageBuffer = new StringBuilder(64);
                messageBuffer.append('\'').append(resourceId).append('\'').append(""' validation error:"");
            }
            messageBuffer.append('\n').append(e.toString());
        }
"
1529,"Shouldn't this be `trackAnalyticsSignIn(true)`? I believe the flag is meant to identify self-hosted vs WP.com logins, and WP.com signups should count as the latter.","    public void onGoogleSignupFinished(String name, String email, String photoUrl, String username) {
        AnalyticsTracker.track(AnalyticsTracker.Stat.SIGNUP_SOCIAL_SUCCESS);
        mLoginAnalyticsListener.trackAnalyticsSignIn(false);
        if (mIsJetpackConnect) {
            ActivityLauncher.showSignupEpilogueForResult(this, name, email, photoUrl, username, false);
        } else {
            ActivityLauncher.showMainActivityAndSignupEpilogue(this, name, email, photoUrl, username);
        }

        setResult(Activity.RESULT_OK);
        finish();
    }
","    public void onGoogleSignupFinished(String name, String email, String photoUrl, String username) {
        AnalyticsTracker.track(AnalyticsTracker.Stat.SIGNUP_SOCIAL_SUCCESS);
START         mLoginAnalyticsListener.trackAnalyticsSignIn(false); END 
        if (mIsJetpackConnect) {
            ActivityLauncher.showSignupEpilogueForResult(this, name, email, photoUrl, username, false);
        } else {
            ActivityLauncher.showMainActivityAndSignupEpilogue(this, name, email, photoUrl, username);
        }

        setResult(Activity.RESULT_OK);
        finish();
    }
","    public void onGoogleSignupFinished(String name, String email, String photoUrl, String username) {
        AnalyticsTracker.track(AnalyticsTracker.Stat.SIGNUP_SOCIAL_SUCCESS);
        if (mIsJetpackConnect) {
            ActivityLauncher.showSignupEpilogueForResult(this, name, email, photoUrl, username, false);
        } else {
            ActivityLauncher.showMainActivityAndSignupEpilogue(this, name, email, photoUrl, username);
        }

        setResult(Activity.RESULT_OK);
        finish();
    }
"
1530,warning: The static field AbstractProcessor.logger should be accessed in a static way.,"    protected void log(final Level level, final String msg, final Throwable t) {
        this.logger.log(level, this.simpleName + "" "" + msg, t);
    }
","    protected void log(final Level level, final String msg, final Throwable t) {
START         this.logger.log(level, this.simpleName + "" "" + msg, t); END 
    }
","    protected void log(final Level level, final String msg, final Throwable t) {
        this.LOGGER.log(level, this.simpleName + "" "" + msg, t);
    }
"
1531,minor: make it static,"  private short[] toShortArray(int[] ints) {
    if (ints == null) {
      return null;
    }
    short[] shorts = new short[ints.length];
    for (int i = 0; i < shorts.length; i++) {
      shorts[i] = toShort(ints[i]);
    }
    return shorts;
  }
","START   private short[] toShortArray(int[] ints) { END 
    if (ints == null) {
      return null;
    }
    short[] shorts = new short[ints.length];
    for (int i = 0; i < shorts.length; i++) {
      shorts[i] = toShort(ints[i]);
    }
    return shorts;
  }
","  private static short[] toShortArray(int[] ints) {
    if (ints == null) {
      return null;
    }
    short[] shorts = new short[ints.length];
    for (int i = 0; i < shorts.length; i++) {
      shorts[i] = toShort(ints[i]);
    }
    return shorts;
  }
"
1532,ここは、`questionList.addAll(questions);`と書くとすっきりしますね。,"        protected void onSuccess(List<Question> questions) {

            if (questions == null) {
                showAlert(""GetQuestion"", ""質問がありません。"");
            } else {
                for (Question q : questions) {
                    questionList.add(q);
                }
            }
            // スクロールを確認するため追加
            for (int i = 0; i < 20; i++)
                questionList.add(new Question(""タイトル"" + i, ""本文"" + i, ""作者"" + i));

            adapter.notifyDataSetChanged();
        }
","        protected void onSuccess(List<Question> questions) {

            if (questions == null) {
                showAlert(""GetQuestion"", ""質問がありません。"");
            } else {
START                 for (Question q : questions) { END 
                    questionList.add(q);
                }
            }
            // スクロールを確認するため追加
            for (int i = 0; i < 20; i++)
                questionList.add(new Question(""タイトル"" + i, ""本文"" + i, ""作者"" + i));

            adapter.notifyDataSetChanged();
        }
","        protected void onSuccess(List<Question> questions) {

            if (questions == null) {
                showAlert(""GetQuestion"", ""質問がありません。"");
            } else {
                adapter.clear();
                // Robolectric does not implement addAll,
                // so we use add method and a loop instead for the time being.
                // https://github.com/pivotal/robolectric/issues/281
                for (Question q : questions) {
                    adapter.add(q);
                }
                adapter.notifyDataSetChanged();
            }
        }
"
1533,"Nit picking, but we don't need the extra brackets. Let's just keep: 
```
kind =  ""desc"".equalsIgnoreCase( order ) ? Order.DESC : Order.ASC;
```","	public AssociationOrderBy(String expression, String order) {
		columnName = expression.substring( 1, expression.length() - 1 );
		kind = ( ""desc"".equalsIgnoreCase( order ) ) ? Order.DESC : Order.ASC;
	}
","	public AssociationOrderBy(String expression, String order) {
		columnName = expression.substring( 1, expression.length() - 1 );
START 		kind = ( ""desc"".equalsIgnoreCase( order ) ) ? Order.DESC : Order.ASC; END 
	}
","	public AssociationOrderBy(String expression, String order) {
		// extract column name from {} expression, such as ""{columnName}""
		columnName = expression.substring( 1, expression.length() - 1 );
		kind = ""desc"".equalsIgnoreCase( order ) ? Order.DESC : Order.ASC;
	}
"
1534,"nulls should be allowed if filter is non-deterministic; consider adding a test that uses `array(real)` to test this

`nullsAllowed = this.filter == null || nonDeterministicFilter || this.filter.testNull();`","    public FloatSelectiveStreamReader(
            StreamDescriptor streamDescriptor,
            Optional<TupleDomainFilter> filter,
            boolean outputRequired,
            LocalMemoryContext systemMemoryContext)
    {
        this.streamDescriptor = requireNonNull(streamDescriptor, ""streamDescriptor is null"");
        this.filter = filter.orElse(null);
        this.outputRequired = outputRequired;
        this.systemMemoryContext = requireNonNull(systemMemoryContext, ""systemMemoryContext is null"");
        this.nonDeterministicFilter = this.filter != null && !this.filter.isDeterministic();
        this.nullsAllowed = this.filter == null || this.filter.testNull();
    }
","    public FloatSelectiveStreamReader(
            StreamDescriptor streamDescriptor,
            Optional<TupleDomainFilter> filter,
            boolean outputRequired,
            LocalMemoryContext systemMemoryContext)
    {
        this.streamDescriptor = requireNonNull(streamDescriptor, ""streamDescriptor is null"");
        this.filter = filter.orElse(null);
        this.outputRequired = outputRequired;
        this.systemMemoryContext = requireNonNull(systemMemoryContext, ""systemMemoryContext is null"");
        this.nonDeterministicFilter = this.filter != null && !this.filter.isDeterministic();
START         this.nullsAllowed = this.filter == null || this.filter.testNull(); END 
    }
","    public FloatSelectiveStreamReader(
            StreamDescriptor streamDescriptor,
            Optional<TupleDomainFilter> filter,
            boolean outputRequired,
            LocalMemoryContext systemMemoryContext)
    {
        this.streamDescriptor = requireNonNull(streamDescriptor, ""streamDescriptor is null"");
        this.filter = filter.orElse(null);
        this.outputRequired = outputRequired;
        this.systemMemoryContext = requireNonNull(systemMemoryContext, ""systemMemoryContext is null"");
        this.nonDeterministicFilter = this.filter != null && !this.filter.isDeterministic();
        this.nullsAllowed = this.filter == null || nonDeterministicFilter || this.filter.testNull();
    }
"
1535,"We need to clear the collection here if the inbound collection is null. Can probably just drop the entire thing down to single line:
```
this.providedProducts = providedProducts != null ? new HashSet<>(providedProducts) : null;
```","    public void setProvidedProducts(Collection<Product> providedProducts) {
        this.providedProductDtos = null;

        if (providedProducts != null) {
            this.providedProducts = new HashSet<>(providedProducts);
        }
    }
","    public void setProvidedProducts(Collection<Product> providedProducts) {
        this.providedProductDtos = null;

        if (providedProducts != null) {
START             this.providedProducts = new HashSet<>(providedProducts); END 
        }
    }
","    public void setProvidedProducts(Collection<Product> providedProducts) {
        this.providedProductDtos = null;

        if (providedProducts != null) {
            this.providedProducts = new HashSet<>(providedProducts);
        }
        else {
            this.providedProducts = new HashSet<>();
        }
    }
"
1536,"The changes make this line relevant only for AddNetworkCommand.
Please remove it and modify: 

  AddNetworkCommand.getPermissionCheckSubjects() to use getNetwork() instead in a safe way.

It can come as a follower patch.","    public NetworkCommon(T parameters) {
        super(parameters);
        this.setStoragePoolId(getNetwork().getDataCenterId());
    }
","    public NetworkCommon(T parameters) {
        super(parameters);
START         this.setStoragePoolId(getNetwork().getDataCenterId()); END 
    }
","    public NetworkCommon(T parameters) {
        super(parameters);
    }
"
1537,you need to close this directory stream,"    private Collection<File> transactionFiles( File dbLocation ) throws IOException
    {
        Collection<File> txFiles = new ArrayList<>();
        DirectoryStream<Path> dirStream = Files.newDirectoryStream( dbLocation.toPath(), ""neostore.transaction.db.*"" );
        dirStream.forEach( path -> txFiles.add( path.toFile() ) );
        return txFiles;
    }
","    private Collection<File> transactionFiles( File dbLocation ) throws IOException
    {
        Collection<File> txFiles = new ArrayList<>();
START         DirectoryStream<Path> dirStream = Files.newDirectoryStream( dbLocation.toPath(), ""neostore.transaction.db.*"" ); END 
        dirStream.forEach( path -> txFiles.add( path.toFile() ) );
        return txFiles;
    }
","    private Collection<File> transactionFiles( File dbLocation ) throws IOException
    {
        Collection<File> txFiles = new ArrayList<>();
        DirectoryStream<Path> dirStream = Files.newDirectoryStream( dbLocation.toPath(), ""neostore.transaction.db.*"" );
        dirStream.forEach( path -> txFiles.add( path.toFile() ) );
        dirStream.close();
        return txFiles;
    }
"
1538,url should be checked for null.,"	private String getBundleVersion() {
		ClassLoader cl = getClass().getClassLoader();
		if (cl instanceof URLClassLoader) {
			URL url = ((URLClassLoader) cl).findResource(JarFile.MANIFEST_NAME);
			try {
				Manifest manifest = new Manifest(url.openStream());
				return manifest.getMainAttributes().getValue(""Bundle-Version"");
			} catch (IOException e) {
				// do nothing - will return null
			}
		}
		return null;
	}
","	private String getBundleVersion() {
		ClassLoader cl = getClass().getClassLoader();
		if (cl instanceof URLClassLoader) {
START 			URL url = ((URLClassLoader) cl).findResource(JarFile.MANIFEST_NAME); END 
			try {
				Manifest manifest = new Manifest(url.openStream());
				return manifest.getMainAttributes().getValue(""Bundle-Version"");
			} catch (IOException e) {
				// do nothing - will return null
			}
		}
		return null;
	}
","	private String getBundleVersion() {
		ClassLoader cl = getClass().getClassLoader();
		if (cl instanceof URLClassLoader) {
			URL url = ((URLClassLoader) cl).findResource(JarFile.MANIFEST_NAME);
			if (url != null)
				return getBundleVersion(url);
		}
		return null;
	}
"
1539,"Do it simpler:

``` java
bind(OkHttpClientSupplier.class).to(DockerOkHttpClientSupplier.class);
```","   protected void configure() {
      super.configure();
      install(new OkHttpCommandExecutorServiceModule());
      bind(new TypeLiteral<Supplier<SSLContext>>() {
      }).to(new TypeLiteral<SSLContextWithKeysSupplier>() {
      });
      bind(OkHttpClientSupplier.class).to(new TypeLiteral<DockerOkHttpClientSupplier>() {});
   }
","   protected void configure() {
      super.configure();
      install(new OkHttpCommandExecutorServiceModule());
      bind(new TypeLiteral<Supplier<SSLContext>>() {
      }).to(new TypeLiteral<SSLContextWithKeysSupplier>() {
      });
START       bind(OkHttpClientSupplier.class).to(new TypeLiteral<DockerOkHttpClientSupplier>() {}); END 
   }
","   protected void configure() {
      super.configure();
      install(new OkHttpCommandExecutorServiceModule());
      bind(OkHttpClientSupplier.class).to(DockerOkHttpClientSupplier.class);
   }
"
1540,"If this is done for every test case, why not just do in in the MockConfigRule's constructor in line 33?","    public void setupEnvironment() {
        CorrelationIdTracker.clean();
        DbUser user = mock(DbUser.class);

        when(engineSessionDao.remove(anyLong())).thenReturn(1);
        mcr.mockConfigValue(ConfigValues.UserSessionTimeOutInterval, 30);
        sessionDataContainer.setUser(session, user);
    }
","    public void setupEnvironment() {
        CorrelationIdTracker.clean();
        DbUser user = mock(DbUser.class);

        when(engineSessionDao.remove(anyLong())).thenReturn(1);
        START  mcr.mockConfigValue(ConfigValues.UserSessionTimeOutInterval, 30); END 
        sessionDataContainer.setUser(session, user);
    }
","    public void setupEnvironment() {
        CorrelationIdTracker.clean();
        DbUser user = mock(DbUser.class);

        when(engineSessionDao.remove(anyLong())).thenReturn(1);
        sessionDataContainer.setUser(session, user);
    }
"
1541,Useless statement.,"    public void clear() {
        commands.clear();
        ;
        items.clear();
        getView().clear();
    }
","    public void clear() {
        commands.clear();
START         ; END 
        items.clear();
        getView().clear();
    }
","    public void clear() {
        commands.clear();
        items.clear();
        getView().clear();
    }
"
1542,"I'd write:

`this.nearClip = nearClip`

And I'd use the same also in the following method. Or did you get a checkstyle warning about it?","    public void setNearClip(float nearClipIn) {
        nearClip = nearClipIn;
    }
","    public void setNearClip(float nearClipIn) {
START         nearClip = nearClipIn; END 
    }
","    public void setNearClip(float nearClipIn) {
        this.nearClip = nearClipIn;
    }
"
1543,"Oh i see!
If it is only used for testing purposes and hence in src/test, then you are correct to have it stay. 👍","	public void scheduleTask(TaskDefinition task) throws SchedulerException {
		boolean contains = false;
		for (String taskDef : scheduledTasks) {
			if (taskDef.equals(task.getName())) {
				contains = true;
				break;
			}
		}
		if (!contains) {
			scheduledTasks.add(task.getName());
		}
	}
","	public void scheduleTask(TaskDefinition task) throws SchedulerException {
		boolean contains = false;
START 		for (String taskDef : scheduledTasks) { END 
			if (taskDef.equals(task.getName())) {
				contains = true;
				break;
			}
		}
		if (!contains) {
			scheduledTasks.add(task.getName());
		}
	}
","	public void scheduleTask(TaskDefinition task) throws SchedulerException {
		if (!scheduledTasks.contains(task)) {
			scheduledTasks.add(task);
		}
	}
"
1544,"I would use the showUnderline in the setter instead of the getter.

Now each time getValue is called, it has to evaluate the template. If you do that in the setter, then the value is always the underlined version and the evaluation only happens once.","    public SafeHtml getValue() {
        if (showUnderline) {
            return templates.underlinedHeader(headerText);
        }
        return headerText;
    }
","    public SafeHtml getValue() {
START         if (showUnderline) { END 
            return templates.underlinedHeader(headerText);
        }
        return headerText;
    }
","    public SafeHtml getValue() {
        return headerText;
    }
"
1545,"Should this be

  if (!Strings.isNullOrEmpty(link)) {

?","  private String resolveUrl(URI uri, String link) {
    String url = cfg.getString(""gerrit"", null, ""canonicalWebUrl"");
    if (Strings.isNullOrEmpty(url)) {
      url = uri.toString();
    }
    if (!url.endsWith(""/"")) {
      url += ""/"";
    }
    if (Strings.isNullOrEmpty(link)) {
      url += ""#"" + link;
    }
    return url;
  }
","  private String resolveUrl(URI uri, String link) {
    String url = cfg.getString(""gerrit"", null, ""canonicalWebUrl"");
    if (Strings.isNullOrEmpty(url)) {
      url = uri.toString();
    }
    if (!url.endsWith(""/"")) {
      url += ""/"";
    }
START     if (Strings.isNullOrEmpty(link)) { END 
      url += ""#"" + link;
    }
    return url;
  }
","  private String resolveUrl(URI uri, String link) {
    String url = cfg.getString(""gerrit"", null, ""canonicalWebUrl"");
    if (Strings.isNullOrEmpty(url)) {
      url = uri.toString();
    }
    if (!url.endsWith(""/"")) {
      url += ""/"";
    }
    if (!Strings.isNullOrEmpty(link)) {
      url += ""#"" + link;
    }
    return url;
  }
"
1546,"This actually isn't correct.  The ""item"" in this case that is being passed to the JSR-352 SkipListener is actually all the items in the current chunk.  Unlike Spring Batch, the JSR does not provide facilities to identify which item within a chunk caused the error.  See section 9.2.7 of the spec for more detail","	public void onSkipInWrite(S item, Throwable t) {
		if(skipWriteDelegate != null && t instanceof Exception) {
			try {
				skipWriteDelegate.onSkipWriteItem(Collections.<Object>singletonList(item), (Exception) t);
			} catch (Exception e) {
				throw new BatchRuntimeException(e);
			}
		}
	}
","	public void onSkipInWrite(S item, Throwable t) {
		if(skipWriteDelegate != null && t instanceof Exception) {
			try {
START 				skipWriteDelegate.onSkipWriteItem(Collections.<Object>singletonList(item), (Exception) t); END 
			} catch (Exception e) {
				throw new BatchRuntimeException(e);
			}
		}
	}
","	public void onSkipInWrite(S item, Throwable t) {
		if(skipWriteDelegate != null && t instanceof Exception) {
			try {
				/*
				 * assuming this SkipListenerAdapter will only be called from JsrFaultTolerantChunkProcessor,
				 * which calls onSkipInWrite() with the whole chunk (List) of items instead of single item 
				 */
				skipWriteDelegate.onSkipWriteItem((List<Object>) item, (Exception) t);
			} catch (Exception e) {
				throw new BatchRuntimeException(e);
			}
		}
	}
"
1547,Shall use dbDir instead of dbDirs[0] array.,"  private FileStatus[] listConstraintFilesInDBDir(FileSystem fs, Path dbDir) {
    try {
      return fs.listStatus(new Path(dbDirs[0].getPath(), ReplicationSemanticAnalyzer.CONSTRAINTS_ROOT_DIR_NAME));
    } catch (FileNotFoundException e) {
      return new FileStatus[]{};
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }
","  private FileStatus[] listConstraintFilesInDBDir(FileSystem fs, Path dbDir) {
    try {
START       return fs.listStatus(new Path(dbDirs[0].getPath(), ReplicationSemanticAnalyzer.CONSTRAINTS_ROOT_DIR_NAME)); END 
    } catch (FileNotFoundException e) {
      return new FileStatus[]{};
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }
","  private FileStatus[] listConstraintFilesInDBDir(FileSystem fs, Path dbDir) {
    try {
      return fs.listStatus(new Path(dbDir, ReplicationSemanticAnalyzer.CONSTRAINTS_ROOT_DIR_NAME));
    } catch (FileNotFoundException e) {
      return new FileStatus[]{};
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }
"
1548,Access can be private,"  public static boolean sqSupportsExternalIssues() {
    return orchestrator.getServer().version().isGreaterThanOrEquals(7, 2);
  }
","START   public static boolean sqSupportsExternalIssues() { END 
    return orchestrator.getServer().version().isGreaterThanOrEquals(7, 2);
  }
","  private static boolean sqSupportsExternalIssues() {
    return orchestrator.getServer().version().isGreaterThanOrEquals(7, 2);
  }
"
1549,"It will be interesting to see if this times out / runs out of memory on low spec devices. It's a good test, though.","    public void testMakeTimeZone_All() throws IOException {
        ZoneInfoDB.TzData instance = ZoneInfoDB.getInstance();
        String[] availableIDs = instance.getAvailableIDs();
        Arrays.sort(availableIDs);
        for (String id : availableIDs) {
            BufferIterator bufferIterator = instance.getBufferIterator(id);

            // Create a ZoneInfo at the earliest possible time to allow us to use the
            // useDaylightTime() method to check whether it ever has or ever will support daylight
            // savings time.
            ZoneInfo zoneInfo = ZoneInfo.makeTimeZone(id, bufferIterator, Long.MIN_VALUE);
            assertNotNull(""TimeZone "" + id + "" was not created"", zoneInfo);
            assertEquals(id, zoneInfo.getID());
        }
    }
","    public void START  testMakeTimeZone_All() END  throws IOException {
        ZoneInfoDB.TzData instance = ZoneInfoDB.getInstance();
        String[] availableIDs = instance.getAvailableIDs();
        Arrays.sort(availableIDs);
        for (String id : availableIDs) {
            BufferIterator bufferIterator = instance.getBufferIterator(id);

            // Create a ZoneInfo at the earliest possible time to allow us to use the
            // useDaylightTime() method to check whether it ever has or ever will support daylight
            // savings time.
            ZoneInfo zoneInfo = ZoneInfo.makeTimeZone(id, bufferIterator, Long.MIN_VALUE);
            assertNotNull(""TimeZone "" + id + "" was not created"", zoneInfo);
            assertEquals(id, zoneInfo.getID());
        }
    }
","  public void testMakeTimeZone_All() throws Exception {
    ZoneInfoDB.TzData instance = ZoneInfoDB.getInstance();
    String[] availableIDs = instance.getAvailableIDs();
    Arrays.sort(availableIDs);
    for (String id : availableIDs) {
      BufferIterator bufferIterator = instance.getBufferIterator(id);

      // Create a ZoneInfo at the earliest possible time to allow us to use the
      // useDaylightTime() method to check whether it ever has or ever will support daylight
      // savings time.
      ZoneInfo zoneInfo = ZoneInfo.makeTimeZone(id, bufferIterator, Long.MIN_VALUE);
      assertNotNull(""TimeZone "" + id + "" was not created"", zoneInfo);
      assertEquals(id, zoneInfo.getID());
    }
  }
"
1550,"```suggestion
  public int getDefaultAutoLimit() {
```","  public Integer getDefaultAutoLimit() {
    return defaultAutoLimit;
  }
","START   public Integer getDefaultAutoLimit() { END 
    return defaultAutoLimit;
  }
","  public int getDefaultAutoLimit() {
    return defaultAutoLimit;
  }
"
1551,Can be package-private,"    public byte getFormatVersion()
    {
        return formatVersion;
    }
","START     public byte getFormatVersion() END 
    {
        return formatVersion;
    }
","    byte getFormatVersion()
    {
        return formatVersion;
    }
"
1552,nit: ordering is different.,"    public SubscribeRule(@JsonProperty(""type"") final Type type,
            @JsonProperty(""all"") final Boolean all,
            @JsonProperty(""publisher"") final String publisher,
            @JsonProperty(""track"") final String track,
            @JsonProperty(""kind"") final Kind kind,
            @JsonProperty(""priority"") final Priority priority) {
        this.type = type;
        this.all = all;
        this.kind = kind;
        this.priority = priority;
        this.publisher = publisher;
        this.track = track;
    }
","    public SubscribeRule(@JsonProperty(""type"") final Type type,
            @JsonProperty(""all"") final Boolean all,
            @JsonProperty(""publisher"") final String publisher,
            @JsonProperty(""track"") final String track,
            @JsonProperty(""kind"") final Kind kind,
            @JsonProperty(""priority"") final Priority priority) {
        this.type = type;
        this.all = all;
        this.kind = kind;
        this.priority = priority;
START         this.publisher = publisher; END 
        this.track = track;
    }
","    public SubscribeRule(@JsonProperty(""type"") final Type type,
            @JsonProperty(""all"") final Boolean all,
            @JsonProperty(""publisher"") final String publisher,
            @JsonProperty(""track"") final String track,
            @JsonProperty(""kind"") final Kind kind,
            @JsonProperty(""priority"") final Priority priority) {
        this.type = type;
        this.all = all;
        this.publisher = publisher;
        this.track = track;
        this.kind = kind;
        this.priority = priority;
    }
"
1553,"Backward incompatible change: if there are no subcategories it used to return null, now it's throwing null pointer.","    public Subcategory getSubcategory() {
        return subcategories.get(0);
    }
","    public Subcategory getSubcategory() {
START         return subcategories.get(0); END 
    }
","    public Subcategory getSubcategory() {
        return subcategories.isEmpty() ? null : subcategories.get(0);
    }
"
1554,Use `if` here instead. We don't nest `LazyBlock`s,"        public void load(LazyBlock lazyBlock)
        {
            if (block == null) {
                return;
            }

            while (block instanceof LazyBlock) {
                block = ((LazyBlock) block).getBlock();
            }
            Block coercedBlock = coercer.apply(block);
            lazyBlock.setBlock(coercedBlock);

            // clear reference to loader to free resources, since load was successful
            block = null;
        }
","        public void load(LazyBlock lazyBlock)
        {
            if (block == null) {
                return;
            }

START             while (block instanceof LazyBlock) { END 
                block = ((LazyBlock) block).getBlock();
            }
            Block coercedBlock = coercer.apply(block);
            lazyBlock.setBlock(coercedBlock);

            // clear reference to loader to free resources, since load was successful
            block = null;
        }
","        public void load(LazyBlock lazyBlock)
        {
            if (block == null) {
                return;
            }

            if (block instanceof LazyBlock) {
                block = ((LazyBlock) block).getBlock();
            }
            Block coercedBlock = coercer.apply(block);
            lazyBlock.setBlock(coercedBlock);

            // clear reference to loader to free resources, since load was successful
            block = null;
        }
"
1555,"You want to cumulate in a `StringBuilder` here, not a plain `String`.","  public final String dumpConfiguration() {
    if (this.properties.isEmpty())
      return ""No configuration settings stored"";

    @SuppressWarnings(""rawtypes"")
    Enumeration e = this.properties.propertyNames();
    String response = ""TSD Configuration:\n"";
    response += ""File ["" + this.config_location + ""]\n"";
    while (e.hasMoreElements()) {
      String key = (String) e.nextElement();
      response += ""Key ["" + key + ""]  Value [""
          + this.properties.getProperty(key) + ""]\n"";
    }
    return response;
  }
","  public final String dumpConfiguration() {
    if (this.properties.isEmpty())
      return ""No configuration settings stored"";

    @SuppressWarnings(""rawtypes"")
    Enumeration e = this.properties.propertyNames();
START     String response = ""TSD Configuration:\n""; END 
    response += ""File ["" + this.config_location + ""]\n"";
    while (e.hasMoreElements()) {
      String key = (String) e.nextElement();
      response += ""Key ["" + key + ""]  Value [""
          + this.properties.getProperty(key) + ""]\n"";
    }
    return response;
  }
","  public final String dumpConfiguration() {
    if (this.properties.isEmpty())
      return ""No configuration settings stored"";

    StringBuilder response = new StringBuilder(""TSD Configuration:\n"");
    response.append(""File ["" + this.config_location + ""]\n"");
    for (Map.Entry<String, String> entry : this.properties.entrySet()) {
      response.append(""Key ["" + entry.getKey() + ""]  Value ["").
          append(entry.getValue() + ""]\n"");
    }
    return response.toString();
  }
"
1556,"We should move that to debug in different patch (or remove at all), I see no value for that in INFO level","    public void cleanup() {
        try {
            log.info(""Start cleanup"");
            DateTime latestTimeToKeep = DateTime.getNow().addDays(
                    Config.<Integer>getValue(ConfigValues.AuditLogAgingThreshold)
                            * -1);
            auditLogDao.removeAllBeforeDate(latestTimeToKeep);
            log.info(""Finished cleanup"");
        } catch (Throwable t) {
            log.error(""Exception in performing audit log cleanup: {}"", ExceptionUtils.getRootCauseMessage(t));
            log.debug(""Exception"", t);
        }
    }
","    public void cleanup() {
        try {
START             log.info(""Start cleanup""); END 
            DateTime latestTimeToKeep = DateTime.getNow().addDays(
                    Config.<Integer>getValue(ConfigValues.AuditLogAgingThreshold)
                            * -1);
            auditLogDao.removeAllBeforeDate(latestTimeToKeep);
            log.info(""Finished cleanup"");
        } catch (Throwable t) {
            log.error(""Exception in performing audit log cleanup: {}"", ExceptionUtils.getRootCauseMessage(t));
            log.debug(""Exception"", t);
        }
    }
","    public void cleanup() {
        try {
            log.debug(""Start cleanup"");
            DateTime latestTimeToKeep = DateTime.getNow().addDays(
                    Config.<Integer>getValue(ConfigValues.AuditLogAgingThreshold)
                            * -1);
            auditLogDao.removeAllBeforeDate(latestTimeToKeep);
            log.debug(""Finished cleanup"");
        } catch (Throwable t) {
            log.error(""Exception in performing audit log cleanup: {}"", ExceptionUtils.getRootCauseMessage(t));
            log.debug(""Exception"", t);
        }
    }
"
1557,"In this case, `Optional` doesn't really give you anything. A simple null check does the exact same thing, doesn't allocate a new object on the heap, and doesn't require a lambda.

Also, this seems much better readable:
  
    String node = canvasHandler.getGraphIndex().get(id);
    if (canvasHandler.getGraphIndex().get(id) == null) {
         context.saveGroup(Collections.emptyMap());
    } else {
         HashMap<String, String> map = new HashMap<>(2);
         map.put(DEFAULT_NODE_ID, id);
         map.put(svgNodeId, id);
         context.saveGroup(map);
    }

Overall, this is also much more efficient that the original.","    public void saveContainer(String id) {
        HashMap<String, String> map = new HashMap<>();
        //setting the node id in case it exists on graph
        Optional.ofNullable(canvasHandler.getGraphIndex().get(id)).ifPresent(node -> {
            map.put(DEFAULT_NODE_ID, id);
            map.put(svgNodeId, id);
        });
        context.saveGroup(map);
    }
","    public void saveContainer(String id) {
        HashMap<String, String> map = new HashMap<>();
        //setting the node id in case it exists on graph
START         Optional.ofNullable(canvasHandler.getGraphIndex().get(id)).ifPresent(node -> { END 
            map.put(DEFAULT_NODE_ID, id);
            map.put(svgNodeId, id);
        });
        context.saveGroup(map);
    }
","    public void saveContainer(String id) {
        HashMap<String, String> map = new HashMap<>();
        //setting the node id in case it exists on graph
        if (canvasHandler.getGraphIndex().get(id) != null) {
            map.put(DEFAULT_NODE_ID, id);
            map.put(svgNodeId, id);
        }
        context.saveGroup(map);
    }
"
1558,"please extract method :
protected GlusterVolumeInfoDao getGlusterVolumeInfoDao()

The reason for doing this, is so you will be able to write a test using mockito (and not pockermock / static mocking) 
for this query.","    protected void executeQueryCommand() {
        getQueryReturnValue().setReturnValue(DbFacade.getInstance()
                .getGlusterVolumeDao()
                .getById(getParameters().getVolumeId()));
    }
","    protected void executeQueryCommand() {
START         getQueryReturnValue().setReturnValue(DbFacade.getInstance() END 
                .getGlusterVolumeDao()
                .getById(getParameters().getVolumeId()));
    }
","    protected void executeQueryCommand() {
        getQueryReturnValue().setReturnValue(getGlusterVolumeDao().getById(getParameters().getVolumeId()));
    }
"
1559,"If I'm understanding this patch correctly, the idea is that if we've reached this point, we're not in an infinite crash loop -- is that right?","    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Prefs.crashedBeforeActivityCreated(false);

        ActivityUtil.requestFullUserOrientation(this);

        setTheme();
        removeSplashBackground();

        if (getSupportActionBar() != null) {
            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        }
        forceOverflowMenuIcon(this);
    }
","    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

START         Prefs.crashedBeforeActivityCreated(false); END 

        ActivityUtil.requestFullUserOrientation(this);

        setTheme();
        removeSplashBackground();

        if (getSupportActionBar() != null) {
            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        }
        forceOverflowMenuIcon(this);
    }
","    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        ActivityUtil.requestFullUserOrientation(this);

        setTheme();
        removeSplashBackground();

        if (getSupportActionBar() != null) {
            getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        }
        forceOverflowMenuIcon(this);
    }
"
1560,"I would probably implement this the other way around.  Since pending is ""this"" (well, the backing store) we should do:

  pending.shareFreeList(q);

to mirror the intent of the caller of invoking this.shareFreeList(q).

Its a subtle issue about how we are discarding a potentially large free list from the bottom of the stack by pushing down an empty free list from the top of the stack.  Weird, I know.  But at least mirror the caller's intent.","	void shareFreeList(final BlockRevQueue q) {
		q.shareFreeList(pending);
	}
","	void shareFreeList(final BlockRevQueue q) {
START 		q.shareFreeList(pending); END 
	}
","	void shareFreeList(final BlockRevQueue q) {
		pending.shareFreeList(q);
	}
"
1561,we could simplify this by immediately returning `false` if `workerNetAddress.getDomainSocketPath().isEmpty()`,"  public static boolean isDomainSocketSupported(WorkerNetAddress workerNetAddress) {
    boolean isDomainSocketSupported = !workerNetAddress.getDomainSocketPath().isEmpty();
    if (isDomainSocketSupported) {
      if (Configuration.getBoolean(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_AS_UUID)) {
        isDomainSocketSupported = FileUtils.exists(workerNetAddress.getDomainSocketPath());
      } else {
        isDomainSocketSupported =
            workerNetAddress.getHost().equals(NetworkAddressUtils.getClientHostName());
      }
    }
    return isDomainSocketSupported && CHANNEL_TYPE == ChannelType.EPOLL;
  }
","  public static boolean isDomainSocketSupported(WorkerNetAddress workerNetAddress) {
START     boolean isDomainSocketSupported = !workerNetAddress.getDomainSocketPath().isEmpty(); END 
    if (isDomainSocketSupported) {
      if (Configuration.getBoolean(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_AS_UUID)) {
        isDomainSocketSupported = FileUtils.exists(workerNetAddress.getDomainSocketPath());
      } else {
        isDomainSocketSupported =
            workerNetAddress.getHost().equals(NetworkAddressUtils.getClientHostName());
      }
    }
    return isDomainSocketSupported && CHANNEL_TYPE == ChannelType.EPOLL;
  }
","  public static boolean isDomainSocketSupported(WorkerNetAddress workerNetAddress) {
    if (workerNetAddress.getDomainSocketPath().isEmpty() || CHANNEL_TYPE != ChannelType.EPOLL) {
      return false;
    }
    if (Configuration.getBoolean(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_AS_UUID)) {
      return FileUtils.exists(workerNetAddress.getDomainSocketPath());
    } else {
      return workerNetAddress.getHost().equals(NetworkAddressUtils.getClientHostName());
    }
  }
"
1562,Is there a way to tell that the gRPC channel is in a bad state without having to manually close it?,"  public static GrpcDataWriter create(FileSystemContext context, WorkerNetAddress address,
      long id, long length, RequestType type, OutStreamOptions options)
      throws IOException {
    long chunkSize = Configuration.getBytes(PropertyKey.USER_NETWORK_WRITER_CHUNK_SIZE_BYTES);
    BlockWorkerClient grpcClient = context.acquireBlockWorkerClient(address);
    try {
      return new GrpcDataWriter(context, address, id, length, chunkSize, type, options,
          grpcClient);
    } catch (Exception e) {
      // Close the client before releasing in order to get it removed from the pool.
      grpcClient.close();
      context.releaseBlockWorkerClient(address, grpcClient);
      throw e;
    }
  }
","  public static GrpcDataWriter create(FileSystemContext context, WorkerNetAddress address,
      long id, long length, RequestType type, OutStreamOptions options)
      throws IOException {
    long chunkSize = Configuration.getBytes(PropertyKey.USER_NETWORK_WRITER_CHUNK_SIZE_BYTES);
    BlockWorkerClient grpcClient = context.acquireBlockWorkerClient(address);
    try {
      return new GrpcDataWriter(context, address, id, length, chunkSize, type, options,
          grpcClient);
    } catch (Exception e) {
      // Close the client before releasing in order to get it removed from the pool.
START       grpcClient.close(); END 
      context.releaseBlockWorkerClient(address, grpcClient);
      throw e;
    }
  }
","  public static GrpcDataWriter create(FileSystemContext context, WorkerNetAddress address,
      long id, long length, RequestType type, OutStreamOptions options)
      throws IOException {
    long chunkSize = Configuration.getBytes(PropertyKey.USER_NETWORK_WRITER_CHUNK_SIZE_BYTES);
    BlockWorkerClient grpcClient = context.acquireBlockWorkerClient(address);
    try {
      return new GrpcDataWriter(context, address, id, length, chunkSize, type, options,
          grpcClient);
    } catch (Exception e) {
      context.releaseBlockWorkerClient(address, grpcClient);
      throw e;
    }
  }
"
1563,Better to use `t.equals(type)` so parameterized types can satisfy test.,"    public static RowMapperFactory of(Type type, RowMapper<?> mapper) {
        return (t, ctx) -> t == type
                ? Optional.of(mapper)
                : Optional.empty();
    }
","    public static RowMapperFactory of(Type type, RowMapper<?> mapper) {
START         return (t, ctx) -> t == type END 
                ? Optional.of(mapper)
                : Optional.empty();
    }
","    public static RowMapperFactory of(Type type, RowMapper<?> mapper) {
        return (t, ctx) -> t.equals(type)
                ? Optional.of(mapper)
                : Optional.empty();
    }
"
1564,I would check getQosOverridden().getIsChangeable() instead of (!getIsToSync().getIsChangable() || getIsToSync().getEntity()) but as you wish...,"    private void updateQosChangeability() {
        getQosModel().setIsChangable(getQosOverridden().getEntity()
                && (!getIsToSync().getIsChangable() || getIsToSync().getEntity()));
    }
","    private void updateQosChangeability() {
        START getQosModel().setIsChangable(getQosOverridden().getEntity()
                && (!getIsToSync().getIsChangable() || getIsToSync().getEntity())); END 
    }
","    private void updateQosChangeability() {
        getQosModel().setIsChangable(getQosOverridden().getEntity() && getQosOverridden().getIsChangable());
    }
"
1565,:bug: uncompilable extra `)`,"    public boolean isRelevant() {
        if (!jenkins.hasPermission(Jenkins.RUN_SCRIPTS))) {
            return false;
        }
        if (rule.getMasterKillSwitch()) {
            return true; // always relevant if it is enabled.
        }
        return jenkins.isUseSecurity()            // if security is off, there's no point
            && (jenkins.getComputers().length>1   // if there's no slave,
                || !jenkins.clouds.isEmpty()      // and no clouds, likewise this is pointless
                || Relevance.fromExtension()      // unless a plugin thinks otherwise
            )
        ;
    }
","    public boolean isRelevant() {
START         if (!jenkins.hasPermission(Jenkins.RUN_SCRIPTS))) { END 
            return false;
        }
        if (rule.getMasterKillSwitch()) {
            return true; // always relevant if it is enabled.
        }
        return jenkins.isUseSecurity()            // if security is off, there's no point
            && (jenkins.getComputers().length>1   // if there's no slave,
                || !jenkins.clouds.isEmpty()      // and no clouds, likewise this is pointless
                || Relevance.fromExtension()      // unless a plugin thinks otherwise
            )
        ;
    }
","    public boolean isRelevant() {
        return jenkins.hasPermission(Jenkins.RUN_SCRIPTS) && jenkins.isUseSecurity();
    }
"
1566,"avoid one time variables, see https://github.com/tpc2/qulice/wiki/mistakes#one-time-variables","    public final void validateNullUser() {
        final AuthKeys authKeys = new AuthKeys();
        final String user = null;
        final String password = ""password"";
        authKeys.authenticate(user, password);
    }
","    public final void validateNullUser() {
        final AuthKeys authKeys = new AuthKeys();
        final String user = null;
START         final String password = ""password""; END 
        authKeys.authenticate(user, password);
    }
","    public final void validateNullUser() throws Exception {
        final AuthKeys authKeys = new AuthKeys();
        authKeys.authenticate(null, ""password"");
    }
"
1567,`IllegalStateException` is actually thrown (not `IllegalArgument`).,"  public int getRackId() {
    if (rackId == null) {
      throw new IllegalStateException(""rackId not defined for the data node "" + hostname + "":"" + port);
    }
    return rackId;
  }
","  public int getRackId() {
    if (rackId == null) {
START       throw new IllegalStateException(""rackId not defined for the data node "" + hostname + "":"" + port); END 
    }
    return rackId;
  }
","  public long getRackId() {
    return rackId;
  }
"
1568,Interesting that this method will handle nulls for aias but performSearch would NPE.  This was exposed in a change to the test for this class.,"   public Collection<String> getProductSearchName() {
      if (aias != null) {
         return ActionableItems.getNames(aias);
      }
      return Collections.emptyList();
   }
","START    public Collection<String> getProductSearchName() { END 
      if (aias != null) {
         return ActionableItems.getNames(aias);
      }
      return Collections.emptyList();
   }
","   public Collection<String> getProductSearchName() {
      return ActionableItems.getNames(aias);
   }
"
1569,Please simplify this.,"		protected boolean validateScreenDescriptor() {
			if (screenBackgroundColor >= screenColors) {
				// Not in the specification, but here the background color would refer to a color
				// index not within the bounds of the Global Color Table.
				return false;
			}
			return true;
		}
","		protected boolean validateScreenDescriptor() {
START 			if (screenBackgroundColor >= screenColors) { END 
				// Not in the specification, but here the background color would refer to a color
				// index not within the bounds of the Global Color Table.
				return false;
			}
			return true;
		}
","		protected boolean validateScreenDescriptor() {
			// Not in the specification, but check whether the background color index is within
			// the bounds of the Global Color Table just to be sure.
			return screenBackgroundColor < screenColors;
		}
"
1570,could we also check that the default value is not `null`?,"  public void testEmptyKeyDefaults() {
    for (PropertyKey key : PropertyKey.defaultKeys()) {
      assertNotEquals(key.getDefaultValue(), """", String.format(
          ""Property keys cannot have a default value of \""\"". Offending key: %s"", key.getName()));
    }
  }
","  public void testEmptyKeyDefaults() {
    for (PropertyKey key : PropertyKey.defaultKeys()) {
START       assertNotEquals(key.getDefaultValue(), """", String.format( END 
          ""Property keys cannot have a default value of \""\"". Offending key: %s"", key.getName()));
    }
  }
","  public void testEmptyKeyDefaults() {
    for (PropertyKey key : PropertyKey.defaultKeys()) {
      assertNotEquals(String.format(
          ""Property keys cannot have a default value of \""\"". Offending key: %s"", key.getName()),
          key.getDefaultValue(), """");
    }
  }
"
1571,Is it possible to avoid copy pasting the code and reuse the code from the other topnresultbuilders?,"  private boolean shouldAdd(String dimName)
  {
    final boolean belowThreshold = pQueue.size() < this.threshold;
    final boolean belowMax = belowThreshold
                             || this.comparator.compare(pQueue.peek().getTopNMetricVal(), dimName) < 0;
    return belowMax && comparator.compare(dimName, previousStop) > 0;
  }
","START   private boolean shouldAdd(String dimName) END 
  {
    final boolean belowThreshold = pQueue.size() < this.threshold;
    final boolean belowMax = belowThreshold
                             || this.comparator.compare(pQueue.peek().getTopNMetricVal(), dimName) < 0;
    return belowMax && comparator.compare(dimName, previousStop) > 0;
  }
","  private boolean shouldAdd(String dimName)
  {
    final boolean belowThreshold = pQueue.size() < threshold;
    final boolean belowMax = belowThreshold
                             || comparator.compare(pQueue.peek().getTopNMetricVal(), dimName) < 0;
    // Only add if dimName is after previousStop
    return belowMax && (previousStop == null || comparator.compare(dimName, previousStop) > 0);
  }
"
1572,"Any reason why this doesn't use Objects.hash()? Because of the 31 instead of 37?

I am ok for changing the hashcode formula here as long as it doesn't violate the equals contract.","    public int hashCode() {
        int result = Objects.hash(entity);
        result = 31 * result + Arrays.hashCode(values);
        return result;
    }
","    public int hashCode() {
        int result = Objects.hash(entity);
START         result = 31 * result + Arrays.hashCode(values); END 
        return result;
    }
","    public int hashCode() {
        return Objects.hash(entity, Arrays.hashCode(values));
    }
"
1573,don't need to throw exceptions - just return `null`.,"  Store getStore(PartitionId id)
      throws StoreException {
    BlobStore store = stores.get(id);
    if (store == null) {
      throw new StoreException(""Could not find partition "" + id + "" on disk "" + disk,
          StoreErrorCodes.Partition_Not_Found);
    }
    if (!store.isStarted()) {
      throw new StoreException(""Store for partition "" + id + "" on disk "" + disk + "" has not been started successfully"",
          StoreErrorCodes.Store_Not_Started);
    }
    return store;
  }
","  Store getStore(PartitionId id)
      throws StoreException {
    BlobStore store = stores.get(id);
    if (store == null) {
START       throw new StoreException(""Could not find partition "" + id + "" on disk "" + disk, END 
          StoreErrorCodes.Partition_Not_Found);
    }
    if (!store.isStarted()) {
      throw new StoreException(""Store for partition "" + id + "" on disk "" + disk + "" has not been started successfully"",
          StoreErrorCodes.Store_Not_Started);
    }
    return store;
  }
","  Store getStore(PartitionId id) {
    BlobStore store = stores.get(id);
    return (store != null && store.isStarted()) ? store : null;
  }
"
1574,This is apparently out of date.,"	public static int getValue(String text) {
		if (text == null || text.isEmpty() || text.equals(""build"")) { //$NON-NLS-1$
			return BUILD;
		}
		if (text.equals(""codan"")) { //$NON-NLS-1$
			return CODAN;
		}
		if (text.equals(""build,codan"")) { //$NON-NLS-1$
			return BUILD_AND_CODAN;
		}
		throw new IllegalArgumentException(""Unknown context value: "" + text); //$NON-NLS-1$
	}
","	public static int getValue(String text) {
		if (text == null || text.isEmpty() || text.equals(""build"")) { //$NON-NLS-1$
			return BUILD;
		}
		if (text.equals(""codan"")) { //$NON-NLS-1$
			return CODAN;
		}
START 		if (text.equals(""build,codan"")) { //$NON-NLS-1$ END 
			return BUILD_AND_CODAN;
		}
		throw new IllegalArgumentException(""Unknown context value: "" + text); //$NON-NLS-1$
	}
","	public static int getValue(String text) {
		if (text == null || text.isEmpty() || text.equals(""build"")) { //$NON-NLS-1$
			return BUILD;
		}
		if (text.equals(""codan"")) { //$NON-NLS-1$
			return CODAN;
		}
		throw new IllegalArgumentException(""Unknown context value: "" + text); //$NON-NLS-1$
	}
"
1575,!ignoreReason.isEmpty() can be used,"	public String getToolTipText(Object element) {
		if (element instanceof TestCaseElement) {
			String ignoreReason= ((TestCaseElement) element).getIgnoreReason();
			if (ignoreReason != null && ignoreReason.length() > 0) {
				return ignoreReason;
			}
		}
		return super.getToolTipText(element);
	}
","	public String getToolTipText(Object element) {
		if (element instanceof TestCaseElement) {
			String ignoreReason= ((TestCaseElement) element).getIgnoreReason();
			if (ignoreReason != null && START  ignoreReason.length() > 0) { END 
				return ignoreReason;
			}
		}
		return super.getToolTipText(element);
	}
","	public String getToolTipText(Object element) {
		if (element instanceof TestCaseElement) {
			String ignoreReason= ((TestCaseElement) element).getIgnoreReason();
			if (ignoreReason != null && !ignoreReason.isEmpty()) {
				return ignoreReason;
			}
		}
		return super.getToolTipText(element);
	}
"
1576,There is no reason to catch all exceptions like this.,"    public String getResourceContent(String name) throws IOException
    {
        if (getEngineContext() != null) {
            try (InputStream is = getResourceAsStream(name)) {
                if (is == null) {
                    // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding
                    return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);
                }
                return IOUtils.toString(is, DEFAULT_ENCODING);
            } catch (Exception e) {
            }
        }
        return null;
    }
","    public String getResourceContent(String name) throws IOException
    {
        if (getEngineContext() != null) {
            try (InputStream is = getResourceAsStream(name)) {
                if (is == null) {
                    // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding
                    return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);
                }
                return IOUtils.toString(is, DEFAULT_ENCODING);
START             } catch (Exception e) { END 
            }
        }
        return null;
    }
","    public String getResourceContent(String name) throws IOException
    {
        if (getEngineContext() != null) {
            try (InputStream is = getResourceAsStream(name)) {
                if (is != null) {
                    return IOUtils.toString(is, DEFAULT_ENCODING);
                }
            }
        }
        // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding
        return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);
    }
"
1577,Dodaj testowanie drugiego Levelu. Moim zdaniem ten test sfailuje dla levelu 1.,"    public void testGetLevel() throws Exception {
        assertEquals(building.getLevel(0), levelA);
        assertNotSame(building.getLevel(0), levelB);
    }
","START     public void testGetLevel() throws Exception { END 
        assertEquals(building.getLevel(0), levelA);
        assertNotSame(building.getLevel(0), levelB);
    }
","    public void testGetLevel() throws Exception {
        assertEquals(building.getLevel(0), levelA);
        assertNotSame(building.getLevel(0), levelB);

        assertEquals(building.getLevel(1), levelB);
        assertNotSame(building.getLevel(1), levelA);
    }
"
1578,"I know this is just test class, but this is what `Optinal.empty()` is for - avoiding necessity to sometimes use null ;-)","        public Optional<Shape> getShapeAt(final double x,
                                          final double y) {
            return null;
        }
","        public Optional<Shape> getShapeAt(final double x,
                                          final double y) {
START             return null; END 
        }
","        public Optional<Shape> getShapeAt(final double x,
                                          final double y) {
            return Optional.empty();
        }
"
1579,"I think we should check for ICBreakpoint instead to include any other
kind of breakpoints that uses this properties page.
For example a watchpoint or an eventBreakpoing can trigger this code.","	public void setElement( IAdaptable element ) {
		if (element instanceof ICLineBreakpoint) {
			fElement = new CBreakpointContext((ICBreakpoint)element, null);
		}
		else {
			fElement = element;
		}
	}
","	public void setElement( IAdaptable element ) {
START 		if (element instanceof ICLineBreakpoint) { END 
			fElement = new CBreakpointContext((ICBreakpoint)element, null);
		}
		else {
			fElement = element;
		}
	}
","	public void setElement( IAdaptable element ) {
		if (element instanceof ICBreakpoint) {
			fElement = new CBreakpointContext((ICBreakpoint)element, null);
		}
		else {
			fElement = element;
		}
	}
"
1580,I don't like the Idea of managing transactions inside table class,"    private boolean TxBegin() {
        if (!TransactionalContext.isInTransaction()) {
            corfuRuntime.getObjectsView()
                    .TXBuild()
                    .type(TransactionType.OPTIMISTIC)
                    .build().begin();
            return true;
        }
        return false;
    }
","    private boolean TxBegin() {
START         if (!TransactionalContext.isInTransaction()) { END 
            corfuRuntime.getObjectsView()
                    .TXBuild()
                    .type(TransactionType.OPTIMISTIC)
                    .build().begin();
            return true;
        }
        return false;
    }
","    private boolean TxBegin() {
        if (TransactionalContext.isInTransaction()) {
            return false;
        }
        corfuRuntime.getObjectsView()
                .TXBuild()
                .type(TransactionType.OPTIMISTIC)
                .build()
                .begin();
        return true;
    }
"
1581,This is not good enough. How do we know which emails failed to be sent? In addition you're sending an exception only for the frist error... what about all the rest?,"    public UUID send(Iterable<? extends MimeMessage> messages, Session session) throws MessagingException
    {
        MailListener listener = getListener(""memory"");
        UUID batchID = sendAsynchronously(messages, session, listener);
        waitTillSent(Long.MAX_VALUE);
        Iterator<MailStatus> errors = listener.getErrors();
        if (errors.hasNext()) {
            throw new MessagingException(
                String.format(""Failed to send mail message [%s] "", errors.next().getException()));
        }
        return batchID;
    }
","    public UUID send(Iterable<? extends MimeMessage> messages, Session session) throws MessagingException
    {
        MailListener listener = getListener(""memory"");
        UUID batchID = sendAsynchronously(messages, session, listener);
        waitTillSent(Long.MAX_VALUE);
        Iterator<MailStatus> errors = listener.getErrors();
        if (errors.hasNext()) {
            throw new MessagingException(
START                 String.format(""Failed to send mail message [%s] "", errors.next().getException())); END 
        }
        return batchID;
    }
","    public UUID send(Iterable<? extends MimeMessage> messages, Session session) throws MessagingException
    {
        MailListener listener = getListener(""memory"");
        UUID batchID = sendAsynchronously(messages, session, listener);
        waitTillSent(Long.MAX_VALUE);
        return batchID;
    }
"
1582,No submonitor is needed in this method. The original monitor can be passed to a single method call as is.,"	public java.io.File toLocalFile(int options, IProgressMonitor monitor) throws CoreException {
		SubMonitor subMonitor = SubMonitor.convert(monitor);
		//caching is the only recognized option
		if (options != EFS.CACHE)
			return null;
		return FileCache.getCache().cache(this, subMonitor);
	}
","	public java.io.File toLocalFile(int options, IProgressMonitor monitor) throws CoreException {
		SubMonitor START  subMonitor = END  SubMonitor.convert(monitor);
		//caching is the only recognized option
		if (options != EFS.CACHE)
			return null;
		return FileCache.getCache().cache(this, subMonitor);
	}
","	public java.io.File toLocalFile(int options, IProgressMonitor monitor) throws CoreException {
		//caching is the only recognized option
		if (options != EFS.CACHE)
			return null;
		return FileCache.getCache().cache(this, monitor);
	}
"
1583,We should move such tasks to doStart and not in constructors,"    public NewCommentsConsumer(JiraEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
        LOG.info(""JIRA NewCommentsConsumer: Indexing current issue comments."");
        getComments();
    }
","    public NewCommentsConsumer(JiraEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
START         LOG.info(""JIRA NewCommentsConsumer: Indexing current issue comments.""); END 
        getComments();
    }
","    public NewCommentsConsumer(JiraEndpoint endpoint, Processor processor) {
        super(endpoint, processor);
    }
"
1584,"i would reverse -- check access control only for existing catalogs. I think an access control impl may have problems for non-existing catalogs.

(here & below)","        private boolean isCatalogAccessible(String catalogName)
        {
            return accessControl.filterCatalogs(session.getIdentity(), ImmutableSet.of(catalogName)).contains(catalogName)
                    && metadata.catalogExists(session, catalogName);
        }
","        private boolean isCatalogAccessible(String catalogName)
        {
            return accessControl.filterCatalogs(session.getIdentity(), ImmutableSet.of(catalogName)).contains(catalogName)
START                     && metadata.catalogExists(session, catalogName); END 
        }
","        private boolean isCatalogAccessible(String catalogName)
        {
            return metadata.catalogExists(session, catalogName)
                    && accessControl.filterCatalogs(session.getIdentity(), ImmutableSet.of(catalogName)).contains(catalogName);
        }
"
1585,use `System.currentTimeMillis()` and avoid creating Date objects. Not sure why we're using Date objects anyway (for Metadata) but I guess we're stuck now. `Long` would be preferable.,"    public static void invalidateThumbnail(PublishedInfo layer) {
        //Allow a bit of leeway, to support GetMap composer format 
        //(in case of getMap returning before put layer)
        Date d = new Date(new Date().getTime()-1000);
        if (Metadata.modified(layer) != null && d.before(Metadata.modified(layer))) {
            return;
        }
        Metadata.map(layer).remove(Metadata.THUMBNAIL);
    }
","    public static void invalidateThumbnail(PublishedInfo layer) {
        //Allow a bit of leeway, to support GetMap composer format 
        //(in case of getMap returning before put layer)
START         Date d = new Date(new Date().getTime()-1000); END 
        if (Metadata.modified(layer) != null && d.before(Metadata.modified(layer))) {
            return;
        }
        Metadata.map(layer).remove(Metadata.THUMBNAIL);
    }
","    public static void invalidateThumbnail(PublishedInfo layer) {
        Metadata.map(layer).remove(Metadata.THUMBNAIL);
    }
"
1586,"I think this should clear any previous webView's listeners, not the current one.","    public void setScrollView(@Nullable ObservableWebView webView) {
        this.webView = webView;
        if (this.webView != null) {
            this.webView.clearAllListeners();
            this.webView.addOnScrollChangeListener(this);
            this.webView.addOnDownMotionEventListener(this);
            this.webView.addOnUpOrCancelMotionEventListener(this);
        }
    }
","    public void setScrollView(@Nullable ObservableWebView webView) {
        this.webView = webView;
        if (this.webView != null) {
            START  this.webView.clearAllListeners(); END 
            this.webView.addOnScrollChangeListener(this);
            this.webView.addOnDownMotionEventListener(this);
            this.webView.addOnUpOrCancelMotionEventListener(this);
        }
    }
","    public void setScrollView(@Nullable ObservableWebView webView) {
        if (this.webView != null) {
            this.webView.clearAllListeners();
        }

        this.webView = webView;
        if (this.webView != null) {
            this.webView.addOnScrollChangeListener(this);
            this.webView.addOnDownMotionEventListener(this);
            this.webView.addOnUpOrCancelMotionEventListener(this);
        }
    }
"
1587,Can be info log.,"  private void verifyFetchedLog(List<String> logs, String[] expectedLogs) {
    StringBuilder stringBuilder = new StringBuilder();
    for (String log : logs) {
      stringBuilder.append(log);
    }
    String accumulatedLogs = stringBuilder.toString();
    for (String expectedLog : expectedLogs) {
      LOG.error(""Checking match for "" + expectedLog);
      assertTrue(accumulatedLogs.contains(expectedLog));
    }
  }
","  private void verifyFetchedLog(List<String> logs, String[] expectedLogs) {
    StringBuilder stringBuilder = new StringBuilder();
    for (String log : logs) {
      stringBuilder.append(log);
    }
    String accumulatedLogs = stringBuilder.toString();
    for (String expectedLog : expectedLogs) {
START       LOG.error(""Checking match for "" + expectedLog); END 
      assertTrue(accumulatedLogs.contains(expectedLog));
    }
  }
","  private void verifyFetchedLog(List<String> logs, String[] expectedLogs) {
    StringBuilder stringBuilder = new StringBuilder();
    for (String log : logs) {
      stringBuilder.append(log);
    }
    String accumulatedLogs = stringBuilder.toString();
    for (String expectedLog : expectedLogs) {
      LOG.info(""Checking match for "" + expectedLog);
      assertTrue(accumulatedLogs.contains(expectedLog));
    }
  }
"
1588,"If we can't find an extension, shouldn't we just return `requestUri`?","    private String uriWithoutExtension(String requestUri) {
        int suffixStart = requestUri.lastIndexOf(""."");
        if (suffixStart >= 0) {
            return requestUri.substring(0, suffixStart);
        }
        return null;
    }
","    private String uriWithoutExtension(String requestUri) {
        int suffixStart = requestUri.lastIndexOf(""."");
        if (suffixStart >= 0) {
            return requestUri.substring(0, suffixStart);
        }
START         return null; END 
    }
","    private String uriWithoutExtension(String requestUri) {
        int suffixStart = requestUri.lastIndexOf(""."");
        if (suffixStart >= 0) {
            return requestUri.substring(0, suffixStart);
        }
        return requestUri;
    }
"
1589,Remove this,"   private static URL deploymentStaticOne() throws Throwable
   {
      System.out.println(""deploymentStatic"");
      return new URL(""http://blah.com/static"");
   }
","   private static URL deploymentStaticOne() throws Throwable
   {
START       System.out.println(""deploymentStatic""); END 
      return new URL(""http://blah.com/static"");
   }
","   private static URL deploymentStaticOne() throws Throwable
   {
      return new URL(""http://blah.com/static"");
   }
"
1590,"I know this was already like this, but it is weird we are dropping the view before creating. If the goal is to assert that it throws an exception, then we should assert on it, otherwise this is not doing anything.","    public void createAndDropViewTest() throws DatabaseEngineException {
        test5Columns();

        try {
            engine.dropView(""VN"");
        } catch (final Throwable a) {
        }

        engine.executeUpdate(
                createView(""VN"").as(select(all()).from(table(""TEST"")))
        );

        engine.dropView(""VN"");
    }
","    public void createAndDropViewTest() throws DatabaseEngineException {
        test5Columns();

        try {
            engine.dropView(""VN"");
        } catch (final Throwable a) {
START         } END 

        engine.executeUpdate(
                createView(""VN"").as(select(all()).from(table(""TEST"")))
        );

        engine.dropView(""VN"");
    }
","    public void createAndDropViewTest() throws DatabaseEngineException {
        test5Columns();

        engine.executeUpdate(
                createView(""VN"").as(select(all()).from(table(""TEST"")))
        );

        engine.dropView(""VN"");
    }
"
1591,"Adjusting this to `private` will be a breaking change - please keep it `public`. 
Just replacing the `@PostConstruct` for an `@Deprecated` is sufficient I think.","    private void ensureIndexes() {
        storageStrategy.ensureIndexes(template.eventCollection(), template.snapshotCollection());
    }
","START     private void ensureIndexes() { END 
        storageStrategy.ensureIndexes(template.eventCollection(), template.snapshotCollection());
    }
","    public void ensureIndexes() {
        storageStrategy.ensureIndexes(template.eventCollection(), template.snapshotCollection());
    }
"
1592,No need to return anything different than DefaultFileOperations.INSTANCE here,"   public <T> ResourceOperations<T> getResourceOperations(Class<T> type)
   {
       return (ResourceOperations<T>) (File.class.equals(type) ? DefaultFileOperations.INSTANCE : null);
   }
","   public <T> ResourceOperations<T> getResourceOperations(Class<T> type)
   {
START        return (ResourceOperations<T>) (File.class.equals(type) ? DefaultFileOperations.INSTANCE : null); END 
   }
","   public <T> ResourceOperations<T> getResourceOperations(Class<T> type)
   {
       return (ResourceOperations<T>) DefaultFileOperations.INSTANCE;
   }
"
1593,"What string is this?  Is it the one we defined in messages.properties?  If so, this won't work when translated.","	public REVERSE_DEBUG_ACTIONS_ENUM getOperation() {
		String item = combo.getItem(combo.getSelectionIndex());
		return REVERSE_DEBUG_ACTIONS_ENUM.valueOf(item.toUpperCase());
	}
","	public REVERSE_DEBUG_ACTIONS_ENUM getOperation() {
START 		String item = combo.getItem(combo.getSelectionIndex()); END 
		return REVERSE_DEBUG_ACTIONS_ENUM.valueOf(item.toUpperCase());
	}
","	public REVERSE_DEBUG_ACTIONS_ENUM getOperation() {
		int index = combo.getSelectionIndex();

		return REVERSE_DEBUG_ACTIONS_ENUM.getValue(index);
	}
"
1594,"This is unnecessary, its called via canFillFluidType() in super.fill().","    public int fill(final FluidStack resource, final boolean doFill) {
        if (resource == null)
            return 0;
        if (resource.amount <= 0)
            return 0;
        if (!matchesFilter(resource))
            return 0;
        int ret = super.fill(resource, doFill);
        if (ret != 0 && updateCallback != null)
            updateCallback.accept(this);
        return ret;
    }
","    public int fill(final FluidStack resource, final boolean doFill) {
        if (resource == null)
            return 0;
        if (resource.amount <= 0)
            return 0;
START         if (!matchesFilter(resource)) END 
            return 0;
        int ret = super.fill(resource, doFill);
        if (ret != 0 && updateCallback != null)
            updateCallback.accept(this);
        return ret;
    }
","    public int fill(final FluidStack resource, final boolean doFill) {
        if (resource == null)
            return 0;
        if (resource.amount <= 0)
            return 0;
        int ret = super.fill(resource, doFill);
        if (ret != 0 && updateCallback != null)
            updateCallback.accept(this);
        return ret;
    }
"
1595,"This can be replaced by method reference, i.e. `pipelineFactory = Channels::pipeline`","  private ChannelPipelineFactory initChannelPipelineFactory() {
    ChannelPipelineFactory pipelineFactory;
    boolean enableCompression = compressionType.equalsIgnoreCase(""deflate"");
    if (enableCompression || enableSsl || enableIpFilter) {
      pipelineFactory = new AdvancedChannelPipelineFactory(
        enableCompression, enableSsl, keystore,
        keystorePassword, keystoreType, enableIpFilter,
        patternRuleConfigDefinition);
    } else {
      pipelineFactory = () -> Channels.pipeline();
    }
    return pipelineFactory;
  }
","  private ChannelPipelineFactory initChannelPipelineFactory() {
    ChannelPipelineFactory pipelineFactory;
    boolean enableCompression = compressionType.equalsIgnoreCase(""deflate"");
    if (enableCompression || enableSsl || enableIpFilter) {
      pipelineFactory = new AdvancedChannelPipelineFactory(
        enableCompression, enableSsl, keystore,
        keystorePassword, keystoreType, enableIpFilter,
        patternRuleConfigDefinition);
    } else {
START       pipelineFactory = () -> Channels.pipeline(); END 
    }
    return pipelineFactory;
  }
","  private ChannelPipelineFactory initChannelPipelineFactory() {
    ChannelPipelineFactory pipelineFactory;
    boolean enableCompression = compressionType.equalsIgnoreCase(""deflate"");
    if (enableCompression || enableSsl || enableIpFilter) {
      pipelineFactory = new AdvancedChannelPipelineFactory(
        enableCompression, enableSsl, keystore,
        keystorePassword, keystoreType, enableIpFilter,
        patternRuleConfigDefinition);
    } else {
      pipelineFactory = Channels::pipeline;
    }
    return pipelineFactory;
  }
"
1596,return the String in one line,"	public String getOpenPinName() {
		waitForElementByElement(pinTitle);
		String pinName = pinTitle.getText();
		return pinName;
	}
","	public String getOpenPinName() {
		waitForElementByElement(pinTitle);
		String pinName = pinTitle.getText();
START 		return pinName; END 
	}
","	public String getOpenPinName() {
		waitForElementByElement(pinTitle);
		return pinTitle.getText();
	}
"
1597,we shouldn't modify the @generated methods. I think you won't need this anyway based on what you are doing in merge(),"	public IBuildServer getServer() {
		if (parent != null) {
			return parent.getServer();
		}

		if (server != null && ((EObject) server).eIsProxy()) {
			InternalEObject oldServer = (InternalEObject) server;
			server = (IBuildServer) eResolveProxy(oldServer);
			if (server != oldServer) {
				if (eNotificationRequired()) {
					eNotify(new ENotificationImpl(this, Notification.RESOLVE, BuildPackage.BUILD_PLAN__SERVER,
							oldServer, server));
				}
			}
		}
		return server;
	}
","	public IBuildServer getServer() {
START 		if (parent != null) { END 
			return parent.getServer();
		}

		if (server != null && ((EObject) server).eIsProxy()) {
			InternalEObject oldServer = (InternalEObject) server;
			server = (IBuildServer) eResolveProxy(oldServer);
			if (server != oldServer) {
				if (eNotificationRequired()) {
					eNotify(new ENotificationImpl(this, Notification.RESOLVE, BuildPackage.BUILD_PLAN__SERVER,
							oldServer, server));
				}
			}
		}
		return server;
	}
","	public IBuildServer getServer() {
		if (server != null && ((EObject) server).eIsProxy()) {
			InternalEObject oldServer = (InternalEObject) server;
			server = (IBuildServer) eResolveProxy(oldServer);
			if (server != oldServer) {
				if (eNotificationRequired()) {
					eNotify(new ENotificationImpl(this, Notification.RESOLVE, BuildPackage.BUILD_PLAN__SERVER,
							oldServer, server));
				}
			}
		}
		return server;
	}
"
1598,"I don't think `<T extends Object>` is needed, `<T>` is enough.","   public <T extends Object> boolean contains(AttributeDefinition<T> def) {
      return contains(def.name());
   }
","START    public <T extends Object> boolean contains(AttributeDefinition<T> def) { END 
      return contains(def.name());
   }
","   public <T> boolean contains(AttributeDefinition<T> def) {
      return contains(def.name());
   }
"
1599,"`return m.method.equals(method);`, instead of this line and next?","		public boolean equals(Object o) {
			if(!(o instanceof MethodKey)) return false;
			MethodKey m = (MethodKey) o;
			if(m.k != k) return false;
			if(m.nArgs != nArgs) return false;
			if(!m.method.equals(method)) return false;
			return true;
		}
","		public boolean equals(Object o) {
			if(!(o instanceof MethodKey)) return false;
			MethodKey m = (MethodKey) o;
			if(m.k != k) return false;
			if(m.nArgs != nArgs) return false;
START 			if(!m.method.equals(method)) return false; END 
			return true;
		}
","		public boolean equals(Object o) {
			if(!(o instanceof MethodKey)) return false;
			MethodKey m = (MethodKey) o;
			if(m.k != k) return false;
			if(m.nArgs != nArgs) return false;
			return m.method.equals(method));
		}
"
1600,"Since incrementing count is the main purpose of this loop, it's better to rewrite the loop as:
for (; extRefs.hasNext(); extRefs.next()) {
    ++count;
}","	private static int countExternalReferences(PDOMBinding binding) throws Exception {
		IPDOMIterator<PDOMName> extRefs = binding.getExternalReferences();
		assertNotNull(extRefs);
		int count = 0;
		for( ; extRefs.hasNext(); ++count)
			extRefs.next();
		return count;
	}
","	private static int countExternalReferences(PDOMBinding binding) throws Exception {
		IPDOMIterator<PDOMName> extRefs = binding.getExternalReferences();
		assertNotNull(extRefs);
		int count = 0;
START 		for( ; extRefs.hasNext(); ++count) END 
			extRefs.next();
		return count;
	}
","	private static int countExternalReferences(PDOMBinding binding) throws Exception {
		IPDOMIterator<PDOMName> extRefs = binding.getExternalReferences();
		assertNotNull(extRefs);
		int count = 0;
		for( ; extRefs.hasNext(); extRefs.next())
			++count;
		return count;
	}
"
1601,"Could call the method `addCookie(String domain,....)` instead.","	public void addCookie(Cookie cookie) {
		this.cookies.add(new ZestCookie(cookie.getDomain(), cookie.getName(), cookie.getValue(),
				cookie.getPath(), cookie.getExpiryDate(), cookie.getSecure()));
	}
","	public void addCookie(Cookie cookie) {
START 		this.cookies.add(new ZestCookie(cookie.getDomain(), cookie.getName(), cookie.getValue(), END 
				cookie.getPath(), cookie.getExpiryDate(), cookie.getSecure()));
	}
","	public void addCookie(Cookie cookie) {
		addCookie(cookie.getDomain(), cookie.getName(), cookie.getValue(), cookie.getPath(), cookie.getExpiryDate(), cookie.getSecure());
	}
"
1602,please just define on the next row.,"    public void testJsonEmptyDiskDescription() throws IOException {
        String jsonDescription = null;
        jsonDescription = ImagesHandler.getJsonDiskDescription(""DiskAlias"", """");
        assertTrue(""Should be map of disk alias and disk description"",
                jsonDescription.equals(""{\""DiskDescription\"":\""\"",\""DiskAlias\"":\""DiskAlias\""}""));
    }
","    public void testJsonEmptyDiskDescription() throws IOException {
START         String jsonDescription = null; END 
        jsonDescription = ImagesHandler.getJsonDiskDescription(""DiskAlias"", """");
        assertTrue(""Should be map of disk alias and disk description"",
                jsonDescription.equals(""{\""DiskDescription\"":\""\"",\""DiskAlias\"":\""DiskAlias\""}""));
    }
","    public void testJsonEmptyDiskDescription() throws IOException {
        String jsonDescription = ImagesHandler.getJsonDiskDescription(""DiskAlias"", """");
        assertTrue(""Should be map of disk alias and disk description"",
                jsonDescription.equals(""{\""DiskDescription\"":\""\"",\""DiskAlias\"":\""DiskAlias\""}""));
    }
"
1603,remove this line,"	public void MobileLogin_003_failedLoginWrongLogin() {
		MobileBasePageObject mobile = new MobileBasePageObject(driver);
		mobile.openHome(wikiURL);
		mobile.openRandomPage();
		System.out.println(credentials.userName12);
		MobileSpecialUserLogin login = mobile.loginFailedDropDown(mobile.getTimeStamp(), mobile.getTimeStamp());
		login.verifyWrongLoginErrorMessage();
	}
","	public void MobileLogin_003_failedLoginWrongLogin() {
		MobileBasePageObject mobile = new MobileBasePageObject(driver);
		mobile.openHome(wikiURL);
		mobile.openRandomPage();
START 		System.out.println(credentials.userName12); END 
		MobileSpecialUserLogin login = mobile.loginFailedDropDown(mobile.getTimeStamp(), mobile.getTimeStamp());
		login.verifyWrongLoginErrorMessage();
	}
","	public void MobileLogin_003_failedLoginWrongLogin() {
		MobileBasePageObject mobile = new MobileBasePageObject(driver);
		mobile.openHome(wikiURL);
		mobile.openRandomPage();
		MobileSpecialUserLogin login =
				mobile.loginFailedDropDown(mobile.getTimeStamp(), mobile.getTimeStamp());
		login.verifyWrongLoginErrorMessage();
	}
"
1604,You can just use `read(long address)` here which also uses defaultReadOptions.,"    private void validateStateOfWrittenEntry(long address, @Nonnull ILogData ld) {
        ILogData logData;
        try {
            logData = read(address, defaultReadOptions);
        } catch (TrimmedException te) {
            // We cannot know if the write went through or not
            throw new UnrecoverableCorfuError(""We cannot determine state of an update because of a trim."");
        }

        if (!logData.equals(ld)){
            throw new OverwriteException(OverwriteCause.DIFF_DATA);
        }
    }
","    private void validateStateOfWrittenEntry(long address, @Nonnull ILogData ld) {
        ILogData logData;
        try {
START             logData = read(address, defaultReadOptions); END 
        } catch (TrimmedException te) {
            // We cannot know if the write went through or not
            throw new UnrecoverableCorfuError(""We cannot determine state of an update because of a trim."");
        }

        if (!logData.equals(ld)){
            throw new OverwriteException(OverwriteCause.DIFF_DATA);
        }
    }
","    private void validateStateOfWrittenEntry(long address, @Nonnull ILogData ld) {
        ILogData logData;
        try {
            logData = read(address);
        } catch (TrimmedException te) {
            // We cannot know if the write went through or not
            throw new UnrecoverableCorfuError(""We cannot determine state of an update because of a trim."");
        }

        if (!logData.equals(ld)){
            throw new OverwriteException(OverwriteCause.DIFF_DATA);
        }
    }
"
1605,"```suggestion
        rm.addRuleset(""child"", rootId, id1);
```
`child` is unused","    public void testReparentingToGrandparent() {
        RulesetModel child = rm.addRuleset(""child"", rootId, id1);
        RulesetModel grandchild = rm.addRuleset(""grandchild"", id1, id2);
        assertEquals(id1, grandchild.getParentRulesetId());

        rm.removeRuleset(id1);
        assertEquals(rootId, grandchild.getParentRulesetId());
    }
","    public void testReparentingToGrandparent() {
START         RulesetModel child = rm.addRuleset(""child"", rootId, id1); END 
        RulesetModel grandchild = rm.addRuleset(""grandchild"", id1, id2);
        assertEquals(id1, grandchild.getParentRulesetId());

        rm.removeRuleset(id1);
        assertEquals(rootId, grandchild.getParentRulesetId());
    }
","    public void testReparentingToGrandparent() {
        rm.addRuleset(""child"", rootId, id1);
        RulesetModel grandchild = rm.addRuleset(""grandchild"", id1, id2);
        assertEquals(id1, grandchild.getParentRulesetId());

        rm.removeRuleset(id1);
        assertEquals(rootId, grandchild.getParentRulesetId());
    }
"
1606,"Isn't the correct thing:

```java
if (this.mavenWorkspaceRepository == mavenWorkspaceRepository) {
  this.mavenWorkspaceRepository = null;
}
```

to properly handle replacement?","	public void unsetMavenWorkspaceRepository(MavenWorkspaceRepository mavenWorkspaceRepository) {
		this.mavenWorkspaceRepository = null;
	}
","	public void unsetMavenWorkspaceRepository(MavenWorkspaceRepository mavenWorkspaceRepository) {
START 		this.mavenWorkspaceRepository = null; END 
	}
","	public void unsetMavenWorkspaceRepository(MavenWorkspaceRepository mavenWorkspaceRepository) {
		if (this.mavenWorkspaceRepository == mavenWorkspaceRepository) {
			this.mavenWorkspaceRepository = null;
		}
	}
"
1607,You can't assert that the request count will be 2 in a base class like this. There are many mock tests that have more requests than that.,"   public void assertAuthentication(MockWebServer server) {
      assertEquals(server.getRequestCount(), 2);
      try {
         assertEquals(server.takeRequest().getRequestLine(), ""POST /tokens HTTP/1.1"");
      } catch (InterruptedException e) {
         Throwables.propagate(e);
      }
   }
","   public void assertAuthentication(MockWebServer server) {
START       assertEquals(server.getRequestCount(), 2); END 
      try {
         assertEquals(server.takeRequest().getRequestLine(), ""POST /tokens HTTP/1.1"");
      } catch (InterruptedException e) {
         Throwables.propagate(e);
      }
   }
","   public void assertAuthentication(MockWebServer server) {
      assertTrue(server.getRequestCount() >= 1);
      try {
         assertEquals(server.takeRequest().getRequestLine(), ""POST /tokens HTTP/1.1"");
      } catch (InterruptedException e) {
         Throwables.propagate(e);
      }
   }
"
1608,Again let's remove this blank lines.,"    void whenCreateLedger_thenSuccess() throws Exception {
        
        LedgerHandle lh = bk.createLedger(BookKeeper.DigestType.MAC, ledgerPassword);
        assertNotNull(lh);
        assertNotNull(lh.getId());
                
        log.info(""[I33] Ledge created: id="" + lh.getId());
    }
","    void whenCreateLedger_thenSuccess() throws Exception {
START          END 
        LedgerHandle lh = bk.createLedger(BookKeeper.DigestType.MAC, ledgerPassword);
        assertNotNull(lh);
        assertNotNull(lh.getId());
                
        log.info(""[I33] Ledge created: id="" + lh.getId());
    }
","    void whenCreateLedger_thenSuccess() throws Exception {
        LedgerHandle lh = bk.createLedger(BookKeeper.DigestType.MAC, ledgerPassword);
        assertNotNull(lh);
        assertNotNull(lh.getId());
        LOG.info(""[I33] Ledge created: id="" + lh.getId());
    }
"
1609,"HashMap is enough, here.","    public String toString() {
        Map<String, Object> display = new ConcurrentHashMap<String, Object>(this.values);
        display.remove(VALUES_KEY);
        return display.toString();
    }
","    public String toString() {
START         Map<String, Object> display = new ConcurrentHashMap<String, Object>(this.values); END 
        display.remove(VALUES_KEY);
        return display.toString();
    }
","    public String toString() {
        Map<String, Object> display = new HashMap<String, Object>(this.values);
        display.remove(VALUES_KEY);
        return display.toString();
    }
"
1610,This instance variable can be inlined.,"	public void setup() {
		openTSDBMessageFormatter = Mockito.mock(OpenTSDBMessageFormatter.class);
		writer = new TCollectorUDPWriter2(openTSDBMessageFormatter);
		outputWriter = Mockito.mock(Writer.class);
		result = Mockito.mock(Result.class);
		server = ServerFixtures.dummyServer();
	}
","	public void setup() {
		openTSDBMessageFormatter = Mockito.mock(OpenTSDBMessageFormatter.class);
		writer = new TCollectorUDPWriter2(openTSDBMessageFormatter);
		outputWriter = Mockito.mock(Writer.class);
		result = Mockito.mock(Result.class);
START 		server = ServerFixtures.dummyServer(); END 
	}
","	public void setup() {
		openTSDBMessageFormatter = Mockito.mock(OpenTSDBMessageFormatter.class);
		writer = new TCollectorUDPWriter2(openTSDBMessageFormatter);
		outputWriter = Mockito.mock(Writer.class);
		result = Mockito.mock(Result.class);
	}
"
1611,The arguments being passed should also be proceeded and followed by a space.  See line 173 as an example.,"	void addRevisionType(Element anyMapping, Element anyMappingEnd, boolean isKey) {
		final Element revTypeProperty = MetadataTools.addProperty(
				anyMapping,
				verEntCfg.getRevisionTypePropName(),
				verEntCfg.getRevisionTypePropType(),
				true,
				isKey
		);
		revTypeProperty.addAttribute( ""type"", ""org.hibernate.envers.internal.entities.RevisionTypeType"" );

        // Add further columns to the aud table
        addAdditionalColumns( anyMappingEnd );
	}
","	void addRevisionType(Element anyMapping, Element anyMappingEnd, boolean isKey) {
		final Element revTypeProperty = MetadataTools.addProperty(
				anyMapping,
				verEntCfg.getRevisionTypePropName(),
				verEntCfg.getRevisionTypePropType(),
				true,
				isKey
		);
		revTypeProperty.addAttribute( ""type"", ""org.hibernate.envers.internal.entities.RevisionTypeType"" );

        // Add further columns to the aud table
        addAdditionalColumns( anyMappingEnd );
START 	} END 
","	void addRevisionType(Element anyMapping, Element anyMappingEnd, boolean isKey) {
		final Element revTypeProperty = MetadataTools.addProperty(
				anyMapping,
				verEntCfg.getRevisionTypePropName(),
				verEntCfg.getRevisionTypePropType(),
				true,
				isKey
		);
		revTypeProperty.addAttribute( ""type"", ""org.hibernate.envers.internal.entities.RevisionTypeType"" );
	}
"
1612,Quite classy code!,"    public void walk(Consumer<Node> consumer) {
        treeIterable(TreeTraversal.PREORDER).forEach(consumer);
    }
","    public void walk(Consumer<Node> consumer) {
START         treeIterable(TreeTraversal.PREORDER).forEach(consumer); END 
    }
","    public void walk(Consumer<Node> consumer) {
        walk(PREORDER, consumer);
    }
"
1613,why not implement in ```IntSet``` methods to avoid this casts and (un)boxing?,"   public void onStateReceived(int segmentId, boolean isLastChunk) {
      if (!isCancelled && isLastChunk) {
         boolean isCompleted = false;
         synchronized (segments) {
            if (segments.contains((Object) segmentId)) {
               finishedSegments.add((Integer) segmentId);
               if (finishedSegments.size() == segments.size()) {
                  log.debugf(""Finished receiving state for segments %s"", segments);
                  isCompleted = true;
               }
            }
         }
         if (isCompleted) {
            notifyCompletion(true);
         }
      }
   }
","   public void onStateReceived(int segmentId, boolean isLastChunk) {
      if (!isCancelled && isLastChunk) {
         boolean isCompleted = false;
         synchronized (segments) {
START             if (segments.contains((Object) segmentId)) { END 
               finishedSegments.add((Integer) segmentId);
               if (finishedSegments.size() == segments.size()) {
                  log.debugf(""Finished receiving state for segments %s"", segments);
                  isCompleted = true;
               }
            }
         }
         if (isCompleted) {
            notifyCompletion(true);
         }
      }
   }
","   public void onStateReceived(int segmentId, boolean isLastChunk) {
      if (!isCancelled && isLastChunk) {
         boolean isCompleted = false;
         synchronized (segments) {
            if (segments.contains(segmentId)) {
               finishedSegments.add(segmentId);
               if (finishedSegments.size() == segments.size()) {
                  log.debugf(""Finished receiving state for segments %s"", segments);
                  isCompleted = true;
               }
            }
         }
         if (isCompleted) {
            notifyCompletion(true);
         }
      }
   }
"
1614,Unnecessary `this`.,"    public Matrix removeColumn(int j) {
        return removeColumn(j, this.factory);
    }
","    public Matrix removeColumn(int j) {
START         return removeColumn(j, this.factory); END 
    }
","    public Matrix removeColumn(int j) {
        return removeColumn(j, factory);
    }
"
1615,"This does not need to be async, or IF it should be async, it should have the same guard.

But here we really don'T do anything bad, we can and should do this without asyncExec.","	void readLogFile() {
		getDisplay().asyncExec(() -> setContentDescription(Messages.LogView_readLog_loading));
		fetchLogEntries().thenAccept(this::updateLogViewer);
	}
","	void readLogFile() {
START 		getDisplay().asyncExec(() -> END  setContentDescription(Messages.LogView_readLog_loading));
		fetchLogEntries().thenAccept(this::updateLogViewer);
	}
","	void readLogFile() {
		setContentDescription(Messages.LogView_readLog_loading);
		fetchLogEntries().thenAccept(this::updateLogViewer);
	}
"
1616,"(1) it seems like the code here won't function well when being executed by several threads simultaneously; and (2) are we sure the commands (run stateless vm in this case) behaves properly when their thread is interrupted?
I think that maybe we should not cancel running tasks and trigger a new task only if we are sure that the previous one is canceled","    public void triggerPoolMonitoringJob() {
        try {
            poolMonitoringJob.cancel(true);
        } catch (Throwable t) {
            log.debug(""Exception cancelling existing job: {}"", ExceptionUtils.getRootCauseMessage(t));
        }
        poolMonitoringJob =
                schedulerService.scheduleWithFixedDelay(
                        this::managePrestartedVmsInAllVmPools,
                        0,
                        vmPoolMonitorIntervalInMinutes,
                        TimeUnit.MINUTES);
    }
","    public void triggerPoolMonitoringJob() {
        try {
            START  poolMonitoringJob.cancel(true); END 
        } catch (Throwable t) {
            log.debug(""Exception cancelling existing job: {}"", ExceptionUtils.getRootCauseMessage(t));
        }
        poolMonitoringJob =
                schedulerService.scheduleWithFixedDelay(
                        this::managePrestartedVmsInAllVmPools,
                        0,
                        vmPoolMonitorIntervalInMinutes,
                        TimeUnit.MINUTES);
    }
","    public void triggerPoolMonitoringJob() {
        try {
            poolMonitoringJob.cancel(false);
        } catch (Throwable t) {
            log.debug(""Exception cancelling existing job: {}"", ExceptionUtils.getRootCauseMessage(t));
        }
        poolMonitoringJob =
                schedulerService.scheduleWithFixedDelay(
                        this::managePrestartedVmsInAllVmPools,
                        0,
                        vmPoolMonitorIntervalInMinutes,
                        TimeUnit.MINUTES);
    }
"
1617,Shouldn't receive a RuntimeException anymore?,"    public ITmfTrace getTrace() throws RuntimeException {
        for (ITmfTrace trace : TmfTraceManager.getInstance().getOpenedTraces()) {
            if (trace.getResource().equals(getResource())) {
                return trace;
            }
        }
        return null;
    }
","START     public ITmfTrace getTrace() throws RuntimeException { END 
        for (ITmfTrace trace : TmfTraceManager.getInstance().getOpenedTraces()) {
            if (trace.getResource().equals(getResource())) {
                return trace;
            }
        }
        return null;
    }
","    public ITmfTrace getTrace() {
        for (ITmfTrace trace : TmfTraceManager.getInstance().getOpenedTraces()) {
            if (trace.getResource().equals(getResource())) {
                return trace;
            }
        }
        return null;
    }
"
1618,Minor: I wouldn't static import these for clarity.,"    private void assertAsSetContainsAll(MetricTarget... targets) {
        assertContainsAll(asSet(targets), asList(targets));
    }
","    private void assertAsSetContainsAll(MetricTarget... targets) {
START         assertContainsAll(asSet(targets), asList(targets)); END 
    }
","    private void assertAsSetContainsAll(MetricTarget... targets) {
        assertContainsAll(MetricTarget.asSet(targets), asList(targets));
    }
"
1619,@manstis Any obscure reason to make this change? Seems like a slower iterator on a List.,"    public void appendColumn( final BaseColumn column ) throws MoveColumnVetoException {
        final MetaData metaData = new BaseColumnSynchronizer.ColumnMetaDataImpl( column );
        for ( int i = 0; i < synchronizers.size(); i++ ) {
            final Synchronizer synchronizer = synchronizers.get( i );
            if ( synchronizer.handlesAppend( metaData ) ) {
                synchronizer.append( metaData );
                break;
            }
        }
        eventBus.fireEvent( new AfterColumnInserted() );
    }
","    public void appendColumn( final BaseColumn column ) throws MoveColumnVetoException {
        final MetaData metaData = new BaseColumnSynchronizer.ColumnMetaDataImpl( column );
        for ( int i = 0; i < synchronizers.size(); i++ ) {
START             final Synchronizer synchronizer = synchronizers.get( i ); END 
            if ( synchronizer.handlesAppend( metaData ) ) {
                synchronizer.append( metaData );
                break;
            }
        }
        eventBus.fireEvent( new AfterColumnInserted() );
    }
","    public void appendColumn( final BaseColumn column ) throws MoveColumnVetoException {
        final MetaData metaData = new BaseColumnSynchronizer.ColumnMetaDataImpl( column );
        for ( Synchronizer synchronizer : synchronizers ) {
            if ( synchronizer.handlesAppend( metaData ) ) {
                synchronizer.append( metaData );
                break;
            }
        }
        eventBus.fireEvent( new AfterColumnInserted() );
    }
"
1620,"You won't need to test for the nullity of `term.getConceptSource()` if you do this:
```java
if (conceptSource.equals(term.getConceptSource())) { ...
```
Because at this point you already know that `conceptSource` is not null.","    private ConceptReferenceTerm getConceptReferenceTermByConceptSource(Concept concept, ConceptSource conceptSource) {
        Collection<ConceptMap> conceptMappings = concept.getConceptMappings();
        if(conceptMappings != null && conceptSource != null) {
            for (ConceptMap cm : conceptMappings) {
                ConceptReferenceTerm term = cm.getConceptReferenceTerm();
                if (term.getConceptSource() != null && term.getConceptSource().equals(conceptSource)) {
                    return term;
                }
            }
        }
        return null;
    }
","    private ConceptReferenceTerm getConceptReferenceTermByConceptSource(Concept concept, ConceptSource conceptSource) {
        Collection<ConceptMap> conceptMappings = concept.getConceptMappings();
        if(conceptMappings != null && conceptSource != null) {
            for (ConceptMap cm : conceptMappings) {
                ConceptReferenceTerm term = cm.getConceptReferenceTerm();
START                 if (term.getConceptSource() != null && term.getConceptSource().equals(conceptSource)) { END 
                    return term;
                }
            }
        }
        return null;
    }
","    private ConceptReferenceTerm getConceptReferenceTermByConceptSource(Concept concept, ConceptSource conceptSource) {
        Collection<ConceptMap> conceptMappings = concept.getConceptMappings();
        if(conceptMappings != null && conceptSource != null) {
            for (ConceptMap cm : conceptMappings) {
                ConceptReferenceTerm term = cm.getConceptReferenceTerm();
                if (conceptSource.equals(term.getConceptSource())) {
                    return term;
                }
            }
        }
        return null;
    }
"
1621,"@yingsu00 I don't think I understand how this works. Would you clarify? Perhaps, a unit tests would be easier to understand. What is the very long string here for?","    public void testMapSubscript()
    {
        assertQuery(""SELECT map(array[1], array['aa'])[1]"", ""SELECT 'aa'"");
        assertQuery(""SELECT map(array['a'], array['aa'])['a']"", ""SELECT 'aa'"");
        assertQuery(""SELECT map(array[array[1,1]], array['a'])[array[1,1]]"", ""SELECT 'a'"");
        assertQuery(""SELECT map(array[(1,2)], array['a'])[(1,2)]"", ""SELECT 'a'"");

        // Force the last value in the key BlockBuilder to the end of the internal Slice, so that searching for longer key values can be tested.
        // 'idv_fail' and 'request_fail' has the same hash value.
        assertQuery(""SELECT map(array['0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456', 'idv_fail'], array['aa', 'bb'])['request_fail']"", ""SELECT NULL"");
        assertQuery(""SELECT map(array['0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456', 'idv_fail'], array['aa', 'bb'])['idv_fail']"", ""SELECT 'bb'"");
    }
","    public void testMapSubscript()
    {
        assertQuery(""SELECT map(array[1], array['aa'])[1]"", ""SELECT 'aa'"");
        assertQuery(""SELECT map(array['a'], array['aa'])['a']"", ""SELECT 'aa'"");
        assertQuery(""SELECT map(array[array[1,1]], array['a'])[array[1,1]]"", ""SELECT 'a'"");
        assertQuery(""SELECT map(array[(1,2)], array['a'])[(1,2)]"", ""SELECT 'a'"");

        // Force the last value in the key BlockBuilder to the end of the internal Slice, so that searching for longer key values can be tested.
        // 'idv_fail' and 'request_fail' has the same hash value.
START         assertQuery(""SELECT map(array['0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456', 'idv_fail'], array['aa', 'bb'])['request_fail']"", ""SELECT NULL""); END 
        assertQuery(""SELECT map(array['0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456', 'idv_fail'], array['aa', 'bb'])['idv_fail']"", ""SELECT 'bb'"");
    }
","    public void testMapSubscript()
    {
        assertQuery(""SELECT map(array[1], array['aa'])[1]"", ""SELECT 'aa'"");
        assertQuery(""SELECT map(array['a'], array['aa'])['a']"", ""SELECT 'aa'"");
        assertQuery(""SELECT map(array[array[1,1]], array['a'])[array[1,1]]"", ""SELECT 'a'"");
        assertQuery(""SELECT map(array[(1,2)], array['a'])[(1,2)]"", ""SELECT 'a'"");
    }
"
1622,return descriptorToImageData.get(descriptor);,"        public ImageData getImageDataFor(ImageDescriptor descriptor) {
            if (descriptorToImageData.containsKey(descriptor)) {
                return descriptorToImageData.get(descriptor);
            }
            return null;
        }
","        public ImageData getImageDataFor(ImageDescriptor descriptor) {
           START   if (descriptorToImageData.containsKey(descriptor)) {
                return descriptorToImageData.get(descriptor);
            }
            return null; END 
        }
","        public ImageData getImageDataFor(ImageDescriptor descriptor) {
            return descriptorToImageData.get(descriptor);
        }
"
1623,"please use project formatter, this should be inside {}","    protected boolean checkCanDisableVirtIoScsi() {
        VmValidator vmValidator = createVmValidator(vmFromConfiguration);
        if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) &&
                !validate(vmValidator.canDisableVirtioScsi(getAdjustedDiskImagesFromConfiguration()))) {
            return false;
        }
        else return true;
    }
","    protected boolean checkCanDisableVirtIoScsi() {
        VmValidator vmValidator = createVmValidator(vmFromConfiguration);
        if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) &&
                !validate(vmValidator.canDisableVirtioScsi(getAdjustedDiskImagesFromConfiguration()))) {
            return false;
        }
START         else return true; END 
    }
","    protected boolean checkCanDisableVirtIoScsi() {
        VmValidator vmValidator = createVmValidator(vmFromConfiguration);
        if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) &&
                !validate(vmValidator.canDisableVirtioScsi(getAdjustedDiskImagesFromConfiguration()))) {
            return false;
        } else {
            return true;
        }
    }
"
1624,"if this.exception != null || this. response == null || !this.response.trim().startsWith(""{""){
return;
} 
try
...
catch
...","	private void doUnmarshal() {
		try {
			if(this.response != null && this.response.trim().startsWith(""{"")){
				unmarshal();
			}
		} catch (Exception e) {
			e.printStackTrace();
			if(this.exception == null){
				this.exception = e;
			}
		}
		
	}
","	private void doUnmarshal() {
START 		try { END 
			if(this.response != null && this.response.trim().startsWith(""{"")){
				unmarshal();
			}
		} catch (Exception e) {
			e.printStackTrace();
			if(this.exception == null){
				this.exception = e;
			}
		}
		
	}
","	private void doUnmarshal() {
		if (this.exception != null || this.response == null
				|| !this.response.trim().startsWith(""{"")) {
			return;
		}
		try {
			unmarshal();
		} catch (Exception e) {
			e.printStackTrace();
			if (this.exception == null) {
				this.exception = e;
			}
		}

	}
"
1625,"don't need the ""== true"", it's a boolean :-)","    private boolean validateHostsConnectionResults(List<Pair<Guid, Boolean>> hostsConnectionResults) {
        for (Pair<Guid, Boolean> hostsConnectionResult : hostsConnectionResults) {
            if (hostsConnectionResult.getSecond() == true) {
                return true;
            }
        }
        return false;
    }
","    private boolean validateHostsConnectionResults(List<Pair<Guid, Boolean>> hostsConnectionResults) {
        for (Pair<Guid, Boolean> hostsConnectionResult : hostsConnectionResults) {
START             if (hostsConnectionResult.getSecond() == true) { END 
                return true;
            }
        }
        return false;
    }
","    private boolean validateHostsConnectionResults(List<Pair<Guid, Boolean>> hostsConnectionResults) {
        for (Pair<Guid, Boolean> hostsConnectionResult : hostsConnectionResults) {
            if (hostsConnectionResult.getSecond()) {
                return true;
            }
        }
        return false;
    }
"
1626,"Here we can check if the String is empty once we change the default value using:

`if(!eventIndexName.isEmpty())`","    public String getModifiedIndex()
    {
    	Objects.requireNonNull(eventIndexName, ""null value"");
		if(!eventIndexName.equals(""netflow"")) {
    	return String.format(""%s-%s"", eventIndexName, TYPE);
		}
		return TYPE;
    }   
","    public String getModifiedIndex()
    {
    	Objects.requireNonNull(eventIndexName, ""null value"");
START 		if(!eventIndexName.equals(""netflow"")) { END 
    	return String.format(""%s-%s"", eventIndexName, TYPE);
		}
		return TYPE;
    }   
","    private String getModifiedIndex() {
        if (!eventIndexName.isEmpty()) {
            return String.format(""%s-%s"", eventIndexName, TYPE);
        }
        return TYPE;
    }
"
1627,mutationContext parameter is never used in this Class (but used in 8 method declaration). I suppose add this parameter in the future will be easier than clean up it.,"    public void applyTitle(final String title,
                           final MutationContext mutationContext) {
        if (title != null && title.trim().length() > 0 && getShapeView() instanceof HasTitle) {
            final HasTitle hasTitle = (HasTitle) getShapeView();
            hasTitle.setTitle(title);
            hasTitle.refreshTitle();
        }
    }
","    public void applyTitle(final String title,
START                            final MutationContext mutationContext) { END 
        if (title != null && title.trim().length() > 0 && getShapeView() instanceof HasTitle) {
            final HasTitle hasTitle = (HasTitle) getShapeView();
            hasTitle.setTitle(title);
            hasTitle.refreshTitle();
        }
    }
","    public void applyTitle(final String title,
                           final MutationContext mutationContext) {
        if (title != null && getShapeView() instanceof HasTitle) {
            final HasTitle hasTitle = (HasTitle) getShapeView();
            hasTitle.setTitle(title);
            hasTitle.refreshTitle();
        }
    }
"
1628,"What is the point of all these logs here? ""Flag service processing debug: PassthroughInboundAdminDistribution"" would be outputted.","    public void processAdminDistribution(EDXLDistribution body, AssertionType assertion) {
        GenericDBUtils.logInfoServiceProcess(this.getClass());
        sendToAdapter(body, assertion, adminUtils, adapterFactory);
    }
","    public void processAdminDistribution(EDXLDistribution body, AssertionType assertion) {
START         GenericDBUtils.logInfoServiceProcess(this.getClass()); END 
        sendToAdapter(body, assertion, adminUtils, adapterFactory);
    }
","    public void processAdminDistribution(EDXLDistribution body, AssertionType assertion) {
        logInfoServiceProcess(this.getClass());
        sendToAdapter(body, assertion, adminUtils, adapterFactory);
    }
"
1629,"if this is supposed to throw an exception (which i guess from the looks of this), then add a
fail statement below stating with what exception this should have thrown.","	public void testReceivedJobMessageWithWrongJobID() {
		exception.expect(IllegalStateException.class);
		JobMessage message = mock(JobMessage.class);
		when(message.getJobID()).thenReturn(JOB_ID);

		try {
			jobHandler.onJobMessage(message);
		} finally {
			verify(jobSpy, atLeast(0)).getState();
			verify(jobSpy, atLeast(0)).getJobID();
			verifyNoMoreInteractions(jobSpy);
		}
	}
","	public void testReceivedJobMessageWithWrongJobID() {
		exception.expect(IllegalStateException.class);
		JobMessage message = mock(JobMessage.class);
		when(message.getJobID()).thenReturn(JOB_ID);

		try {
START 			jobHandler.onJobMessage(message); END 
		} finally {
			verify(jobSpy, atLeast(0)).getState();
			verify(jobSpy, atLeast(0)).getJobID();
			verifyNoMoreInteractions(jobSpy);
		}
	}
","	public void testReceivedJobMessageWithWrongJobID() {
		JobMessage message = mock(JobMessage.class);
		when(message.getJobID()).thenReturn(JOB_ID);

		exception.expect(IllegalStateException.class);
		try {
			jobHandler.onJobMessage(message);
		} finally {
			verify(jobSpy, atLeast(0)).getState();
			verify(jobSpy, atLeast(0)).getJobID();
			verifyNoMoreInteractions(jobSpy);
		}
	}
"
1630,no need for explicitly using 'this',"    public UserProfile() {
        this.userPortalVmLoginAutomatically = true;
        this.sshPublicKey = """";
    }
","    public UserProfile() {
        this.userPortalVmLoginAutomatically = true;
START         this.sshPublicKey = """"; END 
    }
","    public UserProfile() {
        userPortalVmLoginAutomatically = true;
        sshPublicKey = """";
    }
"
1631,This is not needed?,"    public static void subqueryRestriction(RelNode relNode) {
      if(relNode instanceof HiveAggregate) {
        HiveAggregate aggregate = (HiveAggregate)relNode;
        if(!aggregate.getAggCallList().isEmpty() && aggregate.getGroupSet().isEmpty()) {
          throw new CalciteSubqueryRuntimeException(""Subquery rewrite: Aggregate without group by is not allowed"");
        }
      } else if(relNode instanceof HiveProject
      || relNode instanceof HiveFilter) {
        subqueryRestriction(relNode.getInput(0));
      } else {
        return;
      }
  }
","    public static void subqueryRestriction(RelNode relNode) {
      if(relNode instanceof HiveAggregate) {
        HiveAggregate aggregate = (HiveAggregate)relNode;
        if(!aggregate.getAggCallList().isEmpty() && aggregate.getGroupSet().isEmpty()) {
          throw new CalciteSubqueryRuntimeException(""Subquery rewrite: Aggregate without group by is not allowed"");
        }
      } else if(relNode instanceof HiveProject
      || relNode instanceof HiveFilter) {
        subqueryRestriction(relNode.getInput(0));
      } else {
START         return; END 
      }
  }
","  public static void subqueryRestriction(RelNode relNode) {
    if (relNode instanceof HiveAggregate) {
      HiveAggregate aggregate = (HiveAggregate) relNode;
      if (!aggregate.getAggCallList().isEmpty() && aggregate.getGroupSet().isEmpty()) {
        throw new CalciteSubqueryRuntimeException(
            ""Subquery rewrite: Aggregate without group by is not allowed"");
      }
    } else if (relNode instanceof HiveProject || relNode instanceof HiveFilter) {
      subqueryRestriction(relNode.getInput(0));
    }
  }
"
1632,"This method is called before canDoAction(), so if getDisk() is indeed null - which you check in CDA, this will result in a NullPointerException.

Instead, just get the ID from the parameters","    protected Map<String, Pair<String, String>> getExclusiveLocks() {
        if (isImageLockNeeded()) {
            return Collections.singletonMap(getDisk().getId().toString(), LockMessagesMatchUtil.DISK);
        }
        return Collections.EMPTY_MAP;
    }
","    protected Map<String, Pair<String, String>> getExclusiveLocks() {
        if (isImageLockNeeded()) {
START             return Collections.singletonMap(getDisk().getId().toString(), LockMessagesMatchUtil.DISK); END 
        }
        return Collections.EMPTY_MAP;
    }
","    protected Map<String, Pair<String, String>> getExclusiveLocks() {
        if (getDisk() != null && isImageLockNeeded()) {
            return Collections.singletonMap(getDisk().getId().toString(), LockMessagesMatchUtil.DISK);
        }
        return null;
    }
"
1633,"again: removing the explicit initialization: worse, not better","		public void run() {
			Socket socket;
			OutputStream outputStream = null;
			try {
				socket = serverSocket.accept();
				String response = getResponse(socket);
				outputStream = socket.getOutputStream();
				writeResponseHeader(outputStream);
				write(response.getBytes(), outputStream);
				outputStream.flush();
			} catch (IOException e) {
				// e.printStackTrace();
			} finally {
				// we should not close the connection, let the client close the
				// connection
				StreamUtils.quietlyClose(outputStream);
			}
		}
","		public void run() {
START 			Socket socket; END 
			OutputStream outputStream = null;
			try {
				socket = serverSocket.accept();
				String response = getResponse(socket);
				outputStream = socket.getOutputStream();
				writeResponseHeader(outputStream);
				write(response.getBytes(), outputStream);
				outputStream.flush();
			} catch (IOException e) {
				// e.printStackTrace();
			} finally {
				// we should not close the connection, let the client close the
				// connection
				StreamUtils.quietlyClose(outputStream);
			}
		}
","		public void run() {
			Socket socket = null;
			OutputStream outputStream = null;
			try {
				socket = serverSocket.accept();
				String response = getResponse(socket);
				outputStream = socket.getOutputStream();
				writeResponseHeader(outputStream);
				write(response.getBytes(), outputStream);
				outputStream.flush();
			} catch (IOException e) {
				// e.printStackTrace();
			} finally {
				// we should not close the connection, let the client close the
				// connection
				StreamUtils.quietlyClose(outputStream);
			}
		}
"
1634,"Should we also delete this rule?  IIRC the only reason we had it was to ensure already smudged entries stayed smudged.  If we change our smudge logic to be length based this no longer makes any sense, and is actually a source of bugs by always selecting modified files as potentially racily clean.","	public final boolean mightBeRacilyClean(final int smudge_s, final int smudge_ns) {
		// If the index has a modification time then it came from disk
		// and was not generated from scratch in memory. In such cases
		// the entry is 'racily clean' if the entry's cached modification
		// time is equal to or later than the index modification time. In
		// such cases the work file is too close to the index to tell if
		// it is clean or not based on the modification time alone.
		//
		final int base = infoOffset + P_MTIME;
		final int mtime = NB.decodeInt32(info, base);
		if (smudge_s < mtime)
			return true;
		if (smudge_s == mtime)
			return smudge_ns <= NB.decodeInt32(info, base + 4);
		return false;
	}
","	public final boolean mightBeRacilyClean(final int smudge_s, final int smudge_ns) {
		// If the index has a modification time then it came from disk
		// and was not generated from scratch in memory. In such cases
		// the entry is 'racily clean' if the entry's cached modification
		// time is equal to or later than the index modification time. In
		// such cases the work file is too close to the index to tell if
		// it is clean or not based on the modification time alone.
		//
		final int base = infoOffset + P_MTIME;
		final int mtime = NB.decodeInt32(info, base);
START 		if (smudge_s < mtime) END 
			return true;
		if (smudge_s == mtime)
			return smudge_ns <= NB.decodeInt32(info, base + 4);
		return false;
	}
","	public final boolean mightBeRacilyClean(final int smudge_s, final int smudge_ns) {
		// If the index has a modification time then it came from disk
		// and was not generated from scratch in memory. In such cases
		// the entry is 'racily clean' if the entry's cached modification
		// time is equal to or later than the index modification time. In
		// such cases the work file is too close to the index to tell if
		// it is clean or not based on the modification time alone.
		//
		final int base = infoOffset + P_MTIME;
		final int mtime = NB.decodeInt32(info, base);
		if (smudge_s == mtime)
			return smudge_ns <= NB.decodeInt32(info, base + 4);
		return false;
	}
"
1635,"Since init() is only called once, could we move it to start() so that start() and stop() become symmetrical?","    private void init() {
        if (mMediaPlayerList != null) {
            Log.wtfStack(TAG, ""init: The service has already been initialized"");
            return;
        }

        mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
        sDeviceMaxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);

        mMediaPlayerList = new MediaPlayerList(Looper.myLooper(), this);
        mNativeInterface = AvrcpNativeInterface.getInterface();
        mNativeInterface.init(AvrcpTargetService.this);
    }
","    START  private void init() { END 
        if (mMediaPlayerList != null) {
            Log.wtfStack(TAG, ""init: The service has already been initialized"");
            return;
        }

        mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
        sDeviceMaxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);

        mMediaPlayerList = new MediaPlayerList(Looper.myLooper(), this);
        mNativeInterface = AvrcpNativeInterface.getInterface();
        mNativeInterface.init(AvrcpTargetService.this);
    }
","    private void init() {
    }
"
1636,nit: could you please perform the release calls in a finally block so the ByteBufs get released even if the assert fails?,"    public void testByteBuf2BytesEmptyByteBuf() {
        ByteBuf buf = Unpooled.buffer();
        ArrayAsserts.assertArrayEquals(new byte[]{},
                ByteBufUtils.byteBuf2Bytes(buf));
        buf.release();
    }
","    public void testByteBuf2BytesEmptyByteBuf() {
        ByteBuf buf = Unpooled.buffer();
        ArrayAsserts.assertArrayEquals(new byte[]{},
                ByteBufUtils.byteBuf2Bytes(buf));
START         buf.release(); END 
    }
","    public void testByteBuf2BytesEmptyByteBuf() {
        ByteBuf buf = Unpooled.buffer();

        try {
            ArrayAsserts.assertArrayEquals(new byte[]{},
                    ByteBufUtils.byteBuf2Bytes(buf));
        } finally {
            buf.release();
        }
    }
"
1637,Please add braces around the if expression and reformat,"    public String getPagingData() {
    	if(getPagination() == null)
    		return """";
    	
    	return getPagination().getTag();    	
    }
","    public String getPagingData() {
START     	if(getPagination() == null) END 
    		return """";
    	
    	return getPagination().getTag();    	
    }
","    public String getPagingData() {
        if (getPagination() == null) {
            return """";
        }
        return getPagination().getTag();
    }
"
1638,"As you are calling a method in the same class you may want to drop the ""VmDeviceUtils."" prefix.","    private static boolean isBalloonEnabled(VmManagementParametersBase params) {
        Boolean balloonEnabled = params.isBalloonEnabled();
        return balloonEnabled != null ? balloonEnabled :
            VmDeviceUtils.isBalloonEnabled(params.getVmStaticData().getId());
    }
","    private static boolean isBalloonEnabled(VmManagementParametersBase params) {
        Boolean balloonEnabled = params.isBalloonEnabled();
        return balloonEnabled != null ? balloonEnabled :
START             VmDeviceUtils.isBalloonEnabled(params.getVmStaticData().getId()); END 
    }
","    private static boolean isBalloonEnabled(VmManagementParametersBase params) {
        Boolean balloonEnabled = params.isBalloonEnabled();
        return (balloonEnabled != null) ? balloonEnabled : isBalloonEnabled(params.getVmStaticData().getId());
    }
"
1639,"Three things here:
1. Why are you using `Integer.MAX_VALUE` as a magic number, instead of the (arguably more logical) `null` value to indicate a lack of location fix?  (You would obviously need to change the return type to be an `Integer` object rather than an `int` primitive.)
2. Formatting.  Yuck!
3. Why not just return from the if branch; do away with the else branch, and return inline instead of having a `fromEnd` variable?","  private int distanceUntilTurn() {
    final GeoPoint whereIam = whereIAm();
    final int fromEnd;
    if (whereIam == null) {
       fromEnd = Integer.MAX_VALUE;}
    else {
      // Get distance to end of active segment
      final Segment activeSeg = Route.journey().activeSegment();
      fromEnd = activeSeg.distanceFromEnd(whereIam);
    }
    return fromEnd;
  }
","  private int distanceUntilTurn() {
    final GeoPoint whereIam = whereIAm();
    final int fromEnd;
    if (whereIam == null) {
START        fromEnd = Integer.MAX_VALUE;} END 
    else {
      // Get distance to end of active segment
      final Segment activeSeg = Route.journey().activeSegment();
      fromEnd = activeSeg.distanceFromEnd(whereIam);
    }
    return fromEnd;
  }
","  private Integer distanceUntilTurn() {
    final GeoPoint whereIam = whereIAm();
    if (whereIam != null) {
      // Get distance to end of active segment
      final Segment activeSeg = Route.journey().activeSegment();
      return activeSeg.distanceFromEnd(whereIam);
    }
    return null;
  }
"
1640,"yes, we already knew that","    public void transformSlope(){
        final ITmfTimestampTransform slope = TimestampTransformFactory.create(10, 0);
        assertEquals(t1e3, slope.transform(t1e2));
        assertEquals(tn100, slope.transform(new TmfNanoTimestamp(10)));

        assertEquals(tn100, slope.transform(slope.transform(tn1)));
        assertEquals(tn100, slope.transform(slope.transform(tn1)));
        assertEquals(tn100, slope.composeWith(slope).transform(tn1));
    }
","    public void transformSlope(){
        final ITmfTimestampTransform slope = TimestampTransformFactory.create(10, 0);
        assertEquals(t1e3, slope.transform(t1e2));
        assertEquals(tn100, slope.transform(new TmfNanoTimestamp(10)));

        assertEquals(tn100, slope.transform(slope.transform(tn1)));
START         assertEquals(tn100, slope.transform(slope.transform(tn1))); END 
        assertEquals(tn100, slope.composeWith(slope).transform(tn1));
    }
","    public void transformSlope(){
        final ITmfTimestampTransform slope = TimestampTransformFactory.create(10, 0);
        assertEquals(t1e3, slope.transform(t1e2));
        assertEquals(tn100, slope.transform(new TmfNanoTimestamp(10)));
        assertEquals(tn100, slope.transform(slope.transform(tn1)));
        assertEquals(tn100, slope.composeWith(slope).transform(tn1));
    }
"
1641,Looks like the worst that could happen is that the values in the log message are not precise,"    boolean isBitrateImproving(int newBitrateBps)
    {
        synchronized (critSect)
        {
            boolean initialProbe = !remoteRate.isValidEstimate()
                    && newBitrateBps > 0;
            boolean bitrateAboveEstimate =
                    remoteRate.isValidEstimate() &&
                            newBitrateBps > (int) (remoteRate
                                    .getLatestEstimate());
            return initialProbe || bitrateAboveEstimate;
        }
    }
","    boolean isBitrateImproving(int newBitrateBps)
    {
        synchronized (critSect)
        {
            boolean initialProbe = !remoteRate.isValidEstimate()
                    && newBitrateBps > 0;
            boolean bitrateAboveEstimate =
                    remoteRate.isValidEstimate() &&
                            newBitrateBps > (int) (remoteRate
                                    .getLatestEstimate());
START             return initialProbe || bitrateAboveEstimate; END 
        }
    }
","    private boolean isBitrateImproving(int newBitrateBps)
    {
        synchronized (critSect)
        {
            boolean initialProbe = !remoteRate.isValidEstimate()
                    && newBitrateBps > 0;
            boolean bitrateAboveEstimate =
                    remoteRate.isValidEstimate() &&
                            newBitrateBps > (int) (remoteRate
                                    .getLatestEstimate());
            return initialProbe || bitrateAboveEstimate;
        }
    }
"
1642,It would be rather preferable to create a new method with error propagation,"    public COL get() {
        // load upon the first use
        if (parsed==null) {
            synchronized (this) {
                if (parsed==null) {
                    try {
                        load();
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        }
        return parsed;
    }
","    public COL get() {
        // load upon the first use
        if (parsed==null) {
            synchronized (this) {
                if (parsed==null) {
                    try {
                        load();
                    } catch (IOException e) {
START                         throw new RuntimeException(e); END 
                    }
                }
            }
        }
        return parsed;
    }
","    public COL get() {
        // load upon the first use
        if (parsed==null) {
            synchronized (this) {
                if (parsed==null) {
                    load();
                }
            }
        }
        return parsed;
    }
"
1643,"why not private? it is only used by the private method synchCTFState.

I would place the new method below synchCTFState.

I don't get really why the findElements() method does not what you need here. Both do a recursive search for MPartStack in areaModel.

Maybe EModelServiceFindTest could be extended to check your use case?","	protected List<MPartStack> findDirectStacks(MPartSashContainer root) {
		List<MPartStack> result = new ArrayList<>();
		for (MPartSashContainerElement e : root.getChildren()) {
			if (e instanceof MPartStack) {
				result.add((MPartStack) e);
			} else if (e instanceof MPartSashContainer) {
				result.addAll(findDirectStacks((MPartSashContainer) e));
			}
		}
		return result;
	}
","START 	protected List<MPartStack> findDirectStacks(MPartSashContainer root) { END 
		List<MPartStack> result = new ArrayList<>();
		for (MPartSashContainerElement e : root.getChildren()) {
			if (e instanceof MPartStack) {
				result.add((MPartStack) e);
			} else if (e instanceof MPartSashContainer) {
				result.addAll(findDirectStacks((MPartSashContainer) e));
			}
		}
		return result;
	}
","	private List<MPartStack> findDirectStacks(MPartSashContainer root) {
		List<MPartStack> result = new ArrayList<>();
		for (MPartSashContainerElement e : root.getChildren()) {
			if (e instanceof MPartStack) {
				result.add((MPartStack) e);
			} else if (e instanceof MPartSashContainer) {
				result.addAll(findDirectStacks((MPartSashContainer) e));
			}
		}
		return result;
	}
"
1644,Can be simplified to `AutomaticProvisioningStatus.ENABLED.equals(getAutomaticProvisioning());`,"    public boolean isAutomaticProvisioningEnabled () {
        return AutomaticProvisioningStatus.ENABLED.equals(getAutomaticProvisioning()) ? true : false;
    }
","    public boolean isAutomaticProvisioningEnabled () {
START         return AutomaticProvisioningStatus.ENABLED.equals(getAutomaticProvisioning()) ? true : false; END 
    }
","    public boolean isAutomaticProvisioningEnabled () {
        return AutomaticProvisioningStatus.ENABLED.equals(getAutomaticProvisioning());
    }
"
1645,"Sorry that I missed a case. If we poll `null`, we should not increment `capacity`.","        public Object poll() {
            Object value = queue.poll();
            if (capacity != null) {
                capacity.incrementAndGet();
            }
            return value;
        }
","        public Object poll() {
            Object value = queue.poll();
START             if (capacity != null) { END 
                capacity.incrementAndGet();
            }
            return value;
        }
","        public Object poll() {
            Object value = queue.poll();
            if (capacity != null && value != null) {
                capacity.incrementAndGet();
            }
            return value;
        }
"
1646,This becomes unreadable with so many chain of logic operations and ternary blocks. I believe proper if statements would be preferred and more readable,"  public String query() {
    if (query == null) {
      synchronized (conn) {
        if (query == null) {
          query = path() == uri || queryStart == -1 ? null : queryStart > 0 && uri.length() > queryStart
            ? uri.substring(queryStart + 1) : HttpUtils.parseQuery(uri);
        }
      }
    }
    return query;
  }
","START   public String query() { END 
    if (query == null) {
      synchronized (conn) {
        if (query == null) {
          query = path() == uri || queryStart == -1 ? null : queryStart > 0 && uri.length() > queryStart
            ? uri.substring(queryStart + 1) : HttpUtils.parseQuery(uri);
        }
      }
    }
    return query;
  }
","  public String query() {
    if (query == null && uri != null) {
          query = path() == uri || queryStart == -1 ? null : queryStart > 0 && uri.length() > queryStart
            ? uri.substring(queryStart + 1) : HttpUtils.parseQuery(uri);
    }
    return query;
  }
"
1647,"You could also do:

    PropertyValue propertyValue = super.getValue(propertyReference, documentReference);

just to be sure we don't miss something from the base class. It also makes it more clear that the reason we overwrite the implementation from the base class is because we want to change the input raw value and we want to add more information to the returned property value.","    public PropertyValue getValue(ClassPropertyReference propertyReference, Object rawValue)
        throws XWikiRestException
    {
        String reference = """";
        if (rawValue != null) {
            reference = rawValue.toString();
        }
        if (StringUtils.isEmpty(reference)) {
            return null;
        }

        DocumentReference documentReference = documentReferenceResolver.resolve(reference, EntityType.DOCUMENT);
        PropertyValue propertyValue =
            this.getValueFromQueryResult(documentReference, getPropertyDefinition(propertyReference));
        if (propertyValue != null) {
            propertyValue.setValue(reference);
        }

        return propertyValue;
    }
","    public PropertyValue getValue(ClassPropertyReference propertyReference, Object rawValue)
        throws XWikiRestException
    {
        String reference = """";
        if (rawValue != null) {
            reference = rawValue.toString();
        }
        if (StringUtils.isEmpty(reference)) {
            return null;
        }

        DocumentReference documentReference = documentReferenceResolver.resolve(reference, EntityType.DOCUMENT);
        PropertyValue propertyValue =
START             this.getValueFromQueryResult(documentReference, getPropertyDefinition(propertyReference)); END 
        if (propertyValue != null) {
            propertyValue.setValue(reference);
        }

        return propertyValue;
    }
","    public PropertyValue getValue(ClassPropertyReference propertyReference, Object rawValue)
        throws XWikiRestException
    {
        String reference = """";
        if (rawValue != null) {
            reference = rawValue.toString();
        }
        if (StringUtils.isEmpty(reference)) {
            return null;
        }

        DocumentReference documentReference = documentReferenceResolver.resolve(reference, EntityType.DOCUMENT);
        PropertyValue propertyValue = super.getValue(propertyReference, documentReference);
        if (propertyValue != null) {
            propertyValue.setValue(reference);
        }

        return propertyValue;
    }
"
1648,double parantheses should be obsolete here,"	public boolean performPaste(Object target, ISelection selection) {
		if (target instanceof IBreakpointContainer && selection instanceof IStructuredSelection) {
			IBreakpointContainer container = (IBreakpointContainer) target;
			for (Object object : ((IStructuredSelection)selection)) {
				IBreakpoint breakpoint = (IBreakpoint)DebugPlugin.getAdapter(object, IBreakpoint.class);
				if (breakpoint != null) {
					container.getOrganizer().addBreakpoint(breakpoint, container.getCategory());
				}
			}
			return true;
		}
		return false;
	}
","	public boolean performPaste(Object target, ISelection selection) {
		if (target instanceof IBreakpointContainer && selection instanceof IStructuredSelection) {
			IBreakpointContainer container = (IBreakpointContainer) target;
			for (Object object : START  ((IStructuredSelection)selection)) END  {
				IBreakpoint breakpoint = (IBreakpoint)DebugPlugin.getAdapter(object, IBreakpoint.class);
				if (breakpoint != null) {
					container.getOrganizer().addBreakpoint(breakpoint, container.getCategory());
				}
			}
			return true;
		}
		return false;
	}
","	public boolean performPaste(Object target, ISelection selection) {
		if (target instanceof IBreakpointContainer && selection instanceof IStructuredSelection) {
			IBreakpointContainer container = (IBreakpointContainer) target;
			for (Object object : (IStructuredSelection) selection) {
				IBreakpoint breakpoint = (IBreakpoint)DebugPlugin.getAdapter(object, IBreakpoint.class);
				if (breakpoint != null) {
					container.getOrganizer().addBreakpoint(breakpoint, container.getCategory());
				}
			}
			return true;
		}
		return false;
	}
"
1649,Why are we only adding this to this error message only?,"    public static Node createInvalidType(Node node, NodeType type)
    {
        StringBuilder message = new StringBuilder(""Invalid type "" + node.getType() + "", expected "" + type);
        if (node.getParent() != null && node.getParent() instanceof KeyValueNode)
        {
            message.append("" (key: \"""" + ((KeyValueNode) node.getParent()).getKey() + ""\"")"");
        }

        return new ErrorNode(message.toString());
    }
","    public static Node createInvalidType(Node node, NodeType type)
    {
        StringBuilder message = new StringBuilder(""Invalid type "" + node.getType() + "", expected "" + type);
        if (node.getParent() != null && node.getParent() instanceof KeyValueNode)
        {
START             message.append("" (key: \"""" + ((KeyValueNode) node.getParent()).getKey() + ""\"")""); END 
        }

        return new ErrorNode(message.toString());
    }
","    public static Node createInvalidType(Node node, NodeType type)
    {
        return new ErrorNode(""Invalid type "" + node.getType() + "", expected "" + type);
    }
"
1650,printing out stack trace is not needed,"  public static File getHadoopTokens(HadoopSecurityManager hadoopSecurityManager, Props props,
          Logger log) throws HadoopSecurityManagerException {

    File tokenFile = null;
    try {
      tokenFile = File.createTempFile(""mr-azkaban"", "".token"");
    } catch (Exception e) {
      e.printStackTrace();
      throw new HadoopSecurityManagerException(""Failed to create the token file."", e);
    }

    hadoopSecurityManager.prefetchToken(tokenFile, props, log);

    return tokenFile;
  }
","  public static File getHadoopTokens(HadoopSecurityManager hadoopSecurityManager, Props props,
          Logger log) throws HadoopSecurityManagerException {

    File tokenFile = null;
    try {
      tokenFile = File.createTempFile(""mr-azkaban"", "".token"");
    } catch (Exception e) {
START       e.printStackTrace(); END 
      throw new HadoopSecurityManagerException(""Failed to create the token file."", e);
    }

    hadoopSecurityManager.prefetchToken(tokenFile, props, log);

    return tokenFile;
  }
","  public static File getHadoopTokens(HadoopSecurityManager hadoopSecurityManager, Props props,
          Logger log) throws HadoopSecurityManagerException {

    File tokenFile = null;
    try {
      tokenFile = File.createTempFile(""mr-azkaban"", "".token"");
    } catch (Exception e) {
      throw new HadoopSecurityManagerException(""Failed to create the token file."", e);
    }

    hadoopSecurityManager.prefetchToken(tokenFile, props, log);

    return tokenFile;
  }
"
1651,Reverse order.,"  public void tearDown() throws Exception {
    super.tearDown();
    lfuJedis.disconnect();
  }
","  public void tearDown() throws Exception {
START     super.tearDown();
    lfuJedis.disconnect(); END 
  }
","  public void tearDown() throws Exception {
    lfuJedis.disconnect();
    super.tearDown();
  }
"
1652,"Rather than changing the contract that all other compilers match, perhaps follow existing pattern and pass 
`new String[] {}`","  protected AbstractProcessor(final String[] sourceExtensions, final String[] headerExtensions) {
    this.sourceExtensions = sourceExtensions.clone();
      if(headerExtensions != null)
      {
          this.headerExtensions = (String[]) headerExtensions.clone();
      }
      else
      {
          this.headerExtensions = null;
      }


  }
","  protected AbstractProcessor(final String[] sourceExtensions, final String[] headerExtensions) {
    this.sourceExtensions = sourceExtensions.clone();
START       if(headerExtensions != null) END 
      {
          this.headerExtensions = (String[]) headerExtensions.clone();
      }
      else
      {
          this.headerExtensions = null;
      }


  }
","  protected AbstractProcessor(final String[] sourceExtensions, final String[] headerExtensions) {
    this.sourceExtensions = sourceExtensions.clone();
    this.headerExtensions = headerExtensions.clone();
  }
"
1653,IMO this should move to the presenter in the first place.. i.e. where you call ```view.init( this )``` add the next line that calls ```if(this.canUpdateProject()) { view.enableAddAssetButton( false ); }```,"    public void init(EmptyAssetsScreen presenter) {
        this.presenter = presenter;
        if (!this.presenter.canUpdateProject()) {
            this.addAsset.disabled = true;
        }
    }
","    public void init(EmptyAssetsScreen presenter) {
        this.presenter = presenter;
START         if (!this.presenter.canUpdateProject()) { END 
            this.addAsset.disabled = true;
        }
    }
","    public void init(EmptyAssetsScreen presenter) {
        this.presenter = presenter;
    }
"
1654,"можно просто не указывать настройку sentry.dsn
либо явно указать протокол noop:// (https://github.com/getsentry/sentry-java/blob/master/sentry/src/main/java/io/sentry/dsn/Dsn.java#L21) — он используется по умолчанию
думаю, не стоит поверх этого наворачивать ещё какую-то нашу собственную логику

даже без явного вызова Sentry.init сентри все равно будет автоматически инициализировать клиент (и искать dsn в параметрах jvm или энв-переменных), поэтому доп. логика с none может привести к странному поведению","  public static void configureSentry(ApplicationContext context) {
    FileSettings settings = context.getBean(FileSettings.class);
    String sentryDsn = ofNullable(settings.getString(""sentry.dsn"")).orElse(""none"");
    if (!sentryDsn.equals(""none"")) {
      Sentry.init(sentryDsn);
    }
  }
","  public static void configureSentry(ApplicationContext context) {
    FileSettings settings = context.getBean(FileSettings.class);
START     String sentryDsn = ofNullable(settings.getString(""sentry.dsn"")).orElse(""none""); END 
    if (!sentryDsn.equals(""none"")) {
      Sentry.init(sentryDsn);
    }
  }
","  public static void configureSentry(ApplicationContext context) {
    FileSettings settings = context.getBean(FileSettings.class);
    Sentry.init(settings.getString(""sentry.dsn""));
  }
"
1655,"We don't use `this"" for methods.","	public RequestMatcher value(String parameter, String... expectedValues) {
		List<Matcher<? super String>> matcherList = Arrays.stream(expectedValues)
				.map(Matchers::equalTo)
				.collect(Collectors.toList());

		return this.value(parameter, matcherList);
	}
","	public RequestMatcher value(String parameter, String... expectedValues) {
		List<Matcher<? super String>> matcherList = Arrays.stream(expectedValues)
				.map(Matchers::equalTo)
				.collect(Collectors.toList());

START 		return this.value(parameter, matcherList); END 
	}
","	public RequestMatcher value(String parameter, String... expectedValues) {
		List<Matcher<? super String>> matcherList = Arrays.stream(expectedValues)
				.map(Matchers::equalTo)
				.collect(Collectors.toList());

		return value(parameter, matcherList);
	}
"
1656,I think it would be better to have this call at the end of the `ObjCClass.register()` method. Just after the `ObjCClass` instance is created.,"    private ObjCClass(long handle, Class<? extends ObjCObject> type, String name, boolean custom) {
        super(handle, false);
        this.type = type;
        this.name = name;
        this.custom = custom;
        
        if (custom) {
            ObjCObject.ObjectOwnershipHelper.registerClass(this);
        }
    }
","    private ObjCClass(long handle, Class<? extends ObjCObject> type, String name, boolean custom) {
        super(handle, false);
        this.type = type;
        this.name = name;
        this.custom = custom;
        
        if (custom) {
START             ObjCObject.ObjectOwnershipHelper.registerClass(this); END 
        }
    }
","    private ObjCClass(long handle, Class<? extends ObjCObject> type, String name, boolean custom) {
        super(handle, false);
        this.type = type;
        this.name = name;
        this.custom = custom;
    }
"
1657,why flip the `||`?,"    private static boolean inSameSubtree(long bitsA, long bitsB, int level)
    {
        return (bitsA >>> level) == (bitsB >>> level) || level == MAX_BITS;
    }
","    private static boolean inSameSubtree(long bitsA, long bitsB, int level)
    {
START         return (bitsA >>> level) == (bitsB >>> level) || level == MAX_BITS; END 
    }
","    private static boolean inSameSubtree(long bitsA, long bitsB, int level)
    {
        return level == MAX_BITS || (bitsA >>> level) == (bitsB >>> level);
    }
"
1658,"nit: `allReplicas` and `totalReplicas` names are used for the same thing, maybe we should normalize it?","  private ReplicationFactor(int allReplicas, int transientReplicas) {
    this.allReplicas = allReplicas;
    this.fullReplicas = allReplicas - transientReplicas;
  }
","START   private ReplicationFactor(int allReplicas, int transientReplicas) { END 
    this.allReplicas = allReplicas;
    this.fullReplicas = allReplicas - transientReplicas;
  }
","  public ReplicationFactor(int allReplicas, int transientReplicas) {
    this.allReplicas = allReplicas;
    this.transientReplicas = transientReplicas;
    this.fullReplicas = allReplicas - transientReplicas;
  }
"
1659,consider to use CollectionUtils,"    protected static void assertAttAuthzStatements(final Assertion assertion) throws WSSecurityException {
        if (CollectionUtils.isEmpty(assertion.getAttributeStatements())
            && (assertion.getAuthnStatements() == null || assertion.getAuthnStatements().isEmpty())) {
            assertAuthzDecisionStatements(assertion);
        }

    }
","    protected static void assertAttAuthzStatements(final Assertion assertion) throws WSSecurityException {
        if (CollectionUtils.isEmpty(assertion.getAttributeStatements())
START             && (assertion.getAuthnStatements() == null || assertion.getAuthnStatements().isEmpty())) { END 
            assertAuthzDecisionStatements(assertion);
        }

    }
","    protected static void assertAttAuthzStatements(final Assertion assertion) throws WSSecurityException {
        if (CollectionUtils.isEmpty(assertion.getAttributeStatements())
            && CollectionUtils.isEmpty(assertion.getAuthnStatements())) {
            assertAuthzDecisionStatements(assertion);
        }

    }
"
1660,"This stuff would benefit..from a Builder maybe, with defaults in it. What do you think? ;p","    private void newTestSubject(int cachedEvents, long fetchDelay, long cleanupDelay) {
        Optional.ofNullable(testSubject).ifPresent(EmbeddedEventStore::shutDown);
        testSubject = new EmbeddedEventStore(storageEngine, NoOpMessageMonitor.INSTANCE, cachedEvents, fetchDelay,
                                             cleanupDelay, MILLISECONDS, SnapshotResolver.lastSnapshotResolver());
    }
","    private void newTestSubject(int cachedEvents, long fetchDelay, long cleanupDelay) {
        Optional.ofNullable(testSubject).ifPresent(EmbeddedEventStore::shutDown);
        testSubject = new EmbeddedEventStore(storageEngine, NoOpMessageMonitor.INSTANCE, cachedEvents, fetchDelay,
START                                              cleanupDelay, MILLISECONDS, SnapshotResolver.lastSnapshotResolver()); END 
    }
","    private void newTestSubject(int cachedEvents, long fetchDelay, long cleanupDelay) {
        Optional.ofNullable(testSubject).ifPresent(EmbeddedEventStore::shutDown);
        testSubject = new EmbeddedEventStore(storageEngine, NoOpMessageMonitor.INSTANCE, cachedEvents, fetchDelay,
                                             cleanupDelay, MILLISECONDS);
    }
"
1661,can project.getParent() be null?,"    private MavenProject getSiblingModule(Artifact artifact) {
        @SuppressWarnings(""unchecked"")
        List<MavenProject> modules = (List<MavenProject>)project.getParent().getModules();
        for (MavenProject module : modules) {
            if (module.getId().equals(artifact.getId())) {
                return module;
            }
        }
        return null;
    }
","    private MavenProject getSiblingModule(Artifact artifact) {
        @SuppressWarnings(""unchecked"")
START         List<MavenProject> modules = (List<MavenProject>)project.getParent().getModules(); END 
        for (MavenProject module : modules) {
            if (module.getId().equals(artifact.getId())) {
                return module;
            }
        }
        return null;
    }
","    private MavenProject getSiblingModule(Artifact artifact) {
        if (project.getParent() == null) {
            return null;
        }
        @SuppressWarnings(""unchecked"")
        List<MavenProject> modules = (List<MavenProject>)project.getParent().getModules();
        for (MavenProject module : modules) {
            if (module.getId().equals(artifact.getId())) {
                return module;
            }
        }
        return null;
    }
"
1662,it doesn't seem right to do this here.... why a getter triggers node visitation? Aren't we visiting twice these nodes by doing this?,"    private ASTArgumentList getArgumentList(ASTArguments args) {
        if (args != null) {
            super.visit(args, null);
            return args.getFirstChildOfType(ASTArgumentList.class);
        }

        return null;
    }
","    private ASTArgumentList getArgumentList(ASTArguments args) {
        if (args != null) {
START             super.visit(args, null); END 
            return args.getFirstChildOfType(ASTArgumentList.class);
        }

        return null;
    }
","    private ASTArgumentList getArgumentList(ASTArguments args) {
        if (args != null) {
            return args.getFirstChildOfType(ASTArgumentList.class);
        }

        return null;
    }
"
1663,"This should probably be `return MAX_VALUE`, to prevent cycling the step size back to zero. And below should be `return MIN_VALUE`","    public Object getNextValue() {
        double value = (double) getValue();
        double stepSize = MAX_VALUE;
        while (stepSize >= MIN_VALUE) {
            if (value >= stepSize) {
                break;
            } else {
                stepSize = stepSize / 10;
            }
        }

        if( value >= MAX_VALUE) {
            return 0;
        }
        return value + stepSize;
    }
","    public Object getNextValue() {
        double value = (double) getValue();
        double stepSize = MAX_VALUE;
        while (stepSize >= MIN_VALUE) {
            if (value >= stepSize) {
                break;
            } else {
                stepSize = stepSize / 10;
            }
        }

        if( value >= MAX_VALUE) {
START             return 0; END 
        }
        return value + stepSize;
    }
","    public Object getNextValue() {
        double value = (double) getValue();
        double stepSize = MAX_VALUE;
        while (stepSize >= MIN_VALUE) {
            if (value >= stepSize) {
                break;
            } else {
                stepSize = stepSize / 10;
            }
        }

        if( value >= MAX_VALUE) {
            return null;
        }
        return value + stepSize;
    }
"
1664,"I don't think we need that if we drop the support for expression parameters as repository method parameters, right?","	protected Object computeParameterValue(JpaParameter parameter, Object value, Object[] values) {
		return value;
	}
","START 	protected Object computeParameterValue(JpaParameter parameter, Object value, Object[] values) { END 
		return value;
	}
","	private Object computeParameterValue(JpaParameter parameter, Object value, Object[] values) {
		return value;
	}
"
1665,Remove that on before merging.,"	public AbstractRepositoryRestController(PagedResourcesAssembler<Object> assembler,
			PersistentEntityResourceAssembler<Object> entityResourceAssembler) {

		System.out.println(""Registering "" + this.getClass() + "" controller..."");

		this.assembler = assembler;
		this.perAssembler = entityResourceAssembler;
	}
","	public AbstractRepositoryRestController(PagedResourcesAssembler<Object> assembler,
			PersistentEntityResourceAssembler<Object> entityResourceAssembler) {

START 		System.out.println(""Registering "" + this.getClass() + "" controller...""); END 

		this.assembler = assembler;
		this.perAssembler = entityResourceAssembler;
	}
","	public AbstractRepositoryRestController(PagedResourcesAssembler<Object> assembler,
			PersistentEntityResourceAssembler<Object> entityResourceAssembler) {

		this.assembler = assembler;
		this.perAssembler = entityResourceAssembler;
	}
"
1666,"I thought we did not have the processDefinitionId in the extensions json
I thought we had only the process definition key in the extensions json

And that's why yesterday in this class we tried to look up by key(and not by id like in the past)

What am i missing?","    private Optional<Map<String, VariableDefinition>> getVariableDefinitionMap(String processDefinitionId) {
        ProcessExtensionModel processExtensionModel = processDefinitionId != null ?
                                                      processExtensionService.getExtensionsForId(processDefinitionId) :
                                                      null;

        return Optional.ofNullable(processExtensionModel)
                .map(p -> p.getExtensionsByProcessDefinitionId(processDefinitionId))
                .map(Extension::getProperties);
    }
","    private Optional<Map<String, VariableDefinition>> getVariableDefinitionMap(String processDefinitionId) {
        ProcessExtensionModel processExtensionModel = processDefinitionId != null ?
                                                      processExtensionService.getExtensionsForId(processDefinitionId) :
                                                      null;

        return Optional.ofNullable(processExtensionModel)
START                 .map(p -> p.getExtensionsByProcessDefinitionId(processDefinitionId)) END 
                .map(Extension::getProperties);
    }
","    private Optional<Map<String, VariableDefinition>> getVariableDefinitionMap(String processDefinitionId) {
        Extension processExtensionModel = processDefinitionId != null ?
                                                      processExtensionService.getExtensionsForId(processDefinitionId) :
                                                      null;

        return Optional.ofNullable(processExtensionModel)
                .map(Extension::getProperties);
    }
"
1667,is this necessary?,"  protected void checkStarted() throws StoreException {
    if (!started) {
      throw new StoreException(""Store not started"", StoreErrorCodes.Store_Not_Started);
    }
  }
","START   protected void checkStarted() throws StoreException { END 
    if (!started) {
      throw new StoreException(""Store not started"", StoreErrorCodes.Store_Not_Started);
    }
  }
","  private void checkStarted() throws StoreException {
    if (!started) {
      throw new StoreException(""Store not started"", StoreErrorCodes.Store_Not_Started);
    }
  }
"
1668,Should you be closing the connection as well? What happens if the caller attempts to execute query after closing the prepstmt,"    public void close() throws SQLException
    {
        if (hpccConnection != null)
        {
            hpccConnection.close();
            hpccConnection = null;
        }

        if (result != null)
        {
            result.close();
            result = null;
        }

        sqlQuery = """";
        dbMetadata = null;
        closed = true;
        parameters = null;
        parser = null;
        eclQuery = null;
    }
","    public void close() throws SQLException
    {
        if (hpccConnection != null)
        {
START             hpccConnection.close(); END 
            hpccConnection = null;
        }

        if (result != null)
        {
            result.close();
            result = null;
        }

        sqlQuery = """";
        dbMetadata = null;
        closed = true;
        parameters = null;
        parser = null;
        eclQuery = null;
    }
","    public void close() throws SQLException
    {
        if (!closed)
        {
            closed = true;
            hpccConnection = null;
            result = null;
            sqlQuery = null;
            dbMetadata = null;
            parameters = null;
            parser = null;
            eclQuery = null;
        }
    }
"
1669,"toCss() already escape the String, no need to escape it again.","    public String getExpression() {
      // The escaped CSS content has to be escaped to be a valid Java literal
      return ""\"""" + Generator.escape(toCss()) + ""\"""";
    }
","    public String getExpression() {
      // The escaped CSS content has to be escaped to be a valid Java literal
START       return ""\"""" + Generator.escape(toCss()) + ""\""""; END 
    }
","    public String getExpression() {
      // The escaped CSS content has to be escaped to be a valid Java literal
      return ""\"""" + toCss() + ""\"""";
    }
"
1670,"there is another class named IndexingServiceFirehoseModule, 
wondering if we can just delete that class and use FireshoseModule in indexing service also.","  public List<? extends Module> getJacksonModules()
  {
    return Arrays.<Module>asList(
        new SimpleModule(""FirehoseModule"")
            .registerSubtypes(
                new NamedType(ClippedFirehoseFactory.class, ""clipped""),
                new NamedType(TimedShutoffFirehoseFactory.class, ""timed""),
                new NamedType(IrcFirehoseFactory.class, ""irc""),
                new NamedType(LocalFirehoseFactory.class, ""local""),
                new NamedType(ProtoBufInputRowParser.class, ""protobuf""),
                new NamedType(EventReceiverFirehoseFactory.class, ""receiver"")
            )
    );
  }
","  public List<? extends Module> getJacksonModules()
  {
    return Arrays.<Module>asList(
        new SimpleModule(""FirehoseModule"")
            .registerSubtypes(
                new NamedType(ClippedFirehoseFactory.class, ""clipped""),
                new NamedType(TimedShutoffFirehoseFactory.class, ""timed""),
                new NamedType(IrcFirehoseFactory.class, ""irc""),
                new NamedType(LocalFirehoseFactory.class, ""local""),
                new NamedType(ProtoBufInputRowParser.class, ""protobuf""),
START                 new NamedType(EventReceiverFirehoseFactory.class, ""receiver"") END 
            )
    );
  }
","  public List<? extends Module> getJacksonModules()
  {
    return Arrays.<Module>asList(
        new SimpleModule(""FirehoseModule"")
            .registerSubtypes(
                new NamedType(ClippedFirehoseFactory.class, ""clipped""),
                new NamedType(TimedShutoffFirehoseFactory.class, ""timed""),
                new NamedType(IrcFirehoseFactory.class, ""irc""),
                new NamedType(LocalFirehoseFactory.class, ""local""),
                new NamedType(EventReceiverFirehoseFactory.class, ""receiver"")
            )
    );
  }
"
1671,Same question here,"	protected void handleDemandLoadException(Resource resource, IOException exception) {
		try {
			super.handleDemandLoadException(resource, exception);
			// CHECKSTYLE:OFF
		} catch (Exception e) {
			// CHECKSTYLE:ON
			// do nothing. The errors are added to the Resource#getErrors() in super().
		}
	}
","	protected void handleDemandLoadException(Resource resource, IOException exception) {
		try {
			super.handleDemandLoadException(resource, exception);
			// CHECKSTYLE:OFF
START 		} catch (Exception e) { END 
			// CHECKSTYLE:ON
			// do nothing. The errors are added to the Resource#getErrors() in super().
		}
	}
","	protected void handleDemandLoadException(Resource resource, IOException exception) {
		try {
			super.handleDemandLoadException(resource, exception);
			// CHECKSTYLE:OFF
		} catch (RuntimeException e) {
			// CHECKSTYLE:ON
			// do nothing. The errors are added to the Resource#getErrors() in super().
		}
	}
"
1672,Surprising to me you suggest this. I guess you spent this method call because you know for sure the call comes for free because of inlining. Right?,"	public final Type getType() {
		if (beginA == endA && beginB < endB)
			return Type.INSERT;
		if (beginA < endA && beginB == endB)
			return Type.DELETE;
		if (isEmpty())
			return Type.EMPTY;
		return Type.REPLACE;
	}
","	public final Type getType() {
		if (beginA == endA && beginB < endB)
			return Type.INSERT;
		if (beginA < endA && beginB == endB)
			return Type.DELETE;
START 		if (isEmpty()) END 
			return Type.EMPTY;
		return Type.REPLACE;
	}
","	public final Type getType() {
		if (beginA == endA && beginB < endB)
			return Type.INSERT;
		if (beginA < endA && beginB == endB)
			return Type.DELETE;
		if (beginA == endA && beginB == endB)
			return Type.EMPTY;
		return Type.REPLACE;
	}
"
1673,"Cosmetic: Please, always use braces around conditions and loops. Thanks! :)","    private String getHumanReadableSize(long bytes)
    {
        int unit = 1000;
        if (bytes < unit)
            return bytes + "" B"";
        int exp = (int) (Math.log(bytes) / Math.log(unit));
        String pre = """" + ""KMGTPE"".charAt(exp - 1);
        return String.format(""%.1f %sB"", bytes / Math.pow(unit, exp), pre);
    }
","    private String getHumanReadableSize(long bytes)
    {
        int unit = 1000;
        if (bytes < unit)
START             return bytes + "" B""; END 
        int exp = (int) (Math.log(bytes) / Math.log(unit));
        String pre = """" + ""KMGTPE"".charAt(exp - 1);
        return String.format(""%.1f %sB"", bytes / Math.pow(unit, exp), pre);
    }
","    private String getHumanReadableSize(long bytes)
    {
        int unit = 1000;
        if (bytes < unit)
        {
            return bytes + "" B"";
        }
        int exp = (int) (Math.log(bytes) / Math.log(unit));
        String pre = """" + ""KMGTPE"".charAt(exp - 1);
        return String.format(""%.1f %sB"", bytes / Math.pow(unit, exp), pre);
    }
"
1674,It is OK to make the `createKieBuilder` return KieBuilderImpl. Less likely to break in the future in case we support more implementations.,"    private KieBuilderImpl kieBuilderClone( final KieFileSystem kieFileSystemClone ) {
        KieBuilderImpl kieBuilder = null;

        if ( this.kieBuilder != null ) {
            kieBuilder = (KieBuilderImpl) createKieBuilder( kieFileSystemClone );
            kieBuilder.setkModule( ( (KieBuilderImpl) this.kieBuilder ).getkModule() );
            kieBuilder.setTrgMfs( ( (KieFileSystemImpl) kieFileSystemClone ).getMfs() );
        }

        return kieBuilder;
    }
","    private KieBuilderImpl kieBuilderClone( final KieFileSystem kieFileSystemClone ) {
        KieBuilderImpl kieBuilder = null;

        if ( this.kieBuilder != null ) {
START             kieBuilder = (KieBuilderImpl) createKieBuilder( kieFileSystemClone ); END 
            kieBuilder.setkModule( ( (KieBuilderImpl) this.kieBuilder ).getkModule() );
            kieBuilder.setTrgMfs( ( (KieFileSystemImpl) kieFileSystemClone ).getMfs() );
        }

        return kieBuilder;
    }
","    private KieBuilderImpl kieBuilderClone( final KieFileSystem kieFileSystemClone ) {
        KieBuilderImpl kieBuilder = null;

        if ( this.kieBuilder != null ) {
            kieBuilder = createKieBuilder( kieFileSystemClone );
            kieBuilder.setkModule( ( (KieBuilderImpl) this.kieBuilder ).getkModule() );
            kieBuilder.setTrgMfs( ( (KieFileSystemImpl) kieFileSystemClone ).getMfs() );
        }

        return kieBuilder;
    }
"
1675,"Generally, it's a good idea to have `throws Exception` rather than a more specific one in the signature of test methods.","    public void setUp() throws MalformedURLException {
        base = new URL(""http://localhost:"" + port);
    }
","START     public void setUp() throws MalformedURLException { END 
        base = new URL(""http://localhost:"" + port);
    }
","    public void setUp() throws Exception {
        base = new URL(""http://localhost:"" + port);
    }
"
1676,"![MINOR](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/severity-minor.png 'Severity: MINOR') Immediately return this expression instead of assigning it to the temporary variable ""instance"". [![rule](https://raw.githubusercontent.com/SonarCommunity/sonar-github/master/images/rule.png)](http://integration.silverpeas.org/sonar/coding_rules#rule_key=squid%3AS1488)","  public ProcessInstance getProcessInstance(String instanceId) throws WorkflowException {
    ProcessInstanceImpl instance = repository.getById(instanceId);
    return instance;
  }
","  public ProcessInstance getProcessInstance(String instanceId) throws WorkflowException {
START     ProcessInstanceImpl instance = repository.getById(instanceId); END 
    return instance;
  }
","  public ProcessInstance getProcessInstance(String instanceId) throws WorkflowException {
    return repository.getById(instanceId);
  }
"
1677,"same, needs to be negated","  protected int[] makeDimValSelector(PooledTopNParams params, int numProcessed, int numToProcess)
  {
    final TopNMetricSpecBuilder<int[]> arrayProvider = params.getArrayProvider();

    if (query.getDimensionSpec().preservesOrdering()) {
      return arrayProvider.build();
    }

    arrayProvider.ignoreFirstN(numProcessed);
    arrayProvider.keepOnlyN(numToProcess);
    return query.getTopNMetricSpec().configureOptimizer(arrayProvider).build();
  }
","  protected int[] makeDimValSelector(PooledTopNParams params, int numProcessed, int numToProcess)
  {
    final TopNMetricSpecBuilder<int[]> arrayProvider = params.getArrayProvider();

START     if (query.getDimensionSpec().preservesOrdering()) { END 
      return arrayProvider.build();
    }

    arrayProvider.ignoreFirstN(numProcessed);
    arrayProvider.keepOnlyN(numToProcess);
    return query.getTopNMetricSpec().configureOptimizer(arrayProvider).build();
  }
","  protected int[] makeDimValSelector(PooledTopNParams params, int numProcessed, int numToProcess)
  {
    final TopNMetricSpecBuilder<int[]> arrayProvider = params.getArrayProvider();

    if (!query.getDimensionSpec().preservesOrdering()) {
      return arrayProvider.build();
    }

    arrayProvider.ignoreFirstN(numProcessed);
    arrayProvider.keepOnlyN(numToProcess);
    return query.getTopNMetricSpec().configureOptimizer(arrayProvider).build();
  }
"
1678,"Don't need to have this in a separate function if it's just a oneliner, IMO.","    protected void bindWidgetToSetting(UIWidget widget) {
        UISlider slider = widget.find(""slider"", UISlider.class);
        assert slider != null;

        updateSliderIfInteger(slider);

        setSliderRange(slider);

        slider.bindValue(new Binding<Float>() {
            @Override
            public Float get() {
                return getSetting().getValue().floatValue();
            }

            @Override
            public void set(Float value) {
                setSettingValue(value);
            }
        });
    }
","    protected void bindWidgetToSetting(UIWidget widget) {
        UISlider slider = widget.find(""slider"", UISlider.class);
        assert slider != null;

        updateSliderIfInteger(slider);

        setSliderRange(slider);

        slider.bindValue(new Binding<Float>() {
            @Override
            public Float get() {
                return getSetting().getValue().floatValue();
            }

            @Override
            public void set(Float value) {
START                 setSettingValue(value); END 
            }
        });
    }
","    protected void bindWidgetToSetting(UIWidget widget) {
        UISlider slider = widget.find(""slider"", UISlider.class);
        assert slider != null;

        updateSliderIfInteger(slider);

        setSliderRange(slider);

        slider.bindValue(new Binding<Float>() {
            @Override
            public Float get() {
                return getSetting().get().floatValue();
            }

            @Override
            public void set(Float value) {
                setSettingValue(value);
            }
        });
    }
"
1679,NIT:  spacing (need new line).  But wait and see if there's other changes you'll need to make from the other reviewers.,"    public static void sendResponse(ChannelHandlerContext channel, HttpRequest request, String messageBody, HttpResponseStatus status) {
        sendResponse(channel, request, messageBody, null);
    }
","    public static void sendResponse(ChannelHandlerContext channel, HttpRequest request, String messageBody, HttpResponseStatus status) {
        sendResponse(channel, request, messageBody, null);
START     } END 
","    public static void sendResponse(ChannelHandlerContext channel, HttpRequest request, String messageBody, HttpResponseStatus status) {
        sendResponse(channel, request, messageBody, status, null);
    }
"
1680,If its needed to be cleared in init --force please do cleanup there too.,"    public void clearSwapDir() throws IOException {
        if (! m_blockPathMap.isEmpty()) {
            throw new IllegalStateException(""Attempt to clear swap directory when ""
                    + ""there are still managed blocks; use releaseAllBlocks() instead"");
        }

        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(m_largeQuerySwapPath)) {
            Iterator<Path> it = dirStream.iterator();
            while (it.hasNext()) {
                Path path = it.next();
                VoltFile.recursivelyDelete(path.toFile());
            }
        }
    }
","START     public void clearSwapDir() throws IOException { END 
        if (! m_blockPathMap.isEmpty()) {
            throw new IllegalStateException(""Attempt to clear swap directory when ""
                    + ""there are still managed blocks; use releaseAllBlocks() instead"");
        }

        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(m_largeQuerySwapPath)) {
            Iterator<Path> it = dirStream.iterator();
            while (it.hasNext()) {
                Path path = it.next();
                VoltFile.recursivelyDelete(path.toFile());
            }
        }
    }
","    private void clearSwapDir() throws IOException {
        if (! m_blockPathMap.isEmpty()) {
            throw new IllegalStateException(""Attempt to clear swap directory when ""
                    + ""there are still managed blocks; use releaseAllBlocks() instead"");
        }

        try (DirectoryStream<Path> dirStream = Files.newDirectoryStream(m_largeQuerySwapPath)) {
            Iterator<Path> it = dirStream.iterator();
            while (it.hasNext()) {
                Path path = it.next();
                VoltFile.recursivelyDelete(path.toFile());
            }
        }
    }
"
1681,wrap this in a `try`...,"  public void authenticateWithWrongAuthentication()
          throws SecurityException, SecurityProviderNotFoundException {
    when(provider.authenticate(authentication)).thenThrow(UnauthorisedException.class);
    manager.addProvider(provider);

    expected.expect(UnauthorisedException.class);

    manager.authenticate(authentication);

    verify(provider).authenticate(authentication);
  }
","  public void authenticateWithWrongAuthentication()
          throws SecurityException, SecurityProviderNotFoundException {
    when(provider.authenticate(authentication)).thenThrow(UnauthorisedException.class);
    manager.addProvider(provider);

    expected.expect(UnauthorisedException.class);

START     manager.authenticate(authentication); END 

    verify(provider).authenticate(authentication);
  }
","  public void authenticateWithWrongAuthentication()
      throws SecurityException, SecurityProviderNotFoundException {
    when(provider.authenticate(authentication)).thenThrow(UnauthorisedException.class);
    manager.addProvider(provider);

    expected.expect(UnauthorisedException.class);

    try {
      manager.authenticate(authentication);
    } finally {
      verify(provider).authenticate(authentication);
    }
  }
"
1682,"Should return the interface (List), not the class.","	public ArrayList<CapraOfficeObject> getSelection() {
		return this.selection;
	}
","START 	public ArrayList<CapraOfficeObject> getSelection() { END 
		return this.selection;
	}
","	public List<CapraOfficeObject> getSelection() {
		return this.selection;
	}
"
1683,"use local variable ""changeArtifact"" here","   private static ArrayList<Artifact> asArtifacts(Collection<Change> changes) {
      ArrayList<Artifact> arts = new ArrayList<>();
      for (Change artifactChange : changes) {
         Artifact changeArtifact = artifactChange.getChangeArtifact();
         if (changeArtifact.isValid()) {
            arts.add(artifactChange.getChangeArtifact());
         }
      }
      return arts;
   }
","   private static ArrayList<Artifact> asArtifacts(Collection<Change> changes) {
      ArrayList<Artifact> arts = new ArrayList<>();
      for (Change artifactChange : changes) {
         Artifact changeArtifact = artifactChange.getChangeArtifact();
         if (changeArtifact.isValid()) {
START             arts.add(artifactChange.getChangeArtifact()); END 
         }
      }
      return arts;
   }
","   private static ArrayList<Artifact> asArtifacts(Collection<Change> changes) {
      ArrayList<Artifact> arts = new ArrayList<>();
      for (Change artifactChange : changes) {
         Artifact changeArtifact = artifactChange.getChangeArtifact();
         if (changeArtifact.isValid()) {
            arts.add(changeArtifact);
         }
      }
      return arts;
   }
"
1684,"Where is the index guard? Would be much cleaner if you do standard for loop

for (int i=0; i<mappinsg.length;i++) {
   if (mappings[i].inheritedFrom!=LanguageMappingResolver.FILE_MAPPING)
    return mappinsg[i];
}
// not sure what we do here","	private LanguageMapping computeInheritedMapping(IProject project, IFile file, ICConfigurationDescription configuration) throws CoreException {
		LanguageMapping mappings[] = LanguageMappingResolver.computeLanguage(project, file.getProjectRelativePath().toPortableString(), configuration, fContentType.getId(), true);
		LanguageMapping inheritedMapping = mappings[0];
		
		// Skip over the file mapping because we want to know what mapping the file
		// mapping overrides.
		int index = 1;
		while (inheritedMapping.inheritedFrom == LanguageMappingResolver.FILE_MAPPING) {
			inheritedMapping = mappings[index++];
		}
		
		return inheritedMapping;
	}
","	private LanguageMapping computeInheritedMapping(IProject project, IFile file, ICConfigurationDescription configuration) throws CoreException {
		LanguageMapping mappings[] = LanguageMappingResolver.computeLanguage(project, file.getProjectRelativePath().toPortableString(), configuration, fContentType.getId(), true);
		LanguageMapping inheritedMapping = mappings[0];
		
		// Skip over the file mapping because we want to know what mapping the file
		// mapping overrides.
		int index = 1;
		while (inheritedMapping.inheritedFrom == LanguageMappingResolver.FILE_MAPPING) {
START 			inheritedMapping = mappings[index++]; END 
		}
		
		return inheritedMapping;
	}
","	private LanguageMapping computeInheritedMapping(IProject project, IFile file, ICConfigurationDescription configuration) throws CoreException {
		LanguageMapping mappings[] = LanguageMappingResolver.computeLanguage(project, file.getProjectRelativePath().toPortableString(), configuration, fContentType.getId(), true);
		
		// Skip over the file mapping because we want to know what mapping the file
		// mapping overrides.
		for (int i = 0; i < mappings.length; i++) {
			if (mappings[i].inheritedFrom != LanguageMappingResolver.FILE_MAPPING) {
				return mappings[i];
			}
		}
		
		return null;
	}
"
1685,"This is the only thing I object to. I'm not a fan of Spring-style magic--by which I mean stuff just happens because a JAR is on the classpath (or sometime next year, in the Java 9 module graph).

JDBI has thus far done a great job of keeping the magic ""visible."" I would rather force users to make a single call to `DBI.installPlugins()` so that the ServiceLoader stuff is truly opt-in.","    public static DBI create(ConnectionFactory connectionFactory) {
        DBI dbi = new DBI(connectionFactory);
        dbi.installPlugins();
        return dbi;
    }
","    public static DBI create(ConnectionFactory connectionFactory) {
        DBI dbi = new DBI(connectionFactory);
START         dbi.installPlugins(); END 
        return dbi;
    }
","    public static DBI create(ConnectionFactory connectionFactory) {
        return new DBI(connectionFactory);
    }
"
1686,"Oh, so the number of retries actually includes the first try as well.","    public TransactionTemplate retries( int retries )
    {
        if ( retries < 1 )
        {
            throw new IllegalArgumentException( ""Number of retries must be greater than or equal to 1"" );
        }
        return new TransactionTemplate( gds, monitor, retries, backoff, retryPredicate );
    }
","    public TransactionTemplate retries( int retries )
    {
        if ( retries < 1 )
        {
            throw new IllegalArgumentException( ""Number of retries must be greater than or equal to 1"" );
START         } END 
        return new TransactionTemplate( gds, monitor, retries, backoff, retryPredicate );
    }
","    public TransactionTemplate retries( int retries )
    {
        return new TransactionTemplate( gds, monitor, retries, backoff, retryPredicate );
    }
"
1687,"Hmm, let's just have this delegate to the super method. It's internal, so we need not include the original record details.
```suggestion
        return super.toString();
```","    public String toString() {
        return ""InternalSinkRecord{"" +
                ""consumerRecord="" + originalRecord.toString() +
                ""} "" + super.toString();
    }
","    public String toString() {
START         return ""InternalSinkRecord{"" +
                ""consumerRecord="" + originalRecord.toString() +
                ""} "" + super.toString(); END 
    }
","    public String toString() {
        return super.toString();
    }
"
1688,"Instead of calling `init` explicitly here, you could just call `this()` to call the default constructor `ZKConfig`.","    public ZKConfig(File configFile) throws ConfigException {
        init();
        addConfiguration(configFile);
    }
","    public ZKConfig(File configFile) throws ConfigException {
START         init(); END 
        addConfiguration(configFile);
    }
","    public ZKConfig(File configFile) throws ConfigException {
        this();
        addConfiguration(configFile);
    }
"
1689,"why does this need to declare that it throws these exceptions, now?","    public String getServerVersion()
            throws SecurityException, TransactionException, TException {
        return Version.getVersion(ConcourseServer.class).toString();
    }
","    public String getServerVersion()
START             throws SecurityException, TransactionException, TException { END 
        return Version.getVersion(ConcourseServer.class).toString();
    }
","    public String getServerVersion() {
        return Version.getVersion(ConcourseServer.class).toString();
    }
"
1690,Don't forget to re-add default TTL here probably.,"    public void registerCache(String name) {
        CacheDescriptor defaultDescriptor = getCacheDescriptor(DEFAULT_CACHE_ID);
        if (defaultDescriptor == null) {
            defaultDescriptor = new CacheDescriptor();
            defaultDescriptor.options.put(CacheDescriptor.OPTION_MAX_SIZE,
                    String.valueOf(CacheDescriptor.DEFAULT_MAX_SIZE));
            register(XP_CACHES, defaultDescriptor);
        }
        CacheDescriptor newDescriptor = (CacheDescriptor) new CacheDescriptor().merge(defaultDescriptor);
        newDescriptor.name = name;
        // add to registry (merging if needed)
        register(XP_CACHES, newDescriptor);
        // start if needed
        maybeStart(name);
    }
","    public void registerCache(String name) {
        CacheDescriptor defaultDescriptor = getCacheDescriptor(DEFAULT_CACHE_ID);
        if (defaultDescriptor == null) {
            defaultDescriptor = new CacheDescriptor();
START             defaultDescriptor.options.put(CacheDescriptor.OPTION_MAX_SIZE, END 
                    String.valueOf(CacheDescriptor.DEFAULT_MAX_SIZE));
            register(XP_CACHES, defaultDescriptor);
        }
        CacheDescriptor newDescriptor = (CacheDescriptor) new CacheDescriptor().merge(defaultDescriptor);
        newDescriptor.name = name;
        // add to registry (merging if needed)
        register(XP_CACHES, newDescriptor);
        // start if needed
        maybeStart(name);
    }
","    public void registerCache(String name) {
        CacheDescriptor defaultDescriptor = getCacheDescriptor(DEFAULT_CACHE_ID);
        if (defaultDescriptor == null) {
            defaultDescriptor = new CacheDescriptor();
            defaultDescriptor.options.put(OPTION_MAX_SIZE, String.valueOf(DEFAULT_MAX_SIZE));
            register(XP_CACHES, defaultDescriptor);
        }
        CacheDescriptor newDescriptor = (CacheDescriptor) new CacheDescriptor().merge(defaultDescriptor);
        newDescriptor.name = name;
        // add to registry (merging if needed)
        register(XP_CACHES, newDescriptor);
        // start if needed
        maybeStart(name);
    }
"
1691,"`Exceptions.launderedException` is being removed, so avoid calling it here. Just wrap and throw `RuntimeException`.","    private Consumer<Future<String>> assertAllLocksAcquiredCorrectly()
    {
        return result ->
        {
            try
            {
                String assertionError =
                        result.get( SECONDS_TO_RUN * 100, TimeUnit.SECONDS );
                if ( assertionError != null )
                {
                    fail( assertionError );
                }
            }
            catch ( InterruptedException | ExecutionException | TimeoutException e )
            {
                throw Exceptions.launderedException( e );
            }
        };
    }
","    private Consumer<Future<String>> assertAllLocksAcquiredCorrectly()
    {
        return result ->
        {
            try
            {
                String assertionError =
                        result.get( SECONDS_TO_RUN * 100, TimeUnit.SECONDS );
                if ( assertionError != null )
                {
                    fail( assertionError );
                }
            }
            catch ( InterruptedException | ExecutionException | TimeoutException e )
            {
START                 throw Exceptions.launderedException( e ); END 
            }
        };
    }
","    private Consumer<Future<String>> assertAllLocksAcquiredCorrectly()
    {
        return result ->
        {
            try
            {
                String assertionError =
                        result.get( SECONDS_TO_RUN * 100, TimeUnit.SECONDS );
                if ( assertionError != null )
                {
                    fail( assertionError );
                }
            }
            catch ( InterruptedException | ExecutionException | TimeoutException e )
            {
                throw new RuntimeException( e );
            }
        };
    }
"
1692,style nit: missing braces,"	private void storeCredentials(AddRemotePage remotePage) {
		if (remotePage.getStoreInSecureStore()) {
			URIish uri = remotePage.getSelection().getURI();
			if (uri != null)
				SecureStoreUtils.storeCredentials(remotePage.getCredentials(),
						uri);
		}
	}
","	private void storeCredentials(AddRemotePage remotePage) {
		if (remotePage.getStoreInSecureStore()) {
			URIish uri = remotePage.getSelection().getURI();
START 			if (uri != null) END 
				SecureStoreUtils.storeCredentials(remotePage.getCredentials(),
						uri);
		}
	}
","	private void storeCredentials(AddRemotePage remotePage) {
		if (remotePage.getStoreInSecureStore()) {
			URIish uri = remotePage.getSelection().getURI();
			if (uri != null) {
				SecureStoreUtils.storeCredentials(remotePage.getCredentials(),
						uri);
			}
		}
	}
"
1693,try/catch block in a constructor with `e.printStackTrace()`? Shouldn't this be something like `SqlDatabase.createReadOnly(config);` or something?,"	public Indexer(Config config, Deduper deduper) {
		this.config = config;
		this.deduper = deduper;
		this.localDatabase = new SqlDatabase(config);
		try {
			localDatabase.getConnection().setReadOnly(true);
		}
		catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		this.eventBus = LocalEventBus.getInstance();
	}
","	public Indexer(Config config, Deduper deduper) {
		this.config = config;
		this.deduper = deduper;
		this.localDatabase = new SqlDatabase(config);
		try {
START 			localDatabase.getConnection().setReadOnly(true); END 
		}
		catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		this.eventBus = LocalEventBus.getInstance();
	}
","	public Indexer(Config config, Deduper deduper) {
		this.config = config;
		this.deduper = deduper;
		this.localDatabase = new SqlDatabase(config, true);

		this.eventBus = LocalEventBus.getInstance();
	}
"
1694,Should this throw IllegalStateException?  Seems like bug case.,"  void setLocalPartitionCount(int partitionCount) {
    // this method should be invoked before participation, so the initial value is expected to be 0.
    if (!offlineCount.compareAndSet(0, partitionCount)) {
      logger.warn(""Number of OFFLINE partitions has changed before initializing participant metrics"");
    }
  }
","  void setLocalPartitionCount(int partitionCount) {
    // this method should be invoked before participation, so the initial value is expected to be 0.
    if (!offlineCount.compareAndSet(0, partitionCount)) {
START       logger.warn(""Number of OFFLINE partitions has changed before initializing participant metrics""); END 
    }
  }
","  void setLocalPartitionCount(int partitionCount) {
    // this method should be invoked before participation, so the initial value is expected to be 0.
    if (!offlineCount.compareAndSet(0, partitionCount)) {
      throw new IllegalStateException(
          ""Number of OFFLINE partitions has changed before initializing participant metrics"");
    }
  }
"
1695,could be static,"    private void log(ITestNGMethod method, String prefix) {
        if (method.getInstance() != null) {
            messages.add(prefix + method.getInstance().getClass().getName() + ""."" + method.getMethodName());
        } else {
            messages.add(prefix + method.getMethodName());
        }
    }
","START     private void log(ITestNGMethod method, String prefix) { END 
        if (method.getInstance() != null) {
            messages.add(prefix + method.getInstance().getClass().getName() + ""."" + method.getMethodName());
        } else {
            messages.add(prefix + method.getMethodName());
        }
    }
","    private static void log(ITestNGMethod method, String prefix) {
        if (method.getInstance() != null) {
            messages.add(prefix + method.getInstance().getClass().getName() + ""."" + method.getMethodName());
        } else {
            messages.add(prefix + method.getMethodName());
        }
    }
"
1696,It is wrong. Symbols are not expressions.,"        public Void visitAggregation(AggregationNode node, ImmutableList.Builder<Expression> context)
        {
            node.getAggregations().values()
                    .forEach(aggregation -> context.add(aggregation.getCall()));
            node.getGroupingSets().forEach(groupingSet -> groupingSet
                    .forEach(symbol -> context.add(symbol.toSymbolReference())));
            return super.visitAggregation(node, context);
        }
","        public Void visitAggregation(AggregationNode node, ImmutableList.Builder<Expression> context)
        {
            node.getAggregations().values()
                    .forEach(aggregation -> context.add(aggregation.getCall()));
            node.getGroupingSets().forEach(groupingSet -> groupingSet
START                     .forEach(symbol -> context.add(symbol.toSymbolReference()))); END 
            return super.visitAggregation(node, context);
        }
","        public Void visitAggregation(AggregationNode node, ImmutableList.Builder<Expression> context)
        {
            node.getAggregations().values()
                    .forEach(aggregation -> context.add(aggregation.getCall()));
            return super.visitAggregation(node, context);
        }
"
1697,What is the purpose of this mechanism?,"    public SslConnection accept(StreamConnection tcpConnection, SSLEngine engine) {
        SslConnection connection = new JsseSslStreamConnection(tcpConnection, engine, socketBufferPool, applicationBufferPool, startTls);
        if(sslEngineCallback != null) {
            sslEngineCallback.acceptCallback(connection, engine);
        }
        return connection;
    }
","    public SslConnection accept(StreamConnection tcpConnection, SSLEngine engine) {
        SslConnection connection = new JsseSslStreamConnection(tcpConnection, engine, socketBufferPool, applicationBufferPool, startTls);
        if(sslEngineCallback != null) {
            sslEngineCallback.acceptCallback(connection, engine);
        }
START         return connection; END 
    }
","    public SslConnection accept(StreamConnection tcpConnection, SSLEngine engine) {
        return new JsseSslStreamConnection(tcpConnection, engine, socketBufferPool, applicationBufferPool, startTls);
    }
"
1698,"Let's try sticking to the current style
add final
and use it as return value","	private static String remoteUrl(final Context context) {
		String customURL = context.get(Download.INSTANCE);
		if(customURL != null && !customURL.isEmpty()) {
			return context.get(Download.INSTANCE);
		} else {
			return DEFAULT_REMOTE_URL;
		}
	}
","	private static String remoteUrl(final Context context) {
		String customURL = context.get(Download.INSTANCE);
		if(customURL != null && !customURL.isEmpty()) {
START 			return context.get(Download.INSTANCE); END 
		} else {
			return DEFAULT_REMOTE_URL;
		}
	}
","	private static String remoteUrl(final Context context) {
		final String customURL = context.get(Download.INSTANCE);
		if(customURL != null && !customURL.isEmpty()) {
			return customURL;
		} else {
			return DEFAULT_REMOTE_URL;
		}
	}
"
1699,why not have `filePath` be a `Path` directly?,"    private void mapLinesToOffsets() throws IOException {
        try (Scanner scanner = new Scanner(Paths.get(filePath))) {
            int currentGlobalOffset = 0;

            while (scanner.hasNextLine()) {
                lineToOffset.add(currentGlobalOffset);
                currentGlobalOffset += getLineLengthWithLineSeparator(scanner);
            }
        }
    }
","    private void mapLinesToOffsets() throws IOException {
START         try (Scanner scanner = new Scanner(Paths.get(filePath))) { END 
            int currentGlobalOffset = 0;

            while (scanner.hasNextLine()) {
                lineToOffset.add(currentGlobalOffset);
                currentGlobalOffset += getLineLengthWithLineSeparator(scanner);
            }
        }
    }
","    private void mapLinesToOffsets() throws IOException {
        try (Scanner scanner = new Scanner(filePath)) {
            int currentGlobalOffset = 0;

            while (scanner.hasNextLine()) {
                lineToOffset.add(currentGlobalOffset);
                currentGlobalOffset += getLineLengthWithLineSeparator(scanner);
            }
        }
    }
"
1700,"this can be simply ""return BrowserEvents.CLICK.equals( event.getNativeEvent().getType())""","    public boolean handlesEvent(CellPreviewEvent<EntityModel> event) {
        NativeEvent nativeEvent = event.getNativeEvent();
        if (!BrowserEvents.CLICK.equals(nativeEvent.getType())) {
            return false;
        }
        return true;
    }
","    public boolean handlesEvent(CellPreviewEvent<EntityModel> event) START  { END 
        NativeEvent nativeEvent = event.getNativeEvent();
        if (!BrowserEvents.CLICK.equals(nativeEvent.getType())) {
            return false;
        }
        return true;
    }
","    public boolean handlesEvent(CellPreviewEvent<EntityModel> event) {
        return BrowserEvents.CLICK.equals(event.getNativeEvent().getType());
    }
"
1701,We should mark this as `private`.,"  public Optional<Iterable<String>> getFlags(String field) {
    Optional<String> value = delegate.getValue(SECTION_NAME, field);
    return value.map(input -> Splitter.on("" "").split(input.trim()));
  }
","START   public Optional<Iterable<String>> getFlags(String field) { END 
    Optional<String> value = delegate.getValue(SECTION_NAME, field);
    return value.map(input -> Splitter.on("" "").split(input.trim()));
  }
","  private Optional<Iterable<String>> getFlags(String field) {
    Optional<String> value = delegate.getValue(SECTION_NAME, field);
    return value.map(input -> Splitter.on("" "").split(input.trim()));
  }
"
1702,we typically compare enum values using '==' instead of 'equals',"    private void storeNetwork() throws UnsupportedEncodingException {
        if (sourceProtocol.equals(NetConfigSourceProtocol.OPENSTACK_METADATA)) {
            networkData = new VmInitToOpenStackMetadata(vmInit).asMap();
        } else {
            storeNetworkAsEni();
        }
    }
","    private void storeNetwork() throws UnsupportedEncodingException {
START         if (sourceProtocol.equals(NetConfigSourceProtocol.OPENSTACK_METADATA)) { END 
            networkData = new VmInitToOpenStackMetadata(vmInit).asMap();
        } else {
            storeNetworkAsEni();
        }
    }
","    private void storeNetwork() throws UnsupportedEncodingException {
        if (sourceProtocol == NetConfigSourceProtocol.OPENSTACK_METADATA) {
            networkData = new VmInitToOpenStackMetadata(vmInit).asMap();
        } else {
            storeNetworkAsEni();
        }
    }
"
1703,Strings that aren't being displayed to users should not be internationalized.,"	public Object execute(ExecutionEvent aEvent) throws ExecutionException {
		GerritTableView reviewTableView = GerritTableView.getActiveView();

		// see http://gerrit-documentation.googlecode.com/svn/Documentation/2.5.2/user-search.html
		//for All > AbandonedOpen--> status:abandoned
		GerritUi.Ftracer.traceInfo(NLS.bind(Messages.AllReviewsHandler_executeCommand,
				GerritQuery.QUERY_ALL_ABANDONED_CHANGES));
		reviewTableView.processCommands(GerritQuery.QUERY_ALL_ABANDONED_CHANGES);

		return null;
	}
","	public Object execute(ExecutionEvent aEvent) throws ExecutionException {
		GerritTableView reviewTableView = GerritTableView.getActiveView();

		// see http://gerrit-documentation.googlecode.com/svn/Documentation/2.5.2/user-search.html
		//for All > AbandonedOpen--> status:abandoned
START 		GerritUi.Ftracer.traceInfo(NLS.bind(Messages.AllReviewsHandler_executeCommand, END 
				GerritQuery.QUERY_ALL_ABANDONED_CHANGES));
		reviewTableView.processCommands(GerritQuery.QUERY_ALL_ABANDONED_CHANGES);

		return null;
	}
","	public Object execute(ExecutionEvent aEvent) throws ExecutionException {
		GerritTableView reviewTableView = GerritTableView.getActiveView();

		// see http://gerrit-documentation.googlecode.com/svn/Documentation/2.5.2/user-search.html
		//for All > AbandonedOpen--> status:abandoned
		reviewTableView.processCommands(GerritQuery.QUERY_ALL_ABANDONED_CHANGES);

		return null;
	}
"
1704,I think this change does not belong in this patch,"    protected boolean canDoAction() {
        setGlusterVolumeId(getParameters().getVolumeId() == null ? getGeoRepSession().getMasterVolumeId() : getParameters().getVolumeId());
        if (!super.canDoAction()) {
            return false;
        }
        if (getGeoRepSession().getStatus().equals(GeoRepSessionStatus.ACTIVE)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GEOREP_SESSION_ALREADY_STARTED);
        }
        return true;
    }
","    protected boolean canDoAction() {
      START   END   setGlusterVolumeId(getParameters().getVolumeId() == null ? getGeoRepSession().getMasterVolumeId() : getParameters().getVolumeId());
        if (!super.canDoAction()) {
            return false;
        }
        if (getGeoRepSession().getStatus().equals(GeoRepSessionStatus.ACTIVE)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GEOREP_SESSION_ALREADY_STARTED);
        }
        return true;
    }
","    protected boolean canDoAction() {
        setGlusterVolumeId(getGeoRepSession().getMasterVolumeId());
        if (!super.canDoAction()) {
            return false;
        }
        if (getGeoRepSession().getStatus().equals(GeoRepSessionStatus.ACTIVE)) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GEOREP_SESSION_ALREADY_STARTED);
        }
        return true;
    }
"
1705,"Interesting, what's the rationale for not using array.length?","	public boolean isValid(Object[] array, ConstraintValidatorContext constraintValidatorContext) {
		if ( array == null ) {
			return false;
		}
		return Array.getLength( array ) > 0;
	}
","	public boolean isValid(Object[] array, ConstraintValidatorContext constraintValidatorContext) {
		if ( array == null ) {
			return false;
		}
START 		return Array.getLength( array ) > 0; END 
	}
","	public boolean isValid(Object[] array, ConstraintValidatorContext constraintValidatorContext) {
		if ( array == null ) {
			return false;
		}
		return array.length > 0;
	}
"
1706,This needs to be implemented?,"    public String getDescription()
    {
        return null;
    }
","    public String getDescription()
    {
START         return null; END 
    }
","    public String getDescription()
    {
        return """";
    }
"
1707,nit: you can remove the `()`,"    private static HttpScheme connectionScheme(ChannelHandlerContext ctx) {
        final HttpScheme scheme = connectionSchemeAttribute(ctx).get();
        return (scheme == null) ? HttpScheme.HTTP : scheme;
    }
","    private static HttpScheme connectionScheme(ChannelHandlerContext ctx) {
        final HttpScheme scheme = connectionSchemeAttribute(ctx).get();
START         return (scheme == null) ? HttpScheme.HTTP : scheme; END 
    }
","    private static HttpScheme connectionScheme(ChannelHandlerContext ctx) {
        final HttpScheme scheme = connectionSchemeAttribute(ctx).get();
        return scheme == null ? HttpScheme.HTTP : scheme;
    }
"
1708,set your feature as transient,"    public String getDescription() {
        if (description == null || description.isEmpty()) {

        }
        return description;
    }
","    public String START  getDescription() END  {
        if (description == null || description.isEmpty()) {

        }
        return description;
    }
","    public String getDescription() {
        return description;
    }
"
1709,`this.id` -> `id`,"    public String getTitle() {
        return this.id;
    }
","    public String getTitle() {
START         return this.id; END 
    }
","    public String getTitle() {
        return id;
    }
"
1710,style nit: we don't use braces around single line blocks,"	private void buildIndex() {
		int i = 0;
		index.clear();
		Entry q = head;
		while (q != null) {
			if (++i % 100 == 0) {
				index.add(q);
			}
			q = q.next;
		}
	}
","	private void buildIndex() {
		int i = 0;
		index.clear();
		Entry q = head;
		while (q != null) {
START 			if (++i % 100 == 0) { END 
				index.add(q);
			}
			q = q.next;
		}
	}
","	private void buildIndex() {
		int i = 0;
		index.clear();
		Entry q = head;
		while (q != null) {
			if (++i % 100 == 0)
				index.add(q);
			q = q.next;
		}
	}
"
1711,Remove this,"   private URL deploymentOne() throws Throwable
   {
      System.out.println(""deployment"");
      return new URL(""http://blah.com"");
   }
","   private URL deploymentOne() throws Throwable
   {
START       System.out.println(""deployment""); END 
      return new URL(""http://blah.com"");
   }
","   private URL deploymentOne() throws Throwable
   {
      return new URL(""http://blah.com"");
   }
"
1712,return right away if initialized already?,"  public static void initialize(Props props) {
    if (props == null) {
      throw new NullPointerException(""props argument can't be null"");
    }
    instance = new JobCallbackRequestMaker(props);
    isInitialized = true;
    logger.info(""Initialization for "" + JobCallbackRequestMaker.class.getName()
        + "" is completed"");
  }
","  public static void initialize(Props props) {
    if (props == null) {
      throw new NullPointerException(""props argument can't be null"");
    }
START     instance = new JobCallbackRequestMaker(props); END 
    isInitialized = true;
    logger.info(""Initialization for "" + JobCallbackRequestMaker.class.getName()
        + "" is completed"");
  }
","  public static void initialize(Props props) {
    if (props == null) {
      throw new NullPointerException(""props argument can't be null"");
    }

    if (isInitialized) {
      return;
    }

    instance = new JobCallbackRequestMaker(props);
    isInitialized = true;
    logger.info(""Initialization for "" + JobCallbackRequestMaker.class.getName()
        + "" is completed"");
  }
"
1713,This check can be dropped.,"  void cancel() {
    if (callback != null) {
      callback = null;
    }
    ImageView target = this.target.get();
    if (target == null) {
      return;
    }
    ViewTreeObserver vto = target.getViewTreeObserver();
    if (!vto.isAlive()) {
      return;
    }
    vto.removeOnPreDrawListener(this);
  }
","  void cancel() {
START     if (callback != null) { END 
      callback = null;
    }
    ImageView target = this.target.get();
    if (target == null) {
      return;
    }
    ViewTreeObserver vto = target.getViewTreeObserver();
    if (!vto.isAlive()) {
      return;
    }
    vto.removeOnPreDrawListener(this);
  }
","  void cancel() {
    callback = null;
    ImageView target = this.target.get();
    if (target == null) {
      return;
    }
    ViewTreeObserver vto = target.getViewTreeObserver();
    if (!vto.isAlive()) {
      return;
    }
    vto.removeOnPreDrawListener(this);
  }
"
1714,I think we could get rid of the `altKey` variable and the corresponding else block as well.,"    protected Map<K, V> copy(Map<K, V> source, Map dest) {
        for (Entry<K, V> entry : source.entrySet()) {
            K key = entry.getKey();
            K altKey;
            if (key instanceof String) {
                altKey = (K) new CaseInsensitiveString((String) key);
            } else {
                altKey = key;
            }
            dest.put(altKey, entry.getValue());
        }
        return dest;
    }
","    protected Map<K, V> copy(Map<K, V> source, Map dest) {
        for (Entry<K, V> entry : source.entrySet()) {
            K key = entry.getKey();
START             K altKey; END 
            if (key instanceof String) {
                altKey = (K) new CaseInsensitiveString((String) key);
            } else {
                altKey = key;
            }
            dest.put(altKey, entry.getValue());
        }
        return dest;
    }
","    protected Map<K, V> copy(Map<K, V> source, Map dest) {
        for (Entry<K, V> entry : source.entrySet()) {
            K key = entry.getKey();
            if (key instanceof String) {
                key = (K) new CaseInsensitiveString((String) key);
            }
            dest.put(key, entry.getValue());
        }
        return dest;
    }
"
1715,"A graceful shutdown would be nice. See the use of `ServerMetrics.getMetrics().CONNECTION_REJECTED` in the code base. Alternately, could reuse the `ClientCnxnLimitException` exception.","    protected void limitTotalNumberOfCnxns() throws IOException {
        if (maxCnxns <= 0) {
            // maxCnxns limit is disabled
            return;
        }
        int cnxns = getNumAliveConnections();
        if (cnxns >= maxCnxns) {
            throw new IOException(""Too many connections "" + cnxns + "" - max is "" + maxCnxns);
        }
    }
","    protected void limitTotalNumberOfCnxns() throws IOException {
        if (maxCnxns <= 0) {
            // maxCnxns limit is disabled
            return;
        }
        int cnxns = getNumAliveConnections();
        if (cnxns >= maxCnxns) {
START             throw new IOException(""Too many connections "" + cnxns + "" - max is "" + maxCnxns); END 
        }
    }
","    protected boolean limitTotalNumberOfCnxns() {
        if (maxCnxns <= 0) {
            // maxCnxns limit is disabled
            return false;
        }
        int cnxns = getNumAliveConnections();
        if (cnxns >= maxCnxns) {
            LOG.error(""Too many connections "" + cnxns + "" - max is "" + maxCnxns);
            return true;
        }
        return false;
    }
"
1716,"Consider using a Singleton pattern here.  For an example within the CONNECT codebase, see X12EntityExceptionBuilder.java.","    public static TLSClientParametersFactory getInstance() {
        if (tlsCPFactory == null) {
            tlsCPFactory = new TLSClientParametersFactory();
        }
        return tlsCPFactory;
    }
","START     public static TLSClientParametersFactory getInstance() { END 
        if (tlsCPFactory == null) {
            tlsCPFactory = new TLSClientParametersFactory();
        }
        return tlsCPFactory;
    }
","    public static TLSClientParametersFactory getInstance() {
        return tlsCPFactory;
    }
"
1717,Maybe incorportate it into debug logging instead? `log.fine`?,"    public static XmlForm parse(String xml, boolean strict) throws IOException {

        ObjectMapper objectMapper = new XmlMapper();

        if (!strict) {
            objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); //For production, ignore unknown stuff
        }
        XmlForm form = objectMapper.readValue(xml, XmlForm.class);

        System.out.println(form); //Debug only

        return form;
    }
","    public static XmlForm parse(String xml, boolean strict) throws IOException {

        ObjectMapper objectMapper = new XmlMapper();

        if (!strict) {
            objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); //For production, ignore unknown stuff
        }
        XmlForm form = objectMapper.readValue(xml, XmlForm.class);

START         System.out.println(form); //Debug only END 

        return form;
    }
","    public static XmlForm parse(String xml, boolean strict) throws IOException {

        ObjectMapper objectMapper = new XmlMapper();

        if (!strict) {
            objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); //For production, ignore unknown stuff
        }
        XmlForm form = objectMapper.readValue(xml, XmlForm.class);

        return form;
    }
"
1718,it should use integer parameter instead of true i think,"	protected BitmapFont newBitmapFont(BitmapFont.BitmapFontData data, Array<TextureRegion> pageRegions, boolean integer) {
		return new BitmapFont(data, pageRegions, true);
	}
","	protected BitmapFont newBitmapFont(BitmapFont.BitmapFontData data, Array<TextureRegion> pageRegions, boolean integer) {
START 		return new BitmapFont(data, pageRegions, true); END 
	}
","	protected BitmapFont newBitmapFont(BitmapFont.BitmapFontData data, Array<TextureRegion> pageRegions, boolean integer) {
		return new BitmapFont(data, pageRegions, integer);
	}
"
